# ðŸ— btw {#sec-shiny-btw}

```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "y", 
  look = "minimal",
  header = "Alert",
  contents = "The contents for section are being revised. Thank you for your patience."
)
```

In the previous chapters, we used the [`chores` package](https://simonpcouch.github.io/chores/index.html) to develop helpersâ€”pre-written promptsâ€”for repetitive tasks such as creating `roxygen2` documentation and updating `testthat` tests.[^chores] In the [`gander` chapter](https://simonpcouch.github.io/gander/index.html), we used the addin to send code and environment context to the LLM.[^gander]

`chores` and `gander` assist us in automating or enhancing the prompts we submit to the LLM. The addins and shortcuts streamline our interactions with the model, allowing for a more intuitive and efficient experience that resembles a browser interface (like ChatGPT).

[^gander]: This is explained in [What is gander actually doing?](https://simonpcouch.github.io/gander/articles/gander.html#what-is-gander-actually-doing)

[^chores]: The [prompt directory](https://simonpcouch.github.io/chores/articles/custom.html#the-prompt-directory) is where `chores` stores the helpers used in the addin. 


```{r}
#| label: shinypak_apps
#| echo: false
#| results: asis
#| eval: true
shinypak_apps(regex = "^30", branch = "30_llm-btw")
```


In this  chapter we'll focus on the [`btw` package](https://posit-dev.github.io/btw/index.html), which is fundamentally different than `chores` and `gander` because it, 

> "*provides a default set of tools to to peruse the documentation of packages you have installed, check out the objects in your global environment, and retrieve metadata about your session and platform.*"[^btw-desc] 

I'll cover using `btw` to add documentation and improve the contents of the downloadable report in our [`sap` application.](https://github.com/mjfrigaard/sap/tree/30_llm-btw)

[^btw-desc]: This description of `btw` actually comes from the [`mcptools` documentation. ](https://posit-dev.github.io/mcptools/index.html)


## Configuration {#sec-btw-config}

We can place the `btw` configuration options in the `.Rprofile` (similar to other [`ellmer` configurations](https://ellmer.tidyverse.org/reference/chat_anthropic.html)).[^rprof] Recall that the `.Rprofile` file can exist at the user and/or the project-level. 

For example, I've added a project-level `.Rprofile` file this branch of the `sap` package and included a `system_prompt` and `model`: 

[^rprof]: You can easily open this file with [`usethis::edit_r_profile()`.](https://usethis.r-lib.org/reference/edit.html) 

```{r}
#| eval: false 
#| code-fold: false
if (interactive()) { # <1>
  require(ellmer, quietly = TRUE)
} # <1>
if (interactive()) { # <2>
  require(btw, quietly = TRUE)
} # <2>
options(
  btw.client = ellmer::chat_anthropic( #<3>
    system_prompt = #<4>
    "You are an expert R/Python programmer who loves explaining complex topics to non-technical audiences. 
    - When writing R code, use base R functions, but follow the tidyverse style guide.     
    - Avoid using `for` loops and prefer functional programming patterns like `apply()` or `purrr`.    
    - When creating graphs/plots, use `ggplot2`. 
    - If writing R Shiny code, use `bslib` for all layout functions (unless explicitly  instructed otherwise).
    - If writing Python Shiny code, use shiny core (not express) to build apps and include explanations in comments. ", #<4>
    model = "claude-sonnet-4-5-20250929" #<5>
    ) #<3>
)
```
1. Ensure `ellmer` package   
2. Ensure `btw` package    
3. `btw` config   
4. System prompt for all conversations with chat      
5. `model` argument for most current Claude model    


```{r}
#| label: git_box_30_llm-btw
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "launch",
  fig_pw = '65%', 
  branch = "30_llm-btw", 
  repo = 'sap')
```

## `btw` tools {#sec-shiny-btw-tools}

`btw` comes with a set of pre-defined tools for examining package documentation, environments, directories and files, git and GitHub, our development environment, CRAN packages, R sessions, and general web searches.[^btw-tools]  

[^btw-tools]: Read a complete list of available tools from `btw` in the [package documentation.](https://posit-dev.github.io/btw/reference/btw_tools.html)

We can use `btw` to work interactively in the Positron ![](images/positron.png){height=25} (or RStudio ![](images/rstudio-icon.png){height=25}) console by creating a [`btw`-enhanced](https://posit-dev.github.io/btw/reference/btw_client.html) chat client and passing messages directly.[^ellmer-chat]

[^ellmer-chat]: An [`ellmer::Chat` client](https://ellmer.tidyverse.org/reference/Chat.html) which provides a "*sequence of user and assistant [Turns](https://ellmer.tidyverse.org/reference/Turn.html) sent to a specific [Provider.](https://ellmer.tidyverse.org/reference/Provider.html)*" 

```{r}
#| eval: false 
#| code-fold: false
chat <- btw_client()
```

We can view the `btw` enhancements by examining the chat object in the console: 

```{r}
#| eval: false 
#| code-fold: false
chat
```

`btw` has added 'System and Session Context' and 'Tools' sections to the `chat` client.  

```markdown
# System and Session Context

Please account for the following R session and system settings in all 
responses.

<system_info>
R_VERSION: R version 4.5.1 (2025-06-13)
OS: macOS Tahoe 26.0.1
SYSTEM: x86_64, darwin20
UI: Positron (a VS Code equivalent)
LANGUAGE: (EN)
LOCALE: en_US.UTF-8
ENCODING: en_US.UTF-8
TIMEZONE: America/Phoenix
DATE: Tuesday, October 28, 2025 (2025-10-28)
</system_info>


# Tools

You have access to tools that help you interact with the user's R session and
workspace. Use these tools when they are helpful and appropriate to complete 
the user's request. These tools are available to augment your ability to help
the user, but you are smart and capable and can answer many things on your 
own. It is okay to answer the user without relying on these tools.
```

We can see the model will have some additional instructions and methods at it's disposal (beyond what we've provided in the `system_prompt` argument of `ellmer::chat_anthropic()`). 

## Project context {#sec-shiny-btw-md}

As we learned in the [`ellmer` chapter](ellmer.qmd), project prompts should be stored in `inst/prompts/`. `btw` also provides the [`use_btw_md()` function](https://posit-dev.github.io/btw/reference/use_btw_md.html), which creates a project 'context file.'

```{r}
#| eval: false 
#| code-fold: false
use_btw_md(scope = "project")
```

The `btw.md` file comes with some default content for project context:

> "*Use `btw.md` to inform the LLM of your preferred code style, to provide domain-specific terminology or definitions, to establish project documentation, goals and constraints, to include reference materials such or technical specifications, or more. Storing this kind of information in `btw.md` may help you avoid repeating yourself and can be used to maintain coherence across many chat sessions.*"

### [`client`]{style="font-size: 1.10em; font-weight: bold;"} {.unnumbered}

The YAML header in our newly created `btw.md` is where can specify the `client` (along with the `provider` and `model`).

```yaml
---
client: claude/claude-4-5-sonnet-latest
---
```

The default values in `btw.md` will automatically use the latest Claude model from Anthropic. The YAML values above are similar to using `ellmer`'s `chat_*` functions.[^client-btw-md]

[^client-btw-md]: For more information on `client` values, read the [Chat Settings documentation](https://posit-dev.github.io/btw/reference/use_btw_md.html#chat-settings).


### [`tools`]{style="font-size: 1.10em; font-weight: bold;"} {.unnumbered}

The `tools` section of the YAML header contains a list of the groups from  [`btw_tools()`](https://posit-dev.github.io/btw/reference/btw_tools.html). Each of these groups contains a collection of functions "*that allow the chat to interface with your computational environment.*"

```yaml
---
tools:
  - docs
  - env
  - files
  - git
  - github
  - ide
  - search
  - session
  - web
---
```

Now that we have a `btw.md` file for project context, we'll start an interactive chat session to help us write our context file.  

## Console chat: context file {#sec-console-btw-task-create-btw-md}

We can use the `btw` tools to add more project context to the `btw.md` by calling [`btw_task_create_btw_md()`](https://posit-dev.github.io/btw/reference/btw_task_create_btw_md.html) and setting the `mode` to `"console"`. 

```{r}
#| eval: false 
#| code-fold: false
btw_task_create_btw_md(mode = "console", client = "anthropic")
```

This opens an interactive chat in the console:

![](images/btw-btw-task-create-btw-md.png){width='100%' fig-align='center'}

## How tool calling works {#sec-how-tool-calls-work}

LLMs can't execute R code, but if we've registered tools (i.e., R functions) with the model, they can be used to help provide additional information. 

As mentioned above, `btw` has a collection of tools at our disposal, so when we start the interactive chat, the model informs us it will be examining the `sap` package contents for more information.  

```{bash}
#| eval: false 
#| code-fold: false
>>> "Let's get started."
```

The model tells us it's intentions for the `btw.md` file: 

```markdown
I'll help you create a comprehensive project summary. Let me start by 
exploring your project structure to understand what we're working with.
```

To perform this exploration, the model will use the registered tools from `btw`.

### Registered tools

When registering a tool with an LLM, we include the name of the function, a description of what the function does, and a list of function arguments with their type (boolean, integer, number, etc.). [^ellmer-register] 

[^ellmer-register]: We can register tools using `ellmer`'s [`create_tool_def()` and `tool()` functions](https://ellmer.tidyverse.org/articles/tool-calling.html#registering-and-using-tools).

We can view all the tools registered with the LLM using: 

```{r}
#| eval: false 
#| code-fold: false
chat$get_tools()
```


```{r}
#| label: co_box_btw_tools_vs_get_tools
#| echo: false
#| results: asis
#| eval: false
co_box(
  color = "b", 
  look = "minimal",
  header = "Note",
  contents = "The `btw_tools()` function lists all the tools we *could register*, but `chat$get_tools()` returns the tools that *are registered* with the model. "
)
```

:::: {.callout-note collapse=true appearance='minimal' icon=false}

## [Note]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 1.10em; color: #282b2d;'}

The `btw_tools()` function lists all the tools we *could register*, but `chat$get_tools()` returns the tools that *are registered* with the model. 

::: 

::::


The output from `chat$get_tools()` is rather lengthy, but we can use <kbd>Ctrl</kbd>/<kbd>Cmd</kbd> + <kbd>F</kbd> to locate `btw_tool_files_list_files()`, which is the first tool called by the LLM. 


```markdown
List files or directories in the project.

WHEN TO USE:
* Use this tool to discover the file structure of a project.
* When you want to understand the project structure, use `type = "directory"` to list all directories.
* When you want to find a specific file, use `type = "file"` and `regexp` to filter files by name or extension.

CAUTION: Do not list all files in a project, instead prefer listing files in a specific directory with a `regexp` to
filter to files of interest.
```

### Tool calls

Recall the model was going to start by ***'`exploring your project structure`'***, and we can see this aligns with the' `@description` for `btw_tool_files_list_files()`. 

In the console, the tool call and a preview of it's results are printed. Below is the first call to `btw_tool_files_list_files()`: 

```{verbatim}
â—¯ [tool call] btw_tool_files_list_files(path = ".", `_intent` = "Get initial 
overview of project structure")
```

The function includes an `_intent` argument, where the model, "*explain[s] why it called the tool.*"[^tool-intent]

[^tool-intent]: The [`_intent` argument](https://posit-dev.github.io/btw/reference/btw_tool_files_list_files.html#arg--intent) is "*An optional string describing the intent of the tool use. When the tool is used by an LLM, the model will use this argument to explain why it called the tool.*"

### Tool results 

The results are a markdown formatted table of the project contents (file/folder names, their size, and when they were last changed):[^md-output]

```{verbatim}
â— #> | path        | type      | size | modification_time   |
  #> |-------------|-----------|------|---------------------|
  #> | DESCRIPTION | file      | 736  | 2025-10-20 14:04:24 |
  #> | NAMESPACE   | file      | 932  | 2025-10-22 08:01:23 |
  #> | R           | directory | 1K   | 2025-10-22 08:01:23 |
  #> â€¦
```

[^md-output]: I've cleaned up the formatting on this markdown table so it's easier to read. 

### Model response

The table output is sent to the LLM, which them provides a summary of the contents: 

```markdown
Perfect! I can see this is an **R package** with a Shiny application. The structure shows:

- `DESCRIPTION` and `NAMESPACE` files (R package essentials)
- Extensive `R/` directory with many Shiny modules (`mod_*.R` files)
- `app.R` file (Shiny app entry point)
- `data/` directory with datasets
- `tests/testthat/` (comprehensive testing)
- `vignettes/` (package documentation)
- `renv.lock` (dependency management)
```

I've created an overview of this tool call in the diagram  below.[^img-inspiration]

![Tool calls with `btw`](images/btw_tool_call_diagram.png){width='100%' fig-align='center'}

[^img-inspiration]: This image was inspired by the [tool calling overview](https://pkg.garrickadenbuie.com/genAI-2025-llms-meet-shiny/#/section-14) presented in Garrick Aden-Buie's [genAI 2025: Using LLMs in Shiny](https://github.com/gadenbuie/genAI-2025-llms-meet-shiny) presentation.  

The model is equipped with the supplemented system prompt--which informs it of the tools at it's disposal--and when we begin, it starts by attempting to understand the project structure. 

This objective matches the `btw` registered tool description for the `btw_tool_files_list_files()` function, which returns a markdown-formatted table of the project contents. The results from the tool are sent to the LLM, which provides a summary in the console. 

The entire [**PHASE 1: PROJECT EXPLORATION**](https://github.com/mjfrigaard/sap/blob/30_llm-btw/inst/prompts/btw-md-conversation.md#phase-1-project-exploration) is in the callout box below (expand the callout box to view).  

:::: {.callout-caution collapse=true appearance='minimal' icon=false}

## [PHASE 1: PROJECT EXPLORATION (TOOL CALLS)]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 1.10em; font-style: italic; color: #282b2d;'}

I'll help you create a comprehensive project summary. Let me start by exploring your project structure 
to understand what we're working with.

```{verbatim}
â—¯ [tool call] btw_tool_files_list_files(path = ".", `_intent` = "Get initial overview of project
structure")
â— #> | path | type | size | modification_time |
  #> |------|------|------|-------------------|
  #> | DESCRIPTION | file | 736 | 2025-10-20 14:04:24 |
  #> | NAMESPACE | file | 932 | 2025-10-22 08:01:23 |
  #> | R | directory | 1K | 2025-10-22 08:01:23 |
  #> â€¦
```

Perfect! I can see this is an **R package** with a Shiny application. The structure shows:

- `DESCRIPTION` and `NAMESPACE` files (R package essentials)
- Extensive `R/` directory with many Shiny modules (`mod_*.R` files)
- `app.R` file (Shiny app entry point)
- `data/` directory with datasets
- `tests/testthat/` (comprehensive testing)
- `vignettes/` (package documentation)
- `renv.lock` (dependency management)

Let me read the key files to understand this project better.

```{verbatim}
â—¯ [tool call] btw_tool_files_read_text_file(path = "DESCRIPTION", `_intent` = "Read package metadata and
dependencies")
â— #> ```
  #> Package: sap
  #> Title: movies app
  #> Version: 0.0.0.9000
  #> Author: John Smith <John.Smith@email.io> [aut, cre]
  #> â€¦
```

```{verbatim}
â—¯ [tool call] btw_tool_files_read_text_file(path = "README.md", `_intent` = "Understand project purpose
and usage")
â— #> ````md
  #> <h1 align="center"> <code><strong>sap</strong></code> </h1>
  #> <h3 align="center"> Code examples for <a href="https://mjfrigaard.github.io/shiny-app-pkgs/"> Shiny
App-Packages </a> </h3>
  #> <hr>
  #>
  #> â€¦
```

```{verbatim}
â—¯ [tool call] btw_tool_files_read_text_file(path = "btw.md", `_intent` = "Check existing btw.md to see
if I should preserve anything")
â— #> ```md
  #> ---
  #> client: claude/claude-4-5-sonnet-latest
  #> tools:
  #>  - docs
  #> â€¦
```

```{verbatim}
â—¯ [tool call] btw_tool_files_read_text_file(path = "app.R", `_intent` = "Understand the Shiny
application structure")
â— #> ```R
  #> # set option to turn off loadSupport() ----
  #> withr::with_options(new = list(shiny.autoload.r = FALSE), code = {
  #>  if (!interactive()) {
  #>  sink(stderr(), type = "output")
  #> â€¦
```

```{verbatim}
â—¯ [tool call] btw_tool_files_read_text_file(path = "R/launch_app.R", `_intent` = "Understand the
launch_app function")
â— #> ```R
  #> #' Launch the Shiny Application
  #> #'
  #> #' This function initializes and launches the Shiny application with specified
  #> #' options and settings.
  #> â€¦
```

```{verbatim}
â—¯ [tool call] btw_tool_files_read_text_file(path = "R/nav_ui.R", line_end = 50L, ...)
â— #> ```R
  #> #' User Interface for the Shiny Application
  #> #'
  #> #' This function defines the user interface for the Shiny application,
  #> #' integrating Bootstrap and a custom JavaScript file.
  #> â€¦
```

```{verbatim}
â—¯ [tool call] btw_tool_files_read_text_file(path = "R/data.R", `_intent` = "Look at data structure to
understand what this app analyzes")
â— #> ```R
  #> #' @title IMDB movies data
  #> #'
  #> #' @description
  #> #' Movie review data. Note: these data come from the [Building Web Applications with shiny
course](https://rstudio-education.github.io/shiny-course/).
  #> â€¦
```

```{verbatim}
â—¯ [tool call] btw_tool_files_list_files(path = "vignettes", `_intent` = "Look at one vignette to
understand the app's purpose")
â— #> | path | type | size | modification_time |
  #> |------|------|------|-------------------|
  #> | vignettes/graphs.qmd | file | 18.58K | 2025-10-20 14:04:01 |
  #> | vignettes/report.qmd | file | 18.22K | 2025-10-20 14:04:01 |
  #> | vignettes/specs.qmd | file | 5.92K | 2025-10-20 13:35:52 |
  #> â€¦
```

```{verbatim}
â—¯ [tool call] btw_tool_files_read_text_file(path = "vignettes/specs.qmd", line_end = 50L, ...)
â— #> ````qmd
  #> ---
  #> title: "Specifications"
  #> format:
  #>  html:
  #> â€¦
```

:::

::::

As we can see, the  model called `btw_tool_files_list_files()` and `btw_tool_files_read_text_file()` to gather context on the project. The [**PHASE 1: SUMMARY**](https://github.com/mjfrigaard/sap/blob/30_llm-btw/inst/prompts/btw-md-conversation.md#phase-1-summary) is what the model learned about the `sap` package using the `btw` tools (expand the callout box to view): 

:::: {.callout-caution collapse=true appearance='minimal' icon=false}

## [PHASE 1: SUMMARY (TOOL CALLS)]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 1.10em; font-style: italic; color: #282b2d;'}

Based on my exploration, here's what I've learned about this project:

**Project Type:** R Package with integrated Shiny application

**Primary Purpose:** This is `sap` (Shiny App-Packages), which serves as a **comprehensive code example** for the book "Shiny App-Packages" and workshops on developing/testing Shiny applications. It demonstrates how to structure a Shiny app as an R package.

**Technology Stack:**   

- **R Package structure** (DESCRIPTION, NAMESPACE, man/, tests/)    
- **Shiny** for the web application with modular design   
- **Bootstrap/bslib** for modern UI theming   
- **ggplot2** + extensions (ggdist, ggwaffle, plotly) for visualizations    
- **tidyverse** (dplyr, tidyr, forcats) for data manipulation   
- **testthat** for comprehensive testing    
- **renv** for dependency management    
- **Quarto** for vignettes/documentation    

**Key Architecture Insights:**    

- **Modular Shiny design:** Extensive use of Shiny modules (`mod_*.R` files) for different app sections   
- **Multi-branch educational repo:** Different branches show progressive development stages   
- **Theme integration:** Dark theme with custom CSS and thematic integration    
- **Data-focused:** Built around IMDB movie review dataset with 34 variables    
- **Production-ready structure:** Complete with testing, documentation, and dependency management   

**Main Components:**    

- **Data visualization modules:** Compare plots, distribution plots, count plots (bar/waffle)   
- **Award analysis:** Special modules for Oscar/award winner analysis     
- **Tabular displays:** Data tables with custom styling     
- **Report generation:** Quarto-based reporting functionality   

The app appears to provide multiple ways to explore and visualize movie review data through an interactive interface, while serving as a teaching tool for Shiny app development best practices.

:::

::::

After the project summary, the model starts [**Phase 2: Narrative Construction**](https://github.com/mjfrigaard/sap/blob/30_llm-btw/inst/prompts/btw-md-conversation.md#phase-2-narrative-construction), which includes a series of questions from the LLM regarding the context of the package/project (expand the callout box to view).   

:::: {.callout-caution collapse=true appearance='minimal' icon=false}

## [PHASE 2: NARRATIVE CONSTRUCTION]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 1.10em; font-style: italic; color: #282b2d;'}

Now moving to **Phase 2: Narrative Construction**. I need to gather context that would help developers understand the "why" behind decisions and architectural choices.

**Question 1:** What's the main learning objective for developers using this codebase--is it primarily about demonstrating Shiny package structure, modular Shiny development patterns, or both equally?

> "The learning objectives for developers using the codebase are to demonstrate Shiny package structure and modular Shiny development patterns, specifically using modules to add a downloadable html report. Be sure to also create `mermaid` diagrams to illustrate concepts. When creating mermaid diagrams, list the nodes using `CamelCase` abbreviations (i.e., not simply `A`, `B`, `C`,  etc.), and keep the diagrams small enough to fit on a single presentation slide."

**Question 2:** I noticed the app uses a dark theme with custom CSS and thematic integration. Was this theming choice made primarily for visual appeal, or does it serve as an example of a specific theming pattern that developers should learn from when building their own Shiny app-packages?

> "The theme is just for visual appeal, not as an example of a specific theming pattern."

**Question 3:** I see the project has multiple branches representing different development stages, and the main branch appears to be a mature version with full testing and documentation. For developers working with this codebase, which components or modules would you recommend they examine first to understand the core patterns--are there particular modules that best demonstrate the key architectural principles?

> "The code files for each chapter are stored in Git repository. Major code changes are stored in branches. The branches are named sequentially with a prefix and a name of the topic covered: 01_whole-app-game, 02.1_shiny-app, 02.2_movies-app, 02.3_proj-app, 03.1_description, 03.2_rproj, 03.3_create-package, 04_devtools, 05_roxygen2, 06.1_exports, 06.2_imports, 07_data, 08_launch, 09_inst, etc. Developers should review the three `mod_compare_`* to understand the core patterns (these best demonstrate the key architectural  principles)."

**Question 4:** The modular structure shows three `mod_compare_*` modules (vars, point, and presumably the UI/server pairs). These modules appear to handle variable selection, point plotting, and the overall comparison interface. Are there specific patterns in how these three modules communicate with each other--like how data flows between variable selection and plotting--that represent key principles developers should understand about module interaction in Shiny app-packages?

> "Developers should understand that using modules enhances the clarity of the application by providing a structured way to organize its components. This approach allows us to write, analyze, and test each element independently, making it easier to understand its unique functionality and how it interacts within the overall app server."

**Question 5:** I see the app integrates Quarto for report generation and has a dedicated `mod_report` module. Given that downloadable HTML reports are a key learning objective, is the report functionality designed to demonstrate a specific pattern for integrating external document generation tools (like Quarto) within Shiny modules, or does it showcase something else important about report generation in app-packages?

> "The only learning objective is using Shiny modules to integrate external document generation tools (like Quarto). This is a general pattern, not a specific pattern."

Perfect! I now have enough context to create the documentation. Let me summarize what I understand:

:::

::::

I included some instructions to the model on building `mermaid` diagrams for the `btw.md` file. The [**PHASE 2: SUMMARY**](https://github.com/mjfrigaard/sap/blob/30_llm-btw/inst/prompts/btw-md-conversation.md#phase-2-summary) returned after the questions and answers is below (expand the callout box to view).

:::: {.callout-caution collapse=true appearance='minimal' icon=false}

## [PHASE 2: SUMMARY]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 1.10em; font-style: italic; color: #282b2d;'}

**Learning Objectives:** Demonstrate both Shiny package structure and modular Shiny development patterns, with special focus on using modules to integrate external document generation (Quarto for HTML reports).

**Key Architectural Principles:** 

- Modular design enhances application clarity through structured component organization   
- Each module can be written, analyzed, and tested independently    
- Focus on the three `mod_compare_*` modules as the best examples of core patterns    
- General pattern for integrating external tools (like Quarto) within Shiny modules     

**Development Progression:** Sequential git branches show evolution from basic app to full package structure, following a clear learning path through the book chapters.

**Theme Choice:** Visual appeal only, not a teaching pattern.

:::

::::

### Updated `bwd.md` file 

When **Phase 2** is complete, we're told we have a "*comprehensive `btw.md` file that captures the essential information about [our] Shiny App-Packages project*." The full conversation with the model is stored in [`inst/prompts/btw-md-conversation.md`](https://github.com/mjfrigaard/sap/blob/30_llm-btw/inst/prompts/btw-md-conversation.md). 

:::: {.callout-caution collapse=true appearance='minimal' icon=false}

## [Key Features of the Documentation]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 1.10em; font-style: italic; color: #282b2d;'}


**ðŸ“‹ Learning-Focused Structure:** Emphasizes the dual educational objectives (package structure + modular patterns) right at the top    

**ðŸŽ¯ Clear Architecture Diagrams:** Two mermaid diagrams showing: 

- Overall module architecture with CamelCase node names     
- Core module communication pattern (CompareVars â†’ ComparePoint â†’ Report)   

**ðŸ“š Sequential Learning Path:** Explains the git branch progression from basic app to full package   

**ðŸ”§ Practical Developer Guidance:**    

- Points developers to the three `mod_compare_*` modules as the best starting examples    
- Includes actual commands for exploring different development stages     
- Testing patterns for module independence      

**ðŸ“Š Data Context:** Clear explanation of the movie dataset structure and its role in demonstrating 
patterns    

**ðŸš€ Integration Patterns:** Specific focus on how Quarto integration demonstrates external tool patterns   

The documentation serves both as an introduction for newcomers and a reference for developers working with the codebase. It maintains the existing front matter you had while providing comprehensive context that helps developers understand not just *what* the code does, but *why* it's structured this way for learning purposes.

The file should help other AI assistants and developers quickly understand that this is an educational codebase with specific learning objectives, rather than a production movie analysis application.

:::

::::

View the [updated `btw.md` file.](https://github.com/mjfrigaard/sap/blob/30_llm-btw/btw.md#sap-shiny-app-packages) 

## App chat: downloadable report



