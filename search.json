[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "Welcome!",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#whats-in-the-book",
    "href": "index.html#whats-in-the-book",
    "title": "Shiny App-Packages",
    "section": "What’s in the book",
    "text": "What’s in the book\nThis book is a resource to help ‘connect the dots’ between building scalable Shiny applications and writing R packages. Adopting R package development practices in the early stages of your Shiny app will improve the reusability, maintainability, and shareability of all your hard work.\nThe code and data originate from the excellent Building Web Applications with Shiny (BWAS) course. If you’re new to Shiny development this course is a great place to start. The four learning modules will provide a solid understanding for many of the topics covered in this book.\n\nRecent Updates!\nThis resource is currently being revised to include some recent changes in the Shiny development landscape (Positron, AI tools, etc.). While most of the information in the Introduction and App-packages sections will remain unchanged, some sections are being written/updated:\n\n\n\n\n\n\nUpdates\n\n\n\n\n\n\n\nShiny\n\nHas new diagrams in 2.5.1 Modules and 2.5.2 Standalone app function\n\n\n\nPackages\n\nNow includes a 3.1.3 Positron’s workspaces  section\n\n\n\nDevelopment\n\nCovers the differences between RStudio and Positron when calling 4.4 Install\n\n\n\nDependencies\n\nIncludes new diagrams and a new section on managing dependencies with renv.\n\n\n\nDocumentation\n\nIncludes new diagrams in 5.1 roxygen2 basics and 5.2 Documenting app functions\n\n\n\nTesting\n\nNow includes 16.1 Unit tests & LLMs and 16.3 Test logging\n\n\n\nDeployment\n\nBetter GitHub Actions examples for 21.2 Shiny app deployment and 21.3 Actions, Shiny & Docker\n\nExpanded 22  pkgdown example\n\n\n\nFrameworks\n\n23  golem app rebuilt using version 0.5.1\n\n24  leprechaun app built using version 1.0.0.9001\n\n25  rhino app built using version 1.10\n\n\n\n\n\n\n\n\n\n\n\n\nNew Sections/Chapters\n\n\n\n\n\n\n\nDebugging\n\nThe previous debugging chapter has been expanded into a Debugging section:\n\n10  Debuggers\n\n11  Print debugging\n\n12  Debugging apps\n\n13  Logging\n\n\n\n\nShiny Tools\n\nI’ve added a Shiny Tools section:\n\n26  Shiny Assistant\n\n27  ellmer\n\n28  chores (in development)\n29  gander (in development)",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#whats-not-in-the-book",
    "href": "index.html#whats-not-in-the-book",
    "title": "Shiny App-Packages",
    "section": "What’s not in the book",
    "text": "What’s not in the book\nThis book isn’t a replacement for Mastering Shiny or R Packages, 2ed (or Writing R Extensions). I highly suggest bookmarking these resources to return and read when you’d like to learn more about R package and Shiny development.\n\n\n\n\n\nI also won’t be recommending a particular Shiny framework or package, but I’ll cover a few popular choices, show what they’re doing ‘under the hood,’ and let you decide if you’d like to adopt their practices.\n\n\n\n\n\n\nLLM Disclaimer: who wrote this?\n\n\n\n\n\n\nGiven the current landscape of online resources and the impressive capabilities of large language models (LLMs), I feel it’s important to clarify the authorship of this book.\nOnly the code included in this book was created with the assistance of LLMs, and this applies only to specific chapters that are explicitly noted. I have fully authored the narrative, commentary, and explanations. Hopefully, the typos and/or grammatical errors serve as a signature of authenticity.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#what-i-assume-about-you",
    "href": "index.html#what-i-assume-about-you",
    "title": "Shiny App-Packages",
    "section": "What I assume about you",
    "text": "What I assume about you\nIf you’re reading this, I assume you’re comfortable with R, RStudio, Shiny, and the tidyverse. Maybe you haven’t built a ton of applications, but you understand reactivity, and you’re comfortable with the core Shiny concepts (i.e., the UI, server, *_Input(), *_Output(), and render_* functions, etc.).",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#code-examples",
    "href": "index.html#code-examples",
    "title": "Shiny App-Packages",
    "section": "Code examples",
    "text": "Code examples\nThe code files for each chapter are stored in GitHub repository. Major code changes are stored in branches. Whenever a new branch is used, you’ll see the Git Branch icon with a link to the repo/branch in the margin.\n\n\n\n\n\n\n\n\n\n\nSee the &lt;branch&gt; branch of sap.\n\nIn an effort to make the code and examples more accessible and easy to use, I’ve also created the shinypak package. This package can be used to launch or download the applications in each branch.1\nExample:\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\nshinypak::launch('02.3_proj-app')",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "shinypak uses the .Rproj files to launch apps, so a an installation of RStudio is required. However, the applications in each branch still be downloaded with shinypak::get().↩︎",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "Why this book?\nShiny App-Packages attempts to combine and distill Shiny and R package development practices from multiple resources.\nR Packages, 2ed is the premier resource for learning the best practices when creating functions, writing documentation, managing package namespaces, and many other fundamental aspects of package development. However, R Packages, 2ed primarily focuses on creating conventional R packages, so it doesn’t cover Shiny programming (designing user interfaces, server-side computations, modules, etc.). Moreover, testing and debugging a Shiny application differs from the traditional methods used in R packages.\nMastering Shiny is an excellent introduction to the world of Shiny and provides a foundation of best practices for developing applications. R packages are introduced near the end of Mastering Shiny, and this chapter is a great place to start.1 However, to fully understand and appreciate the benefits of developing your Shiny app as an R package, it’s helpful to have an example app-package that includes the full suite of the package development tools (loading, documenting, testing, installing, etc.).2",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#why-this-book",
    "href": "preface.html#why-this-book",
    "title": "Preface",
    "section": "",
    "text": "Did you read R Packages, 2ed and find it difficult to apply package development practices to your Shiny application?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDid you read Mastering Shiny and want to learn more about package development?\n\n\n\n\n\nOther Shiny Resources\nThroughout the course of writing this book, the Shiny community has grown and other resources have been published for developing and customizing Shiny applications. Two popular resources are Engineering Production-Grade Shiny Apps and Outstanding User Interfaces with Shiny.\n\n\n\n\n\n\nEngineering Production-Grade Shiny Apps introduces the golem package, which is an ‘opinionated framework for building production-grade Shiny applications’. golem offers a robust and standardized way to build, maintain, and deploy production-grade Shiny apps. Whether due to the learning curve, number of features, dependencies, or a particular set of deployment constraints, golem might not be the right fit for your application.3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOutstanding User Interfaces with Shiny ‘addresses a specific gap between the beginner and advanced level’ focusing on customizing your Shiny application with HTML, CSS and JavaScript. It introduces charpente, which streamlines the creation of Shiny development by quickly creating an R package, importing external web dependencies for JavaScript and CSS, initializing input/output bindings, and providing custom handler boilerplates. charpente also offers a high-level interface to htmltools (the workhorse that converts R code to web-friendly HTML).\n\n\n\nWe’ll cover both of these texts more in the frameworks section.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#sec-pkgs-ides",
    "href": "preface.html#sec-pkgs-ides",
    "title": "Preface",
    "section": "Development Environments",
    "text": "Development Environments\nThe two integrated development environments (IDEs) I will be demonstrating are RStudio and Positron.\n\n\n\n\n\n\nRStudio is a popular integrated development environment (IDE) that streamlines many R package development tasks. I’d previously connected this IDE to the definitions above for R package and Shiny app-packages. Specifically, the package development tools provided in the Build pane and the devtools package.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPositron is Posit’s new integrated development environment (IDE) designed to improve productivity and performance across multiple programming languages. Building on RStudio’s success, Positron offers a sleek, user-friendly interface while keeping powerful tools for debugging, profiling, and interactive visualizations.\n\n\n\nMost of the book will focus on developing Shiny app-packages in RStudio, because Positron is under active development. When I’m including information specific to particular IDE, I will use icons to differentiate Positron from RStudio ( vs. ).\n\nOther tools\nDeveloping R packages in RStudio or Positron is not required. There are alternative IDEs and tools, and many developers employ these setups (VS Code, PyCharm, Jupyter Lab, Colab, etc). Package development outside RStudio would look almost identical to development in the IDE:\n\nCreate the package structure (R/ folder for .R scripts, man/ folder for documentation, data/ folder for datasets, etc.)\nCreate DESCRIPTION and NAMESPACE files, etc.\nEnsure the package can be installed and loaded into an R session.\n\nThe development workflow functions we’ll cover work just about anywhere you can execute R code (i.e., roxygen2::roxygenize(), devtools::load_all(), devtools::install(), etc.).",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#how-to-read-this-book",
    "href": "preface.html#how-to-read-this-book",
    "title": "Preface",
    "section": "How to read this book",
    "text": "How to read this book\nTransitioning from programming in R to building Shiny applications and writing R packages presents a steep learning curve. The chapters in this book are aimed flattening the package development portion of that curve. As with any new skill, app-package development involves new mental models, concepts, terminology, habits, and details. If you find yourself getting frustrated, I recommend the 15 minute rule:\n\n“By forcing yourself to try for 15 minutes, you gain a deeper understanding of what you’re troubleshooting so that, even if you don’t fix it in 15, next time you’re in a better position to troubleshoot than you were the last time.\nAnd by forcing yourself to ask for help after 15, you not only limit the amount of banging-your-head time, but you also get to see how the other person solves the problem while all the details are still fresh in your mind, so that you’ll more likely have a deeper understanding of why what you were doing to fix it wasn’t working, and why the ultimate solution actually worked.” - Hacker News, 2013\n\nThe chapters in this book (roughly) represent the steps of R package development, but through the lens of an existing Shiny application.4 Each topic can be applied to creating a new app-package, but–in my experience–many Shiny developers have existing applications they’d like to convert into an R package.\n\nThe stable stuff\nThe first two sections contain topics that aren’t likely to change anytime soon. Introduction covers the development of a Shiny app project and it’s gradual progression of complexity to warrant an R package. The app-packages section applies the key components of R package development to a Shiny app.\n\n1  Whole app game is a ‘whole game’ for the development of a toy app-package. This chapter gives a high-level overview of the app-package development workflow.5\nIn 2  Shiny we’ll dive into shiny development, focusing on the files and folders found in most Shiny applications.\nR packages are introduced in 3  Packages, and it covers the differences between Shiny app projects, R packages, and Shiny app-packages.\n4  Development introduces devtools and the app-package development workflow.\n5  Documentation covers documenting the application’s utility functions, modules, UI, server, and standalone app function using roxygen2.\nManaging dependencies (both imports and exports) using the NAMESPACE file is introduced in 6  Dependencies\n7  Data discusses the storage, format, and documentation of data files your app-package.\nThere are multiple ways to launch an application from an app-package. 8  Launch covers options to include in the app.R file and your standalone app function.\n9  Resources covers the many uses of the inst/ folder in R packages. This chapter also covers how to add external files and resources to your application.\n\n\n\nThe opinionated bits\nThe sections below represent my approach to developing app-packages. Most of these practices come from the same resources referenced above, but there are many ways to debug and test your code.\nDebugging is an important part of development, both for R packages and Shiny apps. This section contains chapters on using an interactive debugger and other methods for ensuring you can reliably investigate and address bugs in your code quickly and effectively.\n\n10  Debuggers covers\n11  Print debugging explains\n12  Debugging apps gives\n13  Logging describes\n\nWhile developing your application, you’ll want to ensure it’s features are documented and tested. The Tests section covers testing:\n\nBefore running any tests we need to set up the test suite in our app-package. 14  Test suite briefly covers setting up the testing infrastructure with testthat.\nKnowing what features to implement and what tests to develop reduces the chances of writing code that doesn’t address a user needs. 15  Specifications discusses how to identify user specifications, features, and functional requirements. It also briefly introduces behavior-driven development.\n16  Test tools covers how to include testing tools (fixtures and helpers) in your test suite to ensure isolated yet controllable test conditions.\nReactivity makes testing modules tricky. In 17  Testing modules, I’ll cover some strategies and approaches for verifying that your modules are communicating correctly with Shiny’s testServer() function.\n18  System tests introduces performing system (or end-to-end) tests in you app-package with the shinytest2 package.\n\nAfter you’ve developed your Shiny App-Package, you’ll likely want to deploy it (or put it ‘into production’). A selection of popular methods are covered in Deploy:\n\n20  Docker explains how build Docker images and containers using Docker desktop. These topics are also covered in 23  golem.\n21  GitHub Actions covers continuous integration (CI) / continuous deployment (CD) for Shiny app-packages using GitHub Actions.\n22  pkgdown websites are an excellent way to enhance it’s visibility and usability of your app-package (and it’s made seamless with usethis and GitHub actions (see 22.4 Deploying your site)).\n\n\n\nStuff from the web\nIf you’re Googling ‘what is the best way to build a Shiny application?’ you’ll eventually encounter a Shiny framework. This section contains the development workflow and methods for three popular Shiny application frameworks (golem, leprechaun, charpente and rhino).\n\n23  golem covers developing an application using the golem framework (which is introduced in Engineering Production-Grade Shiny Apps).\nFor developers looking for a ‘lightweight’ version of the golem package, 24  leprechaun introduces the leprechaun package and development workflow\n25  rhino covers how to build a rhino application (which is not technically a package, but is still worth including based on it’s popularity and features).\n\n\n\nExtras\nThe special topics section includes a handful of topics on development, AI tools, storing and retrieving data, reading error outputs, and keeping track of dependencies.\n\n32  App data explores the differences between and use of shiny::reactiveValues() and session$userData.\nAppendix H — Stack traces (this chapter is under construction)\n33  Dependency hell (this chapter is under construction)",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#acknowledgments",
    "href": "preface.html#acknowledgments",
    "title": "Preface",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThis book is the result of multiple discussions with 1) Shiny developers who were new to writing R packages, 2) R package authors who were learning Shiny development and testing, and 3) new R users who wanted to build a robust and scalable application. Shiny App-Packages wouldn’t have been possible without the contributors below (and I am deeply grateful for all of their help!).\n\nHenry Bernreuter & Elizabeth Marshallsay for the initial discussions that created the outline for this book\n\nAndrew Bates for being an exemplary developer and professional, quietly building outstanding UIs, applications, and packages\nEric Simms for asking so many great questions, reviewing chapters, and giving phenomenal feedback\n\nEric Nantz6 for his R podcast, Shiny developer series, workshops, and everything else he does for the Shiny community\n\nPhilip Bowsher for everything he does for the R/Pharma conference and community\n\nTed Laderas for his excellent gRadual intRoduction to Shiny course and insightful blog posts\n\nJennifer Bryan and Hadley Wickham for their posit::conf(23) package development masterclass workshop.\nMaya Gans for having multiple conversations and Shiny modules and package dependencies\nLeon Samson for his feedback on the testing chapters",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#footnotes",
    "href": "preface.html#footnotes",
    "title": "Preface",
    "section": "",
    "text": "Testing Shiny apps requires additional packages and tools to ensure an application’s reliability and performance.↩︎\nThe ‘Converting an existing app’ chapter provides an example of converting a Shiny app into an R Package. However, many of the helpful package development tools aren’t available (i.e., roxygen2 tags, NAMESPACE imports/exports, tests, vignettes, etc.).↩︎\ngolem apps are built as packages. Still, EPGSA assumes the reader is ‘comfortable with building an R package.’ (if you’re familiar with package development, EPGSA is an excellent resource).↩︎\nThe original code and data for the application in this book comes from the Building Web Applications with Shiny (BWAS) course.↩︎\nR Packages, 2ed, has a similar chapter that covers developing standard R packages.↩︎\nEric’s LinkedIn↩︎",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Packages help you\nUsing R package development practices will boost your productivity when building applications and make it easier for your collaborators. First, you will have a clear structure for your files. Second, others can easily share and use your work.\nA guiding principle in this book comes from the Benjamin Franklin quote,\nDo future you a favor.\nStandardizing your projects helps anyone reading your code, especially future you. By structuring every Shiny app like an R package, you save time on setup (or re-orienting yourself to each project’s structure). Clear code is essential for Shiny applications in production, and using an R package is a common way to organize your code.1\nIf you’re using RStudio or Positron, the package structure lets you access user-friendly tools for developing Shiny applications. These tools help you develop and test functions, run unit tests, store data, manage dependencies, and create documentation.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#packages-help-you",
    "href": "intro.html#packages-help-you",
    "title": "Introduction",
    "section": "",
    "text": "“a package [is] the fundamental unit of shareable, reusable, and reproducible R code.” - R Packages, 2ed",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#packages-help-them",
    "href": "intro.html#packages-help-them",
    "title": "Introduction",
    "section": "Packages help them",
    "text": "Packages help them\nAssume someone else will read your code.\nR packages provide a standardized way to enhance R’s capabilities, allowing others to install and use them in their R environment. When developing Shiny apps for production deployment, it’s important to remember that the code will likely be accessed and used by others.\nTo quote Marie Kondo, the de-cluttering expert,\n\n“Ensuring that each one of your belongings has its own spot is the only way to maintain a tidy and clutter-free home. Clutter has nothing to do with what or how much you own – it’s the failure to put things back where they belong.”\n\nR packages simplify sharing your work with colleagues by eliminating the need for them to determine where everything is located, how everything connects, and how it works.\n\n\n\n\n\n\nWhat does it mean to ‘put something into production?’\n\n\n\n\n\n\n‘Production’ usually means passing the code from your personal development environment into your company’s cloud-based server environment, which typically involves bundling your app in a structure that can be shared, installed, tested, and launched.\n\n‘I think the easiest way to think about it for me is that we develop a model in one computational environment–think of this as maybe your laptop or maybe you work in a server environment–still, it’s in one place, and it turns out the software that you need to have installed there is about tuning, training, etc. Putting something into production is getting it out of that computational environment and successfully carrying it over to a new computational environment. For many people, this might be like a cloud computing environment. It might be some kind of server your organization has, and we need to take it, lift it, and then successfully have it working.’ - Julia Silge, What is ‘production’ anyway? MLOps for the curious (SatRdays London 2023))\n\nI’ve added emphasis and edited this for clarity.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#packages-are-scalable",
    "href": "intro.html#packages-are-scalable",
    "title": "Introduction",
    "section": "Packages are scalable",
    "text": "Packages are scalable\nGreat R packages solve common problems.\nIf you’ve developed R functions for tasks such as analysis, data visualization, or report generation, consider creating a package instead of using source() to load them. This approach will help you expand your understanding from specific use cases (e.g., “this code performs a specific task”) to a broader perspective (e.g., “this package can perform various tasks”).\nThe advantage of having a mental model for R packages is that you will often observe similarities in common problems. Developing packages that address and solve frequent issues in your workflow can lead to some of the most valuable and popular contributions, as seen with packages like datapasta and reprex`.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#packages-to-know",
    "href": "intro.html#packages-to-know",
    "title": "Introduction",
    "section": "Packages to know",
    "text": "Packages to know\nI highly recommend reading and bookmarking the Shiny articles and the sites for the core package development tools:\n\ndevtools\n\npkgbuild\npkgload\nrcmdcheck\nrevdepcheck\nroxygen2\n\nremotes\nsessioninfo\nusethis",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introduction",
    "section": "",
    "text": "David Neuzerling has a great post on the benefits of structuring your project as a package↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "whole_game.html",
    "href": "whole_game.html",
    "title": "1  Whole app game",
    "section": "",
    "text": "1.1 A toy app-package\nThis chapter is modeled on the Whole Game chapter in R Packages, 2ed.1 We’ll go through the development of the monthAppPkg Shiny app-package (adapted from Mastering Shiny).2\nWe will briefly discuss creating an R package with a Shiny application. Each topic will be explained in detail in the next chapters. In the end, you will have a Shiny application with all the features and functions of an R package.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-description",
    "href": "whole_game.html#sec-use-description",
    "title": "1  Whole app game",
    "section": "1.2 Package metadata",
    "text": "1.2 Package metadata\nEvery R package requires a DESCRIPTION file. You can quickly create one using usethis::use_description().3\n\nusethis::use_description(\n  fields = list(\n    Package = 'monthAppPkg',\n    Title = 'An example app-pkg',\n    Version = '0.0.0.9000',\n    Description = 'A shiny application built inside an R package.',\n    \"Authors@R\" = NULL,\n    Author = utils::person(\n      given = \"Jane\",\n      family = \"Doe\",\n      role = c(\"aut\", \"cre\")\n    ),\n    Maintainer = utils::person(\n      given = \"Jane\",\n      family = \"Doe\",\n      email = \"Jane.Doeh@email.io\"\n    ),\n    License = \"GPL-3\"\n  )\n)\n\nThe values above in the fields list avoids the boilerplate content from use_description().4\nThe essential seven fields are shown below:5\nPackage: monthAppPkg\nTitle: An example app-pkg\nVersion: 0.0.0.9000\nAuthor: Jane Doe [aut, cre]\nMaintainer: Jane Doe &lt;Jane.Doeh@email.io&gt;\nDescription: A shiny application built inside an R package.\nLicense: GPL-3\nYou will get specific fields automatically for function documentation and dependency management.6\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-data",
    "href": "whole_game.html#sec-use-data",
    "title": "1  Whole app game",
    "section": "1.3 Data",
    "text": "1.3 Data\nTo include the birthstones.csv data in monthAppPkg, we’ll create a data-raw/ folder with usethis::use_data_raw(\"stones\"). Next, we’ll move the birthstones.csv file into data-raw/, load it into the Global Environment, and an R package data object witho usethis::use_data():\n\nusethis::use_data_raw(\"stones\")\n\n✔ Setting active project to '/path/to/monthAppPkg'\n✔ Creating 'data-raw/'\n✔ Adding '^data-raw$' to '.Rbuildignore'\n✔ Writing 'data-raw/stones.R'\n• Modify 'data-raw/stones.R'\n• Finish the data preparation script in 'data-raw/stones.R'\n• Use `usethis::use_data()` to add prepared data to package\nMove birthstones.csv to data-raw/birthstones.csv:\n\nfs::file_move(path = \"birthstones.csv\", new_path = \"data-raw/birthstones.csv\")\n\nContents of data-raw/stones.R:\n\n## code to prepare `stones` dataset goes here\nlibrary(vroom)\nstones &lt;- vroom::vroom(\"data-raw/birthstones.csv\")\nusethis::use_data(stones, overwrite = TRUE)\n\nRows: 12 Columns: 2                                                                                                                                \n── Column specification ──────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): month, stone\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nusethis::use_data(stones)\n\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Setting LazyData to 'true' in 'DESCRIPTION'\n✔ Saving 'stones' to 'data/stones.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nData should be documented using roxygen2 which we’ll cover in the data chapter.7",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-dependencies",
    "href": "whole_game.html#sec-use-dependencies",
    "title": "1  Whole app game",
    "section": "1.4 Dependencies",
    "text": "1.4 Dependencies\nEvery Shiny app-package depends on the shiny package. usethis::use_package()8 adds it under the Imports field the DESCRIPTION file.\n\nusethis::use_package(\"shiny\")\n\n✔ Adding 'shiny' to Imports field in DESCRIPTION\n• Refer to functions with `shiny::fun()`\nWe’re advised to use explicit namespacing (i.e., pkg::fun()), but we can avoid this by importing all Shiny’s functions into our package namespace using the @import tag from roxygen2.9",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-r-code",
    "href": "whole_game.html#sec-use-r-code",
    "title": "1  Whole app game",
    "section": "1.5 Package code",
    "text": "1.5 Package code\nCreate new .R files under R/ using use_r():\n\nusethis::use_r(\"monthFeedback\")\n\n✔ Setting active project to '/projects/apps/monthAppPkg'\n• Modify 'R/monthFeedback.R'\nBoth UI and server module functions are stored in R/monthFeedback.R and R/birthstone.R. Tests should also be created for each function.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-load-all",
    "href": "whole_game.html#sec-use-load-all",
    "title": "1  Whole app game",
    "section": "1.6 Loading",
    "text": "1.6 Loading\nShiny app development typically involves something like the following workflow:\n\nWrite UI/server code\n\nClick Run App\n\nRinse, repeat\n\nWhen making the switch from app development to app-package development, calling load_all() is somewhat analogous to clicking on the Run App icon–you’ll do it often (more than any other devtools or usethis function).\n\ndevtools::load_all()\n\nThe output we’re looking for from load_all() is straightforward:\nℹ Loading monthAppPkg\nload_all() is similar to calling library, but it’s specifically designed to be used during package development. Imagine sourcing all the functions in the R/ folder, but more sophisticated.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-package-tests",
    "href": "whole_game.html#sec-use-package-tests",
    "title": "1  Whole app game",
    "section": "1.7 Package tests",
    "text": "1.7 Package tests\nCreate tests for the code in the R/ folder using use_test()\n\nusethis::use_test(\"monthFeedbackServer\")\n\nThis will add test- files in tests/testthat/:\n\ntests/\n├── testthat/\n│   └── test-monthFeedbackServer.R\n└── testthat.R\n\n2 directories, 2 files\n\nThe first time you run use_test(), it will detect if your package has the testthat infrastructure (and create the necessary files if you don’t).10 use_test() will also adds the testthat package to the Suggests field in the DESCRIPTION and includes the edition (currently 3).\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Adding '3' to Config/testthat/edition\nTests are covered in Mastering Shiny,11 on the Shiny website,12 and in various testing packages (like shinytest13 and shinytest214).",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-app-dot-r",
    "href": "whole_game.html#sec-use-app-dot-r",
    "title": "1  Whole app game",
    "section": "1.8 app.R",
    "text": "1.8 app.R\nThe contents of app.R have been changed to include a call to pkgload::load_all() the standalone app function (monthApp()), which is stored in the R/ folder.\n\npkgload::load_all(\".\")\nmonthApp()\n\npkgload needs to be listed under Imports in the DESCRIPTION file (just like we did with shiny above).\n\nusethis::use_package(\"pkgload\")\n\n✔ Adding 'pkgload' to Imports field in DESCRIPTION\n• Refer to functions with `pkgload::fun()`\nBecause we’re only going to use load_all() from pkgload, we’ll use explicit namespacing (i.e., pkg::fun()).15\n\n1.8.1 use_package_doc()\nThe use_package_doc() creates the R/[[name]-package].R file, which can be used as a single location for declaring dependencies in monthAppPkg:\n\nusethis::use_package_doc()\n\n✔ Setting active project to 'projects/apps/monthAppPkg'\n✔ Writing 'R/monthAppPkg-package.R'\n• Modify 'R/monthAppPkg-package.R'\nWe’ll use @importFrom to add only the load_all() function to the NAMESPACE.\n\n#' @keywords internal\n\"_PACKAGE\"\n\n## usethis namespace: start\n#' @importFrom pkgload load_all\n## usethis namespace: end\nNULL\n\n\n\n1.8.2 use_build_ignore()\nR packages don’t typically have an app.R file in their root folder, so we’ll let devtools know this file should be ignored by creating a .Rbuildignore and include a pattern that excludes app.R whenever the package is built.\n\nusethis::use_build_ignore(\"app.R\")\n\n✔ Adding '^app\\\\.R$' to '.Rbuildignore'\nIt’s best to let use_build_ignore() handle excluding any files or folders from your package builds because it automatically writes the correct regular expression pattern.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-license-file",
    "href": "whole_game.html#sec-use-license-file",
    "title": "1  Whole app game",
    "section": "1.9 LICENSE",
    "text": "1.9 LICENSE\nUse one of the usethis license functions to add a LICENSE file.\n\nusethis::use_mit_license()\n\nThe license file should match the License field in the DESCRIPTION file (in this case, it’s MIT).16\n✔ Adding 'MIT + file LICENSE' to License\n✔ Writing 'LICENSE'\n✔ Writing 'LICENSE.md'\n✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-roxygen2",
    "href": "whole_game.html#sec-use-roxygen2",
    "title": "1  Whole app game",
    "section": "1.10 Document",
    "text": "1.10 Document\nAfter writing roxygen2 documentation for the data, modules, and standalone app function, calling devtools::document()() generates the .Rd files and NAMESPACE.17\n\ndevtools::document()\n\nThe output from document() tells us what files have been created (and if there were any errors in them).18\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nWriting NAMESPACE\nWriting NAMESPACE\nWriting birthstoneUI.Rd\nWriting birthstoneServer.Rd\nWriting monthApp.Rd\nWriting monthFeedbackUI.Rd\nWriting monthFeedbackServer.Rd\n\n1.10.1 Namespace\nThe NAMESPACE file contains the imported and exported functions from monthAppPkg:19\n# Generated by roxygen2: do not edit by hand\n\nexport(birthstoneServer)\nexport(birthstoneUI)\nexport(monthApp)\nexport(monthFeedbackServer)\nexport(monthFeedbackUI)\nimport(shiny)\nimportFrom(pkgload,load_all)",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-rstudio-project-options",
    "href": "whole_game.html#sec-use-rstudio-project-options",
    "title": "1  Whole app game",
    "section": "1.11 RStudio project options ",
    "text": "1.11 RStudio project options \nIf you’re developing in RStudio, we need to update our .Rproj file to enable the Build pane and keyboard shortcuts:\n\nfile.edit(\"monthAppPkg.Rproj\")\n\nIf your app-package was initially built as an RStudio project (i.e., not as a package), the following fields should be included at the bottom of monthAppPkg.Rproj:\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\nThese options are also available under Tools &gt; Project Options … &gt; Build Tools",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-git",
    "href": "whole_game.html#sec-use-git",
    "title": "1  Whole app game",
    "section": "1.12 Git",
    "text": "1.12 Git\nThe use_git() step is performed much earlier in R Packages, 2ed, but I’ve saved it for this step because using Git will prompt the IDE to re-initialize and display the Git pane (and it will also read our new settings in the .Rproj file).\n✔ Setting active project to '/projects/apps/monthAppPkg'\n✔ Initialising Git repo\n✔ Adding '.Rproj.user', '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\nThere are 12 uncommitted files:\n* '.gitignore'\n* '.Rbuildignore'\n* 'app.R'\n* 'data/'\n* 'DESCRIPTION'\n* 'LICENSE'\n* 'LICENSE.md'\n* 'man/'\n* 'monthAppPkg.Rproj'\n* 'NAMESPACE'\n* ...\nIs it ok to commit them?\n\n1: Absolutely not\n2: Not now\n3: Absolutely\nAgree to commit these files:\nSelection: 3\n✔ Adding files\n✔ Making a commit with message 'Initial commit'\n• A restart of RStudio is required to activate the Git pane\nRestart now?\n\n1: Not now\n2: Negative\n3: Absolutely\nRestarting RStudio will activate the Git and Build panes:\n\n\n\n\n\n\n\nGit Pane\n\n\n\n\n\n\n\n\n\nBuild Pane\n\n\nThis will also activate the devtools keyboard shortcuts:",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-keyboard-shortcuts",
    "href": "whole_game.html#sec-use-keyboard-shortcuts",
    "title": "1  Whole app game",
    "section": "1.13 Keyboard shortcuts",
    "text": "1.13 Keyboard shortcuts\nThe devtools keyboard shortcuts are available in RStudio and Positron.\n\n\n\n\n\n\nload_all()\nShift + Ctrl/Cmd + L\n\n\ndocument()\nShift + Ctrl/Cmd + D\n\n\n\n\ninstall()\nShift + Ctrl/Cmd + B\n\n\ntest()\nShift + Ctrl/Cmd + T",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-pkg-install",
    "href": "whole_game.html#sec-use-pkg-install",
    "title": "1  Whole app game",
    "section": "1.14 Install",
    "text": "1.14 Install\nInstalling monthAppPkg with devtools::install() produces see the following output in the Build pane:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nDocumentation completed\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source monthAppPkg\n\n* installing to library ‘/path/to/Library/R/x86_64/4.2/library’\n* installing *source* package ‘monthAppPkg’ ...\n** using staged installation\n** R\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (monthAppPkg)\nBack in the Console, RStudio will restart and call library(monthAppPkg):\nRestarting R session...\n\n&gt; library(monthAppPkg)\nWe can now launch the app using monthApp()\n\nmonthApp()\n\n\n\n\nOur monthApp() application\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('01_whole-app-game')",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-additional-files",
    "href": "whole_game.html#sec-use-additional-files",
    "title": "1  Whole app game",
    "section": "1.15 Additional files",
    "text": "1.15 Additional files\nThe following sections cover additional files you should include in your ap-package (but are not required).\n\n1.15.1 README\nA README.md file is the initial point of contact for users and/or contributors looking for information about your app-package. use_readme_rmd() will create a README.Rmd (i.e., the file you’ll edit), which serves as the source document for your README.md.\n\nusethis::use_readme_rmd()\n\nThe README.Rmd pattern is automatically added to the .Rbuildignore, and includes a Git ‘pre-commit’ hook:20\n✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n✔ Writing '.git/hooks/pre-commit'\n\n\n1.15.2 NEWS.md\nA NEWS.md is helpful for logging updates to your app-package and tracking release information.\n\nusethis::use_news_md()\n\nuse_news_md() will also prompt me to add and commit this file to the Git repository:\nThere is 1 uncommitted file:\n* 'NEWS.md'\nIs it ok to commit it?\n\n1: Negative\n2: Yeah\n3: Absolutely not\n\nSelection: 2\n✔ Adding files\n✔ Making a commit with message 'Add NEWS.md'\nThe contents of the NEWS.md are below:21\n# monthAppPkg (development version)\n\n* Initial CRAN submission.\n\n\n1.15.3 Vignettes\nVignettes can be used to store detailed tutorials, explanations of core concepts, use-cases, FAQs and troubleshooting, integration with other packages, etc.\n\nuse_vignette(\"monthAppPkg\")\n\nThe first time we call use_vignette() will prompt usethis to add the following fields in the DESCRIPTION:\n✔ Adding 'knitr' to Suggests field in DESCRIPTION\n✔ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✔ Adding 'knitr' to VignetteBuilder\nThe following files are also included in the .gitignore:\n✔ Adding 'inst/doc' to '.gitignore'\n✔ Creating 'vignettes/'\n✔ Adding '*.html', '*.R' to 'vignettes/.gitignore'",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#recap",
    "href": "whole_game.html#recap",
    "title": "1  Whole app game",
    "section": "1.16 Recap",
    "text": "1.16 Recap\nIn this chapter we’ve covered the steps used to create a package containing a Shiny application.\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#footnotes",
    "href": "whole_game.html#footnotes",
    "title": "1  Whole app game",
    "section": "",
    "text": "The example app comes from the Packages chapter of Mastering Shiny↩︎\nI’ve stored the code for this application in the 01_whole-app-game branch of the sap repository (to avoid confusing it with the actual application repo for this chapter).↩︎\nThe Whole Game chapter of R Packages, 2ed begins with the usethis::create_package() function, which calls usethis::use_description() internally.↩︎\nAt the time this was written, there are over 4,000 hits with the boilerplate value for Description (i.e., \"What the package does\"), which is a sign of how much usethis has been adopted (and how often people forget to come back and edit their DESCRIPTION file).↩︎\nIf you frequently develop R packages or Shiny apps, consider adding these fields to your .Rprofile.↩︎\nAlways leave an empty final line in the DESCRIPTION.↩︎\nView the documented stones dataset here on GitHub.↩︎\nWhenever you use a function from another package, start by running usethis::use_package() to ensure it’s in the DESCRIPTION file.↩︎\nI’ve included @import shiny above the definition of our standalone app function (R/launch_app.R), which means I don’t need to add shiny:: when using Shiny functions belowR/.↩︎\nYou can also set up the testthat infrastructure by calling usethis::use_testthat()↩︎\nThe Testing chapter in Mastering Shiny covers unit tests with testthat, shiny::testServer(), and the shinytest package.↩︎\nSee the ‘Server Function Testing’ article on the Shiny website for more information on testServer()↩︎\nCheck the shinytest package website and video tutorial for more information on testing your app.↩︎\nshinytest2 is an updated verison of shinytest with excellent documentation and videos.↩︎\nWe typically call devtools::load_all(), but using pkgload reduces the number of dependencies included with devtools. Read more about pkgload in the ‘Conscious uncoupling’ of devtools.↩︎\nuse_mit_license() will automatically include the LICENSE.md file in the root folder (and includes the necessary pattern in the .Rbuildignore to exclude it from the package builds).↩︎\nYou can include an Roxygen skeleton in the IDE by clicking on Code &gt; Insert Roxygen Skeleton, or using the keyboard shortcut: Option/⌥ + Shift⇧ + Ctrl/Cmd + R↩︎\nThe files created by document() rely on the roxygen2 package (and should not be edited manually).↩︎\nWe’re importing the everything from shiny and only load_all from pkgload):↩︎\nThis Git behavior is designed to prevent us from making changes to the README.Rmd and forgetting to re-render the README.md. If you find this behavior confusing or would like to disable it, run the following commands in the Terminal: rm .git/hooks/pre-commit↩︎\nThe Initial CRAN submission bullet doesn’t apply to monthAppPkg, so I’ll remove it and re-commit/push the NEWS.md file.↩︎",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "shiny.html",
    "href": "shiny.html",
    "title": "2  Shiny",
    "section": "",
    "text": "Shiny basics\nReactivity is the process that lets Shiny apps respond to user actions automatically. When developing Shiny apps, we need to connect inputs, reactivity, and outputs to manage how the app behaves and predict its actions.\nShiny programming is different from regular R programming in a few important ways:\nLearning reactivity can be challenging when you start, but fortunately, there are excellent tutorials and articles to help you along the way!",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#shiny-basics",
    "href": "shiny.html#shiny-basics",
    "title": "2  Shiny",
    "section": "",
    "text": "An Event-driven UI: Shiny apps require developers to create a user interface (UI) that helps users navigate the app. The UI registers user actions, such as button clicks or input changes, which trigger updates in the application.1\n\nRegular R programming often involves executing predefined steps or functions without direct interaction or responses to user events.\n\nA Reactive Server: In Shiny, the app reacts based on how inputs, values, and outputs are connected, which means that when a user makes a change, those changes are automatically shared throughout the app.\n\nIn standard R programming, we write functions to process data and generate outputs like graphs, tables, and model results. This method does not account for reactivity or downstream changes.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-shiny-projects",
    "href": "shiny.html#sec-shiny-projects",
    "title": "2  Shiny",
    "section": "2.1 Shiny projects ",
    "text": "2.1 Shiny projects \n\n\nLaunch app with the shinypak package:\n\nlaunch('02.1_shiny-app')\n\nRStudio’s New Project Wizard  can be used to create a new Shiny application project:\n\n\n\n\n\n\n\nNew Shiny app project\n\n\nNew app projects need a name and location:\n\n\n\n\n\n\n\nWe can also decide whether we want to use Git or renv\n\n\n\n2.1.1 Boilerplate app.R\nNote that the only items in the new Shiny app project are app.R and the sap.Rproj file.\n\nsap/\n    ├── app.R\n    └── sap.Rproj\n\n1 directory, 2 files\n\nIf you’ve created a new app project in RStudio , the app.R initially contains a boilerplate application, which we can launch by clicking on the Run App button:\n\n\n\n\n\n\n\n\n\nClick on Run App\n\n\n\n\n\n\n\n\n\n\n\n(a) Old Faithful geyser app\n\n\n\n\n\nFigure 2.1: Boilerplate Old Faithful geyser app in new Shiny projects\n\n\n\nThe boilerplate ‘Old Faith Geyser Data’ app is a perfect example of what Shiny can do with a single app.R file, but we’ll want to exchange this code for a more realistic application.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-introduce-movie-review-app",
    "href": "shiny.html#sec-introduce-movie-review-app",
    "title": "2  Shiny",
    "section": "2.2 Movies app",
    "text": "2.2 Movies app\n\n\nLaunch app with the shinypak package:\n\nlaunch('02.2_movies-app')\n\nThe next few sections will cover some intermediate/advanced Shiny app features using the Shiny app from the ‘Building Web Applications with Shiny’ course. This app is a great example for the following reasons:\n\nIt has multiple input types that are collected in the UI\nThe graph output can be converted to a utility function\nThe app loads an external data file when it’s launched\nThe code is accessible (and comes from a trusted source)\n\nAs Shiny applications become more complex, they often grow beyond just one app.R file. Knowing how to store utility functions, data, documentation, and metadata is important to manage this complexity. This preparation helps us successfully organize our Shiny apps into R packages.\n\n2.2.1 app.R\nThe code below replaces our boilerplate ‘Old Faith Geyser Data’ app in app.R:\n\n\nshow/hide movie review Shiny app\nui &lt;- shiny::fluidPage(\n  theme = shinythemes::shinytheme(\"spacelab\"),\n  shiny::sidebarLayout(\n    shiny::sidebarPanel(\n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.4\n      ),\n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 3\n      ),\n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n      shiny::actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n    shiny::mainPanel(\n      shiny::br(),\n      shiny::p(\n        \"These data were obtained from\",\n        shiny::a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n        shiny::a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \".\"\n      ),\n      shiny::p(\n        \"The data represent\",\n        nrow(movies),\n        \"randomly sampled movies released between 1972 to 2014 in the United States.\"\n      ),\n      shiny::plotOutput(outputId = \"scatterplot\"),\n      shiny::hr(),\n      shiny::p(shiny::em(\n        \"The code for this Shiny application comes from\",\n        shiny::a(\"Building Web Applications with shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"\n        )\n      ))\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- shiny::reactive({\n    tools::toTitleCase(input$plot_title)\n  }) |&gt;\n    shiny::bindEvent(input$update_plot_title,\n      ignoreNULL = FALSE,\n      ignoreInit = FALSE\n    )\n\n\n  output$scatterplot &lt;- shiny::renderPlot({\n    scatter_plot(\n      df = movies,\n      x_var = input$x,\n      y_var = input$y,\n      col_var = input$z,\n      alpha_var = input$alpha,\n      size_var = input$size\n    ) +\n      ggplot2::labs(title = new_plot_title()) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\n2.2.2 Utility functions\nI’ve converted ggplot2 server code into a scatter_plot() utility function:\n\n\nshow/hide scatter_plot()\nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\nThis function is stored in a new utils.R file:\n\n\n2.2.3 Data\nThe movies.RData dataset contains reviews from IMDB and Rotten Tomatoes. You can download these data here. The sap project now contains the following files:\n\nsap/\n  ├── app.R\n  ├── movies.RData\n  ├── sap.Rproj\n  └── utils.R\n\n2 directories, 4 files\n\nTo run the movies app, we need to load the data and source the utils.R file by adding the code below to the top of the app.R file:\n\n# install ------------------------------------\n# install pkgs, then comment or remove below\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# data -----------------------------------------\nload(\"movies.RData\")\n\n# utils ----------------------------------------\nsource(\"utils.R\")\n\n\n1\n\nInstall pkgs, then comment or remove below\n\n\n\n\nClicking on Run App displays the movie review app:\n\n\n\n\n\n\n\nMovie review app",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-shiny-folders",
    "href": "shiny.html#sec-shiny-folders",
    "title": "2  Shiny",
    "section": "2.3 Folders",
    "text": "2.3 Folders\nNow that we have a slightly more complex application in app.R, I’ll add a few project folders we can include in our project that have unique built-in behaviors. These folders will help organize your files and make additional resources available to your app.\n\n\nLaunch app with the shinypak package:\n\nlaunch('02.3_proj-app')\n\n\n2.3.1 R/\nIf your Shiny app relies on utility or helper functions outside the app.R file, place this code in an R/ folder. Any .R files in the R/ folder will be automatically sourced when the application is run.\n\n\n\n\n\n\nPlace utils.R in R/ folder\n\n\n\n\n\nI’ve moved the utils.R file into the R/ folder in sap:\n\nsap/\n     └── R/\n         └── utils.R\n\n1 directory, 1 file\n\n\n\n\nShiny’s loadSupport() function makes this process possible. We’ll return to this function in a later chapter, because the R/ folder has a similar behavior in R packages.2\n\n\n2.3.2 www/\nWhen you run a Shiny application, any static files (i.e., resources) under a www/ directory will automatically be made available within the application. This folder stores images, CSS or JavaScript files, and other static resources.\n\n\n\n\n\n\nCreate www/ folder and download image\n\n\n\n\n\nI’ve downloaded the Shiny logo (shiny.png) and stored it in the www/ folder.\n\nsap/\n     └── www/\n           └── shiny.png\n\n1 directory, 1 file\n\nIn the section below, we’ll reference shiny.png directly in the UI.\n\n\n\nFollowing the conventional folder structure will also help set you up for success when/if you decide to convert it into an app-package.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-shiny-files",
    "href": "shiny.html#sec-shiny-files",
    "title": "2  Shiny",
    "section": "2.4 Files",
    "text": "2.4 Files\nThe sections below cover additional files to include in your Shiny app. None of these files are required, but including them will make the transition to package development smoother.\n\n2.4.1 README\nIncluding a README.md file in your root folder is a good practice for any project. Using the standard markdown format (.md) guarantees it can be read from GitHub, too. README.md files should contain relevant documentation for running the application.\n\n\n\n\n\n\nCreate README.md\n\n\n\n\n\nI’ve included the content below in the README.md file\n# movies app\n\nThe original code and data for this Shiny app comes from the [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) course. It's been converted to use [shiny modules](https://shiny.posit.co/r/articles/improve/modules/). \n\nView the code for this application in the [`sap` branches](https://github.com/mjfrigaard/sap/branches/all).\n\n\n\n\n\n2.4.2 DESCRIPTION\nDESCRIPTION files play an essential role in R packages, but they are also helpful in Shiny projects if I want to deploy the app in showcase mode.\n\n\n\n\n\n\nCreate DESCRIPTION\n\n\n\n\n\nI’ve included the content below in DESCRIPTION:\n\nType: shiny\nTitle: movies app\nAuthor: John Smith\nDisplayMode: Showcase                                                 \n                                                                      \n\n\n\n\n\n\n\nIt’s always a good idea to leave at least one &lt;empty final line&gt; in your DESCRIPTION file.\n\nAfter adding README.md and a DESCRIPTION file (listing DisplayMode: Showcase), the movies app will display the code and documentation when the app launches.3",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-app-code",
    "href": "shiny.html#sec-app-code",
    "title": "2  Shiny",
    "section": "2.5 Code",
    "text": "2.5 Code\nThe following two items are considered best practices because they make your app more scalable by converting app.R into functions.\n\n2.5.1 Modules\nShiny modules are a ‘pair of UI and server functions’ designed to compartmentalize input and output IDs into distinct namespaces,\n\n‘…a namespace is to an ID as a directory is to a file…’ - shiny::NS() help file\n\nModule UI functions usually combine the layout, input, and output functions using tagList(). Module server functions handle the ‘backend’ logic within a Shiny server function. UI and server module functions are connected through an id argument. The UI function creates this id with NS() (namespace), and the server function uses moduleServer() to call it.\n\n2.5.1.1 Inputs\nThe mod_var_input_ui() function creates a list of inputs (column names and graph aesthetics) in the UI:\n\n\nshow/hide mod_var_input_ui()\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n1      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n2      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n3      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n4      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n5      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n6      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace',\"fontSize\":\"16px\"}}}%%\nflowchart TD\n    User([\"User\"])\n    subgraph mod_var_input_server[\"&lt;strong&gt;mod_var_input_server()&lt;/strong&gt;\"]\n        XServer[\\\"input$x\"\\]\n        YServer[\\\"input$y\"\\]\n        ZServer[\\\"input$z\"\\]\n        AlphaServer[\\\"input$alpha\"\\]\n        SizeServer[\\\"input$size\"\\]\n        TitleServer[\\\"input$plot_title\"\\]\n    end\n    subgraph mod_var_input_ui[\"&lt;strong&gt;mod_var_input_ui()&lt;/strong&gt;\"]\n        XUI[/\"X-axis\"/]\n        YUI[/\"Y-axis\"/]\n        ZUI[/\"Color by\"/]\n        AlphaUI[/\"Alpha\"/]\n        SizeUI[/\"Size\"/]\n        TitleUI[/\"Plot title\"/]\n    end\n    User --&gt; |\"&lt;em&gt;Selects...&lt;/em&gt;\"|mod_var_input_ui\n    mod_var_input_ui --&gt;|\"&lt;em&gt;Collects...&lt;/em&gt;\"| mod_var_input_server\n    mod_var_input_server --&gt; |\"&lt;em&gt;Returns...&lt;/em&gt;\"|Return([\"Reactive&lt;br&gt;list\"])\n    \n\n\n Variable input module \n\n\n\nmod_var_input_server() returns these values in a reactive list:\n\n\nshow/hide mod_var_input_server()\nmod_var_input_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n        reactive({\n          list(\n1            \"y\" = input$y,\n2            \"x\" = input$x,\n3            \"z\" = input$z,\n4            \"alpha\" = input$alpha,\n5            \"size\" = input$size,\n6            \"plot_title\" = input$plot_title\n          )\n        })\n    )\n  })\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\n\n\n2.5.1.2 Display\nmod_scatter_display_ui() creates a dedicated namespace for the plot output (along with some help text):\n\n\nshow/hide mod_scatter_display_ui()\nmod_scatter_display_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\"The data for this application comes from the \",\n        shiny::tags$a(\"Building web applications with Shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"),\n                      \"tutorial\"))\n      ),\n1    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\n\n1\n\nNamespaced module id for plot in UI\n\n\n\n\nmod_scatter_display_server() loads the movies data and collects the returned reactive list from variable input module as var_inputs.\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    User([\"User\"])\n    mod_var_input_ui[\"&lt;strong&gt;mod_var_input_ui()&lt;/strong&gt;\"]\n    mod_scatter_display_ui[\"&lt;strong&gt;mod_scatter_display_ui&lt;/strong&gt;\"] \n    \n    subgraph mod_scatter_display_server[\"&lt;strong&gt;mod_scatter_display_server()&lt;/strong&gt;\"]\n        var_inputs[\\\"var_inputs()\"\\]\n        inputs[\\\"inputs()\"\\]\n        scatter_plot(\"scatter_plot()\")\n    end\n    \n    subgraph mod_var_input_server[\"&lt;strong&gt;mod_var_input_server()&lt;/strong&gt;\"]\n        Reactives[/\"input$x&lt;br&gt;input$y&lt;br&gt;input$z&lt;br&gt;input$alpha&lt;br&gt;input$size\"/]\n        Title[/\"input$plot_title\"\\]\n    end\n    \n    User --&gt; |\"&lt;em&gt;Selects inputs...&lt;/em&gt;\"|mod_var_input_ui\n    mod_var_input_ui --&gt; |\"&lt;em&gt;Collects inputs..&lt;/em&gt;\"|mod_var_input_server\n    Reactives --&gt;|\"&lt;em&gt;Returns inputs...&lt;/em&gt;\"|selected_vars\n    Title -.-&gt; |\"&lt;em&gt;Optional input...&lt;/em&gt;\"|selected_vars\n    selected_vars[/\"selected inputs\"/] --&gt;|\"&lt;em&gt;Input argument for...&lt;/em&gt;\"|mod_scatter_display_server\n    var_inputs --&gt; inputs --&gt; scatter_plot\n    scatter_plot --&gt;|\"&lt;em&gt;Renders plot...&lt;/em&gt;\"|mod_scatter_display_ui\n    mod_scatter_display_ui --&gt;|\"&lt;em&gt;Displays output...&lt;/em&gt;\"|Display([\"Graph\"])\n    \n    style mod_scatter_display_ui stroke-width:2px,rx:3,ry:3\n    style mod_scatter_display_server stroke-width:2px,rx:3,ry:3\n    style mod_var_input_ui stroke-width:2px,rx:3,ry:3\n    style mod_var_input_server stroke-width:2px,rx:3,ry:3\n    style scatter_plot stroke-width:2px,rx:10,ry:10\n    style Reactives font-size:15px,stroke-width:1px,rx:5,ry:5\n    style Title font-size:15px,stroke-width:1px,rx:5,ry:5\n\n\n Display module \n\n\n\nvar_inputs() is used to build the inputs() reactive, which is passed to the scatter_plot() utility function. scatter_plot() creates the graph, adds the plot_title() (if necessary) and theme:\n\n\nshow/hide mod_scatter_display_server()\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    \n1    load(\"movies.RData\")\n\n2    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n3    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n4      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(\n                  tools::toTitleCase(\n                      inputs()$x),\n                  \"_\", \" \"),\n          y = stringr::str_replace_all(\n                  tools::toTitleCase(\n                    inputs()$y),\n                \"_\", \" \")\n        ) + \n5        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n1\n\nloading the movies data\n\n2\n\nassembling the returned values from mod_var_input_server(), and creating the input() reactive\n\n3\n\nscatter_plot() utility function creates the plot object\n\n4\n\nadds the plot_title()\n\n5\n\nadd theme to layers\n\n\n\n\nBoth UI and server module functions are combined into a single .R file, and all modules are placed in the R/ folder so they are sourced when the application is run.\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n └── utils.R\n\n\n\n\n2.5.2 Standalone app function\nInstead of using shiny::shinyApp() (or the Run App icon), we’ll want a custom standalone app function to launch our application. This give us more flexibility and control with our modules (and makes debugging easier).\n\n\nshow/hide launch_app()\nlaunch_app &lt;- function() { \n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n1          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n2          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      \n3      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n4      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\n\n\n\n1\n\nVariable input UI module\n\n2\n\nGraph display UI module\n\n3\n\nVariable input server module\n\n4\n\nGraph display server module\n\n\n\n\nThe id arguments (\"vars\" and \"plot\") connect the UI functions to their server counterparts, and the output from mod_var_input_server() is the var_inputs argument in mod_scatter_display_server().\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart LR\n    subgraph Launch[\"&lt;code&gt;launch_app()&lt;/code&gt;\"]\n        subgraph VarNS[\"Variable (&lt;code&gt;vars&lt;/code&gt;) Namespace\"]\n            VarInpuUI[\"UI Module:&lt;br&gt;&lt;code&gt;mod_var_input_ui()&lt;/code&gt;\"]\n            VarInpuServer[\"Server Module:&lt;br&gt;&lt;code&gt;mod_var_input_server()&lt;/code&gt;\"]\n            VarInpuUI &lt;--&gt; VarInpuServer\n        end\n        subgraph GraphNS[\"Graph (&lt;code&gt;plot&lt;/code&gt;) Namespace\"]\n        DisplayUI[\"UI Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_ui()&lt;/code&gt;\"]\n        DisplayServer[\"Server Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_server()&lt;/code&gt;\"]\n        PlotUtil[\"Utility Function:&lt;br&gt;&lt;code&gt;scatter_plot()&lt;/code&gt;\"]\n        VarInpuServer &lt;--&gt;|\"selected_vars\"|DisplayServer\n        DisplayServer &lt;-.-&gt; PlotUtil &lt;--&gt; DisplayUI\n        end\n    end\n\n    VarNS &lt;==&gt;|\"Communicates&lt;br&gt;across namespaces\"| GraphNS\n\n\n\n Standalone app function \n\n\n\nTo launch our app, we place the call to shinyApp() in a launch_app() function in app.R. Both module functions are combined in the ui and server arguments of shinyApp().\n\n\nshow/hide launch_app() in app.R\n# install ------------------------------------\n# after installing, comment this out\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\n2library(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\nlaunch_app &lt;- function() { \n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n3          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n4          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      \n5      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n6      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\nlaunch_app()\n\n\n\n1\n\nHeader (comment this out after the packages are installed)\n\n2\n\nLoad packages\n\n\n3\n\nVariable input UI module\n\n4\n\nGraph display UI module\n\n5\n\nVariable input server module\n\n6\n\nGraph display server module\n\n\n\n\nNow, I can run the app with launch_app().\n\n\n\n\n\n\n\nView a deployed version here\n\n\nThe deployed files of sap are below:\n\nsap/ # 02.3_proj-app branch\n├── DESCRIPTION\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── sap.Rproj\n├── rsconnect/\n│   └── shinyapps.io/\n│       └── user/\n│           └── sap.dcf\n└── www/\n    └── shiny.png\n\n6 directories, 10 files\n\n\n\nThe rsconnect/ folder has been removed from the 02.3_proj-app branch.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-adv-shiny-projects",
    "href": "shiny.html#sec-adv-shiny-projects",
    "title": "2  Shiny",
    "section": "2.6 Additional features",
    "text": "2.6 Additional features\nBelow are two additional ‘optional’ features that can be included with your Shiny application. I consider these ‘optional’ because they’re use depends on the specific needs and environment for each application.\n\n2.6.1 Globals\nPlacing a global.R file in your root folder (or in the R/ directory) causes this file to be sourced only once when the Shiny app launches, rather than each time a new user connects to the app. global.R is commonly used for initializing variables, loading libraries, loading large data sets and/or performing initial calculations.\n\n\n\n\n\n\nUsing global.R\n\n\n\n\n\nI could place the header from app.R in global.R to ensure these packages are loaded before the application launches:\n\n\nshow/hide contents of R/global.R\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n\nglobal.R can be placed in the R/ folder\n\nR/\n├── global.R\n├── mod_scatter_display.R\n├── mod_var_input.R\n└── utils.R\n\n1 directory, 4 files\n\nOr in the project root folder\n\n├── DESCRIPTION\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── global.R\n├── man\n├── movies.RData\n├── sap.Rproj\n└── www\n    └── shiny.png\n\n4 directories, 10 files\n\nIn both locations, it will be sourced before launching the application.\n\n\n\nglobal.R can be used to maintain efficiency and consistency across application sessions.\n\n\n2.6.2 Project dependencies (renv)\nIf you use renv to keep track of project-level dependencies, regularly run renv::status() and renv::snapshot() to keep the lockfile updated.\n\n\n\n\n\n\nUsing renv\n\n\n\n\n\nStart by initiating renv with renv::init(), then run renv::status() to check which packages have been added to the lockfile:\n\nrenv::status()\n\nThe following package(s) are in an inconsistent state:\n\n package      installed recorded used\n colorspace   y         n        y   \n fansi        y         n        y   \n farver       y         n        y   \n ggplot2      y         n        y   \n gtable       y         n        y   \n isoband      y         n        y   \n labeling     y         n        y   \n lattice      y         n        y   \n MASS         y         n        y   \n Matrix       y         n        y   \n mgcv         y         n        y   \n munsell      y         n        y   \n nlme         y         n        y   \n pillar       y         n        y   \n pkgconfig    y         n        y   \n RColorBrewer y         n        y   \n scales       y         n        y   \n shinythemes  y         n        y   \n tibble       y         n        y   \n utf8         y         n        y   \n vctrs        y         n        y   \n viridisLite  y         n        y   \nTake a ‘snapshot’ to capture the current package dependencies:\n\nrenv::snapshot()\n\nThe following package(s) will be updated in the lockfile:\n\n# CRAN --------------------------------------------------\n- lattice        [* -&gt; 0.21-8]\n- MASS           [* -&gt; 7.3-60]\n- Matrix         [* -&gt; 1.5-3]\n- mgcv           [* -&gt; 1.8-42]\n- nlme           [* -&gt; 3.1-162]\n- vctrs          [* -&gt; 0.6.3]\n\n# RSPM --------------------------------------------------\n- colorspace     [* -&gt; 2.1-0]\n- fansi          [* -&gt; 1.0.4]\n- farver         [* -&gt; 2.1.1]\n- ggplot2        [* -&gt; 3.4.2]\n- gtable         [* -&gt; 0.3.3]\n- isoband        [* -&gt; 0.2.7]\n- labeling       [* -&gt; 0.4.2]\n- munsell        [* -&gt; 0.5.0]\n- pillar         [* -&gt; 1.9.0]\n- pkgconfig      [* -&gt; 2.0.3]\n- RColorBrewer   [* -&gt; 1.1-3]\n- scales         [* -&gt; 1.2.1]\n- shinythemes    [* -&gt; 1.2.0]\n- tibble         [* -&gt; 3.2.1]\n- utf8           [* -&gt; 1.2.3]\n- viridisLite    [* -&gt; 0.4.2]\n\nDo you want to proceed? [Y/n]: y\n\n- Lockfile written to '~/path/to/sap/renv.lock'.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#recap",
    "href": "shiny.html#recap",
    "title": "2  Shiny",
    "section": "2.7 Recap",
    "text": "2.7 Recap\nThis chapter has covered some differences between developing Shiny apps and regular R programming, creating new Shiny projects in Posit Workbench, and some practices to adopt that can make the transition to app-packages a little easier. The code used in this chapter is stored in the sap repository.\n\n\n\n\n\n\nRecap\n\n\n\n\n\n\n\nPlacing utility or helper files in an R/ folder removes the need to call source() in app.R.\nImages, CSS, JavaScript, and other static resources can be stored in www/ and Shiny will serve these files when the application is run.\nREADME.md files can document the application’s description, purpose, requirements, etc.\nDESCRIPTION files provide metadata and include fields that affect application deployment (i.e., DisplayMode: Showcase)\nConverting the application code into functions (modules and standalone app functions) creates a ‘division of labor’ for each component, which makes it easier to think about and work on them independently.\nFinally, if you’re using renv, run renv::status() and renv::snapshot() to manage dependencies\n\n\n\n\n\nIn the next chapter, I’ll cover what makes a package a package, and some do’s and don’ts when converting a developed Shiny application into an R package.\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#footnotes",
    "href": "shiny.html#footnotes",
    "title": "2  Shiny",
    "section": "",
    "text": "Shiny apps require developers to design and develop a user interface (UI). User experience (UX) design is an entirely separate field, but as Shiny developers, we need to know enough to allow users to interact with and navigate our apps.↩︎\nShiny introduced these features in version 1.3.2.9001, and you can read more about them in the section titled, ‘The R/ directory’ in App formats and launching apps↩︎\nRead more about showcase mode here↩︎",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "3  Packages",
    "section": "",
    "text": "3.1 R packages\nBefore we start, we should establish some operational definitions of what is meant by the terms ‘project,’ ‘package,’ and ‘app-package.’\nThere are multiple reasons for deciding to develop a Shiny app-package, but if you’re reading this book, you’ve likely found yourself in one of two circumstances:\nThe previous chapters covered a few practices to adopt during development that improve the extensibility of your app and will make it easier to convert into a Shiny app-package.3\nR packages can be easily shared, reused, and reproduced because they all have a similar structure, and each folder and file plays an essential role in extending R’s capabilities. Below is a folder tree with some of the typical files and folders found in R packages:4\n&lt;R package&gt;/\n1    ├── DESCRIPTION\n2    ├── &lt;R package&gt;.Rproj\n3    ├── LICENSE\n    ├── LICENSE.md\n4    ├── NAMESPACE\n5    ├── NEWS.md\n6    ├── README.Rmd\n    ├── README.md\n7    ├── renv.lock\n8    ├── R/\n9    ├── man/\n10    ├── tests/\n11    ├── data/\n12    ├── data-raw/\n13    ├── vignettes/\n14    ├── inst/\n15    └── renv/\n  \n\n\n1\n\nMetadata file with the package’s purpose, dependencies, authors, and other essential information.\n\n\n2\n\nRStudio project file for managing and organizing the package’s development environment.\n\n3\n\nSpecifies the terms under which the package can be used, modified, and distributed.\n\n4\n\nDefines the functions and datasets exported by the package and the imports from other packages.\n\n\n5\n\nContains a changelog detailing updates and changes made across package versions.\n\n6\n\nProvides an overview of the package, usage examples, and installation instructions (typically for display on GitHub).\n\n\n7\n\nContains he exact package versions and dependencies for a reproducible development environment.\n\n8\n\nAll the R scripts with the package’s functions and main code.\n\n9\n\nDocumentation files for functions and datasets in .Rd format, generated using tools like roxygen2.\n\n\n10\n\nStores unit tests to validate the functionality of the package, often using frameworks like testthat.\n\n11\n\nIncludes preprocessed datasets provided with the package, saved in .RData or .rda format.\n\n12\n\nRaw data and scripts for processing it into the format stored in the data/ folder.\n\n13\n\nLong-form documentation and tutorials, written in RMarkdown, explaining package usage in depth.\n\n\n14\n\ndirectory for additional files installed with the package, such as documentation, examples, or datasets.\n\n\n15\n\nManages the package’s dependencies in an isolated environment, ensuring reproducibility.\nThe sections below cover the minimum requirements for an R package, so you can handle both creating new Shiny app-packages and converting existing Shiny projects into Shiny app-packages.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#sec-packages-r-pkgs",
    "href": "packages.html#sec-packages-r-pkgs",
    "title": "3  Packages",
    "section": "",
    "text": "3.1.1 Essential ingredients\nIf you’ve done some research on R packages, you’ve probably encountered one (or both) of the following statements,\n\n‘RStudio and devtools consider any directory containing DESCRIPTION to be a package’ - R Packages, 2ed (Chapter 9, DESCRIPTION)\n‘all a project needs to be a package is a directory of R/ files and a DESCRIPTION file.’ - Mastering Shiny (Chapter 20, Packages)\n\nBelow is the current sap app folder:\n\nsap/\n1├── DESCRIPTION\n├── sap.Rproj \n2├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n└── www/\n    └── shiny.png\n\n4 directories, 9 files\n\n\n1\n\nDESCRIPTION file\n\n\n2\n\nR/ folder with .R files\n\n\n\n\nWe can see sap has:\n\na DESCRIPTION file\nan R/ directory\n\nSo, is sap a functioning R package?\n\n3.1.1.1 Can we load it with devtools?\nPackage development kicks off with the load_all() function from devtools, which is similar to calling library() (we’ll cover this function extensively in the Development chapter).\nHowever, when we attempt to load the code in the R/ folder with load_all(), we see the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n\n\ndevtools is looking for the Package field in our DESCRIPTION file\n\n\n\n\n3.1.1.2 Does it have a DESCRIPTION?\n\n\nLaunch app with the shinypak package:\n\nlaunch('03.1_description')\n\nThe official R documentation5 lists the following required fields for the DESCRIPTION in R packages:\n\nThe ‘Package’, ‘Version’, ‘License’, ‘Description’, ‘Title’, ‘Author’, and ‘Maintainer’ fields are mandatory.\n\nBelow is an example DESCRIPTION file for our new sap package with the mandatory fields:6\n\nPackage: sap\nTitle: Shiny App-Packages\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: An R package with a collection of Shiny applications.\nLicense: GPL-3\n\n\n\n\n\n\n\nAuthor and Maintainer fields\n\n\n\n\n\nNote that the Author and Maintainer fields require additional information beyond first and last name (i.e., John Smith). These can be created with the utils::person() function:\n\n# Author\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  role = c(\"aut\", \"cre\"))\n## [1] \"John Smith [aut, cre]\"\n# Maintainer\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  email = \"John.Smith@email.io\")\n## [1] \"John Smith &lt;John.Smith@email.io&gt;\"\n\n\n\n\n\n\n\n3.1.2 RStudio’s Build pane \nIf you’re using RStudio, then functioning R packages also have access to the Build pane, which allows us to quickly load, install, and test code. When we open sap, the Build pane is not displayed in the IDE:\n\n\n\n\n\n\n\nThe Build pane is normally between Connections and Git\n\n\nAfter adding the seven mandatory fields to the DESCRIPTION file, devtools::load_all() runs without the previous error, but the IDE still doesn’t display the Build pane:\n\n\n\n\n\n\n\nWhere is the Build pane?\n\n\n\n3.1.2.1 RStudio projects \n.Rproj files are plain text files with various configurations for the RStudio IDE. We were able to run devtools::load_all() above without the presence of the Build pane because RStudio displays the Build pane after reading the fields in the .Rproj file.\nThe quickest way to access the fields in the .Rproj file is under Tools &gt; Project Options….\n\n\n3.1.2.2 Project options\nSelecting Tools &gt; Project Options… will provide us access to the project-level options. For example, fields 2 - 4 are available under General, 5 - 8 affect the Code options, and the final two fields deal with Sweave.\n\n\n\n\n\n\n\nField settings from sap.Rproj file\n\n\nThe default settings were created when we selected the Shiny app project from the New Project Wizard in the last chapter.\n\n\n3.1.2.3 Build tools\nI’ve placed the .Rproj file from sap with the example .Rproj file from R Packages, (2ed) side-by-side so you can compare them below:7\n\n\n\n\n\n\n\n\n\n(a) .Rproj files\n\n\n\n\n\nFigure 3.1: Comparison of sap.Rproj file and .Rproj file in R Packages, 2ed\n\n\n\nI’ve circled the fields in the .Rproj file that illustrate it’s configured to work with an R package. Note that in sap, the Project build tools are initially set to (None) under Build Tools:\n\n\n\n\n\n\n\n\n\n(a) sap.Rproj build tools\n\n\n\n\n\nFigure 3.2: Build tool settings in sap.Rproj file\n\n\n\nChanging the Project build tools option to Package will set the default Build Tools options:8\n\n\n\n\n\n\n\n\n\n(a) Default package build tools\n\n\n\n\n\nFigure 3.3: Default build tool settings\n\n\n\nThe links between the Build Tools options and fields in sap.Rproj are in the figure below:\n\n\n\n\n\n\n\n\n\n(a) sap.Rproj build tool fields\n\n\n\n\n\nFigure 3.4: Default build tool settings in sap.Rproj file\n\n\n\n\nBuildType: Package tells the IDE sap is an R package and triggers the Build pane.\nPackageUseDevtools: Yes links the options in the Build pane to the devtools package.\nThe PackageInstallArgs are complicated, but I’ve included some information about them in the callout block below (and you can read more in the official R documentation)\nThe fourth option (PackageRoxygenize) is available under Generate documentation with Roxygen &gt; Use roxygen to generate:\n\nThese options affect the documentation in an R package. To match the example from R Packages, 2ed above, make sure Rd files, Collate field, and NAMESPACE file are selected and click OK.\n\n\n\n\n\n\n\n\n\n\n\n(a) PackageRoxygenize in .Rproj file\n\n\n\n\n\nFigure 3.5: roxygen2 build settings\n\n\n\nAfter clicking OK, the IDE will automatically reboot, and the additional fields will be added to the bottom of the sap.Rproj:\n\n\nLaunch app with the shinypak package:\n\nlaunch('03.2_rproj')\n\n\nVersion: 1.0\n1ProjectId: 1b90afca-cb2f-ae46-4bc8-fc983de5f832\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\n                                            \n\n\n1\n\nProjectId is a relatively new field, and it helps keep each project configured with the RStudio IDE.\n\n\n\n\n\n\n\n\n\n\nWhat is --no-multiarch --with-keep.source?\n\n\n\n\n\n\n\n--no-multiarch: refers to the option for the package installer to only compile the package for the architecture of the current R session. By default, R tries to compile packages for 32-bit and 64-bit architectures if running in a 64-bit R session on Windows. This flag can help avoid problems if a package can only be compiled on one architecture. Read more here.\n--with-keep.source: In R, when a function is created, its body can be stored in two ways: 1) as a parsed but unevaluated expression and 2) as a character string containing the function’s source code. By default, only the parsed expression is kept. If –with-keep.source is specified, R will also keep the source code as a character string, which can be helpful for debugging and tools that analyze or modify source code. Read more here.\n\n\n\n\n\nWhen the new session starts, the new project-level options activate the Build pane in the IDE, and I can check the R package functionality by loading the code with Build &gt; Load All\n\n\n\n\n\n\n\nIdentical to running devtools::load_all()\n\n\n\n\n\n3.1.3 Positron’s workspaces \nPositron doesn’t recognize RStudio’s project files (.Rproj) or their build tools configuration. Instead, Positron organizes files and paths around workspaces.9\nA workspace is any folder that contains your project’s files. You can open an existing folder or create a new one from Positron’s welcome pane:\n\n\n\n\n\n\n3.1.3.1 Positron projects\nThe Welcome pane also offers an option for creating a New Project, but this shouldn’t be confused with creating an RStudio project.\nIf we follow the steps for a new project by specifying the type, name, and location:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe see this opens a folder in the IDE without an .Rproj file:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf you’re building your Shiny app from scratch, this is still a great way to get started because it makes it easy to adopt best practices (i.e., using Git and renv).\n\n\n3.1.3.2 Build tools\nIn Positron, all of the package development tools from devtools are available, but they are executed and handled a little differently by the IDE. We’ll cover these differences more in the Development, Degbug, and Tests chapters.\n\n\n\n3.1.4 R packages recap\nIn summary, to turn a Shiny Project  into a ‘functioning’ R package that can be installed and loaded into an R session we need:\n\nA DESCRIPTION file containing the seven mandatory fields (Package, Version, License, Description, Title, Author, and Maintainer), making running the necessary devtools functions possible.10\n\n\nIf we’re using RStudio, the .Rproj file must contain the three package configuration fields11, which makes the Build pane accessible and functional.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#sec-packages-app-pkgs",
    "href": "packages.html#sec-packages-app-pkgs",
    "title": "3  Packages",
    "section": "3.2 App-packages ",
    "text": "3.2 App-packages \nShiny app-packages  have all of the functionality of a standard R Package  but also contain the files and folders required to successfully develop, run, and deploy a Shiny app . The Posit documentation lists the following way(s) to create R packages:12\n\n\nCall usethis::create_package().\nIn Posit Workbench, do File &gt; New Project &gt; New Directory &gt; R Package. This ultimately calls usethis::create_package(), so really there’s just one way.\n\n\n\n\n\n\n\n\n\n\n\n\nSee the 03.3_create-package branch of sap.\n\ncreate_package() is a great option if you’re looking for a way to quickly create or convert your Shiny project into a Shiny app-package. In the following sections I’ll cover some suggestions for using create_package().13\n\n3.2.1 New app-packages\nIf you haven’t written any code and want to create a new Shiny app-package, create_package() is the quickest way to get started.\nFirst, install devtools:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\ndevtools automatically loads usethis\nLoading required package: usethis\nAssuming your current working directory is where you want your new Shiny app-package, call usethis::create_package() with the path argument set to getwd()\n\nusethis::create_package(path = getwd())\n\nThis call launches a series of actions:\n\nFirst, the active project is set to whatever was given to the path argument.\n✔ Setting active project to 'path/to/newApp'\nThe R/ folder and DESCRIPTION/ file are created:\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\nThe NAMESPACE and .Rproj files are created:\n✔ Writing 'NAMESPACE'\n✔ Writing 'newApp.Rproj'\nThe .Rproj is added to the .Rbuildignore file, the .Rproj.user folder is added to the .gitignore and .Rbuildignore files.\n✔ Adding '^newApp\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\nA new session is opened from the new .Rproj file:\n✔ Opening 'path/to/newApp/' in new RStudio session\n\nWhen the new session opens, newApp has the following contents:\n\nnewApp/\n  ├── .Rbuildignore\n  ├── .Rproj.user/\n  ├── .gitignore\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── newApp.Rproj\n\nYou’re now free to develop newApp. Store and document any .R files in the R/ folder, edit the DESCRIPTION file with details about the application, read through R Packages and Mastering Shiny, and add the Shiny code to complete your Shiny app-package.\n\n\n3.2.2 Converting a Shiny project\nIf you already have a Shiny app project that needs to be converted into a Shiny app-package, you can also use create_package(path = getwd()) in your root folder, but I recommend using the following arguments:\n\n3.2.2.1 DESCRIPTION arguments\n\nfields: these are arguments passed to usethis::use_description(). If the fields argument is empty, a boilerplate DESCRIPTION file is created (similar to this one).\n\nThese boilerplate fields in the DESCRIPTION work, but I’ve found some of the fields are unnecessary (i.e., I’ve never needed Authors@R: or ORCID) and inevitably require revision, so I’d prefer to handle this during the creation process (and remove the risk of forgetting to change it later).\nAll fields should be passed in a list() as field = 'value' pairs.\n\n\nusethis::use_description(\n    list(Package = 'sap',\n         Version = '0.3.3',\n         Title = 'Shiny App-Packages',\n         Description = 'An R package with a collection of Shiny applications.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"))\n\n\nA few fields require specially formatted values (see the utils::person() examples below).\n\nutils::person(\"John\", \"Smith\", \n              email = \"John.Smith@email.io\", \n              role = c(\"aut\", \"cre\"))\n\n[1] \"John Smith &lt;John.Smith@email.io&gt; [aut, cre]\"\n\n\n\nTwo additional arguments from use_description() are passed to create_package():\n\ncheck_name: verifies your Shiny app-package name is valid for CRAN, so we can set this to FALSE (unless you’re planning on submitting to CRAN)\nroxygen2: is TRUE by default and adds the fields required to use roxygen2 (which I won’t cover here because we’ll cover documentation in-depth in a future chapter).\n\n\n\n\n\n\n\n\nDon’t use \".\" with create_package()\n\n\n\n\n\n\nWhen converting your existing Shiny app project into a Shiny app-package with usethis::create_package(), don’t use '.' in the path argument:\nusethis::create_package('.')\nThis will return the following warning about creating nested projects, and ask if you want to proceed anyway:\nNew project 'sap' is nested inside an existing project\n'./', which is rarely a good idea. If this is unexpected, \nthe here package has a function,\n`here::dr_here()` that reveals why './' is regarded as a\nproject.\n  \nDo you want to create anyway?\n\n1: Yes\n2: No way\n3: Not now\nWe can avoid this warning altogether by passing getwd() to the path argument, so I recommend cancelling the project creation:\nSelection: 2\nError: Cancelling project creation.\n\n\n\n\n\n\n3.2.2.2 IDE arguments\n\nrstudio: adds the necessary Build Tools fields in the .Rproj file (leave as TRUE)\nopen: can be set to FALSE because we don’t need RStudio/Posit Workbench to open in a new session\n\n\nusethis::create_package(\n  path = getwd(),\n  fields = list(Package = 'sap',\n         Version = '0.3.3',\n         Title = 'Shiny App-Packages',\n         Description = 'An R package with a collection of Shiny applications.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            email = \"John.Smith@email.io\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"),\n  roxygen = TRUE,\n  check_name = FALSE, \n  rstudio = TRUE,\n  open = FALSE)\n\nAfter running usethis::create_package() with the arguments above, the IDE will present us with a few prompts to confirm:\nOverwrite pre-existing file 'DESCRIPTION'?\nOverwrite pre-existing file 'sap.Rproj'?\nThe Shiny app-package structure is below:\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── sap.Rproj\n└── www\n    └── Shiny.png\n\n3 directories, 10 files\nThe DESCRIPTION file (shown below) has a few additional fields (Encoding, Roxygen, and RoxygenNote) we didn’t include when we converted sap above, but we will cover these in the upcoming chapters.\nPackage: sap\nTitle: Shiny App-Packages\nVersion: 0.3.3\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: An R package with a collection of Shiny applications.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.2\n\n\nLaunch app with the shinypak package:\n\nlaunch('03.3_create-package')",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#recap",
    "href": "packages.html#recap",
    "title": "3  Packages",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered the mandatory fields in the DESCRIPTION file and the R package configuration fields in .Rproj. We also covered creating and converting Shiny app projects using the usethis::create_package() function.\n\n\n\n\n\n\nRecap: Packages!\n\n\n\n\n\n\n\nThe DESCRIPTION file ultimately controls whether you have a functional Shiny app-package.\n\nThe mandatory fields are Package, Version, License, Description, Title, Author, and Maintainer.\n\nusethis::create_package() can be used to create a new R package and to convert an existing Shiny project into a Shiny app-package.\nThe RStudio IDE reads project (.Rproj) files and determines R session settings at the project-level (i.e., working directory, workspace, history, code formatting, etc.)\n\nPackage development settings can be accessed via Project Options &gt; Build Tools.\n\n\n\n\n\n\nIn the next chapter, I’ll cover how you can quickly Load, Document, and Install your package!\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#footnotes",
    "href": "packages.html#footnotes",
    "title": "3  Packages",
    "section": "",
    "text": "If you’re developing in RStudio , your Shiny project might also include a Posit workbench project file (.Rproj).↩︎\nIf you’re working in RStudio , your R package will also likely include a project file (.Rproj).↩︎\nShiny app project features are covered in Section 2.3 and Section 2.4 of the previous chapter.↩︎\nFortunately, Shiny app-packages don’t require all the files and folders displayed in the folder tree to gain the functionality and benefits of an R package.↩︎\nThe mandatory fields are covered in Writing R Extensions, ‘The DESCRIPTION file’↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎\n.Rproj files are covered in the What makes an RStudio Project? section of R Packages (2 ed)↩︎\nThe initial Build Tools settings (i.e., (None)) should help explain the absence of any R package development fields in the sap.Rproj when we compared it to the version in R Packages, 2ed (i.e., BuildType, PackageUseDevtools, PackageInstallArgs, and PackageRoxygenize).↩︎\nLearn more about this in Jenny Bryan’s discussion in the Introducing Positron, a new data science IDE presentation at posit::conf(2024).↩︎\nRead more about the mandatory fields DESCRIPTION fields.↩︎\nThe .Rproj package configuration fields are BuildType: Package, PackageUseDevtools: Yes, and PackageInstallArgs: --no-multiarch --with-keep.source.↩︎\nThis information comes from the Writing R Packages documentation for Posit Workbench.↩︎\nusethis::create_package() is covered in the ‘Fundamental development workflows’ chapter of R Packages, 2ed↩︎",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "development.html",
    "href": "development.html",
    "title": "4  Development",
    "section": "",
    "text": "4.1 Getting started\nIf you’d like a refresher on the Shiny and R package chapters, I’ve provided a refresher of these topics below:\nIf you’re new to package development, having a little background on the devtools package is helpful. Earlier versions of devtools contained most of the functions used for package development. In version 2.0, devtools went under a conscious uncoupling, which means there was a “division of labor” for its core functionality:\nYou don’t have to install all of these packages (they will be loaded with devtools), but the information is essential because it affects the dependencies in your app-package:\nWe will cover this topic more in the dependencies chapter..\nBefore we can start developing, we need to install devtools:\ninstall.packages(\"devtools\")\nlibrary(devtools)\nusethis is automatically loaded/attached with devtools.\nLet’s assume we’re continuing with a Shiny project from the previous branch of sap. Our Shiny project has a DESCRIPTION file and the code has been placed in the R/ folder, so we’re ready to start developing our app-package with devtools (the files and folders are below).\nsap/ \n1  ├── DESCRIPTION\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n2  ├── sap.Rproj\n  └── www\n      └── shiny.png\n\n4 directories, 9 files\n\n\n1\n\nThe DESCRIPTION file contains the required fields: Package, Version, License, Description, Title, Author, and Maintainer.\n\n\n2\n\nThe .Rproj file is still configured to work with a Shiny project (not an R package).",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#getting-started",
    "href": "development.html#getting-started",
    "title": "4  Development",
    "section": "",
    "text": "Loading required package: usethis\n\n\n\n\n\n\n\n\n\n\n\nSee the 03.1_description branch of sap.\n\n\n\n4.1.1 Keyboard shortcuts\nI strongly recommend using the keyboard shortcuts for each devtools function. Shortcuts reduce typing and bundle all those keystrokes into a single action. They also create a kind of ‘muscle memory’ for each step.\nIn RStudio , new keyboard shortcuts can be created using the shrtcts package or by clicking on Tools &gt; Modify Keyboard Shortcuts.\nIn Positron , the devtools functions covered below are already mapped to the keyboard shortcuts. Follow the instructions found in Positron’s Wiki to add new shortcuts.\n\n\n4.1.2 Habits\nThe differences between developing an R package and a Shiny app can be boiled down to a handful of habits, each of which calls a devtools function:\n\n\nI’ll use this font style to indicate each habit and accompanying function.\n\nLoad all the functions and data in your app-package with load_all()\nDocument the app-package functions and data with document()\nInstall the app-package with install()\n\nIn the sections below, I’ll cover each devtools function and my habits around their use when my Shiny app transitions to an app-package.1",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#sec-dev-load",
    "href": "development.html#sec-dev-load",
    "title": "4  Development",
    "section": "4.2 Load",
    "text": "4.2 Load\nload_all() is the most common devtools function used during development. Load the package when anything changes in the R/ folder.\n\n‘load_all() removes friction from the development workflow and eliminates the temptation to use workarounds that often lead to mistakes around namespace and dependency management’ - Benefits of load_all(), R Packages, 2ed\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n=\n\n\ndevtools::load_all()\n\n\n\n\nUsing load_all() is similar to calling library(sap) because it loads the code in R/ along with any data files. load_all() is also designed for iteration (unlike using source()), and when it’s successful, the output is a single informative message:\nℹ Loading sap",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#sec-dev-document",
    "href": "development.html#sec-dev-document",
    "title": "4  Development",
    "section": "4.3 Document",
    "text": "4.3 Document\nThe document() function from devtools serves two purposes:\n\nWriting the package NAMESPACE file\nCreates the help files in the man/ folder\n\nDocument a package whenever changes are made to the roxygen2 syntax or DESCRIPTION.\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n=\n\n\ndevtools::document()\n\n\n\n\ndevtools is smart enough to recognize the first time document() is called, so when I initially run it in the Console, it prompts me that the roxygen2 version needs to be set in the DESCRIPTION file:2\nℹ Updating sap documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.3.2\"\nYou may have noticed calling document() also calls load_all(), which scans the loaded package contents for special documentation syntax before writing the NAMESPACE file (we’ll cover the NAMESPACE in the Dependencies chapter).\nℹ Loading sap\nWriting NAMESPACE\nIf we open the NAMESPACE file, we see it’s empty (and that we shouldn’t edit this file by hand).\n\n\n\n\n\n\nFigure 4.1: Initial NAMESPACE file\n\n\n\nThe last few output lines warn us to include the Encoding field in the DESCRIPTION.\nWarning message:\nroxygen2 requires Encoding: \"UTF-8\"\nℹ Current encoding is NA \ndevtools won’t automatically add Encoding (like it did with RoxygenNote above), so we’ll need to add it to the DESCRIPTION file manually:\n\nPackage: sap\nVersion: 0.0.0.9000\nType: Package\nTitle: Shiny App-Packages\nDescription: An R package with a collection of Shiny applications.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\n1Encoding: UTF-8\n                                                      \n\n\n1\n\nThe Encoding value shouldn’t include quotes like the warning message above (i.e., UTF-8)\n\n\n\n\nAfter adding the required fields to the DESCRIPTION file,3 we’ll document() the package again and we should see the following:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating sap documentation\nℹ Loading sap\nDocumentation completed",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#sec-dev-install",
    "href": "development.html#sec-dev-install",
    "title": "4  Development",
    "section": "4.4 Install",
    "text": "4.4 Install\nThe final development habit checking if our app-package can be installed locally with devtools::install() or pak::local_install(upgrade = FALSE) (depending on the IDE you’re using).\nInstall a package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n=\n\n\ndevtools::install()\n\n\n\n\n4.4.1 In RStudio \n\ninstall() will prompt the following output in the Build pane:\n1==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source sap\n\n2* installing to library ‘/path/to/local/install/sap-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n3* installing *source* package ‘sap’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n4No man pages found in package  ‘sap’\n5** help\n*** installing help indices\n** building package indices\n6** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n7** testing if installed package keeps a record of temporary installation path\n8* DONE (sap)\n\n1\n\nWe saw both of these R CMD INSTALL settings in the sap.Rproj file from the previous chapter\n\n\n2\n\nFull file path for installation\n\n3\n\ninstall() attempts to install the package from the *source* files and a ‘bundle’ or source tarball file (i.e., .tar.gz)\n\n4\n\nNo man pages found in package 'sap' tells us none of the code in R/ has adequately been documented (which we’ll cover in the roxygen2 chapter)\n\n\n5\n\nBuilding the ?help files\n\n\n6\n\nChecks to see if package can be loaded from multiple locations and stores\n\n7\n\nChecks to see if package stores the install location\n\n8\n\nDONE (sap) means sap was successfully installed!\n\n\n\n\n4.4.2 In Positron \n\nIn Positron, Ctrl/Cmd + Shift + B will call pak::local_install(upgrade = FALSE). This command will be run in a new Terminal window:\n1 *  Executing task: /Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/bin/R -e 'pak::local_install(upgrade = FALSE)'\n\n\n2R version 4.4.0 (2024-04-24) -- \"Puppy Cup\"\nCopyright (C) 2024 The R Foundation for Statistical Computing\nPlatform: x86_64-apple-darwin20\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n3&gt; pak::local_install(upgrade = FALSE)\n4✔ Updated metadata database: 7.50 MB in 12 files.\n✔ Updating metadata database ... done\n \n5→ Will update 1 package.\n→ The package (0 B) is cached.\n+ sap 0.0.0.9000 → 0.0.0.9000 👷🏾‍♂️\nℹ No downloads are needed, 1 pkg is cached\n✔ Got sap 0.0.0.9000 (source) (96 B)\n6ℹ Packaging sap 0.0.0.9000\n✔ Packaged sap 0.0.0.9000 (18.2s)\n7ℹ Building sap 0.0.0.9000\n✔ Built sap 0.0.0.9000 (3.1s)\n8✔ Installed sap 0.0.0.9000 (local) (63ms)\n9✔ 1 pkg + 54 deps: kept 54, upd 1, dld 1 (NA B) [53.2s]\n&gt; \n&gt; \n10 *  Terminal will be reused by tasks, press any key to close it.\n\n1\n\nName of task and terminal\n\n\n2\n\nStarts new R session\n\n3\n\nCalls pak::local_install(upgrade = FALSE)\n\n\n4\n\npak will check the package database for updates\n\n5\n\nthe upgrade = FALSE means pak is going to do “the minimum amount of work to give you the latest version(s) of pkg”\n\n6\n\nPackaging sap\n\n7\n\nBuilding sap\n\n\n8\n\nInstalling sap\n\n\n9\n\nSummary (‘kept 54 dependencies, updated 1, downloaded 1 package’)\n\n10\n\nClose Terminal message\n\n\n\n\nWhat’s the difference?\ndevtools::install() focuses on helping package developers by managing all necessary steps for installation, including rebuilding documentation and running tests. install() also automatically updates outdated dependencies during installation unless dependencies is set to FALSE.\npak::local_install() is designed to use parallel downloads and more efficient dependency resolution, making it faster and more reliable than devtools::install() in many cases.4 The upgrade = FALSE installs a package without upgrading its dependencies, keeping the current package versions intact.\n\n\nLaunch app with the shinypak package:\n\nlaunch('04_devtools')",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#sec-dev-check",
    "href": "development.html#sec-dev-check",
    "title": "4  Development",
    "section": "4.5 Check?",
    "text": "4.5 Check?\ndevtools::check() performs a series of checks to ensure a package meets the standards set by CRAN. You can consider check() as a ‘quality control’ function for documentation, NAMESPACE dependencies, unnecessary or non-standard folders and files, etc. R Packages recommends using check() often, but I agree with the advice in Mastering Shiny on using check() with app-packages,\n\n‘I don’t recommend that you [call devtools::check()] the first time, the second time, or even the third time you try out the package structure. Instead, I recommend that you get familiar with the basic structure and workflow before you take the next step to make a fully compliant package.’\n\nHowever, I’ve included an example of running check() on sap in the callout box below to demonstrate how it works.\n\n\n\n\n\n\nRunning devtools::check()\n\n\n\n\n\n\ndevtools::check()\n\nThe output from check() can be rather lengthy (it’s pretty comprehensive!), and it provides feedback on each item in the form of a note (N), warning (W), or error (E).\n==&gt; devtools::check()\n\nDuration: 15.3s\n\nN  checking top-level files\n   Non-standard files/directories found at top level:\n     ‘app.R’ ‘movies.RData’\n\nW  checking dependencies in R code ...\n   '::' or ':::' imports not declared from:\n     ‘ggplot2’ ‘shiny’ ‘stringr’\n\nN  checking R code for possible problems (3.1s)\n   mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n     variable ‘movies’\n   scatter_plot: no visible binding for global variable ‘.data’\n   Undefined global functions or variables:\n     .data movies\n\nW  checking for missing documentation entries ...\n   Undocumented code objects:\n     ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n     ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n   All user-level objects in a package should have documentation entries.\n   See chapter ‘Writing R documentation files’ in the ‘Writing R\n   Extensions’ manual.\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nA summary of each item is below:\n\nchecking top-level files: This note refers to the two non-standard (i.e., not typically found in an R package) files, app.R and movies.RData.\nchecking dependencies in R code: This warning tells I need to namespace functions from add-on packages (in this case, ggplot2, shiny, and stringr)\nchecking R code for possible problems: This item refers to the call to load the movies data in the module server function (mod_scatter_display_server).\nchecking for missing documentation entries: This is warning me that the module functions aren’t properly documented and refers me to the official R documentation.\n\nEach of these items is also printed under the ── R CMD check results heading:\n\n\nshow/hide R CMD check results\nDuration: 15.3s\n\n❯ checking dependencies in R code ... WARNING\n  '::' or ':::' imports not declared from:\n    ‘ggplot2’ ‘shiny’ ‘stringr’\n\n❯ checking for missing documentation entries ... WARNING\n  Undocumented code objects:\n    ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n    ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n  All user-level objects in a package should have documentation entries.\n  See chapter ‘Writing R documentation files’ in the ‘Writing R\n  Extensions’ manual.\n\n❯ checking top-level files ... NOTE\n  Non-standard files/directories found at top level:\n    ‘app.R’ ‘movies.RData’\n\n❯ checking R code for possible problems ... NOTE\n  mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n    variable ‘movies’\n  scatter_plot: no visible binding for global variable ‘.data’\n  Undefined global functions or variables:\n    .data movies\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\n\n\nIf you’re submitting your app-package to CRAN (or want to use check() for other reasons), follow the suggested workflow for check():\n\nThe workflow for checking a package is simple, but tedious:\n\nRun devtools::check() or press Shift + Ctrl/Cmd + E\nFix the first problem.\nRepeat until there are no more problems.’\n\n\nI’ve found a good habit for when to check() to be:\nAfter adding a bug fix or feature, check a package and keep any notes, warnings, or errors from accumulating.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#package-versions",
    "href": "development.html#package-versions",
    "title": "4  Development",
    "section": "4.6 Package versions",
    "text": "4.6 Package versions\nThe DESCRIPTION file contains a boilerplate version number (0.0.0.9000) to signify it’s a development package.5 Generally speaking, R package development versions follow the Semantic versioning methods:\n\nGiven a version number MAJOR.MINOR.PATCH, increment the:\n1. MAJOR version when you make incompatible API changes\n2. MINOR version when you add functionality in a backward compatible manner\n3. PATCH version when you make backward compatible bug fixes\nAdditional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\n\nIn this book, the package versions all begin with 0.0.0.9000, because they should all be considered ‘development’ packages. However, I’ve included the chapter/section to align with the package version. So this chapter’s version is:\n\nPackage: sap\nVersion: 0.0.0.9400\nType: Package\nTitle: Shiny App-Packages\nDescription: An R package with a collection of Shiny applications.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#hidden-files",
    "href": "development.html#hidden-files",
    "title": "4  Development",
    "section": "4.7 Hidden files",
    "text": "4.7 Hidden files\nYou might notice additional ‘hidden’ files in your new app-package:6 .gitignore, .Rbuildignore, and .Rprofile:\n\n4.7.1 .gitignore\n.gitignore will ignore some of the standard hidden files created by R or RStudio. The initial contents will include something like the following:\n\n.Rproj.user\n.Rhistory\n.RData\n.Ruserdata\n.DS_Store # for mac users \n\n\n\n4.7.2 .Rbuildignore\n.Rbuildignore includes files that we need to have in our app-package, but don’t conform to the standard R package structure (and shouldn’t be included when building our app-package from the source files).\n\n^.*\\.Rproj$\n^\\.Rproj\\.user$\n\nNote the syntax for detecting file patterns.\n\n\n4.7.3 .Rprofile\nThe .Rprofile is specific to the user (you) and might include options for loading packages or tests:\n\nif (interactive()) {\n  require(usethis, quietly = TRUE)\n}\noptions(shiny.testmode = TRUE)\n\n.Rprofile is also included in your directory if you’re using renv to manage packages/versions.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#recap",
    "href": "development.html#recap",
    "title": "4  Development",
    "section": "Recap",
    "text": "Recap\nCreating an app-package involves adopting some new devtools habits, and the initial contents of sap hopefully helped demonstrate the purpose of each function.\n\n\n\n\n\n\nRecap: Package development habits\n\n\n\n\n\n\nAfter installing and loading devtools:\n\nLoad the package whenever changes occur in the R/ folder.\n\nCtrl/Cmd + Shift + L load all the code in the package.\n\nDocument the package whenever changes are made to any roxygen2 syntax or the DESCRIPTION file..\n\nCtrl/Cmd + Shift + D record the documentation and dependencies.\n\nInstall the package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\nCtrl/Cmd + Shift + B confirms the package can be installed.\npak::local_install() benefits from optimized dependency resolution and download methods\ndevtools::install() handles a broader range of tasks during installation (including rebuilding documentation and running tests)\n\n\nHabits require repetition to develop, but things like keyboard shortcuts can help minimize the friction we all experience with change.\n\n\n\n\nThe following section will cover documenting functions with roxygen2\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#footnotes",
    "href": "development.html#footnotes",
    "title": "4  Development",
    "section": "",
    "text": "The topics covered in this section shouldn’t be considered a replacement for the ‘Whole Game’ chapter in R packages (2 ed) or the ‘Workflow’ section of Mastering Shiny (and I highly recommend reading both).↩︎\ndevtools relies on roxygen2 for package documentation, so the RoxygenNote field is required in the DESCRIPTION.↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎\nIt stands to reason that installing a package with pak::local_install() in Positron would be faster than installing a package using devtools::install() in RStudio, but this has not been my experience.↩︎\nRead more about package development version in R Packages, 2nd Ed.↩︎\nBy convention, files that begin with . (dot files) are considered hidden.↩︎",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "app_packages.html",
    "href": "app_packages.html",
    "title": "App-packages",
    "section": "",
    "text": "App-packages\nExpand the callout boxes below to review what we’ve covered in the last four chapters:\nIn the following chapters, we will continue developing our Shiny application within the R package structure. Below is a preview of each topic covered in the upcoming chapters.",
    "crumbs": [
      "App-packages"
    ]
  },
  {
    "objectID": "app_packages.html#app-packages",
    "href": "app_packages.html#app-packages",
    "title": "App-packages",
    "section": "",
    "text": "Documentation (Chapter 5)\n5  Documentation covers documenting the code in your app-package with roxygen2:\n\nRequired tags:\n\n5.1.2 Markdown support\n5.1.3 Title & description\n5.1.4 Parameters & return objects and\n5.1.6 Examples\n\nApp-package tags for modules and standalone app functions:\n\n5.2.1 See also\n\n5.2.2 Family\n\n5.3.1 Usage, and\n\n5.2.3 Section\n\n\n\n\nDependencies (Chapter 6)\n6  Dependencies dives into the external (i.e. add-on) functions and packages you’ve used to build your app-package. We’ll also cover how to export functions and objects from your app-packages for others to use.\n\n6.2 Package exports\n\n6.3 Package imports\n\n\n\nData (Chapter 7)\n7  Data covers how to include datasets in your app-package namespace, and the various kinds of data in R packages.\n\nStoring and Documenting data:\n\n7.1 The data/ folder\n7.3 Documenting data\n\n\nRaw data files:\n\n7.2 data-raw/\n\n\nOther locations for data:\n\n7.4 External data\n\n\n\n\nLaunch (Chapter 8)\nThe 8  Launch chapter covers how to 1) run your application during development, 2) how to run your app using a standalone app function, and 3) how to deploy your application to shinyapps.io.\n\nApp run functions:\n\n8.2.1 shinyApp()\n8.2.2 shinyAppDir()\n8.2.3 runApp()\n\nLaunching app files:\n\n8.4 The app.R file\n\n\n\n\nResources (Chapter 9)\n9  Resources covers how to include external resources (i.e. the images, CSS, html, or other files that are typically included in the www/ folder and served when you run your Shiny app). This chapter also covers other uses for the isnt/ folder in app-packages.\n\nStatic files:\n\n9.1 Image files\n\n9.1.2 addResourcePath()\n\n\nData files:\n\n9.2.1 A tidy-movies app\n\n\nQuarto apps:\n\n9.3 Quarto apps\n\n\nProduction:\n\n9.4 Production\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages"
    ]
  },
  {
    "objectID": "document.html",
    "href": "document.html",
    "title": "5  Documentation",
    "section": "",
    "text": "5.1 roxygen2 basics\nThis chapter covers documenting Shiny app functions with roxygen2. I’ll start by introducing the fundamentals of the roxygen2 syntax, but also touch on a few helpful tips specific to Shiny modules and standalone app functions.\nThe current structure of our sap package is displayed in the folder tree below:1\n(the rsconnect/ folder from deploying sap has been removed)\nWhen we use devtools::install(), the following message regarding documentation is returned:\nDocumenting the functions in the R/ folder will address this message, and I strongly encourage checking out the roxygen2 vignettes and the chapter in R Packages, 2ed for more information on documenting your app-package.\nroxygen2 connects the package code (i.e., the .R files in the R/ folder) to its documentation files (i.e., the .Rd files in the man/ folder). Two pieces of roxygen2 syntax to know are comment blocks and tags:\nThe roxygen2 tags and comment blocks are placed above functions and used with devtools::document() to create help documentation:\n#' \n#' @tag\n#' \nmy_fun &lt;- function() {\n  \n}\nIn the following sections, we’ll cover some roxygen2 basics using the scatter_plot() function in the R/utils.R file.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#sec-intro-roxygen2",
    "href": "document.html#sec-intro-roxygen2",
    "title": "5  Documentation",
    "section": "",
    "text": "See the 04_devtools branch of sap.\n\n\n\nComment blocks are any lines beginning with #'\n\n#' \n#' \n#' \n\nTags begin with @\n\n#' \n#' @tag\n#' \n\n\n\n\n\n\n5.1.1 File name alignment\nShiny apps (and most R projects) often contain utility functions in helper.R or utils.R files. Placing non-Shiny code in these files isn’t a bad practice–it’s is even encouraged in Mastering Shiny:\n\n“You might want to collect smaller, simpler, functions into one place. I often use R/utils.R for this…”\n\nHowever, because we’ll want to develop tests for scatter_plot(), we should follow the advice in R Packages,2 and rename R/utils.R to R/scatter_plot.R as we transition to an app-package.3\n\n\n\n\n\n\nR/utils.R\n\n\n\n\n\n\nFrom now on, I’ve renamed R/utils.R to R/scatter_plot.R, so it aligns with the naming conventions in other R packages.\nFor a deep dive on R/utils.R files in R packages, I recommend reading Dissecting R Package “Utility Belts”\n\n\n\n\n\n\n5.1.2 Markdown support\nWhen we created our app-package with create_package(), support for markdown formatting in our package help files was automatically included by adding Roxygen: list(markdown = TRUE) to the DESCRIPTION file:\n\nPackage: sap\n1Version: 0.0.0.9500\nType: Package\nTitle: Shiny App-Packages\nDescription: An R package with a collection of Shiny applications.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.3.2\nEncoding: UTF-8\n2Roxygen: list(markdown = TRUE)\n                                                    \n\n\n1\n\nUpdated package version\n\n\n2\n\nMarkdown support\n\n\n\n\nIf this field is not in your DESCRIPTION file, follow the instructions in the roxygen2 documentation for enabling markdown.\n\n\n5.1.3 Title & description\n\n\n\n\n\n\nInserting roxygen2 skeletons\n\n\n\n\n\n\nIn RStudio , you can insert an roxygen2 skeleton into your function using Code &gt; Insert Roxygen Skeleton\n\n\n\n\n\n\n\nStandard roxygen2 skeleton\n\n\n\n\n\n\nThe first two sections of roxygen2 documentation are the title and description. These sections don’t require tags–roxygen2 will detect each section as long as there is at least one #' line separating them (and their contents don’t extend past the length indicated in parentheses below):\n\n#' function title (one line)\n#'\n#' A short description... (one paragraph)\n#' \n\nThe @title and @description for the scatter_plot() function stored in R/utils.R might look like this:\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `sap`.\n#' \n\n\n\n\n\n\n\nFunction @description and @details\n\n\n\n\n\n\nIf the contents in the @description for a function requires more complicated formatting than a single paragraph (i.e., multiple paragraphs, lists, etc.), you can use the @details tag:\n#' Create scatter plot  \n#' \n#' @description\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `sap`.\n#' \n#' @details\n#' `scatter_plot()` is a custom `ggplot2` function written to handle string arguments from reactive inputs (i.e., `input$x` or `input$y`)\n\n\n\n\n\n\n5.1.4 Parameters & return objects\nDocument function arguments and outputs with @param and @return:\n\n@param should include the name and description of each function input (i.e., their type and what they do)4\n\n#' @param name description of its action\n\n\n\n@return describes the type (or class) and structure of the function output5\n\n#' @return type/structure of the output\n\n\nBelow are examples for @param and @return in the scatter_plot() function stored in R/utils.R:\n\n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n\nTo view how the roxygen2 syntax will appear in the .Rd file, we’ll need to document sap:\n\n\nTo reduce the amount of repetitive code, I’ll just be showing the keyboard shortcuts for each devtools function from this point forward\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nI can see the scatter_plot.Rd file is written to the man/ folder:\nℹ Updating sap documentation\nℹ Loading sap\nWriting scatter_plot.Rd\nDocumentation completed\nAn overview of what devtools::document() does is illustrated below:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TB\n  subgraph Code[\"R/ Folder\"]\n   Roxy2(\"&lt;code&gt;roxygen2&lt;/code&gt; comments (&lt;code&gt;#'&lt;/code&gt;)&lt;br&gt; & tags (&lt;code&gt;@&lt;/code&gt;)\")\n   end\n  Roxy2 --&gt; Doc[[\"&lt;strong&gt;Run &lt;code&gt;devtools::document()&lt;/code&gt;&lt;/strong&gt;\"]]\n  Doc --&gt; Parse(\"Parses &lt;code&gt;roxygen2&lt;/code&gt; comments and tags\")\n   \n   subgraph Man[\"man/ Folder\"]\n    Rd(\".Rd Files\")\n   end\n   \n   subgraph Root[\"Package Root Folder\"]\n    NS(\"NAMESPACE\")\n   end\n\n   Parse --&gt; Man \n   Parse --&gt; Root\n  \n  %% style Code fill:#8dd38d,stroke:none,rx:10,ry:10,font-size:13px\n  %% style Roxy2 fill:#8dd38d,stroke:none,rx:10,ry:10,font-size:13px\n  %% style Doc fill:#89D6FB,stroke:none,rx:10,ry:10,font-size:13px\n  %% style Parse fill:#89D6FB,stroke:none,rx:10,ry:10,font-size:13px\n  %% style Man fill:#8dd38d,stroke:none,rx:10,ry:10,font-size:13px\n  %% style NS fill:#8dd38d,stroke:none,rx:10,ry:10,font-size:13px\n\n\n roxygen2 creates the NAMESPACE and help files in the man/ folder \n\n\n\n\n\n5.1.5 .Rd files\nWhen we open man/scatter_plot.Rd, we see it contains the following:\n\n\n\n\n\n\n\nThe scatter_plot.Rd documentation file\n\n\nR documentation (.Rd) files have a formatting style similar to (La)TeX, but roxygen2 saves us from having to learn this syntax by automatically generating the .Rd files.\nTo view the help file, I can enter ?scatter_plot in the console:\n\n?scatter_plot\n\n\n\n\n\n\n\n\nHelp file\n\n\nPreviewing the development versions of our documentation is a great way to verify the content in each .Rd file meets our expectations.\n\n\n5.1.6 Examples\n@examples are unique because they include executable code that demonstrates how a particular function works. In the Posit Workbench IDE, @examples are especially helpful because they come with a clickable hyperlink (the @examples from ggplot2::aes() are below):\n\n\n\n\n\n\n\n\n\n\n\n(a) Run examples hyperlink\n\n\n\n\n\n\n\n\n\n\n\n(b) Executed @examples code\n\n\n\n\n\n\n\nFigure 5.1: Run examples in help files\n\n\n\nBelow is an example demonstrating how the scatter_plot() utility function works:\n\n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n\n\n\n\n\n\n\nTab-completion for @tags\n\n\n\n\n\n\nIf you’re documenting your package functions in Positron, tab-completion is your friend! The help text displayed with each tag ensures you’re including the correct version (see @example vs. @examples below).\n\n\n\nTab completion for @example\n\n\nRead more here.\n\n\n\n\nTo preview the @examples in the help file, I’ll document() and open the development .Rd file:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n?scatter_plot\n\n\n\n\n\n\n\n\nPreview of examples\n\n\nThe Run examples hyperlink won’t be active in the .Rd file preview, but reviewing the code in @examples allows me to correct any errors or typos early.\nThe scatter_plot() function now has a Title, Description, Usage, Arguments, Value, and Examples documented. Consider these tags as the minimum level of documentation for the functions in your app-package.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#sec-document-app-functions",
    "href": "document.html#sec-document-app-functions",
    "title": "5  Documentation",
    "section": "5.2 Documenting app functions",
    "text": "5.2 Documenting app functions\nUsing Markdown in roxygen2 can improve the clarity of our documentation, especially in Shiny app-packages, where modules and functions often need detailed explanations.\n\n5.2.1 See also\nWhen documenting Shiny modules, I tend to think of the audience as anyone looking to understand the execution path through an application. For example, in our sap application, the inputs are collected in the UI and returned from the mod_var_input_server() function:\nExample for mod_var_input_ui:\n\n#' @seealso\n#' - [`mod_var_input_server()`]  for server-side logic.\n#' - [`shiny::tagList()`](https://shiny.rstudio.com/reference/shiny/latest/tagList.html) \n#'   for containing UI elements.\n#' - [`shiny::NS()`](https://shiny.rstudio.com/reference/shiny/latest/NS.html) \n#'   for namespacing.\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart LR\n        mod_var_input_ui(\"UI Module:&lt;br&gt;&lt;code&gt;mod_var_input_ui()&lt;/code&gt;\")\n        mod_var_input_server(\"Server Module:&lt;br&gt;&lt;code&gt;mod_var_input_server()&lt;/code&gt;\")\n        mod_scatter_display_server(\"Server Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_server()&lt;/code&gt;\")\n        tag(\"Documentation:&lt;br&gt;&lt;code&gt;shiny::tagList()&lt;/code&gt;\")\n        ns(\"Documentation:&lt;br&gt;&lt;code&gt;shiny::NS()&lt;/code&gt;\")\n\n    mod_var_input_ui &lt;--&gt;|\"@seealso\"|mod_var_input_server\n    mod_var_input_ui &lt;--&gt;|\"@seealso\"|tag\n    mod_var_input_ui &lt;--&gt;|\"@seealso\"|ns\n    mod_var_input_server &lt;--&gt;|\"@seealso\"|mod_scatter_display_server\n    \n    style mod_scatter_display_server font-size:13px\n\n\n The @seealso tag \n\n\n\nExample for mod_var_input_server:\n\n#' @seealso\n#' - [`mod_var_input_ui()`] for the UI counterpart of this module.\n#' - [`mod_scatter_display_server()`] for displaying the scatter plot.\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart LR\n    mod_var_input_ui(\"UI Module:&lt;br&gt;&lt;code&gt;mod_var_input_ui()&lt;/code&gt;\")\n    mod_var_input_server(\"Server Module:&lt;br&gt;&lt;code&gt;mod_var_input_server()&lt;/code&gt;\")\n    mod_scatter_display_server(\"Server Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_server()&lt;/code&gt;\")\n\n    mod_var_input_server &lt;--&gt;|\"@seealso\"|mod_var_input_ui\n    mod_var_input_server &lt;--&gt;|\"@seealso\"|mod_scatter_display_server\n    \n    style mod_scatter_display_server font-size:13px\n\n\n The @seealso tag \n\n\n\nWith Markdown, you can use backticks for inline code, bulleted lists, and links for external references. To make references more readable and user-friendly, we can use @seealso to connect modules, utility functions, and links to external documentation.\n\n\n5.2.2 Family\nThe @family tag works the same way, but can be used to group functions by type. Markdown gives us the ability to use bold or italic text for emphasis.\nFor the variable input module:\n\n#' @family **Variable Input Module**\n\nFor utility functions:\n\n#' @family *Utility Functions*\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TD\n    subgraph AppCom[\"&lt;strong&gt;Application Components&lt;/strong&gt;\"]\n        launch_app(\"Standalone Function:&lt;br&gt;launch_app()\")\n    end\n    subgraph Vars[\"&lt;strong&gt;Variable Input Module&lt;/strong&gt;\"]\n        mod_var_input_ui(\"UI Module:&lt;br&gt;mod_var_input_ui()\")\n        mod_var_input_server(\"Server Module:&lt;br&gt;mod_var_input_server()\")\n    end\n    subgraph Graph[\"&lt;strong&gt;Plot Display Module&lt;/strong&gt;\"]\n        mod_scatter_display_ui(\"UI Module:&lt;br&gt;mod_scatter_display_ui()\")\n        mod_scatter_display_server(\"Server Module:&lt;br&gt;mod_scatter_display_server()\")\n    end\n    subgraph Utils[\"&lt;strong&gt;Utility Functions&lt;/strong&gt;\"]\n        scatter_plot(\"Utility Function:&lt;br&gt;scatter_plot()\")\n    end\n\n    launch_app --&gt; mod_var_input_ui --&gt; mod_var_input_server\n    launch_app --&gt; mod_scatter_display_ui --&gt; mod_scatter_display_server --&gt; scatter_plot\n\n\n The @family tag \n\n\n\nMarkdown doesn’t drastically change @family, but it improves the consistency of formatting across related functions.\n\n\n5.2.3 Section\nMarkdown shines in sections, where you can use headings (###), bold text, or lists to structure detailed explanations.\nExample for mod_var_input_server:\n\n#' @section Inputs:\n#' This function expects inputs provided via the `shiny` session namespace:\n#'\n#' - `y`: Variable for the y-axis.\n#' - `x`: Variable for the x-axis.\n#' - `z`: Variable for the color aesthetic.\n#' - `alpha`: Transparency level of points (0-1).\n#' - `size`: Size of the points.\n#' - `plot_title`: Title for the plot.\n#'\n#' @section Outputs:\n#' - A **reactive expression** that returns a list of selected inputs.\n\nFor scatter_plot:\n\n#' @section Usage:\n#' Use this function to create a scatter plot as part of a Shiny app or in a\n#' standalone script. This is particularly useful when integrated with reactive\n#' inputs from Shiny modules.\n\n\n5.2.3.1 Variable input\nBelow are full example of variable input module documented with Markdown. Note the use of @family and interactive() in the @examples:\nmod_var_input_ui():\n\n\nshow/hide mod_var_input_ui documentation\n#' Variable Input Module - UI\n#'\n#' Creates a UI for selecting variables and attributes for a scatter plot.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#'\n#' @return A `shiny::tagList()` containing UI elements for variable \n#' selection.\n#'\n#' @section Details: \n#' `mod_var_input_ui()` provides UI controls for customizing scatter plots. \n#'  It includes:  \n#' - **Dropdowns**: \n#'   - X-axis variable\n#'   - Y-axis variable\n#'   - Color aesthetic variable\n#' - **Sliders**:\n#'   - Transparency (`alpha`) ranging from 0 to 1.\n#'   - Point size ranging from 0 to 5.\n#' - **Text Input**:\n#'   - Plot title.\n#'\n#' The function uses `shiny::NS()` to namespace all input IDs.\n#'\n#' @seealso\n#' - [`mod_var_input_server()`]  for server-side logic.\n#' - [`shiny::tagList()`](https://shiny.rstudio.com/reference/shiny/latest/tagList.html) \n#'   for containing UI elements.\n#' - [`shiny::NS()`](https://shiny.rstudio.com/reference/shiny/latest/NS.html) \n#'   for namespacing.\n#'\n#' @family **Variable Input Module**\n#'\n#' @examples\n#'\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(mod_var_input_ui(\"vars\")),\n#'     server = function(input, output, session) {\n#'       selected_vars &lt;- mod_var_input_server(\"vars\")\n#'       shiny::observe(\n#'           print(selected_vars())\n#'        )\n#'     }\n#'   )\n#' }\n#' \n\n\nmod_var_input_server():\n\n\nshow/hide mod_var_input_server documentation\n#' Variable Input Module - Server\n#'\n#' Handles the server-side logic for the variable input module.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#'\n#' @return A **reactive expression** that returns a list of selected input\n#'   values:  \n#' - `y`: Variable for the y-axis.\n#' - `x`: Variable for the x-axis.\n#' - `z`: Variable for the color aesthetic.\n#' - `alpha`: Transparency level of points (0-1).\n#' - `size`: Size of the points.\n#' - `plot_title`: Title for the scatter plot.\n#'\n#' @section Details: \n#' `mod_var_input_server()` reads user input from the corresponding UI \n#'  function created with \n#' `mod_var_input_ui()`. It processes and returns a reactive object \n#'  containing the selected variables and plot attributes.\n#'\n#' @seealso\n#' - [`mod_var_input_ui()`] for the UI counterpart of this module.\n#' - [`mod_scatter_display_server()`] for displaying the scatter plot.\n#'\n#' @family **Variable Input Module**\n#'\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(mod_var_input_ui(\"vars\")),\n#'     server = function(input, output, session) {\n#'       selected_vars &lt;- mod_var_input_server(\"vars\")\n#'       shiny::observe(print(selected_vars()))\n#'     }\n#'   )\n#' }\n#'\n\n\n\n\n5.2.3.2 Graph display\nmod_scatter_display_ui:\n\n\nshow/hide mod_scatter_display_ui documentation\n#' Scatter Plot Display Module - UI\n#'\n#' Creates a UI for displaying a scatter plot with user-selected options.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#'\n#' @return A `shiny::tagList` containing the plot output and metadata.\n#'\n#' @section Details: \n#' `mod_scatter_display_ui()` includes:\n#' - A **scatter plot** created dynamically based on user input.\n#' - Metadata about the app, including the data source.\n#'\n#' @seealso\n#' - [`mod_scatter_display_server()`]  for the server-side logic of this \n#'   module.\n#' - [`scatter_plot()`]  for the utility function generating the plot.\n#'\n#' @family **Plot Display Module**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(mod_scatter_display_ui(\"plot\")),\n#'     server = function(input, output, session) {\n#'       # Example usage - server logic is minimal for standalone testing.\n#'     }\n#'   )\n#' }\n#'\n\n\nmod_scatter_display_server:\n\n\nshow/hide mod_scatter_display_server documentation\n#' Scatter Plot Display Module - Server\n#'\n#' Handles the server-side logic for rendering a scatter plot.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#' @param var_inputs *(reactive)* A reactive expression containing \n#'  user-selected variables and attributes.\n#'\n#' @return No direct return value. This function generates a plot output.\n#'\n#' @section Details: \n#' `mod_scatter_display_server()`:\n#' - Uses `var_inputs` to dynamically generate a scatter plot with \n#'   user-selected variables.\n#' - Reads from the `movies` dataset, which must be loaded in the app \n#'   environment.\n#' - Processes plot titles and axis labels to improve readability.\n#'\n#' @section Reactive Inputs:\n#' - `var_inputs()$x`: X-axis variable.\n#' - `var_inputs()$y`: Y-axis variable.\n#' - `var_inputs()$z`: Color aesthetic variable.\n#' - `var_inputs()$alpha`: Transparency level.\n#' - `var_inputs()$size`: Size of points.\n#' - `var_inputs()$plot_title`: Title of the plot.\n#'\n#' @seealso\n#' - [`mod_var_input_server()`] for variable selection.\n#' - [`scatter_plot()`] for generating the scatter plot.\n#'\n#' @family **Plot Display Module**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(\n#'       mod_var_input_ui(\"vars\"),\n#'       mod_scatter_display_ui(\"plot\")\n#'     ),\n#'     server = function(input, output, session) {\n#'       selected_vars &lt;- mod_var_input_server(\"vars\")\n#'       mod_scatter_display_server(\"plot\", selected_vars)\n#'     }\n#'   )\n#' }\n#'\n\n\n\n\n5.2.3.3 Utility function\nscatter_plot():\n\n\nshow/hide scatter_plot() documentation\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building \n#' scatter plots in `sap`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' Generate a Scatter Plot\n#'\n#' Creates a scatter plot using `ggplot2` with the specified data and \n#' aesthetics.\n#'\n#' @param df *(data.frame)* The dataset containing the variables to plot.\n#' @param x_var *(character)* Name of the variable for the x-axis.\n#' @param y_var *(character)* Name of the variable for the y-axis.\n#' @param col_var *(character)* Name of the variable for the color aesthetic.\n#' @param alpha_var *(numeric)* Transparency level of points (0 to 1).\n#' @param size_var *(numeric)* Size of points.\n#'\n#' @return A `ggplot` object representing the scatter plot.\n#'\n#' @section Details:\n#' `scatter_plot()` is designed for use in Shiny applications but can also be \n#'  used independently.\n#' It supports customization of transparency, size, and color aesthetics.\n#'\n#' @seealso\n#' - [`mod_scatter_display_server()`] for integrating this function into the\n#'   scatter plot module.\n#' - [`ggplot2::ggplot()`](https://ggplot2.tidyverse.org/) for details on \n#'   `ggplot2` usage.\n#'\n#' @family **Utility Functions**\n#'\n#' @examples\n#' scatter_plot(\n#'   df = mtcars,\n#'   x_var = \"mpg\",\n#'   y_var = \"hp\",\n#'   col_var = \"cyl\",\n#'   alpha_var = 0.7,\n#'   size_var = 3\n#' )\n#'",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#sec-roxygen2-ui-server",
    "href": "document.html#sec-roxygen2-ui-server",
    "title": "5  Documentation",
    "section": "5.3 UI & Server functions",
    "text": "5.3 UI & Server functions\nSplitting the standalone app function in app.R into separate UI and server functions has multiple benefits:\n\nDocumenting each function will be easier if they are stored in the R/ folder.\nHaving dedicated UI, server, and app function means we can develop and test them independently.\nA standalone app function can have multiple applications in the same app-package.\n\nI’ve split the UI and server from launch_app() into separate movies_ui() and movies_server() below.\nThe movies_ui() doesn’t have any arguments–it contains the theme, image, and application title:\n\n\nshow/hide movies_ui documentation\n#' User Interface for the Movies Review Application\n#'\n#' Creates the user interface (UI) for the Movies Review application, which \n#' allows users to create customizable scatter plots based on movie data.\n#'\n#' @return A Shiny `tagList` object containing the UI elements.\n#'\n#' @section Details:\n#' The interface is built using:\n#' - **Theme**: `shinythemes::shinytheme(\"spacelab\")`.\n#' - **Title Panel**: Displays the app title and a logo.\n#' - **Sidebar Panel**: Includes the variable selection module \n#'   ([`mod_var_input_ui`]).\n#' - **Main Panel**: Displays the scatter plot module \n#'   ([`mod_scatter_display_ui`]).\n#'\n#' @seealso\n#' - [`movies_server()`] for the server logic of the app.\n#' - [`mod_var_input_ui()`] and [`mod_scatter_display_ui()`] for the modules \n#'   included in the UI.\n#'\n#' @family **Application Components**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(ui = movies_ui(), server = movies_server)\n#' }\n#'\nmovies_ui &lt;- function() {\n  tagList(\n    fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      titlePanel(\n        div(\n          img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movie Reviews\"\n        )\n      ),\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\n\nmovies_server() is written to be passed to the server argument in shinyApp():\n\n\nshow/hide movies_server documentation\n#' Server Logic for the Movies Review Application\n#'\n#' Handles the server-side logic for the Movies Review application.\n#'\n#' @param input The Shiny `input` object.\n#' @param output The Shiny `output` object.\n#' @param session The Shiny `session` object.\n#'\n#' @return No direct return value. Defines server logic for reactive outputs \n#' and module integration.\n#'\n#' @section Details:\n#' The server integrates the following modules:\n#' - **Variable Input Module**: Processes user input for scatter plot \n#'   customization using  [`mod_var_input_server()`].\n#' - **Plot Display Module**: Generates and displays a scatter plot \n#'   based on user inputs using [`mod_scatter_display_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the corresponding user interface.\n#' - [`launch_app()`] for the entry point of the application.\n#'\n#' @family **Application Components**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(ui = movies_ui(), server = movies_server)\n#' }\n#'\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\nThis will change the grouping in our @family tags to the following:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"14px\"}}}%%\nflowchart TD\n    subgraph AppCom[\"&lt;strong&gt;Application Components&lt;/strong&gt;\"]\n        launch_app[\"Standalone Function:&lt;br&gt;&lt;code&gt;launch_app()&lt;/code&gt;\"]\n        UI[\"UI:&lt;br&gt;&lt;code&gt;movies_ui()&lt;/code&gt;\"]\n        Server[\"Server:&lt;br&gt;&lt;code&gt;movies_server()&lt;/code&gt;\"]\n    end\n    subgraph Vars[\"&lt;strong&gt;Variable Input Module&lt;/strong&gt;\"]\n        mod_var_input_ui[\"UI Module:&lt;br&gt;&lt;code&gt;mod_var_input_ui()&lt;/code&gt;\"]\n        mod_var_input_server[\"Server Module:&lt;br&gt;&lt;code&gt;mod_var_input_server()&lt;/code&gt;\"]\n    end\n    subgraph Graph[\"&lt;strong&gt;Plot Display Module&lt;/strong&gt;\"]\n        mod_scatter_display_ui[\"UI Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_ui()&lt;/code&gt;\"]\n        mod_scatter_display_server[\"Server Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_server()&lt;/code&gt;\"]\n    end\n    subgraph Utils[\"&lt;strong&gt;Utility Functions&lt;/strong&gt;\"]\n        scatter_plot[\"Utility Function:&lt;br&gt;&lt;code&gt;scatter_plot(&lt;/code&gt;\"]\n    end\n\n    launch_app --&gt; UI\n    launch_app --&gt; Server\n    UI --&gt; mod_var_input_ui\n    UI --&gt; mod_scatter_display_ui\n    Server --&gt; mod_var_input_server\n    Server --&gt; mod_scatter_display_server --&gt; scatter_plot\n\n\n The updated @family tag \n\n\n\n\n5.3.1 Usage\nWe’ll explicitly describe the use of movies_ui() and set @usage to NULL (note the use of a code block). We’ll also use @section to describe each module UI function (and link to the server functions with @seealso).\n\n\nshow/hide movies_server documentation\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#'\n#' @usage NULL\n#' \n#' @details\n#' The [launch_app()] function is as a wrapper for `shiny::shinyApp()`: \n#'  \n#' ```\n#' shinyApp(ui = movies_ui, server = movies_server)\n#' ```\n#' \n#' In [launch_app()]:\n#'  * UI is stored in `movies_ui()`    \n#'  * server is stored in [movies_server()]\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_ui()] is used to collect the following inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'  \n#' @seealso [mod_var_input_server()]\n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_ui()] displays the graph output using [scatter_plot()]\n#' \n#' @seealso [mod_scatter_display_server()]\n#'\n#' @return `ui` argument in `shiny::shinyApp()` \n#' \nlaunch_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#recap",
    "href": "document.html#recap",
    "title": "5  Documentation",
    "section": "Recap",
    "text": "Recap\nGood documentation aims to make it as easy as possible for others (and future you) to understand what your function does and how to use it.\n\n\nLaunch app with the shinypak package:\n\nlaunch('05_roxygen2')\n\nBelow is a recap of the topics covered in this chapter.\n\n\n\n\n\n\n   Documentation Recap\n\n\n\n\n\n\nThis chapter covered:\n\nFunction @title and @description: The @title should be a short one-line description of the function, followed by a more detailed paragraph @description. These tags should give users an idea of what the function does (you can also use @details)\nArguments (@param) and outputs (@return): List all function arguments with @param. Include the argument type (e.g., integer, character, etc.) and a brief description of what the argument does. Be sure to mention any default or optional arguments. Function outputs should be listed with @return and describe the type or class of the object, whether or not it’s reactive, and mention any related functions.\nExamples: @examples provide executable R code that captures how the function is used in your app-package. These are incredibly valuable for new users trying to understand how a function (and your app-package) works.\n\nApp-package specific considerations:\n\nConnect functions with@seealso and @family: Use @seealso to provide links to related functions (i.e., modules) so users can click through a ‘guided tour’ of your application’s code–group similar functions using @family {description}.\nGive more info with @sections: Use @section to give in-depth explanations and specific details about how a function works, including any information about the @usage or its @params.\n@usage: This field will be automatically generated by roxygen2, but in some circumstances, it makes sense to set it to NULL and describe a function’s use explicitly.\n\n\n\n\n\nIn the next section, we’ll use roxygen2 to manage our app-package dependencies.\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#footnotes",
    "href": "document.html#footnotes",
    "title": "5  Documentation",
    "section": "",
    "text": "View the 04_devtools branch and review the previous chapter for more information.↩︎\n‘More often, a single .R file will contain multiple function definitions: such as a main function and its supporting helpers, a family of related functions, or some combination of the two.’ - Organise functions into files, R Packages, 2ed↩︎\nMaking .R file/function names brief but descriptive will also make writing and running tests easier.↩︎\nRead more about @param in the arguments chapter of R Packages, 2ed.↩︎\nRead more about @return in the return value chapter of R Packages, 2ed.↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "dependencies.html",
    "href": "dependencies.html",
    "title": "6  Dependencies",
    "section": "",
    "text": "6.1 Managing dependencies\nDependencies are the must-have components for your app-package, and they can be divided into imports and exports.\nIn this chapter we’ll cover how to manage dependencies in your new app-package.\nDependencies are handled with the NAMESPACE (generated via roxygen2 tags) and in the DESCRIPTION file. Together, these files determine which packages and functions our app-package depends on, and the functions and objects we’re making available to anyone using our app-package.\nThis chapter will pick up where we left off with the 05_roxygen2 branch of sap. Below is a folder tree of it’s contents:\nWhen in doubt…load, document, and install\nDuring development, you might lose track of the last devtools function you called (I know I do). If this happens, I’ve found loading, documenting, and installing helps to re-orient me to the current state of the package.\nIt’s also satisfying to see all three functions execute without any errors!\nThe first step in managing dependencies is identifying which packages sap relies on. In the Shiny chapter I introduced the renv package (see Section 2.6.2), which is designed for project-level dependency management. renv ensures the same package versions are used across different systems by capturing R and package versions in a lockfile (renv.lock) and a private library (renv/library).1\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    subgraph Dir[\"&lt;strong&gt;App-Package Directory&lt;/strong&gt;\"]\n        Init[\"&lt;code&gt;renv::init()&lt;/code&gt;\"]\n        Snap[\"&lt;code&gt;renv::snapshot()&lt;/code&gt;\"]\n    end\n    subgraph RepEnv[\"&lt;strong&gt;Reproducible Environment&lt;/strong&gt;\"]\n        Lock[\"&lt;code&gt;renv.lock&lt;/code&gt; file\"]\n        Lib[\"&lt;code&gt;renv/&lt;/code&gt; library\"]\n    end\n    Init --&gt; Snap\n    Snap --&gt;|\"&lt;em&gt;Captures dependencies&lt;br&gt;in lockfile&lt;/em&gt;\"| Lock\n    Snap --&gt;|\"&lt;em&gt;Stores packages&lt;br&gt;in private library&lt;/em&gt;\"| Lib\n\n    style Dir stroke:1px,rx:3,ry:3,font-size:13px\n    style RepEnv stroke:1px,rx:3,ry:3,font-size:13px\n\n\n Project level dependencies with renv\nR packages are designed to distribute and reuse code, so the dependencies are listed in the DESCRIPTION file under Imports, Depends, Suggests, and Remotes. The packages listed in the DESCRIPTION of our app-package will be different than those listed in a renv.lock file because not every package used to create an app-package needs to be used to use and run said app-package.2 However, it’s worth noting that installing an R package doesn’t enforce the strict version control like renv.\nThe diagram below outlines the basic process for importing functions from add-on packages to use in our locally developed package, and then exporting those functions for people to use when they install/load our package.3\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    subgraph RPkg[\"&lt;strong&gt;R Package (&lt;code&gt;pkg&lt;/code&gt;)&lt;/strong&gt;\"]\n        fun(\"Exports &lt;code&gt;fun()&lt;/code&gt; function\")\n    end\n    subgraph SapPkg[\"&lt;strong&gt;&lt;code&gt;sap&lt;/code&gt;&lt;/strong&gt;\"]\n    sap(\"Uses &lt;code&gt;pkg::fun()&lt;/code&gt; for local&lt;br&gt;&lt;code&gt;foo()&lt;/code&gt; function\")\n    end\n    Users(\"Users install/load &lt;code&gt;sap&lt;/code&gt; to use &lt;code&gt;foo()&lt;/code&gt;\")\n    RPkg --&gt;|\"&lt;em&gt;imports &lt;code&gt;fun()&lt;/code&gt; from &lt;code&gt;pkg&lt;/code&gt;&lt;/em&gt;\"| SapPkg\n    SapPkg --&gt;|\"&lt;em&gt;exports &lt;code&gt;foo()&lt;/code&gt; from &lt;code&gt;sap&lt;/code&gt;&lt;/em&gt;\"| Users\n    \n    style RPkg stroke:1px,rx:3,ry:3,font-size:15px\n    style SapPkg stroke:1px,rx:3,ry:3,font-size:16px\n\n\n Handling package dependencies\nOur goal is to limit the dependencies to only those critical to the functioning of our app, because each additional dependency is a potential point of failure (should this package become unavailable or significantly change).\nA great place to start is our app.R file:\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# launch_app ------------------------------------\nlaunch_app()\nIdeally, we’ll want to replace these calls to libary(), but first we have to make sure the functions we’re using in these packages will be available in sap.\nWhen we run the contents of app.R, we see the following:\nWhy can’t R find the \"launch_app\" function in app.R?\nLet’s recap what we’ve done so far:\nThe error above is telling us that despite having documentation for launch_app() in the R/ folder and generating the corresponding .Rd file in man/, launch_app() isn’t being exported from sap.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#managing-dependencies",
    "href": "dependencies.html#managing-dependencies",
    "title": "6  Dependencies",
    "section": "",
    "text": "&gt; launch_app()\nError in launch_app() : could not find function \"launch_app\"\n\n\n\n\n\n\n\n\napp.R\n\nThe app.R file loads the necessary packages and calls launch_app():\n\n\n\n\nsap/\n    └── app.R\n\n\n\n\n\n\n\n\n\nR/\n\nThe R/launch_app.R file contains the code and roxygen2 documentation for launch_app() function:\n\n\n\n\nsap/\n    └── R/\n        └── launch_app.R\n\n\n\n\n\n\n\n\n\nman/\n\nroxygen2 generates the man/launch_app.Rd documentation file:\n\n\n\n\nsap/\n    └── man/\n          └── launch_app.Rd",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#sec-depends-exports",
    "href": "dependencies.html#sec-depends-exports",
    "title": "6  Dependencies",
    "section": "6.2 Package exports",
    "text": "6.2 Package exports\nThe exact cause of the error above becomes more apparent when we try to explicitly namespace launch_app() from sap:4\n\nsap::launch_app()\n\nError: 'launch_app' is not an exported object from 'namespace:sap'\n\n\nLaunch app with the shinypak package:\n\nlaunch('06.1_pkg-exports')\n\nTo make the launch_app() function available to users of our package, we need to export it by including the @export tag in the roxygen2 comment block:\n\n@export: make function available to users of sap.\n\n1#' @export my_func\n#' my_func &lt;- function() {\n#' \n#' }\n\n\n1\n\nPlaced above the function we want to export (function name is not required)\n\n\n\n\n\n\nExport launch_app()\nWe’ll export launch_app() from sap by placing the @export tag above the function in R/launch_app.R:\n\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#'\n#' @return A **Shiny application** object.\n#'\n#' @section Details:\n#' The application uses:\n#' - **UI**: Defined in [`movies_ui()`].\n#' - **Server Logic**: Defined in [`movies_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the user interface.\n#' - [`movies_server()`] for the server logic.\n#'\n#' @family **Standalone Application**\n#'\n#' @examples\n#' if (interactive()) {\n#'   launch_app()\n#' }\n#'\n#' @export\nlaunch_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nIn app.R, we’ll replace the calls to library() with a single call to library(sap)\n\n# packages ------------------------------------\nlibrary(sap)\n\n# launch_app ------------------------------------\nlaunch_app()\n\nWe’ll document the package to generate the NAMESPACE changes:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nNow, when we run the code app.R, we see the following:\n\n\n\nlaunch_app()\n\n\n\n\nWe’ve lost the Shiny icon (www/shiny.png) in the UI, but we’ll address this in Chapter 9.\nlaunch_app() launches our application!\n\n\nThe NAMESPACE file now contains a single export (launch_app), and when we enter sap:: in the Console, we see the launch_app() function help file in the tab completion.\n\n\n\n\n\n\n\n\n\n\n\n(a) updated NAMESPACE\n\n\n\n\n\n\n\n\n\n\n\n(b) launch_app() from the sap namespace\n\n\n\n\n\n\n\nFigure 6.1: The launch_app() is now part of the sap namespace\n\n\n\n\n\nWhat @export does\nWe’ll pause here to notice a few things about what @export does. When we documented our package, the code was automatically loaded before the NAMESPACE was updated with export(launch_app).\n\n&gt; devtools::document()\nℹ Updating sap documentation\n1ℹ Loading sap\nWriting NAMESPACE\n\n\n1\n\nCall to devtools::load_all()\n\n\n\n\ndocument() will call load_all() to make sure all the changes in the R/ folder are included in the updated documentation.\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart\n    subgraph R[\"&lt;strong&gt;R/ folder&lt;/strong&gt;\"]\n        Tag(\"Add &lt;code&gt;@export&lt;/code&gt;&lt;br&gt;to function&lt;br&gt;documentation\")\n    end\n  subgraph NS[\"&lt;strong&gt;NAMESPACE&lt;/strong&gt;\"]\n        Exported([\"&lt;code&gt;export(launch_app)&lt;/code&gt;\"])\n  end\n  subgraph Man[\"&lt;strong&gt;man/ folder&lt;/strong&gt;\"]\n        RdFile([\"&lt;code&gt;.Rd&lt;/code&gt; files created\"])\n  end\n  Document[[\"Run &lt;code&gt;document()&lt;/code&gt;\"]]\n  Load(\"Calls &lt;code&gt;load_all()&lt;/code&gt;\")\n  \n\n  Tag --&gt; Document\n  Document -.-&gt; Load --&gt; NS & Man\n\n\n\n What @export does \n\n\n\nWe can confirm launch_app() has been exported with ls(), which returns “the names of the objects in the specified environment.\n\nls(name = \"package:sap\")\n\n[1] \"launch_app\"\n\nThe search() list\nlibrary(sap) attaches sap to the search list. We can view all the attached packages in the string returned from search():\n\"package:sap\" %in% search()\n[1] TRUE\nWhat about the add-on/third-party package functions launch_app() relies on, like ggplot2? Let’s check to see if ggplot2 is also attached to the search() list:\n\nc(\"package:ggplot2\") %in% search()\n\n[1] FALSE\nWhy does this matter? Because if these packages aren’t attached to the search() list, we can’t call their functions directly (the way we would if we’d loaded the package with library()). For example, if we try to use ggplot2 to build a plot (similar to the one we have in the app), we see the following:\nggplot(data = mtcars, \n  aes(x = disp, y = mpg)) + \n  geom_point()\n# Error in ggplot(data = mtcars, aes(x = disp, y = mpg)) : \n#  could not find function \"ggplot\"\nWe can use the add-on/third-party package functions sap relies on, but we need to explicitly namespace these functions from their original package namespaces (i.e., using pkg::fun()):\n\n\n\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\n\nWe can use ggplot2 if we explicitly namespace it’s functions\n\n\n\n\n\n\nAccessing add-on package functions\n\n\n\n\n\n\nWhat happens to add-on/third party functions that are exported from sap?\nWhen a user loads sap with library(sap), any add-on/third-party package functions used in exports are available to users if they use pkg::fun() (or if they load the package themselves with library()).\n\n\n\n\nAccess to add-on/third-party package functions has implications for the other functions in sap–for example, the scatter_plot() function uses ggplot2 functions. But we’re not exporting scatter_plot(), so when we attempt to run the examples, we see the following error:\n\n\n\n\n\n\n\n\n\n(a) Error in scatter_plot() examples\n\n\n\n\n\nFigure 6.2: Examples in scatter_plot() function without exporting\n\n\n\nExamples for ‘sap::scatter_plot’\nThe message at the top of the Help pane is informative because it tells us that despite scatter_plot() being functional when we run launch_app(), it’s not part of the package namespace (and thus, not accessible to users in the help file).\n\n\n\nExport scatter_plot()\nLet’s add the @export tag to R/scatter_plot.R so it’s exported from sap.\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building \n#' scatter plots in `sap`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' Generate a Scatter Plot\n#'\n#' Creates a scatter plot using `ggplot2` with the specified data and \n#' aesthetics.\n#'\n#' @param df *(data.frame)* The dataset containing the variables to plot.\n#' @param x_var *(character)* Name of the variable for the x-axis.\n#' @param y_var *(character)* Name of the variable for the y-axis.\n#' @param col_var *(character)* Name of the variable for the color aesthetic.\n#' @param alpha_var *(numeric)* Transparency level of points (0 to 1).\n#' @param size_var *(numeric)* Size of points.\n#'\n#' @return A `ggplot` object representing the scatter plot.\n#'\n#' @section Details:\n#' `scatter_plot()` is designed for use in Shiny applications but can also be \n#'  used independently.\n#' It supports customization of transparency, size, and color aesthetics.\n#'\n#' @seealso\n#' - [`mod_scatter_display_server()`] for integrating this function into the\n#'   scatter plot module.\n#' - [`ggplot2::ggplot()`](https://ggplot2.tidyverse.org/) for details on \n#'   `ggplot2` usage.\n#'\n#' @family **Utility Functions**\n#'\n#' @examples\n#' scatter_plot(\n#'   df = mtcars,\n#'   x_var = \"mpg\",\n#'   y_var = \"hp\",\n#'   col_var = \"cyl\",\n#'   alpha_var = 0.7,\n#'   size_var = 3\n#' )\n#'\n#' @export\n\nAfter documenting sap, the NAMESPACE is updated with the export() directive:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nThe contents of the updated NAMESPACE file and typing sap:: in the Console now displays the scatter_plot() help file in the tab completion:\n\n\n\n\n\n\n\n\n\n\n\n\n(a) @export the scatter_plot function\n\n\n\n\n\n\n\n\n\n\n\n(b) scatter_plot()\n\n\n\n\n\n\n\nFigure 6.3: scatter_plot() is now part of the sap namespace\n\n\n\n\nBelow, we confirm users can access the help file for scatter_plot() and run the examples:\n\n\n\n\n\n\n\nRunning examples in ?scatter_plot\n\n\n\nloadedNamespaces()\nWe’ve already confirmed that ggplot2 isn’t attached with sap (and hence, it is not included in the search() list)\n\nc(\"package:ggplot2\") %in% search()\n\n[1]  FALSE\nHowever, we can access the functions we used the pkg::fun() syntax with because those functions are included in the loaded namespaces (which we can view with loadedNamespaces())\n\nc(\"ggplot2\") %in% loadedNamespaces()\n\n[1] TRUE\n\n\n\n\n\n\nAccessing non-exported functions\n\n\n\n\n\n\nWhat about functions that aren’t exported from sap?\nFunctions that are not exported (i.e., do not include the @export tag) are still accessible after installing and loading a package using the pkg:::fun()\n\n\n\n\n\n\n\nWhat to @export\n\n‘Always err on the side of caution, and simplicity. It’s easier to give people more functionality than it is to take away stuff they’re used to’ - What to export, R Packages, 2ed\n\nWhen determining which functions to export, consider the question: “When a user installs and loads sap, what functions do I want to be available?”\nIn app-packages, I’ll take the following general approach:\n\nStart by exporting the standalone app function (launch_app())\nThen selectively export modules and/or functions that perform distinct tasks with potentially reusable functionality (i.e., generate specific UI components, perform data processing tasks, etc.).\n\nIt’s rare that I don’t export functions from app-packages, but I like to make sure users have the ability to get ‘under to hood’ and see how each part of an application works.\nIf you’d like to the Low-key @exports with @keywords internal box below for exporting functions without including them in your package index.\n\n\n\n\n\n\nLow-key exports with @keywords internal\n\n\n\n\n\n\nIf you’d like a function to be exported, but not listed in your app-package index, you can use @export in combination with @keywords internal:\n#' @export\n#' \n#' @keywords internal\nFor example, adding @export and @keywords internal to R/scatter_plot.R will make the function accessible to users and generate a help file:\n\n\n\n\n\nBut if a user were to click on the Index for sap (at the bottom of the help file) scatter_plot would not be listed:",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#sec-depends-imports",
    "href": "dependencies.html#sec-depends-imports",
    "title": "6  Dependencies",
    "section": "6.3 Package imports",
    "text": "6.3 Package imports\n\n\nLaunch app with the shinypak package:\n\nlaunch('06.2_imports')\n\nImporting dependencies is slightly more involved than exports because imports are managed by both the DESCRIPTION and the NAMESPACE:\n\nThe DESCRIPTION file handles package-level dependencies, specifying which add-on packages our app-package uses.\nThe NAMESPACE manages function-level access, importing functions from add-on packages to be used in our app-package, and–as we’ve seen above–exporting functions from our app-package for others to use.\n\n\nPackage-level depencencies\nThe DESCRIPTION file manages dependencies with three fields: Depends, Imports, and Suggests. Most add-on packages belong under the Imports field (i.e., functions from these packages are used in the code below R/).5\n\nDepends\nPackages listed under Depends are essential for our app-package to work. These packages will be attached before our package when library(sap) is called.\n\n\nImports\nPackages listed under Imports are necessary for our app-package to work. These packages are loaded (but not attached) when our app-package is installed.\n\n\nSuggests\nThe Suggests field should include any packages that enhance our app-package, but aren’t necessary for the basic functionality. This might include packages used in examples, vignettes, tests, etc.\n\n\n\n\n\n\nAvoiding dependency hell\n\n\n\n\n\n\nGenerally speaking, you want to keep your app-package lightweight (i.e., limit the number of add-on/third-party dependencies, other than base-R packages and shiny). Doing this ensures you’ll be able to safely use this app-packages as a dependencies in the next app-packages. We’ll cover tracking and exploring dependencies in Chapter 33.\n\n\n\n\n\n\n\nFunction-level access\nFunction-level access is managed using namespace-qualified references (or ‘explicit namespacing’) in the code below R/. The NAMESPACE can also be used to include add-on packages or functions with the @import and @importFrom tags.6\n\nNamespace-qualified referencing: Refer to add-on package functions using pkg::fun() syntax in the code below R/.\nSpecial imports: @importFrom should be used when 1) “You can’t call an operator from another package via ::” 2) “importing a function makes your code much more readable” (not easier to write)\nImporting everything: @import should be used if “you make such heavy use of so many functions from another package that you want to import its entire namespace”\n\n\n\nHandling imports\nThe workflow I use to manage add-on dependencies comes from the advice in the roxygen2 documentation:\n\n“if you are using just a few functions from another package, we recommending adding the package to the Imports: field of the DESCRIPTION file and calling the functions explicitly using ::, e.g., pkg::fun()…”\n…“If the repetition of the package name becomes annoying you can @importFrom and drop the pkg::fun()”. - Importing functions\n\n\nInclude the add-on package to the Imports field with usethis::use_package().\nRefer to add-on functions using explicit namespacing (i.e., pkg::fun()) in the code beneath R/.\n\nWe have some special considerations for the imported add-on functions in our app-package:\n\nUsing @import\nA substantial portion of the code in sap comes from shiny, so we’ll remove the explicit namespacing and place the @import tag in R/launch_app.R7\n\n\nshow/hide R/launch_app.R\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#'\n#' @return A **Shiny application** object.\n#'\n#' @section Details:\n#' The application uses:\n#' - **UI**: Defined in [`movies_ui()`].\n#' - **Server Logic**: Defined in [`movies_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the user interface.\n#' - [`movies_server()`] for the server logic.\n#'\n#' @family **Standalone Application**\n#'\n#' @examples\n#' if (interactive()) {\n#'   launch_app()\n#' }\n#'\n1#' @import shiny\n#' \n\n\n\n1\n\nImport entire shiny package namespace\n\n\n\n\n\n\nUsing @importFrom\n.data can’t be exported using ::, so we’ll include @importFrom in R/scatter_plot.R. On the other hand, ggplot2 has over 400 functions, so we’ll add the package to the Imports field and use the namespace-qualified references.8\n\n\nshow/hide R/scatter_plot.R\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building \n#' scatter plots in `sap`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' Generate a Scatter Plot\n#'\n#' Creates a scatter plot using `ggplot2` with the specified data and \n#' aesthetics.\n#'\n#' @param df *(data.frame)* The dataset containing the variables to plot.\n#' @param x_var *(character)* Name of the variable for the x-axis.\n#' @param y_var *(character)* Name of the variable for the y-axis.\n#' @param col_var *(character)* Name of the variable for the color aesthetic.\n#' @param alpha_var *(numeric)* Transparency level of points (0 to 1).\n#' @param size_var *(numeric)* Size of points.\n#'\n#' @return A `ggplot` object representing the scatter plot.\n#'\n#' @section Details:\n#' `scatter_plot()` is designed for use in Shiny applications but can also be \n#'  used independently.\n#' It supports customization of transparency, size, and color aesthetics.\n#'\n#' @seealso\n#' - [`mod_scatter_display_server()`] for integrating this function into the\n#'   scatter plot module.\n#' - [`ggplot2::ggplot()`](https://ggplot2.tidyverse.org/) for details on \n#'   `ggplot2` usage.\n#'\n#' @family **Utility Functions**\n#'\n#' @examples\n#' scatter_plot(\n#'   df = mtcars,\n#'   x_var = \"mpg\",\n#'   y_var = \"hp\",\n#'   col_var = \"cyl\",\n#'   alpha_var = 0.7,\n#'   size_var = 3\n#' )\n#'\n#' @export\n#' \n1#' @importFrom rlang .data\n#' \n\n\n\n1\n\nImport a the .data operator from rlang\n\n\n\n\n\n\nuse_package('pkg')\nAs an example, we’ll add the bslib package and update our app UI layout:\n\nusethis::use_package('bslib')\n\n✔ Setting active project to '/Users/mjfrigaard/projects/apps/sap'\n✔ Adding 'bslib' to Imports field in DESCRIPTION\n• Refer to functions with `bslib::fun()`\nIn movies_ui(), we’ll change the fluidPage() to the bslib::page_fillable() and adjust move the data source information to the bslib::card_footer():\n\n\nupdated movies_ui() bslib function\n#' User Interface for the Movies Review Application\n#'\n#' Creates the user interface (UI) for the Movies Review application, which \n#' allows users to create customizable scatter plots based on movie data.\n#'\n#' @return A Shiny `tagList` object containing the UI elements.\n#'\n#' @section Details:\n#' The interface is built using [`bslib`](https://rstudio.github.io/bslib/)\n#' - **Page (fillable)**: [`bslib::page_fillable()`](https://rstudio.github.io/bslib/reference/page_fillable.html) \n#'   displays the app title. \n#' - **Sidebar**: [`bslib::layout_sidebar()`](https://rstudio.github.io/bslib/reference/sidebar.html) \n#'   includes a logo and the variable \n#'   selection module.\n#'   ([`mod_var_input_ui`]).\n#' - **Card**: [`bslib::card()`](https://rstudio.github.io/bslib/reference/card.html) \n#'   displays the scatter plot module \n#'   ([`mod_scatter_display_ui`]).\n#'\n#' @seealso\n#' - [`movies_server()`] for the server logic of the app.\n#' - [`mod_var_input_ui()`] and [`mod_scatter_display_ui()`] for the modules \n#'   included in the UI.\n#'\n#' @family **Application Components**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(ui = movies_ui(), server = movies_server)\n#' }\n#'\nmovies_ui &lt;- function() {\n  tagList(\n    bslib::page_fillable(\n      h1(\"Movie Reviews\"),\n      bslib::layout_sidebar(\n        sidebar =\n          bslib::sidebar(\n            title = tags$h4(\"Sidebar inputs\"),\n            img(\n              src = \"shiny.png\",\n              height = 60,\n              width = 55,\n              style = \"margin:10px 10px\"\n            ),\n            mod_var_input_ui(\"vars\")\n          ),\n        bslib::card(\n          full_screen = TRUE,\n          bslib::card_header(\n            tags$h4(\"Scatter Plot\")\n          ),\n          mod_scatter_display_ui(\"plot\"),\n          bslib::card_footer(\n            tags$blockquote(\n              tags$em(\n                tags$p(\n                  \"The data for this application comes from the \",\n                  tags$a(\"Building web applications with Shiny\",\n                    href = \"https://rstudio-education.github.io/shiny-course/\"\n                  ),\n                  \"tutorial\"\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n}\n\n\nAfter adding the add-on packages to the DESCRIPTION with usethis::use_package(), then deciding if/where to use @importFrom and @import, we’ll load, document, and install sap:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nWhen we review the updated NAMESPACE and DESCRIPTION files, we should see the following:\n\n\n\n\n\n\nUpdated NAMESPACE with @import and @importFrom:\n\n\n\n\n\nNAMESPACE\n\n\n\n\n\n\n\n\n\n\n\nUpdated DESCRIPTION with all Imports:\n\n\n\n\n\nDESCRIPTION\n\n\n\n\n\nroxygen2 will update the NAMESPACE, but usethis::use_package() is needed to update the DESCRIPTION.\n\nWhen we run launch_app(), we see the application launches and we can still run the scatter_plot() examples:\n\n\n\n\n\n\n\n\n\n\n\n(a) launch_app() works\n\n\n\n\n\n\n\n\n\n\n\n(b) Examples in ?scatter_plot\n\n\n\n\n\n\n\nFigure 6.4: Confirming we still have full functionality in sap\n\n\n\n\n\n\nWhat @import does\nThe figure below attempts to capture some of confusion between the dependencies listed in the NAMESPACE and the Imports field in the DESCRIPTION file.9\n\n\n\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TD\n    subgraph DESCRIPTION[\"&lt;strong&gt;DESCRIPTION&lt;/strong&gt;\"]\n        UsePkg[\"&lt;code&gt;use_package('pkg')&lt;/code&gt;\"]\n        Imports(\"&lt;code&gt;Imports&lt;/code&gt;&lt;br&gt; in DESCRIPTION\")\n    end\n    subgraph R[\"&lt;strong&gt;R/ Folder&lt;/strong&gt;\"]\n        Tag(\"Use &lt;code&gt;pkg::fun()&lt;/code&gt;&lt;br&gt;\")\n        Import(\"Use &lt;code&gt;@import&lt;/code&gt;\")\n        ImportFrom(\"Use &lt;code&gt;@importFrom&lt;/code&gt;\")\n    end\n    subgraph NAMESPACE[\"&lt;strong&gt;NAMESPACE&lt;/strong&gt;\"]\n        NSImport(\"&lt;code&gt;import(pkg)&lt;/code&gt;\")\n        NSImportFrom(\"&lt;code&gt;importFrom(fun,pkg)&lt;/code&gt;\")\n    end\n    Document([\"&lt;code&gt;devtools::document()&lt;/code&gt;&lt;/strong&gt;\"])\n\n  UsePkg --&gt;|\"Adds &lt;code&gt;pkg&lt;/code&gt; to\"|Imports\n  DESCRIPTION ==&gt;|\"To use &lt;code&gt;fun()&lt;/code&gt;&lt;br&gt;from &lt;code&gt;pkg&lt;/code&gt;...\"|Tag\n  DESCRIPTION -.-&gt; |\"To use everything&lt;br&gt;from &lt;code&gt;pkg&lt;/code&gt;...\"|Import \n  DESCRIPTION -.-&gt; |\"For special cases&lt;br&gt;from &lt;code&gt;pkg&lt;/code&gt;...\"|ImportFrom\n  Tag ==&gt; Document\n  Import -.-&gt; Document -.-&gt; |\"Adds &lt;code&gt;pkg&lt;/code&gt; to\"|NSImport\n  ImportFrom -.-&gt; Document -.-&gt; |\"Adds &lt;code&gt;fun, pkg&lt;/code&gt; to\"|NSImportFrom\n\n\n\n devtools::document does not change the DESCRIPTION file \n\n\n\n\n\nFigure 6.5: devtools::document() (or Ctrl/Cmd + Shift + D) updates the NAMESPACE with any @import, @importFrom or @export tags. However, no changes are made to the DESCRIPTION file.\n\n\n\nLet’s confirm we’re still only exporting launch_app() and scatter_plot() from sap:\n\nls(name = \"package:sap\")\n\n[1] \"launch_app\"   \"scatter_plot\"\nGreat. Now we’ve listed six packages in the Imports field of the DESCRIPTION file:\nImports: \n    bslib,\n    ggplot2,\n    rlang,\n    shiny,\n    stringr,\n    tools\n\nThe search() list\nAre these packages on the search list?\n\npkgs &lt;- c(\"package:bslib\", \"package:ggplot2\", \n          \"package:rlang\", \"package:shiny\", \n          \"package:stringr\", \"package:tools\")\npkgs %in% search()\n\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\nThis demonstrates that none of these packages are attached with sap.\n\n\nloadedNamespaces()\nHowever, the rlang and shiny packages are included in the loadedNamespaces() (because we included them with @import/@importFrom).\n\npkgs &lt;- c(\"bslib\", \"ggplot2\", \"rlang\", \n          \"shiny\", \"stringr\", \"tools\")\npkgs %in% loadedNamespaces()\n\n[1] FALSE FALSE  TRUE  TRUE FALSE  TRUE\nWe can still access the add-on package functions in sap using the pkg::fun() syntax:\n\n\n\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(\n      x = disp, \n      y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\nggplot2 functions are still available if we explicitly namespace\n\n\n\n\n\n\n\n\nImports FAQ\nBelow are handful of questions and answers I’ve encountered regarding package imports:\nQuestion 1: How can I include an add-on package to my DESCRIPTION file?\nAnswer 1: usethis::use_package() automatically adds a package in the Imports section, and has options for specifying the minimum version.\nQuestion 2: Will users of my app-package have access to the packages listed in the Imports field of my DESCRIPTION file?\nAnswer 3: library(pkg) loads the namespace of imported packages, but they are not attached to the search() path.10\nQuestion 4: How can I tell the difference between functions written by a package author and imported functions in the code below R/?\nAnswer 4: using pkg::fun() makes calls to add-on packages explicit and easy to differentiate from the native functions developed in sap.11\nQuestion 5: What does the NAMESPACE do when my package is installed by a user?\nAnswer 5: managing the NAMESPACE ensures your app-package works when it’s installed and loaded on another machine, because R will read your package namespace to find what it imports and exports.12\nQuestion 6: Where should I place the @importFrom tag in the code below R/?\nAnswer 6: place the @importFrom pkg fun tag directly above the code using the add-on function. You can also consolidate all @import and @importFrom tags into a single package doc file (i.e., R/[sap]-package.R) by calling usethis::use_package_doc().\nQuestion 7: Should I be using @importFrom or @import from?\nAnswer 7: prefer @importFrom over @import, but try to avoid using either.13 14\nQuestion 8: Where can I find more information about package namespaces and imports?\nAnswer 8a: Imports are described briefly in R Packages, 2ed15 and covered in-depth in Advanced R, 2ed.16\nAnswer 8b: “Each namespace has an imports environment that can contain bindings to functions used by the package that are defined in another package.”\nAnswer 8c: “The imports environment is controlled by the package developer with the NAMESPACE file. Specifically, directives such as importFrom() and imports() populate this environment.”\nIn order for app-package to work, users needs to have access to any add-on packages that are called in the code below R/. Knowing when, why, how and what happens to imports helps you decide how to fit these habits into your package development workflow.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#checking-dependencies",
    "href": "dependencies.html#checking-dependencies",
    "title": "6  Dependencies",
    "section": "Checking dependencies",
    "text": "Checking dependencies\nWith all the moving parts in dependency management, it can be easy to forget if you’ve documented everything correctly. So far we haven’t covered using devtools::check() as part of your app-package habits (which is fine), but this is one area it’s particularly helpful.\nFor example, if I had listed shiny as an import using the @import tag (resulting in the import(shiny) directive in the NAMESPACE), devtools::check() would produce the following error:\n── R CMD check results ────────────────────────── sap 0.0.0.9620 ────\nDuration: 7.4s\n\n❯ checking package dependencies ... ERROR\n  Namespace dependency missing from DESCRIPTION Imports/Depends entries: ‘shiny’\n  \n  See section ‘The DESCRIPTION file’ in the ‘Writing R Extensions’\n  manual.\n\n1 error ✖ | 0 warnings ✔ | 0 notes ✔\nError: R CMD check found ERRORs\nExecution halted\n\nExited with status 1.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#recap",
    "href": "dependencies.html#recap",
    "title": "6  Dependencies",
    "section": "Recap",
    "text": "Recap\nBelow are the main takeaways from managing the imports and exports from your app-package:\n\n\n\n\n\n\nDependencies recap\n\n\n\n\n\n\nThis chapter covered:\n\nExports: Aim for a balance between simplicity and utility when deciding which functions to export (i.e., what functions should be available to users who install your package). Export objects from using @export\nImports: Use pkg::fun() syntax when you use add-on package functions and include them in the Imports field of the DESCRIPTION file. App-packages use so many shiny functions it makes sense to include @import shiny to 1) ensure all of these functions are available, and 2) you won’t need to use pkg::fun().\n\nDESCRIPTION Imports This field lists the packages your app-package uses. All add-on packages used in the R/ folder must be listed in the Imports field. These functions can be called using the pkg::fun() syntax (or with @importFrom()). Functions from these packages will be available for your package, but not for the user unless they use the :: operator or load the package themselves with library().\nNAMESPACE imports: The @import/@importFrom tags make the functions from add-on packages available to your package. Favor using @importFrom over @import for add-on package functions (the only exception being shiny, which you’d want to use @import).\n\n\nThe Imports field in the DESCRIPTION handles package-level dependencies (and it is managed manually or with usethis::use_package()), while the NAMESPACE handles function-level access (with @export and @import/@importFrom). Multiple packages can help you manage the dependencies in your app-package, and these are covered in the Dependency hell chapter.\n\n\n\n\nIf you’d like to read more about package dependencies, I recommend Writing R Extensions (specifically the sections on dependencies 17 and namespaces 18).\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub\n\n\n\n\nIn the next section, we’ll cover how to ensure the movies.RData can be stored and loaded in our app-package!",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#footnotes",
    "href": "dependencies.html#footnotes",
    "title": "6  Dependencies",
    "section": "",
    "text": "Although the branches throughout the book do not use renv, I highly recommend adopting this practice (especially if you’re collaborating with other developers).↩︎\nWe’re using devtools and usethis to develop our app-package, but these packages are not needed for our code to run.↩︎\nI’ve made this process somewhat easier by explicitly namespacing all of the add-on package functions in sap (i.e., with pkg::fun()).↩︎\nRead more in the Exports section of R Packages, 2nd Ed↩︎\nAdditional fields exists (i.e., Remotes), but these are special circumstances.↩︎\nRead more about this in the section titled, ‘In code below R/’ in R Packages, 2ed↩︎\nUsing @import is not generally considered best practice, but it makes sense for app-packages: …for Shiny apps, I recommend using @import shiny to make all the functions in the Shiny package easily available. Mastering Shiny, R CMD check”↩︎\nRead more about using ggplot2 in packages in the section titled, ‘Referring to ggplot2 functions’↩︎\nSee the section titled, ‘Confusion about Imports’ in R Packages, 2ed, “Listing a package in Imports in DESCRIPTION does not ‘import’ that package.”↩︎\nUsers can access functions from add-on packages with the pkg::fun syntax.↩︎\n“Our recommended default is to call external functions using the package::function() syntax.” - R Packages, 2ed↩︎\nThe namespace controls the search strategy for variables used by functions in the package. If not found locally, R searches the package namespace first, then the imports, then the base namespace and then the normal search path (so the base namespace precedes the normal search rather than being at the end of it). - Writing R Extensions↩︎\n“Using importFrom selectively rather than Imports is good practice and recommended notably when importing from packages with more than a dozen exports and especially from those written by others (so what they export can change in future).” - Specifying imports and exports.↩︎\n“Specifically, we recommend that you default to not importing anything from [add-on packages] into your namespace. This makes it very easy to identify which functions live outside of your package, which is especially useful when you read your code in the future. This also eliminates any concerns about name conflicts between [add-on packages] and your package.” - R Packages, 2ed↩︎\nSee the Function lookup inside a package section of R Packages, 2ed↩︎\nSee the Package environments and the search path of Advanced R, 2ed↩︎\nSee section 1.1.3 Package Dependencies in Writing R Extensions↩︎\nSee section 1.5, Package namespaces in Writing R Extensions↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "7  Data",
    "section": "",
    "text": "7.1 The data/ folder\nThe previous chapters in this section covered how documenting functions and managing dependencies. In this chapter, we’ll discuss how data files (like movies.RData) become part of an app-package so they can be loaded into our application. We’ll also cover the various locations and purposes for app-package data files.\nData in R packages are typically stored in one of three folders: data/, data-raw/, and inst/extdata/.1 The folder you use will depend on the format, accessibility, and intended purpose of the data file.2\nThe primary location for data is the data/ folder. Objects in data/ folder are available in your package namespace when it’s installed and loaded, and can be accessed with the :: syntax. See the example below of the storms data from dplyr:\nlibrary(dplyr)\nhead(dplyr::storms)\n## # A tibble: 6 × 13\n##   name   year month   day  hour   lat  long status\n##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; \n## 1 Amy    1975     6    27     0  27.5 -79   tropi…\n## 2 Amy    1975     6    27     6  28.5 -79   tropi…\n## 3 Amy    1975     6    27    12  29.5 -79   tropi…\n## 4 Amy    1975     6    27    18  30.5 -79   tropi…\n## 5 Amy    1975     6    28     0  31.5 -78.8 tropi…\n## 6 Amy    1975     6    28     6  32.4 -78.7 tropi…\n## # ℹ 5 more variables: category &lt;dbl&gt;, wind &lt;int&gt;,\n## #   pressure &lt;int&gt;,\n## #   tropicalstorm_force_diameter &lt;int&gt;,\n## #   hurricane_force_diameter &lt;int&gt;",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-data",
    "href": "data.html#sec-data-data",
    "title": "7  Data",
    "section": "",
    "text": "7.1.1 LazyData\nData files become part of a package when they’re added to the data/ folder and LazyData: true is added to the DESCRIPTION file. Enabling LazyData means the data are only loaded into memory if they are explicitly accessed by the user or a function in the package. Until then, only the dataset name is loaded. This user-friendly practice is the default for most R packages.\nOmitting LazyData (or setting it to false) means we would have to access the data file from the package by explicitly loading it with the data() function.\n\n\n7.1.2 use_data()\nThe usethis::use_data() function simplifies adding data to packages. To use usethis::use_data(), we can load the data into the global environment with load(\"movies.RData\"), then run usethis::use_data(movies):\n\nusethis::use_data(movies)\n\n✔ Adding R to Depends field in DESCRIPTION.\n✔ Creating data/.\n✔ Setting LazyData to \"true\" in DESCRIPTION.\n✔ Saving \"movies\" to \"data/movies.rda\".\n☐ Document your data (see &lt;https://r-pkgs.org/data.html&gt;).\nWe can see use_data() added two fields in the DESCRIPTION and stored movies.rda in the data/ folder. After loading and installing sap, we can see movies is now part the package NAMESPACE.\nIf we run devtools::load_all(), any data in the data/ folder are not lazy-loaded at this stage. However, the data are directly available in our environment for testing during development.\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nIf we want data to be part of the lazyload DB, we need to install the package.\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nWhen the package is installed, we’ll see the following outputs related to data processing:\n\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\n\nmovies is now part of sap’s namespace:\n\n\n\n\n\n\n\nsap::movies\n\n\n\n\n7.1.3 Installed package files\nThe lazyload DB is located in the installed version of the sap package. Installation begins by reading and parsing the DESCRIPTION file to extract metadata such as the package name, version, and dependencies (e.g., Depends, Imports, Suggests). After checking the dependencies (and downloading and installing any that are missing), our source package is extracted, and the files are organized into specific folders:\n\nMeta/: information about datasets, help files, and general package metadata.\nR/: byte-compiled R code stored as .rdb and .rdx files\ndata/: datasets serialized into a lazyload database (stored as .rdb and .rdx files in the R/ directory)\nhelp/: binary help files\nhtml/: html and css files for help files\n\nThe installed folders and files can be viewed using the file path accessor function, system.file().3\n\nsystem.file(..., package = \"\", mustWork = FALSE)\n\nPassing \".\" to the ... argument of system.file() will return the installed location of the root folder of package.\nTo view the path to the R/ folder in our installed package, we can use:\n\nsystem.file(\"R\", package = \"sap\")\n\npath/to/installed/pkg/library/R-4.4/sap/R\nIf we combine this with fs::dir_tree(), we can see the files contained in the R/ folder:\n\nfs::dir_tree(system.file(\"R\", package = \"sap\"))\n\npath/to/installed/pkg/library/R-4.4/sap/R\n├── sap\n├── sap.rdb\n└── sap.rdx\nDuring installation, data in the data/ folder are converted to .rdb and .rdx file formats and moved to the binary database stored in the R/ folder.\n\nfs::dir_tree(system.file(\"data\", package = \"sap\"))\n\npath/to/installed/pkg/library/R-4.4/sap/data\n├── Rdata.rdb\n├── Rdata.rds\n└── Rdata.rdx\nThe lazyload database stores data objects in serialized form for fast retrieval (i.e., data are loaded only when explicitly requested, optimizing memory usage). The diagram below illustrates the development workflow for adding data to an app-package:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TD\n    subgraph DESC[\"&lt;strong&gt;DESCRIPTION&lt;/strong&gt;\"]\n        LazyData(\"Add &lt;code&gt;LazyData: true&lt;/code&gt;\")\n    end\n    subgraph Data[\"&lt;strong&gt;data/ folder&lt;/strong&gt;\"]\n        app_data[(\"&lt;br&gt;&lt;code&gt;app_data.rda&lt;/code&gt;\")]\n    end\n    subgraph Global[\"&lt;strong&gt;Global Environment&lt;/strong&gt;\"]\n        load_data[(\"&lt;br&gt;&lt;code&gt;app_data&lt;/code&gt;\")]\n    end\n    subgraph Lazy[\"&lt;strong&gt;lazyload DB&lt;/strong&gt;\"]\n        app_data_lazy[(\"&lt;br&gt;Serialized&lt;br&gt; (&lt;code&gt;.rdb&lt;/code&gt;/&lt;code&gt;.rds&lt;/code&gt;/&lt;code&gt;.rdx&lt;/code&gt;)\")]\n    end\n    load(\"&lt;code&gt;devtools::load_all()&lt;/code&gt;\")\n    inst(\"&lt;code&gt;devtools::install()&lt;/code&gt;\")\n    \n    DESC --&gt;|\"&lt;code&gt;usethis::use_data(app_data)&lt;/code&gt;\"|Data\n    Data --&gt; load & inst\n    load --&gt; |\"Direct access for testing\"|Global\n    inst --&gt; |\"Loaded only when&lt;br&gt;explicitly requested\"|Lazy\n  \n\n\n LazyData field in the DESCRIPTION file",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-data-raw",
    "href": "data.html#sec-data-data-raw",
    "title": "7  Data",
    "section": "7.2 data-raw/",
    "text": "7.2 data-raw/\nThe data-raw folder is not an official directory in the standard R package structure, but it’s a common location for any data processing or cleaning scripts, and the raw data file for datasets stored in data/.4\nWe’ll move the movies.RData file into data-raw/.\n\n├── data\n│   └── movies.rda\n└── data-raw\n    └── movies.RData\n\nWe can create a script to document sap::movies using usethis::use_data_raw(\"movies\"):\n\n✔ Adding \"^data-raw$\" to .Rbuildignore.\n✔ Writing data-raw/movies.R.\n☐ Modify data-raw/movies.R.\n☐ Finish writing the data preparation script in data-raw/movies.R.\n☐ Use `usethis::use_data()` to add prepared data to package.\n\nIn the data-raw/movies.R file, we find the following:\n\n## code to prepare `movies` dataset goes here\n\nusethis::use_data(movies, overwrite = TRUE)\n\nWe’ll adapt the script for the movies.RData file.\n\n## code to prepare `movies` dataset goes here\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\n\n\n\n\n\n\n\nScripts for creating movies data\n\n\n\n\n\n\nThe code used to produce the movies dataset in the data/ directory might* come from this GitHub repo. If so, the data-raw folder is where the data processing and preparation scritps would be stored (along with a copy of the data in .csv format) before saving a copy in the data/ folder.\n*I say ‘might’ because it’s not clear if the movies.RData is the output from these .R files (although many of the column names match).\n\n\n\n\n\n7.2.1 A data-raw/ example\nIf we look at the data in the dplyr package, we can see the data-raw/ folder contains a combination of .R and .csv files:\ndata-raw/\n├── band_members.R\n├── starwars.R\n├── starwars.csv\n└── storms.R\n\n1 directory, 4 files\nIn this example, the starwars.R script downloads & prepares starwars, then saves a .csv copy of the data in data-raw.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#sec-document-data",
    "href": "data.html#sec-document-data",
    "title": "7  Data",
    "section": "7.3 Documenting data",
    "text": "7.3 Documenting data\nDocumenting data can be tedious, but it’s worth the effort if you’ll be sharing your package with collaborators. There are multiple ways to store dataset documentation, but we’ll cover using a R/data.R file.5\nIn R/data.R, provide a title, description, a @details tag for more information:\n\n#' IMDB movies data \n#'\n#' Movie review data from the Building Web Applications with Shiny \n#' [course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the 'Web Scraping and programming' \n#' section of [Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#' \n\nBelow @details, include a @format tag with a one-sentence description of the data (and it’s dimensions).\n\n#' IMDB movies data \n#'\n#' Movie review data from the Building Web Applications with Shiny \n#' [course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the 'Web Scraping and programming' \n#' section of [Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming)  \n#' \n#' @format A data frame with [] rows and [] variables:\n\nEach variable (column) in the data is documented with a combination of \\describe and \\item (pay close attention to the curly brackets):\n\n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n\nAfter closing the curly brackets in \\describe, place the name of the data in quotes (\"movies\") on the following line. Below is the documentation for the first five columns in the movies dataset:\n\n#' IMDB movies data \n#'\n#' Movie review data from the Building Web Applications with Shiny \n#' [course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the 'Web Scraping and programming' \n#' section of [Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming)  \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#' }\n#'\n\"movies\"\n\nIf we load and document sap, we can see a preview of the help file:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nWe can view the documentation using the following in the Console:\n\n?movies\n\n\n\n\n\n\n\n\nDocumentation for the movies dataset\n\n\nI’ve provided documentation for the full movies dataset below.\n\n\nshow/hide full movies data documenation\n#' IMDB movies data \n#'\n#' Movie review data from the Building Web Applications with Shiny \n#' [course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the 'Web Scraping and programming' \n#' section of [Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#'  \\item{studio}{name of studio, chr}\n#'  \\item{thtr_rel_date}{Theatre release date, POSIXct, min = 1970-05-19 21:00:00, max = 2014-12-24 21:00:00}\n#'  \\item{thtr_rel_year}{Theatre release year, num, min = 1970, max = 2014}\n#'  \\item{thtr_rel_month}{Theatre release month, num, min = 1, max =12}\n#'  \\item{thtr_rel_day}{Theatre release day, num, min = 1, max =31}\n#'  \\item{dvd_rel_date}{DVD release date, POSIXct, min = 1991-03-27 21:00:00, max = 2015-03-02 21:00:00}\n#'  \\item{dvd_rel_year}{DVD release year, num, min = 1991, max = 2015}\n#'  \\item{dvd_rel_month}{DVD release month, num, min = 1, max = 12}\n#'  \\item{dvd_rel_day}{DVD release day, num, min = 1, max = 31}\n#'  \\item{imdb_rating}{Internet movie database rating, avg = 6.49, sd = 1.08}\n#'  \\item{imdb_num_votes}{Internet movie database votes, avg = 57533, sd = 112124}\n#'  \\item{critics_rating}{Rotten tomatoes rating, fct (Certified Fresh, Fresh, Rotten)}\n#'  \\item{critics_score}{Rotten tomatoes score, avg = 57.7, sd = 28.4}\n#'  \\item{audience_rating}{Audience rating, fct (Spilled, Upright)}\n#'  \\item{audience_score}{Audience score, avg = 62.4, sd = 20.2}\n#'  \\item{best_pic_nom}{Best picture nomination, fct (no, yes)}\n#'  \\item{best_pic_win}{Best picture win, fct (no, yes)}\n#'  \\item{best_actor_win}{Best actor win, fct (no, yes)}\n#'  \\item{best_actress_win}{Best actress win, fct (no, yes)}\n#'  \\item{best_dir_win}{Best director win, fct (no, yes)}\n#'  \\item{top200_box}{Top 20 box-office, fct (no, yes)}\n#'  \\item{director}{Name of director, chr}\n#'  \\item{actor1}{Name of leading actor, chr}\n#'  \\item{actor2}{Name of supporting actor, chr}\n#'  \\item{actor3}{Name of #3 actor, chr}\n#'  \\item{actor4}{Name of #4 actor, chr}\n#'  \\item{actor5}{Name of #5 actor, chr}\n#'  \\item{imdb_url}{IMDB URL}\n#'  \\item{rt_url}{Rotten tomatoes URL}\n#' }\n#'\n\"movies\"\n\n\n\n\n\n\n\n\nDocumenting data\n\n\n\n\n\n\nDocumenting data requires the following roxygen2 structure:\n#' \n#' @title single-sentence describing [data]\n#' \n#' @description\n#' Single-paragraph describing [data]\n#' \n#' @format [data] number of rows and columns:\n#' \\describe{\n#'  \\item{variable}{description}\n#'  \\item{variable}{description}\n#' }\n#'\n\"[data]\"\nReplace [data] with the name of your dataset.\n\n\n\n\n\n7.3.1 Documentation example\nTo illustrate other options for data documentation, we’ll use the dplyr package again. As we can see from the folder tree below, dplyr stores its data in the data/ folder:\ndata/\n├── band_instruments.rda\n├── band_instruments2.rda\n├── band_members.rda\n├── starwars.rda\n└── storms.rda\nThe documentation for the datasets in dplyr are stored in R/ using a data- prefix:\nR/\n├── data-bands.R\n├── data-starwars.R\n└── data-storms.R\nThe three band_ datasets have documented in a single file, data-bands.R:\n\n\nshow/hide documentation for dplyr::band_ datasets\n# from the dplyr github repo: \n# https://github.com/tidyverse/dplyr/blob/main/R/data-bands.R\n# \n#' Band membership\n#'\n#' These data sets describe band members of the Beatles and Rolling Stones. They\n#' are toy data sets that can be displayed in their entirety on a slide (e.g. to\n#' demonstrate a join).\n#'\n#' `band_instruments` and `band_instruments2` contain the same data but use\n#' different column names for the first column of the data set.\n#' `band_instruments` uses `name`, which matches the name of the key column of\n#' `band_members`; `band_instruments2` uses `artist`, which does not.\n#'\n#' @format Each is a tibble with two variables and three observations\n#' @examples\n#' band_members\n#' band_instruments\n#' band_instruments2\n\"band_members\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments2\"\n\n\nIn the example above, note that two of the datasets (band_instruments and band_instruments2) have the @format set to NULL, and define the help search name with @rdname. The @examples tag can be used to view the dataset when users click ‘Run Examples.’\nEither method works–what’s important is that each dataset in your package has documentation.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-inst-extdata",
    "href": "data.html#sec-data-inst-extdata",
    "title": "7  Data",
    "section": "7.4 External data",
    "text": "7.4 External data\nThe inst/extdata folder is used for external datasets in other file formats (.csv, .tsv, .txt, .xlsx, etc).6 These data files aren’t directly loadable using the package::data syntax or data() like with the data/ directory, but we can access them using system.file().\n\n7.4.1 inst/extdata/\nWe’ll create the inst/extdata/ folder and save a copy of movies in the .fst file format:\n\nlibrary(fs)\nlibrary(tibble)\nlibrary(fst)\n\nfst package v0.9.8\n\nfs::dir_create(\"inst/extdata/\")\nfst::write_fst(\n  x = movies, \n  path = \"inst/extdata/movies.fst\", \n  compress = 75)\n\nfstcore package v0.9.14\n(OpenMP was not detected, using single threaded mode)\nThen load, document, and install sap:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nWe can import movies.fst using system.file() to create a path to the file:\n\ntibble::as_tibble(\n  fst::read_fst(path = \n      system.file(\"extdata/\", \"movies.fst\", package = \"sap\")\n    )\n  )\n\nfstcore package v0.9.18\n(OpenMP was not detected, using single threaded mode)\n# A tibble: 651 × 34\n   title                  title_type genre runtime mpaa_rating studio\n   &lt;chr&gt;                  &lt;fct&gt;      &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;       &lt;fct&gt;\n 1 Filly Brown            Feature F… Drama      80 R           Indom…\n 2 The Dish               Feature F… Drama     101 PG-13       Warne…\n 3 Waiting for Guffman    Feature F… Come…      84 R           Sony …\n 4 The Age of Innocence   Feature F… Drama     139 PG          Colum…\n 5 Malevolence            Feature F… Horr…      90 R           Ancho…\n 6 Old Partner            Documenta… Docu…      78 Unrated     Shcal…\n 7 Lady Jane              Feature F… Drama     142 PG-13       Param…\n 8 Mad Dog Time           Feature F… Drama      93 R           MGM/U…\n 9 Beauty Is Embarrassing Documenta… Docu…      88 Unrated     Indep…\n10 The Snowtown Murders   Feature F… Drama     119 Unrated     IFC F…\n# ℹ 641 more rows\n# ℹ 28 more variables: thtr_rel_date &lt;dttm&gt;, thtr_rel_year &lt;dbl&gt;,\n#   thtr_rel_month &lt;dbl&gt;, thtr_rel_day &lt;dbl&gt;, dvd_rel_date &lt;dttm&gt;,\n#   dvd_rel_year &lt;dbl&gt;, dvd_rel_month &lt;dbl&gt;, dvd_rel_day &lt;dbl&gt;,\n#   imdb_rating &lt;dbl&gt;, imdb_num_votes &lt;int&gt;, critics_rating &lt;fct&gt;,\n#   critics_score &lt;dbl&gt;, audience_rating &lt;fct&gt;,\n#   audience_score &lt;dbl&gt;, best_pic_nom &lt;fct&gt;, best_pic_win &lt;fct&gt;, …\n# ℹ Use `print(n = ...)` to see more rows\nWe’ll cover inst/ and system.file() in more detail in the next chapter.\n\n\n\n\n\n\n\n\n\n\nSee the 07_data branch of sap.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#using-movies",
    "href": "data.html#using-movies",
    "title": "7  Data",
    "section": "7.5 Using movies",
    "text": "7.5 Using movies\nAfter documenting the movies data in R/data.R, we’ll remove the call to load() in the mod_scatter_display_server() function and replace it with a direct call to the dataset:\n\n#' Plot Display Module - Server\n#'\n#' Handles the server-side logic for rendering a scatter plot.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#' @param var_inputs *(reactive)* A reactive expression containing \n#'  user-selected variables and attributes.\n#'\n#' @return No direct return value. This function generates a plot output.\n#'\n#' @section Details: \n#' `mod_scatter_display_server()`:\n#' - Uses `var_inputs` to dynamically generate a scatter plot with \n#'   user-selected variables.\n1#' - Reads from the `sap::movies` dataset\n#' - Processes plot titles and axis labels to improve readability.\n#'\n#' @section Reactive Inputs:\n#' - `var_inputs()$x`: X-axis variable.\n#' - `var_inputs()$y`: Y-axis variable.\n#' - `var_inputs()$z`: Color aesthetic variable.\n#' - `var_inputs()$alpha`: Transparency level.\n#' - `var_inputs()$size`: Size of points.\n#' - `var_inputs()$plot_title`: Title of the plot.\n#'\n#' @seealso\n#' - [`mod_var_input_server()`] for variable selection.\n#' - [`scatter_plot()`] for generating the scatter plot.\n#'\n#' @family **Plot Display Module**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(\n#'       mod_var_input_ui(\"vars\"),\n#'       mod_scatter_display_ui(\"plot\")\n#'     ),\n#'     server = function(input, output, session) {\n#'       selected_vars &lt;- mod_var_input_server(\"vars\")\n#'       mod_scatter_display_server(\"plot\", selected_vars)\n#'     }\n#'   )\n#' }\n#'\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n\n    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n2        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n1\n\nUpdated roxygen2 documentation\n\n\n2\n\nThe movies data from our package namespace\n\n\n\n\nAfter loading, documenting, and installing the package, we see the following application:\n\n\n\n\n\n\n\nlaunch_app() with movies data file",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#recap",
    "href": "data.html#recap",
    "title": "7  Data",
    "section": "Recap",
    "text": "Recap\nIt’s hard to imaging a Shiny app without any data, so knowing how and where to store and access data files in an app-package will make it easier to load and be reproducible in other environments. Here are a few other things to consider when including data in your app-package:\n\n\n\n\n\n\nRecap: Package data files\n\n\n\n\n\n\n\ndata/: All data files stored in data/ will be ‘lazy loaded’ (see below) when the package is installed and loaded.\nLoading: include the LazyData: true field in the DESCRIPTION file so the data is only loaded when it’s used (and it increases package loading speed).\nSize: large data files can inflate the size of your app-package, making it harder for users to download and install. CRAN also has a size limit for packages (if you plan on submitting your app-package).\nFormat: data files in data/ must be either .rda or .RData format.\nDocumentation: document the data files in either a single R/data.R file or individual .R files. Documentation should include the following roxygen2 format:\n#' \n#' @title \n#' \n#' @description\n#' \n#' @format \n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n#'\n'data'\ninst/extdata/: Store external data in the inst/extdata/ directory and access it using system.file(). This can be helpful if your app-package needs access to data files that are not R objects. For faster loading, consider the fst or feather formats.\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#footnotes",
    "href": "data.html#footnotes",
    "title": "7  Data",
    "section": "",
    "text": "Read more about the data folder in the ‘Data in packages’ section of Writing R Extenstions and the ‘Data’ chapter of R Packages, 2ed.↩︎\nFor information on how to store and retrieve inside your application, see the chapter on app Data.↩︎\nThis is similar to find.package(\"sap). Read more about system.file() and find.package().↩︎\nRead more about the data-raw folder in R Packages, 2ed↩︎\nThe ggplot2 package has a great example of documenting datasets in the R/data.R file↩︎\nRead more about the inst/extdata/ folder in R Packages, 2ed↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "launch.html",
    "href": "launch.html",
    "title": "8  Launch",
    "section": "",
    "text": "8.1 Running apps\nThis chapter covers the differences between shinyApp(), runApp(), and shinyAppDir(), what should go in an app.R file, and other options for launching an app (or apps) from within an app-package.\nDuring development, we have a variety of options for launching applications. Both RStudio  and Positron  offer a single-click button to run our application the top of the Source pane/Editor. We can also launch the app by calling the standalone app function in the Console. Below we’ll cover what happens behind the scenes when we click on these icons.\nIn the current branch of sap, the app.R file contains a call to launch_app(), which loads the package and passes the UI and server functions to shinyApp().\nAs we can see in the image below, this places the Run App icon in RStudio’s  Source pane. In Positron , the app.R file displays the Run Shiny App.\nClicking on either Run App/Run Shiny App buttons calls runApp() and launches our application, but with a loadSupport() warning.\nThe section below will cover the loadSupport() warning and why it appears when using the Run App/Run Shiny App buttons in RStudio  and Positron .",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#running-apps",
    "href": "launch.html#running-apps",
    "title": "8  Launch",
    "section": "",
    "text": "‘Launch’ vs. ‘Run’\n\n\n\n\n\n\nI’ll be using the term ‘launch’ to differentiate successfully displaying the application locally (either in the IDE window, viewer pane, or browser) from clicking on the Run App/Run Shiny App button or calling the runApp() function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSee the 06.2_pkg-imports branch of sap.\n\n\n\nRStudio Positron \n\n\n\n\n\n\n\n\n\n\n\n\n8.1.1 loadSupport() warnings\n\n\n\n\n\n\nloadSupport() warning\n\n\n\n\n\n\n\n\nThe warning in the Console is telling us loadSupport() has detected that sap is a package, but it’s still sourcing the R/ subdirectory.1\n\n\n\n\n\nRStudio Positron \n\n\nAs noted above, clicking Run App in RStudio  calls runApp() and launches our application with a loadSupport() warning printed in the Console.\n\n\n\nClicking Run App in RStudio calls runApp() and displays the loadSupport() warning\n\n\n\n\nIn Positron , clicking on the Run Shiny App button launches the application with a slightly different process than RStudio :\n\n\n\nClicking Run Shiny App in Positron calls runApp() and displays the loadSupport() warning\n\n\n\nA new Shiny terminal process is started with the --devmode option\n\nrunApp() is called with the full path to our app.R file and a port argument2\n\nThe loadSupport() warning is displayed in the Terminal\n\n\n\n\n\nIt’s important to note that we also see the loadSupport() warning if we bypass the Run App/Run Shiny App buttons and call shiny::runApp() directly in the Console:\n\nRStudio Positron \n\n\n\n\n\nCalling runApp() directly in RStudio’s Console displays the loadSupport() warning\n\n\n\n\n\n\n\nCalling runApp() directly in Positron’s Console displays the loadSupport() warning\n\n\n\n\n\n\nWhat’s with the warning?\nIn the Shiny chapter we learned loadSupport() is called automatically when an application is run with runApp(). Specifically, loadSupport()\n\n“loads any top-level supporting .R files in the R/ directory adjacent to the app.R/server.R/ui.R files” 3\n\nBehind the scenes, runApp() is called by both Run App/Run Shiny App buttons, which then automatically calls loadSupport(). This is why if we pass our standalone app function to the Console (which uses shinyApp(), not runApp()), the warning disappears:\n\nRStudio Positron \n\n\n\n\n\n\n\n\n\nNo loadSupport() warning in RStudio\n\n\n\n\n\n\n\n\n\n\n\nNo loadSupport() warning in Positron\n\n\n\n\n\n\nThe examples above demonstrate the differences between calling shinyApp() and runApp(), and the tension between calling a standalone app function from an R package vs. sourcing the app.R file in a Shiny project.\n\n\n8.1.2 --devmode\nAs we saw above, clicking Run Shiny App in Positron  will launch the application in devmode,4 which is controlled by the script below:\n\n\nshow/hide Positron’s runShinyApp.R script\nusage &lt;- \"Usage: Rscript runShinyApp.R &lt;path&gt; &lt;port&gt; [--devmode]\"\n\n1args &lt;- commandArgs(trailingOnly = TRUE)\n\nif (length(args) &lt; 2) {\n  stop(usage)\n}\n\npath &lt;- args[1]\nport &lt;- as.integer(args[2])\nstopifnot(is.integer(port))\n2devmode &lt;- \"--devmode\" %in% args\n\nif (devmode) {\n  shiny::devmode()\n} else {\n  options(shiny.autoreload = TRUE)\n}\n\nmessage(\"Running Shiny app\")\nmessage(\"-----------------\")\nmessage(sprintf('shiny::runApp(%s, port = %d)\\n', deparse(path), port))\n\n3shiny::runApp(path, port = port, launch.browser = FALSE)\n\n\n\n1\n\ncommandArgs(trailingOnly = TRUE) retrieves the arguments passed to the script, excluding the default arguments used when R starts.\n\n\n2\n\ndevmode &lt;- \"--devmode\" %in% args checks if the --devmode flag is present among the arguments. If it is, devmode is set to TRUE\n\n\n3\n\nLastly, the script runs the Shiny app using runApp() (with the specified path and port), and launch.browser = FALSE ensures the app is not automatically opened in a web browser.\n\n\n\n\nShiny devmode will display something like the following messages the first time your application is launched using the Run Shiny App button in Positron :\n\n\nshow/hide devmode options\nshiny devmode - Using full shiny javascript file. To use the minified version, call `options(shiny.minified = TRUE)`\nThis message is displayed once every 8 hours.\nshiny devmode - Turning off caching of Sass -&gt; CSS compilation. To turn caching on, call `options(sass.cache = TRUE)`\nThis message is displayed once every 8 hours.\nshiny devmode - Disabling the use of bslib precompiled themes. To be able to use precompiled themes, call `options(bslib.precompiled = TRUE)`\nThis message is displayed once every 8 hours.\nshiny devmode - Enabling warnings about low color contrasts found inside `bslib::bs_theme()`. To suppress these warnings, set `options(bslib.color_contrast_warnings = FALSE)`\nThis message is displayed once every 8 hours.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#shiny-launch-functions",
    "href": "launch.html#shiny-launch-functions",
    "title": "8  Launch",
    "section": "8.2 Shiny launch functions",
    "text": "8.2 Shiny launch functions\n\nIn the following sections, we’ll compare shinyApp(), shinyAppDir(), and runApp() to determine which one to use in R/launch_app.R and the app.R file. As we’ve seen, the Run App/Run Shiny App buttons call runApp(), even when we have a call to shinyApp() in the app.R file. This might make you wonder,\n“Why even include a call to shinyApp() if the app is being launched with runApp()?”\nLet’s review what happens when we call shinyApp().\n\n8.2.1 shinyApp()\nOne of the key features of shinyApp() is the creation of the shiny.appobj (a shiny app object):\n\napp &lt;- shinyApp(ui = movies_ui, \n                server = movies_server)\nstr(app)\n\nIf we look at the structure of the returned object from shinyApp(), we see the shiny.appobj includes the appDir under appOptions:\nList of 5\n $ httpHandler     :function (req)  \n $ serverFuncSource:function ()  \n $ onStart         : NULL\n $ options         : list()\n $ appOptions      :List of 2\n1  ..$ appDir       : chr \"/path/to/sap\"\n  ..$ bookmarkStore: NULL\n2 - attr(*, \"class\")= chr \"shiny.appobj\"\n\n1\n\nappDir is the first argument of runApp()\n\n\n2\n\nA shiny app object\n\n\nThis is why runApp() works with any .R file creating a shiny app object.\n\n\n\n\n\n\nshinyApp()\n\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(): Creates and launches an app defined inline within the call itself (or with UI and server functions passed as arguments).\n\n\nshinyApp(\n  ui = fluidPage(\n    # UI elements\n  ),\n  server = function(input, output) {\n    # Server logic\n  }\n)\n\n\n\n\n\n\n\n\n\n8.2.2 shinyAppDir()\nshinyAppDir() is similar to shinyApp(), but is designed to use a “path to directory that contains a Shiny app.”\nIn practice, we can use shinyAppDir() with a returned object from shinyApp():\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server\n      )\napp$appOptions$appDir\n\n[1] \"path/to/sap\"\nThis path can be passed to the appDir argument (along with any Shiny options).\n\nshinyAppDir(\n  appDir = app$appOptions$appDir,\n  options(test.mode = TRUE)\n)\n\n\n\n\n\n\n\nshinyAppDir()\n\n\n\n\n\n\n\n\n\n\n\n\nshinyAppDir(): Launches an app from a directory (with an app.R or ui.R/server.R files).\n\n\nshinyAppDir(\n  appDir = \"path/to/app/\", \n  options = list())\n\n\n\n\n\n\n\n\n\n8.2.3 runApp()\nThe reason we’re able to call runApp() in the Console to launch both applications above is because it’s very versatile:\n\n\n\n\n\n\nrunApp()\nCan launch apps from ui.R/server.R, app.R or directory:\n\n\n\n# In console\nrunApp()\n\n\n\n\n\n\n\n\n\nWorks with a path to an .R file that creates a shiny.appobj:5\n\n\nrunApp(appDir = \"path/to/sap\")\n\n\n\n\n\n\n\n\n\nCan also use a shiny.appobj directly:\n\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server)\nrunApp(appDir = app)\n\n\n\nThis final method does not produce the loadSupport() warning because a Shiny object (shiny.appobj) has already been created, and runApp() is essentially calling print(app) in the Console.\n\n\n\n\n\n\nrunApp()\n\n\n\n\n\n\n\n\n\n\n\n\nrunApp(): A generalized way to launch your app–it can run apps defined inline, or from a directory.\n\n\nrunApp(\n  appDir = \"path/to/app/\",\n  test.mode = TRUE/FALSE)\n\n\n\n\n\n\n\n\nRecap\n\nshinyApp() is typically used to create apps within an interactive R session\nshinyAppDir() runs a Shiny app stored in a directory (containing an app.R file (or ui.R and server.R files)\nrunApp() also launches apps in a directory, but it’s versatility makes it suitable for running apps in various formats, either defined inline or in separate directories.6",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#standalone-function",
    "href": "launch.html#standalone-function",
    "title": "8  Launch",
    "section": "8.3 Standalone function",
    "text": "8.3 Standalone function\nI tend to name the standalone app function launch_app() and include the options covered below (none of these are required, though).\n\n\nLaunch app with the shinypak package:\n\nlaunch('08_launch')\n\n\n8.3.1 App launching options\nshinyApp() or shinyAppDir() both have an options argument, so we should make this available in launch_app(). For example, one of the Shiny options we could include in our standalone app function is test.mode:\n\n‘Should the application be launched in test mode? This is only used for recording or running automated tests. Defaults to the shiny.testmode option, or FALSE if the option is not set.’\n\nThe test.mode option lets us export values from our application when we’re running tests (which we’ll cover in-depth in the Tests section).\nWe’ll make options an argument that defaults to an empty list() in launch_app():\n\nlaunch_app &lt;- function(options = list()) {\n    shinyApp(\n1      ui = movies_ui(),\n      server = movies_server,\n2      options = options\n      )\n}\n\n\n1\n\nBuild the shiny app object with movies_ui and movies_server\n\n\n2\n\nInclude options list\n\n\n\n\n\n\n8.3.2 Where to launch?\nI’ve written a display_type() helper function to 1) check if the application is being run in RStudio and, if so, 2) control where the Shiny app is launched. The run argument in display_type() takes the following options:\n\n\"p\" = Viewer Pane\n\n\"w\" = IDE Window\n\n\"b\" = External browser\n\nThe option to access configuration is shiny.launch.browser:7\n\n#' Shiny app display mode helper\n#'\n#' @param run where to launch app: \n#'  * `\"p\"` = launch in viewer pane \n#'  * `\"b\"` = launch in external browser  \n#'  * `\"w\"` = launch in window (default)\n#'\n#' @return notification of `shinyViewerType` option\n#' \n#' @export\n#'\ndisplay_type &lt;- function(run = \"w\") {\n  if (interactive()) {\n1    if (Sys.getenv(\"RSTUDIO\") == \"1\") {\n      \n2      switch(\n        run,\n        p = options(shiny.launch.browser = .rs.invokeShinyPaneViewer),\n        b = options(shiny.launch.browser = .rs.invokeShinyWindowExternal),\n        w = options(shiny.launch.browser = .rs.invokeShinyWindowViewer),\n        NULL = options(shiny.launch.browser = NULL)\n      )\n      environment &lt;- \"RStudio\"\n      shinyViewerType &lt;- getOption('shiny.launch.browser') |&gt;\n        attributes() |&gt;\n        unlist() |&gt;\n        unname()\n      \n3      cli::cli_alert_info(\"App running in {environment}\")\n4      cli::cli_alert_info(\"shinyViewerType set to {shinyViewerType}\")\n    } else {\n      environment &lt;- \"RStudio\"\n      cli::cli_alert_info(\"App not running in {environment}\")\n    }\n  } else {\n    cli::cli_alert_info(\"App not running in interactive session\")\n  }\n}\n\n\n1\n\nDetect IDE\n\n2\n\nSet option\n\n\n3\n\nPrint IDE\n\n\n4\n\nPrint option\n\n\n\n\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe cli package is imported as part the devtools/usethis workflow but we want to add it the Imports field of the DESCRIPTION with usethis::use_package('cli').\n\n\n\n\n\n\n8.3.3 An updated launch_app()\nThe display_type() and options list have been added to launch_app():\n\nlaunch_app &lt;- function(options = list(), run = \"p\") {\n1    display_type(run = run)\n    shinyApp( \n      ui = movies_ui(),\n      server = movies_server,\n2      options = options\n3    )\n}\n\n\n1\n\nSet shinyViewerType option with display_type()\n\n\n2\n\nPass options\n\n\n3\n\nLaunch app\n\n\n\n\nAfter loading, documenting, and installing our package, we can see the documentation for our updated launch_app() function in RStudio  and Positron :\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStandalone app function in RStudio\n\n\n\n\n\n\n\nStandalone app function in Positron\n\n\n\n\n\nIn RStudio , we will confirm the app is launching without the loadSupport() warning, the message is printing to the Console from the run argument, and test.mode are implemented correctly.\nWe also want to confirm launch_app() works in Positron :\n\n launch_app() launch_app() args launch_app()\n\n\n\n\n\nlaunch_app() launches the app in the Window\n\n\n\n\n\n\n\nThe updated launch_app() function launches the application in the Viewer\n\n\n\n\n\n\n\nThe updated launch_app() function in Positron\n\n\n\n\n\nWhen we’re confident our standalone app function is working, we’ll write the app.R file.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#sec-launch-app-dot-r",
    "href": "launch.html#sec-launch-app-dot-r",
    "title": "8  Launch",
    "section": "8.4 The app.R file",
    "text": "8.4 The app.R file\nThe app.R file should contain any options or settings that we would use during development. There are multiple ways to launch an application from app.R, so I encourage you to explore the options below to find a method that works for your workflow/environment.\n\n8.4.1 Is this an interactive session?\nThe first condition we’ll check to see if there is a “human operator to interact with” with base::interactive():\n\nif (!interactive()) {\n  \n} else {\n   \n}\n\nYou have probably seen control flow like this in shiny help file examples (like flowLayout() below):\n\n\n\n\n\n\n\n\n\n(a) if (interactive()) in flowLayout() example\n\n\n\n\n\nFigure 8.1: Running examples ‘interactively’ let’s us see the app demo beneath the code\n\n\n\nAdding if and interactive() will allow our app.R file distinguish between 1) launching apps from a RStudio/Positron session (i.e., during development) and 2) deploying apps (i.e., like publishing the application on Posit Connect).\n\n8.4.1.1 Non-interactive sessions\nIf the session is non-interactive, we’ll divert all regular output to the standard error stream. The sink() function “diverts R output to a connection”, so the code below sends the output that would normally print to the console to the where error messages are written.\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n} else {\n   \n}\n\nThis is useful in a non-interactive settings if we want to re-direct the error output for the console text-mode connection.\ntryCatch() is used for ‘catching conditions’ during the execution of an expression (expr =):\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(sap)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   \n}\n\nIn this case, if library(sap) throws an error, the function specified after error = is executed (i.e., pkgload::load_all()).8\nWritten this way, in a non-interactive R session, app.R will re-direct the error output and attempt to load and attach sap, and if this fails, app.R will attempt to load all the files in the R/ folder.\n\n\n8.4.1.2 Interactive sessions\nIf the session is interactive, we want app.R to load all the code in the R/ folder with pkgload::load_all() before launching our app with launch_app() (and a few optional arguments).\n\nif (!interactive()) {\n  sink(stderr(), type = \"output\")\n  tryCatch(\n    expr = {\n      library(sap)\n    },\n    error = function(e) {\n      pkgload::load_all()\n    }\n  )\n} else {\n  pkgload::load_all()\n}\n  sap::launch_app(\n    options = list(test.mode = TRUE), run = 'p')\n\npkgload::load_all() is the function that’s called when we run devtools::load_all() (or use Ctrl/Cmd + Shift + L), and this is somewhat analogous to running library(sap)\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe pkgload package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('pkgload').\n\n\n\n\n\n\n8.4.1.3 Dealing with loadSupport()\nThe withr package is designed to ‘run code with safely and temporarily modified global state’, and it comes in handy when launching shiny apps. For example, I want to turn off the loadSupport() behavior when launching the app from app.R.9\nWe can use withr::with_options() to accomplish this using the following new and code arguments\n\nnew: a named list of the new options and their values\n\ncode: the ’Code to execute in the temporary environment\n\nWe’ll place the withr::with_options() at the top of app.R and pass shiny.autoload.r = FALSE to the new argument (the contents of our app.R are passed into the code argument).\n\n1withr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n2  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        library(sap)\n      },\n      error = function(e) {\n        pkgload::load_all()\n      }\n    )\n3  } else {\n    pkgload::load_all()\n  }\n4    sap::launch_app(\n      options = list(test.mode = TRUE), run = 'p')\n}) \n\n\n1\n\nTurn off loadSupport()\n\n\n2\n\nDefine non-interactive behaviors\n\n\n3\n\nDefine interactive behaviors\n\n\n4\n\nLaunch app (with options)\n\n\n\n\nNow that we’ve updated the app.R to account for the app-package structure, we’ll load, document, and install sap and send it’s contents to the Console:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe withr package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('withr').\n\n\n\n\n\n\n\n8.4.2 Updated app.R\nWhen we send the contents of app.R to the Console, the loadSupport() options are applied before running the app:\n\nRStudio Positron \n\n\n\n\n\nSending app.R to RStudio’s Console\n\n\n\n\n\n\n\nSending app.R to Positron’s Console\n\n\n\n\n\n\n\n\n\n\n\nR/_disable_autoload.R\n\n\n\n\n\n\nIn the documentation for loadSupport(), you’ll find a second option for removing the R/ directory sourcing behavior: placing a _disable_autoload.R file in the R/ directory (this is also one of the behaviors of the golem framework, which we will cover in the following chapters).\nBoth methods work–this chapter demonstrates a way to remove the loadSupport() warning without having to add this file.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#recap-1",
    "href": "launch.html#recap-1",
    "title": "8  Launch",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some options for launching your app within your app-package. We went over what to include in the standalone app function and the app.R file, the differences between shinyApp(), shinyAppDir() and runApp(), but it’s worth exploring these topics further (especially if you plan on having more than one apps in your package).\n\n\n\n\n\n\nRecap: launching your app\n\n\n\n\n\n\nshinyApp():\n\nshinyApp() doesn’t care about file structure, so it’s useful for quick prototyping or if the app is in a single .R script. It’s also more portable because you can share your app with a single .R script.\n\nIt’s possible to bundle shinyApp() in a wrapper function to integrate within an R package (like we’ve done with launch_app()).\nshinyApp() returns a shiny app object, which can be useful if you want to explore the app structure programmatically (i.e., testing).\n\n\nshinyAppDir():\n\nshinyAppDir() launches an app from a directory, and is useful if an app is spread across multiple files and folders.\n\nrunApp()\n\nrunApp() a more generalized way to launch an app. It works with:\n\napps contained in a directory (i.e., runApp('path/to/app')\napps in separate ui.R and server.R files (or a single app.R file)\na shiny app object (passed to the appDir argument).\n\nClicking on Run App will run the application with runApp() if is detects a file (or files) that creates a shiny object.\n\n\n\n\n\nIn the following chapter, we’re going to cover where to put non-standard R package files that are common to Shiny apps (images, .css/.scss file, etc.).\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#footnotes",
    "href": "launch.html#footnotes",
    "title": "8  Launch",
    "section": "",
    "text": "If you recall, we covered the loadSupport() function in Chapter 2.↩︎\nI’ve displayed the application in the browser clicking on the  ‘Open the current URL in the default browser’ icon.↩︎\nloadSupport() does this by sourcing the files in alphabetical order.↩︎\ndevmode is an experimental option with multiple settings.↩︎\nShiny’s examples are run using runApp()↩︎\nIt’s worthwhile to read the documentation on shinyApp(), shinyAppDir(), and runApp().↩︎\nThe shiny.launch.browser options are covered in this blog post by Garrick Aden-Buie, and I’ve combined them into a run argument in launch_app()↩︎\npkgload is part of the conscious uncoupling of the devtools package we learned about back in Chapter 6.↩︎\nYou can read more about the shiny.autoload.r option and loadSupport() in this article↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "9  Resources",
    "section": "",
    "text": "Package files\nIn this chapter, we’ll cover how to include external resources (i.e., the images, CSS styling, JavaScript files, etc. previously served from the www/ folder) in an app-package.\nWhen we launch our app, we see the Shiny logo (shiny.png) in the www/ folder is not being loaded into the UI:\nShiny’s internal functions previously automatically handled serving the contents of www/.1 Now that we’ve converted our application into a package, we’ll need to tell the application where to find these resources explicitly.2\nWhile developing, we get used to accessing and interacting with our package files from the Files pane or Explorer window:\nHowever, as noted in the data chapter, the aren’t the files in our installed package. We can use system.file() and fs::dir_tree() to print a folder tree of our installed package files:\nVery few of the source folders and files we’ve been working with remain in the installed version of our package. An exception is the movies.fst file (stored in inst/extdata/). Hopefully seeing these two folder trees side-by-side demystifies what devtools::install() does.\nWhen we want to add non-R package files to our app (like the shiny.png logo), we store these files in the inst/folder and access them with system.file().3",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#package-files",
    "href": "resources.html#package-files",
    "title": "9  Resources",
    "section": "",
    "text": "RStudio Positron \n\n\n\n\n\n‘Source’ files for sap in Files pane\n\n\n\n\n\n\n\n‘Source’ files for sap in Explorer window\n\n\n\n\n\n\n\n\n\n\n\n\nsap/\n├── DESCRIPTION \n├── NAMESPACE \n├── R \n│   ├── data.R\n│   ├── display_type.R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   ├── launch_app.R\n│   ├── movies_server.R\n│   ├── movies_ui.R\n│   └── scatter_plot.R\n├── README.md\n├── app.R\n├── data \n│   ├── movies.RData\n│   └── movies.rda\n├── inst\n│   └── extdata \n│       └── movies.fst\n├── man\n│   ├── display_type.Rd\n│   ├── mod_scatter_display_server.Rd\n│   ├── mod_scatter_display_ui.Rd\n│   ├── mod_var_input_server.Rd\n│   ├── mod_var_input_ui.Rd\n│   ├── movies.Rd\n│   ├── launch_app.Rd\n│   ├── movies_server.Rd\n│   ├── movies_ui.Rd\n│   └── scatter_plot.Rd\n├── sap.Rproj\n└── www\n    └── shiny.png\n\n\nsap/\n1├── DESCRIPTION\n├── INDEX\n2├── Meta\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n3├── NAMESPACE\n4├── R\n│   ├── sap\n│   ├── sap.rdb\n│   └── sap.rdx\n5├── data\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n6├── extdata\n│   └── movies.fst\n7├── help\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── sap.rdb\n│   ├── sap.rdx\n│   └── paths.rds\n8└── html\n    ├── 00Index.html\n    └── R.css\n\n1\n\nDESCRIPTION is in both source and installed versions, and format remains unchanged.\n\n2\n\nMetadata files, such as data.rds and package.rds, are created in the Meta/ directory\n\n\n3\n\nNAMESPACE is in both source and installed versions, and format remains unchanged.\n\n4\n\nR code in the R/ directory is byte-compiled for improved performance, stored in .rdb and .rdx files.\n\n\n5\n\nDatasets in the data/ directory are serialized into a lazyload database and stored as .rdb and .rdx files in the R/ directory.\n\n\n6\n\nThe extdata/ folder is in both source and installed versions, and the movies.fst file remains unchanged.\n\n\n7\n\n.Rd files are processed into binary help files\n\n\n8\n\nHTML and styling for help index\n\n\n\n\n\n\n\n\n“The contents of the inst/ subdirectory will be copied recursively to the installation directory. Subdirectories of inst/ should not interfere with those used by R (currently, R/, data/, demo/, exec/, libs/, man/, help/, html/ and Meta/, and earlier versions used latex/, R-ex/).” - Writing R extensions, Package subdirectories\n\n\n\n\n\n\n\nOther Uses of the inst/ folder\n\n\n\n\n\n\nI found exploring the structure of the inst/ folder in other packages incredibly helpful in understanding how to use this directory for package development. For example, the inst/examples/ folder in the shiny package holds a variety of Shiny apps:\n/path/to/install/Library/R/x86_64/4.2/library/shiny/examples/\n├── 01_hello\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 02_text\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 03_reactivity\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 04_mpg\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 05_sliders\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 06_tabsets\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 07_widgets\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 09_upload\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 10_download\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n└── 11_timer\n    ├── DESCRIPTION\n    ├── Readme.md\n    └── app.R\nThese files are used in shiny::runExample()):\nshiny::runExample(example = '11_timer')",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#sec-resources-image-files",
    "href": "resources.html#sec-resources-image-files",
    "title": "9  Resources",
    "section": "9.1 Image files",
    "text": "9.1 Image files\nTo include the contents of www/ in our app-package, we’ll need to move www/ into inst/, and then access its contents with system.file().4\n\n9.1.1 system.file()\nWe used system.file() in the Data chapter (see Section 7.1.3) to access the movies.fst file in inst/extdata/. system.file() gives us access to the package files on installation (i.e., the files we saw in the folder tree above).\n\n\nsystem.file() is accessing movies.fst from the installed location\nfst::read_fst(\n  path = system.file(\"extdata/\", \"movies.fst\", \n                     package = \"sap\")\n  )\n\n\nIn essence, movies.fst has ‘source’ package and ‘installed’ locations.\n\nSource package files\n\n1inst/\n  └── extdata/\n        └── movies.fst\n\n\n1\n\nWhat we see\n\n\n\n\n\n\nInstalled package files\n\n1└── extdata/\n      └── movies.fst\n\n\n1\n\nWhat R sees\n\n\n\n\n\n\n\n9.1.2 addResourcePath()\nThe addResourcePath() function will add a “directory of static resources to Shiny’s web server.”5 In sap, we want to add the www directory, which includes the shiny.png file.\n\n\n\n\n\n\nCurrent www location\n├── inst\n│   └── extdata\n│       └── movies.fst\n└── www\n    └── shiny.png\n\n\n \n\n\nNew www location\ninst/\n  ├── extdata/\n  │   └── movies.fst\n  └── www/\n      └── shiny.png\n\n\n\nIn R/movies_ui.R, we’ll include the addResourcePath() at the top of the tagList() and reference the image in img() using only the subfolder in the path:\n\n\nshow/hide movies_ui()\nmovies_ui &lt;- function() {\n  addResourcePath(\n1    prefix = \"www\",\n2    directoryPath = system.file(\"www\", package = \"sap\")\n  )\n  tagList(\n    bslib::page_fillable(\n      h1(\"Movie Reviews\"),\n      bslib::layout_sidebar(\n        sidebar =\n          bslib::sidebar(\n            title = tags$h4(\"Sidebar inputs\"),\n            img(\n3              src = \"www/shiny.png\",\n              height = 60,\n              width = 55,\n              style = \"margin:10px 10px\"\n            ),\n            mod_var_input_ui(\"vars\")\n          ),\n        bslib::card(\n          full_screen = TRUE,\n          bslib::card_header(\n            tags$h4(\"Scatter Plot\")\n          ),\n          mod_scatter_display_ui(\"plot\"),\n          bslib::card_footer(\n            tags$blockquote(\n              tags$em(\n                tags$p(\n                  \"The data for this application comes from the \",\n                  tags$a(\"Building web applications with Shiny\",\n                    href = \"https://rstudio-education.github.io/shiny-course/\"\n                  ),\n                  \"tutorial\"\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n}\n\n\n\n1\n\nPrefix (or folder name) of installed location\n\n\n2\n\nPath to installed package files\n\n\n3\n\nReference to installed package image file\n\n\n\n\nThe application includes the image file after loading, documenting, and installing our package:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlibrary(sap)\nlaunch_app(run = 'p')\n\n\n\n\n\n\n\n\ninst/www accessible with addResourcePath()\n\n\nWe can also use inst/ to store alternate image files and configure the UI to display a different layout. This method ensures our app has the exact same functionality, but a different UI layout.6\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nbslib is a dependency of shiny, so we don’t need to import this with usethis::use_package() (see output from pak::pkg_deps_tree('shiny') below)\nshiny 1.9.1 ✨                                                             \n├─httpuv 1.6.15 ✨🔧\n│ ├─later 1.3.2 ✨🔧\n│ │ ├─Rcpp 1.0.13 ✨🔧\n│ │ └─rlang 1.1.4 ✨🔧\n│ ├─promises 1.3.0 ✨🔧\n│ │ ├─fastmap 1.2.0 ✨🔧\n│ │ ├─later\n│ │ ├─magrittr 2.0.3 ✨🔧\n│ │ ├─R6 2.5.1 ✨\n│ │ ├─Rcpp\n│ │ └─rlang\n│ ├─R6\n│ └─Rcpp\n├─mime 0.12 ✨🔧\n├─jsonlite 1.8.8 ✨🔧\n├─xtable 1.8-4 ✨\n├─fontawesome 0.5.2 ✨\n│ ├─rlang\n│ └─htmltools 0.5.8.1 ✨🔧\n│   ├─base64enc 0.1-3 ✨🔧\n│   ├─digest 0.6.36 ✨🔧\n│   ├─fastmap\n│   └─rlang\n├─htmltools\n├─R6\n├─sourcetools 0.1.7-1 ✨🔧\n├─later\n├─promises\n├─crayon 1.5.3 ✨\n├─rlang\n├─fastmap\n├─withr 3.0.1 ✨\n├─commonmark 1.9.1 ✨🔧\n├─glue 1.7.0 ✨🔧\n├─bslib 0.8.0 ✨\n│ ├─base64enc\n│ ├─cachem 1.1.0 ✨🔧\n│ │ ├─rlang\n│ │ └─fastmap\n│ ├─fastmap\n│ ├─htmltools\n│ ├─jquerylib 0.1.4 ✨\n│ │ └─htmltools\n│ ├─jsonlite\n│ ├─lifecycle 1.0.4 ✨\n│ │ ├─cli 3.6.3 ✨🔧\n│ │ ├─glue\n│ │ └─rlang\n│ ├─memoise 2.0.1 ✨\n│ │ ├─rlang\n│ │ └─cachem\n│ ├─mime\n│ ├─rlang\n│ └─sass 0.4.9 ✨🔧\n│   ├─fs 1.6.4 ✨🔧\n│   ├─rlang\n│   ├─htmltools\n│   ├─R6\n│   └─rappdirs 0.3.3 ✨🔧\n├─cachem\n└─lifecycle\n\nKey:  ✨ new | 🔧 compile\n\n\n\n\nThe updated movies_ui() function below has an optional bslib argument that will change the layout an display an alternate image (stored in inst/www/bootstrap.png).\n\n\nshow/hide updated movies_ui()\n#' User Interface for the Movies Review Application\n#'\n#' Creates the user interface (UI) for the Movies Review application, which\n#' allows users to create customizable scatter plots based on movie data.\n#' \n#' @param bslib View bslib logo?\n#'\n#' @return A Shiny `tagList` object containing the UI elements.\n#'\n#' @section Details:\n#' The interface is built using [`bslib`](https://rstudio.github.io/bslib/)\n#' - **Page (fillable)**: [`bslib::page_fillable()`](https://rstudio.github.io/bslib/reference/page_fillable.html)\n#'   displays the app title.\n#' - **Sidebar**: [`bslib::layout_sidebar()`](https://rstudio.github.io/bslib/reference/sidebar.html)\n#'   includes a logo and the variable\n#'   selection module.\n#'   ([`mod_var_input_ui`]).\n#' - **Card**: [`bslib::card()`](https://rstudio.github.io/bslib/reference/card.html)\n#'   displays the scatter plot module\n#'   ([`mod_scatter_display_ui`]).\n#'\n#' @seealso\n#' - [`movies_server()`] for the server logic of the app.\n#' - [`mod_var_input_ui()`] and [`mod_scatter_display_ui()`] for the modules\n#'   included in the UI.\n#'\n#' @family **Application Components**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(ui = movies_ui(), server = movies_server)\n#' }\n#'\n#' @export\nmovies_ui &lt;- function(bslib = FALSE) {\n1  addResourcePath(\n    prefix = 'www', \n    directoryPath = system.file('www', package = 'sap'))\n  if (isFALSE(bslib)) {\n2  tagList(\n    bslib::page_fillable(\n      h1(\"Movie Reviews\"),\n      bslib::layout_sidebar(\n        sidebar =\n          bslib::sidebar(\n            title = tags$h4(\"Sidebar inputs\"),\n            img(\n              src = \"www/shiny.png\",\n              height = 60,\n              width = 55,\n              style = \"margin:10px 10px\"\n            ),\n            mod_var_input_ui(\"vars\")\n          ),\n        bslib::card(\n          full_screen = TRUE,\n          bslib::card_header(\n            tags$h4(\"Scatter Plot\")\n          ),\n          bslib::card_body(fillable = TRUE,\n            mod_scatter_display_ui(\"plot\")\n          ),\n          bslib::card_footer(\n            tags$blockquote(\n              tags$em(\n                tags$p(\n                  \"The data for this application comes from the \",\n                  tags$a(\"Building web applications with Shiny\",\n                    href = \"https://rstudio-education.github.io/shiny-course/\"\n                  ),\n                  \"tutorial\"\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n  } else {\n3    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            open = TRUE,\n            mod_var_input_ui(\"vars\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n                bslib::card_header(\n4                  img(src = \"www/bootstrap.png\",\n                  height = 80,\n                  width = 100,\n                  style = \"margin:10px 10px\")\n              ),\n             bslib::card_body(fillable = TRUE,\n                 mod_scatter_display_ui(\"plot\")\n            )\n          )\n        )\n      )\n    )\n  }\n} \n\n\n\n1\n\nInclude inst/www resources\n\n\n2\n\nOriginal bslib layout\n\n\n3\n\nNew bslib layout\n\n\n4\n\nReference to alternate image (in inst/www/bootstrap.png)\n\n\n\n\nThe new bslib argument in our updated moves_ui() function toggles between the two UI options. We should also add an app argument to launch_app() to handle the two UI options:\n\n\nshow/hide updated launch_app()\n#' Movies app standalone function\n#'\n#' Wrapper function for `shinyApp()`\n#'\n#' @param app which app to run. Options are: \n#'  * `NULL` = the default app (`\"movies\"`)  \n#'  * `\"bslib\"` = Alternative `bslib` layout \n#' @param options arguments to pass to `options()`\n#' @param run where to launch app:\n#'  * `p` = launch in viewer pane\n#'  * `b` = launch in external browser\n#'  * `w` = launch in window\n#' @param ... arguments passed to UI\n#'\n#' @return shiny app\n#'\n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n#'\n#' @export\n#' \n#' @import shiny\n#' \nlaunch_app &lt;- function(app = NULL, options = list(), run = \"p\", ...) {\n  \n  if (interactive()) {\n    display_type(run = run)\n  }\n  \n  if (is.null(app)) {\n    app &lt;- \"movies\"\n  }\n  \n  if (app == \"bslib\") {\n    shinyApp(\n      ui = movies_ui(bslib = TRUE),\n      server = movies_server,\n      options = options\n    )\n  } else {\n    shinyApp(\n      ui = movies_ui(...),\n      server = movies_server,\n      options = options\n    )\n  }\n}\n\n\nNow we can load, document, and build the package and confirm app = \"bslib\" works:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlaunch_app(app = 'bslib')\n\nThis alternate version of launch_app() uses the same modules and utility functions as the previous versions but when app = \"bslib\", the app displays the alternate UI layout:\n\n\n\n\n\n\n\ninst/www/bootstrap.png image from movies_ui()\n\n\nThe inst/ folder is a versatile tool for storing various files needed in our application (logos or images, CSS styling, JavaScript functions, HTML, etc.). The example above was simple, but using inst/ to hold resources for alternate UIs that can be displayed with a single argument is handy for demoing versions for stakeholders.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#sec-resources-data-files",
    "href": "resources.html#sec-resources-data-files",
    "title": "9  Resources",
    "section": "9.2 Data files",
    "text": "9.2 Data files\nIt is not uncommon to develop an application that can handle data from multiple sources. In these situations, we can sometimes store the alternative data files in the inst/ folder.7\n\n9.2.1 A tidy-movies app\nWe’ll create an alternative application in sap that uses a tidy version of the ggplot2movies data, which we create using a function stored in the data-raw/tidy_movies.R file.8\nWe can place the application modules, UI, and server functions in inst/tidy-movies/R:\n\n1inst/tidy-movies/\n            ├── R \n2            │   ├── devServer.R\n            │   ├── devUI.R # \n            │   ├── dev_mod_scatter.R  \n            │   └── dev_mod_vars.R\n3            ├── app.R\n4            ├── imdb.png\n5            └── tidy_movies.fst\n\n2 directories, 7 files\n\n\n1\n\nTidy movies app folder\n\n\n2\n\nApp ui, server, and modules\n\n\n3\n\nLaunch tidy-movies app\n\n4\n\nAlternate image/logo\n\n\n5\n\nAlternate data\n\n\n\n\nAll of the functions from sap are available in the tidy-movies/ app with explicit namespacing (i.e., sap::fun()):\n\ndev_mod_vars_ui() contains choices for the columns in the tidy_movies data, but there’s no need to rewrite the mod_var_input_server() function.9\nThe dev_mode_scatter module functions have been rewritten to add functionality for importing the tidy_movies.fst data file and an option to removing missing values from the graph.\ninst/tidy-data/app.R contains a call to shinyApp() and any other packages we’ll need to launch the application. The data and alternative image file can be placed in the root folder (with the app.R file):\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart LR\n    subgraph R[\"&lt;strong&gt;R/ folder&lt;/strong&gt;\"]\n        subgraph launch[\"launch_app('ggp2')\"]\n            display_type[\"display_type()\"]\n        end\n        mod_var_input_server[\"mod_var_input_server()\"]\n        scatter_plot[\"scatter_plot()\"]\n    end\n    \n    subgraph tidy_movies[\"&lt;strong&gt;tidy-movies/ folder&lt;/strong&gt;\"]\n        subgraph app[\"app.R file\"]\n          subgraph SubR[\"&lt;strong&gt;R/ folder&lt;/strong&gt;\"]\n            devServer[\"devServer()\"]\n            dev_mod_scatter_server[\"dev_mod_scatter_server()\"]\n            devServer -.-&gt;|\"&lt;em&gt;Calls&lt;/em&gt;\"|dev_mod_scatter_server\n            devUI[\"devUI()\"]\n            dev_mod_vars_ui[\"dev_mod_vars_ui()\"]\n            dev_mod_scatter_ui[\"dev_mod_scatter_ui()\"]\n            devUI -.-&gt;|\"&lt;em&gt;Calls&lt;/em&gt;\"|dev_mod_vars_ui & dev_mod_scatter_ui\n            end\n        end\n        data[(\"tidy_movies.fst\")]\n        img[/\"imdb.png\"\\]\n    end\n        \n\n    launch ==&gt; |\"&lt;strong&gt;&lt;code&gt;shinyAppDir()&lt;/code&gt;&lt;/strong&gt;\"|app\n    scatter_plot -.-&gt;|\"&lt;em&gt;Called from&lt;/em&gt;\"|dev_mod_scatter_server\n    mod_var_input_server -.-&gt;|\"&lt;em&gt;Called from&lt;/em&gt;\"|devServer\n\n    %% utility functions\n    style scatter_plot fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    style display_type fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    \n    %% tidy-movies/ \n    style tidy_movies fill:#e8f0f5,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% tidy-movies/R\n    style SubR fill:#f7fafb,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% tidy-movies/R/ files\n    style devUI stroke:#333,stroke-width:1px,rx:6,ry:6\n    style devServer stroke:#333,stroke-width:1px,rx:6,ry:6\n    style dev_mod_scatter_server color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style dev_mod_scatter_ui color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style dev_mod_vars_ui color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    %% files \n    style app fill:#f8f6e7,color:#000\n    style data fill:#f8f6e7,color:#000\n    style img fill:#f8f6e7,color:#000\n\n\n\n Architecture of app functions in inst/tidy-movies/ folder \n\n\n\n\n\n9.2.2 Launching tidy-movies\nFinally, we’ll launch the tidy_movies data app with the app argument in our standalone function. This conditional argument is similar to the app = \"bslib\" option, but we use shinyAppDir() to launch the app stored in inst/tidy-movies (which we locate with system.file()).\n\n\nshow/hide R/launch_app.R\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#' \n#' @param app which app to run. Options are:\n#'  * `NULL` = the default app (`\"movies\"`)  \n#'  * `\"bslib\"` = Alternative `bslib` layout \n#'  * `\"ggp2\"` = `ggplot2movies` (tidy) data app.\n#' @param options arguments to pass to `options()`\n#' @param run where to launch app:\n#'  * `p` = launch in viewer pane\n#'  * `b` = launch in external browser\n#'  * `w` = launch in window\n#' @param ... arguments passed to UI \n#'\n#' @return A **Shiny application** object.\n#'\n#' @section Details:\n#' The application uses:\n#' - **UI**: Defined in [`movies_ui()`].\n#' - **Server Logic**: Defined in [`movies_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the user interface.\n#' - [`movies_server()`] for the server logic.\n#'\n#' @family **Standalone Application**\n#' \n#' @details\n#' See the [ggplot2movies](https://github.com/hadley/ggplot2movies) package.\n#' \n#'\n#' @examples\n#' if (interactive()) {\n#'   launch_app()\n#' }\n#'\n#' @export\n#' \n#' @import shiny\n#' \nlaunch_app &lt;- function(app = NULL, options = list(), run = \"p\", ...) {\n  \n  if (interactive()) {\n    display_type(run = run)\n  }\n  \n  if (is.null(app)) {\n    app &lt;- \"movies\"\n  }\n  \n  if (app == \"bslib\") {\n    shinyApp(\n      ui = movies_ui(bslib = TRUE),\n      server = movies_server,\n      options = options\n    )\n  } else if (app == \"ggp2\") {\n      shinyAppDir(\n        appDir = system.file(\"tidy-movies\",\n          package = \"sap\"\n      ),\n      options = options\n      )\n  } else {\n    shinyApp(\n      ui = movies_ui(...),\n      server = movies_server,\n      options = options\n    )\n  }\n}\n\n\n\nAfter loading, documenting, and installing, we’ll run the tidy ggplot2movies::movies data app:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlaunch_app(app = 'ggp2')\n\n\n\n\n\n\n\n\ninst/tidy-movies/ app with dev_movies_ui()\n\n\n\n\n\n\n\n\nUsing colors and themes\n\n\n\n\n\n\nUsing different colors and themes for alternative applications can be a quick and easy way to differentiate the versions of your application.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#sec-resources-inst-quarto",
    "href": "resources.html#sec-resources-inst-quarto",
    "title": "9  Resources",
    "section": "9.3 Quarto apps",
    "text": "9.3 Quarto apps\nShiny apps can also be built inside Quarto documents, in which case we could also use the inst/ folder to store and load resources (images, CSS, etc.).\nThe inst/quarto/ folder contains a Quarto version of our movies app:\n\ninst/quarto\n├── _quarto.yml\n├── index.qmd\n└── www\n    ├── quarto.png\n    └── styles.scss\n\n1 directory, 4 files\n\nThe _quarto.yml file contains project metadata for the app10, and the www/ folder contains an image file and a CSS file.\ntitle: \"Quarto Movies App\"\n\nformat:\n  html:\n    embed-resources: true\n\n9.3.1 Shiny documents\nIn index.qmd, we can specify server: shiny in the YAML header to let Quarto know we want the document to be interactive:\n\n---\ntitle: Quarto Movies App\nformat:\n  html:\n    page-layout: full\n    embed-resources: true\n    theme:\n      - united\n      - www/styles.scss\n    \nserver: shiny\n---\n\nThe other options we’ve included in our YAML header are page-layout (for customizing the layout of each element), embed-resources (to create a standalone HTML document), and theme (we’re using a Bootstrap 5 theme with custom CSS).\nTo set up our Quarto/Shiny app, we should include a code chunk with context: setup near the top of the document. We can use the image files in inst/quarto/www by adding a call to addResourcePath() in the setup chunk:\n\n```{r}\n1#| context: setup\n2library(sap)\nlibrary(thematic)\nlibrary(ragg)\n3addResourcePath(\n    prefix = 'quarto',\n    directoryPath = system.file('www', package = 'sap'))\n4options(shiny.useragg = TRUE)\n5thematic::thematic_set_theme(\n  theme = thematic::thematic_theme(\n    bg = \"#070d35\", \n    fg = \"#FFFFFF\", \n    sequential = NA, \n    accent = \"#2ee3a4\"))\n```\n\n1\n\nsetup for HTML document\n\n2\n\npackages (including our app-package)\n\n3\n\nresources (including CSS)\n\n4\n\noptions (for images)\n\n5\n\ntheme from thematic\n\n\n\nNote the context: setup chunk includes options and themes (I’m using the thematic package to set a theme for the ggplot2 graph in our app).\nUsing page-layout: full in the YAML header lets us use a variety of panel options for each code chunk. For example, we’ll place the variable input module in a code chunk with the input option,11 the display module with the center option,12 and the data/Quarto attribution in the fill option.13\n\n```{r}\n1#| panel: input\nmod_var_input_ui(\"vars\")\n```\n\n```{r}\n2#| panel: center\nmod_scatter_display_ui(\"plot\")\n```\n\n```{r}\n3#| panel: fill\ntags$br()\ntags$em(\n  \"Built using \",\n  tags$a(\n    img(\n      src = \"www/quarto.png\",\n      height = 25,\n      width = 90,\n      style = \"margin:10px 10px\"\n    ),\n    href = \"https://quarto.org/docs/interactive/shiny/\"\n  ),\n  \"and data from the \",\n  tags$a(\"Building web applications with Shiny\", \n    href = \"https://rstudio-education.github.io/shiny-course/\"),\n  \"tutorial.\"\n)\n```\n\n1\n\nHorizontal input panel\n\n\n2\n\nCenter the graph display\n\n\n3\n\nData/Quarto attribute with hyperlinks across bottom of app\n\n\n\nThe context: setup and panel option code chunks will execute when the document is rendered. However, any code chunk with context: server will execute when the document is served (not when it is rendered).14\n\n```{r}\n#| context: server\n\nselected_vars &lt;- mod_var_input_server(\"vars\")\n\nmod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n\n```\n\nThese chunks are run in separate R sessions, meaning we cannot access variables created in the first chunk within the second and vice versa (similar to to the movies_ui(), and movies_server.R()).\nTo render our Quarto Shiny app, we can use the Run Document/Preview button or running the following commands in the Terminal:\nquarto serve /&lt;path&gt;/&lt;to&gt;/sap/inst/quarto/index.qmd\n\n\n\n\n\n\n\nMovies Quarto Shiny App\n\n\nWe can also launch the quarto app using the following R commands:\n\nquarto::quarto_preview(\n  file = system.file(\"quarto\", \"index.qmd\", \n                     package = \"sap\"),\n  render = \"all\",\n  browse = utils::browseURL,\n  watch = TRUE\n)\n\n\n\n9.3.2 Launching inst/quarto\nTo launch our Quarto application from inst/quarto, we’ll change the app argument again in launch_app():\n\n\nshow/hide launch_app()\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#' \n#' @param app which app to run. Options are:\n#'  * `NULL` = the default app (`\"movies\"`)  \n#'  * `\"bslib\"` = Alternative `bslib` layout \n#'  * `\"ggp2\"` = `ggplot2movies` (tidy) data app.\n#'  * `\"quarto\"` = Quarto movies app.\n#' @param options arguments to pass to `options()`\n#' @param run where to launch app:\n#'  * `p` = launch in viewer pane\n#'  * `b` = launch in external browser\n#'  * `w` = launch in window\n#' @param ... arguments passed to UI \n#'\n#' @return A **Shiny application** object.\n#'\n#' @section Details:\n#' The application uses:\n#' - **UI**: Defined in [`movies_ui()`].\n#' - **Server Logic**: Defined in [`movies_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the user interface.\n#' - [`movies_server()`] for the server logic.\n#'\n#' @family **Standalone Application**\n#' \n#' @details\n#' See the [ggplot2movies](https://github.com/hadley/ggplot2movies) package.\n#' \n#'\n#' @examples\n#' if (interactive()) {\n#'   launch_app()\n#' }\n#' \n#' @export\n#' \n#' @import shiny\n#' \nlaunch_app &lt;- function(app, options = list(), run = \"p\", ...) {\n  \n  if (interactive()) {\n    display_type(run = run)\n  }\n  \n  if (is.null(app)) {\n    app &lt;- \"movies\"\n  }\n  \n  if (app == \"bslib\") {\n    shinyApp(\n      ui = movies_ui(bslib = TRUE),\n      server = movies_server,\n      options = options\n    )\n  } else if (app == \"ggp2\") {\n      shinyAppDir(\n        appDir = system.file(\"tidy-movies\",\n          package = \"sap\"\n      ),\n      options = options\n      )\n  } else if (app == \"quarto\") {\n      quarto::quarto_preview(\n        system.file(\"quarto\", \"index.qmd\",\n            package = \"sap\" ), \n        render = \"all\")\n  } else {\n    shinyApp(\n      ui = movies_ui(...),\n      server = movies_server,\n      options = options\n    )\n  }\n}\n\n\nNow we can load, document, and build the package:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nLaunching the application now just requires a single argument:\n\nlaunch_app(app = \"quarto\")",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#sec-resources-inst-prod",
    "href": "resources.html#sec-resources-inst-prod",
    "title": "9  Resources",
    "section": "9.4 Production",
    "text": "9.4 Production\nFinally, it’s also possible to have a folder dedicated for deploying a production version of our application from our app-package. I recommend naming this folder something like inst/prod/ or inst/deploy, and it can contain a version of your application that’s ‘fit for public consumption.’ In inst/prod/app I’ve created an app.R file:\n\ninst/\n  └── prod/\n      └── app\n          └── app.R\n          \n2 directories, 1 file\n\n\n9.4.1 prod/app/app.R\napp.R includes a call to launch_app() with the app and options arguments:\n\n\nshow/hide prod/app/app.R\nlibrary(sap)\nlaunch_app(app = \"bslib\", options = list(test.mode = FALSE))\n\n\nI’ll use the \"bslib\" version from above to differentiate it from the other applications in sap.\n\n\n9.4.2 Deploying inst/prod/\nBack in the our app.R file, we’ll use shinyAppDir() and system.file() to return the app object from prod/app/app.R:\n\n\nshow/hide app.R\n1withr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        library(sap)\n      },\n      error = function(e) {\n        pkgload::load_all()\n      }\n    )\n2    shinyAppDir(appDir = system.file(\"prod/app\", package = \"sap\"))\n  } else {\n    pkgload::load_all()\n  }\n  launch_app(options = list(test.mode = FALSE), run = 'p')\n})\n\n\n\n1\n\nSet option to turn off loadSupport()\n\n2\n\nCreate shiny object from prod/app\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nTo deploy the app, call rsconnect::deployApp() in the console and supply an appName:\n\nrsconnect::deployApp(appName = 'movie-reviews-prod')\n\nThe deployment log will look something like this:\n── Preparing for deployment ─────────────────────────────────────────────────\n✔ Deploying \"movie-reviews-prod\" using \"server: shinyapps.io / username: &lt;username&gt;\"\nℹ Creating application on server...\n✔ Created application with id 12711883\nℹ Bundling 39 files: .Rbuildignore, app.R, data/movies.rda, data/movies.RData,\ndata-raw/tidy_movies.R, DESCRIPTION, inst/tidy-data/app.R, inst/tidy-data/imdb.png,\ninst/tidy-data/R/dev_mod_scatter.R, inst/tidy-data/R/dev_mod_vars.R, \ninst/tidy-data/R/devServer.R, inst/tidy-data/R/devUI.R, \ninst/tidy-data/tidy_movies.fst, inst/extdata/movies.fst, inst/prod/app/app.R, \ninst/www/bootstrap.png, inst/www/shiny.png, man/display_type.Rd, …, \nR/scatter_plot.R, and README.md\nℹ Capturing R dependencies with renv\n✔ Found 69 dependencies\n✔ Created 1,568,327b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 9101312\n── Deploying to server ────────────────────────────────────────────────────────\nWaiting for task: 1457289827\n  building: Processing bundle: 9101312\n  building: Building image: 11074678\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 11074678\n  deploying: Starting instances\n  success: Stopping old instances\n── Deployment complete ───────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://&lt;username&gt;.shinyapps.io/movie-reviews-prod/&gt;\nYou can see a deployed version of this application here",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#recap",
    "href": "resources.html#recap",
    "title": "9  Resources",
    "section": "Recap",
    "text": "Recap\n\n\nLaunch app with the shinypak package:\n\nlaunch('09_inst')\n\nThis chapter had covered how to include external files and resources (i.e., what was previously stored in the www/ folder of a regular Shiny app project) in your app-package with addResourcePath() and system.file().\nWe’ve also covered how to use the inst/ folder to include alternative files, development and production/deployment versions of your app. You can now launch the following applications from sap:\nStandard application with/without test mode\n\nlibrary(sap)\nlaunch_app(options = list(test.mode = TRUE))\n# or \nlaunch_app(options = list(test.mode = FALSE))\n\ninst/bslib: an application with an alternative layout (with/without test mode)\n\nlibrary(sap)\nlaunch_app(app = \"bslib\", options = list(test.mode = TRUE))\n# or \nlaunch_app(app = \"bslib\", options = list(test.mode = FALSE)) \n\ninst/tidy-data: an application using a ‘development’ dataset (with/without test mode)\n\nlibrary(sap)\nlaunch_app(app = \"ggp2\", options = list(test.mode = TRUE))\n# or \nlaunch_app(app = \"ggp2\", options = list(test.mode = FALSE))\n\ninst/prod: An app.R file for launching a ‘production’ version of our app.\n\nlibrary(sap)\nrsconnect::deployApp(appName = 'movie-reviews-prod')\n\nIn the next section, we’re going to cover testing the code in a shiny app-package.\n\n\n\n\n\n\nRecap: inst & www folders\n\n\n\n\n\n\n\ninst/: the inst/ folder is installed with your app-package and will be accessible to users, so it’s a great location for files you want contained in your app, but don’t fit into the standard R package structure.\n\ninst/ is also a great location for alternative versions of applications (i.e., inst/app/dev or inst/app/prod/).\n\nsystem.file(): constructs a path to files or folders within installed packages and is especially useful when working with external datasets (i.e., inst/extdata/) or other external resources included with your app-package (i.e., inst/www/).\nwww: used for external static resources in shiny apps. shiny will automatically serve files under the www/ directory, but in app-packages we need to explicitly set this location with shiny::addResourcePath()\naddResourcePath(): create a prefix (i.e., path) for a directoryPath of static files to accessible in shiny’s web server:\n# file location\ninst/\n  └── www/\n        └── shiny.png\n# add path to app \naddResourcePath(prefix = 'www', \n                directoryPath = system.file('www', \n                                package = 'sap'))\n# use path without 'inst/' prefix\nshiny::img(src = 'www/shiny.png')\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#footnotes",
    "href": "resources.html#footnotes",
    "title": "9  Resources",
    "section": "",
    "text": "“The www/ folder is a special one for Shiny. Resources your app may link to, such as images—or in this case, scripts—are placed in the www/ folder. Shiny then knows to make these files available for access from the web browser.” - Shiny documentation↩︎\nThis is a common problem developers encounter when converting shiny app into app-packages. See this popular thread on Posit Community.↩︎\nRead more about sub-directories to avoid in inst/ in R Packages, 2ed.↩︎\nThe key takeaway here is that the inst/ subfolders and files are available unchanged in the installed version (with the inst/ folder omitted.).↩︎\nYou can read more about adding external resources in the documentation for addResourcePath().↩︎\nAs the development of your application progresses, you can (and should) keep different versions of your application in separate Git branches. But I’ve also found using the inst/ folder for those early stages of developing is helpful.↩︎\nWe covered external data in Section 7.4.↩︎\nWe covered the data-raw/ folder in the Data chapter, and you can read more about it here in R packages, 2ed↩︎\nThis requires exporting mod_var_input_server() with @export in the R/ folder.↩︎\nRead more about the _quarto.yml configuration file in the Quarto documentation.↩︎\nThis requires exporting mod_var_input_ui() with @export in the R/ folder.↩︎\nThis requires exporting mod_scatter_display_ui() with @export in the R/ folder.↩︎\nRead more about page-layout in the Quarto documentation↩︎\nThis requires exporting mod_var_input_server() and mod_scatter_display_server() with @export in the R/ folder.↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "debug.html",
    "href": "debug.html",
    "title": "Debug",
    "section": "",
    "text": "Shiny bugs\nExpand the callout boxes below to review what we’ve covered in the last section:\nThis section covers common methods for debugging R code and how we can adapt these methods to use within a Shiny app. So far this book has covered the contents of an R package when it contains a basic, functional Shiny application. Consider the diagram below that illustrates the reactive inputs in our application:\nThe inputs are collected by the variable input module1 and passed to the graph display module (as var_inputs()),2 where they become the reactive inputs() for the graph utility function,3 before finally being rendered.\nAs applications grow in complexity, it’s highly likely you’ll encounter bugs or errors during development. Fortunately, both RStudio  and Positron  come with powerful interactive debuggers, which help us identify, analyze, and fix errors in our code.4\nOur application launches with pre-selected values for the x, y and color graph inputs, along with values for the size and opacity (alpha) of the points. Users can add a title or change the graph inputs, but by having pre-selected values, we guarantee the graph renders when the application launches.\nAny text entered for the title is converted to title case when the variable inputs are passed to the scatter plot display module. The reactives in the application are all updated with the new output:\nIn Shiny apps, debugging can be challenging because the reactive model involves dynamic interactions and a non-linear flow of execution between inputs, reactive expressions, and outputs. Shiny is inherently asynchronous, so bugs can originate from reactive dependencies, execution order, utility functions, hidden states, lazy evaluation, and invalidation (i.e., reactive(), observe(), isolate(), etc.).\nFor example, we could have an incorrectly defined inputIds or outputIds in the UI, which causes our graph utility function to fail. We could also have missing parentheses on reactive values in the server. Finally, the bug could be originating from the output/render point.\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    subgraph Inputs[\"&lt;strong&gt;Inputs&lt;/strong&gt;\"]\n        subgraph Variables[\"Variables\"]\n        var_input[/\"&lt;code&gt;input$x&lt;/code&gt;&lt;br&gt;&lt;code&gt;input$y&lt;/code&gt;&lt;br&gt;&lt;code&gt;input$z&lt;/code&gt;\"/]\n        end\n        subgraph Aesthetics[\"Aesthetics\"]\n        aes_input[/\"&lt;code&gt;input$alpha&lt;/code&gt;&lt;br&gt;&lt;code&gt;input$size&lt;/code&gt;\"/]\n        end\n        subgraph Title[\"Title\"]\n        plot_title[/\"&lt;code&gt;input$plot_title&lt;/code&gt;\"/]\n        end\n    end\n    IDs(\"&lt;code&gt;inputId&lt;/code&gt; or &lt;code&gt;outputId&lt;/code&gt; errors\") --x var_input & aes_input & plot_title\n    subgraph React[\"&lt;strong&gt;App Reactives&lt;/strong&gt;\"]\n        var_inputs&gt;\"&lt;code&gt;var_inputs()&lt;/code&gt; \"]\n        inputs&gt;\"&lt;code&gt;inputs()&lt;/code&gt;\"]\n    end\n    Obs(\"&lt;code&gt;observe&lt;/code&gt; listener&lt;br&gt;errors\") --x React\n    Rxt(\"Reactive context&lt;br&gt;errors\") --x Inputs & React\n    subgraph Output[\"&lt;strong&gt;Output&lt;/strong&gt;\"]\n        output[\\\"&lt;code&gt;output$scatterplot&lt;/code&gt;\"\\]\n    end\n    Rend(\"&lt;code&gt;render_*&lt;/code&gt; function&lt;br&gt;errors\") ----x Output\n\n    var_input & aes_input &lt;==&gt; var_inputs \n    plot_title &lt;-.-&gt; var_inputs \n    var_inputs &lt;==&gt; inputs\n    inputs &lt;==&gt; output\n    \n    style var_input stroke:#333,stroke-width:1px,rx:5,ry:5 \n    style aes_input stroke:#333,stroke-width:1px,rx:5,ry:5\n    style IDs stroke:#333,stroke-width:1px,rx:10,ry:10\n    style Obs stroke:#333,stroke-width:1px,rx:10,ry:10\n    style Rend stroke:#333,stroke-width:1px,rx:10,ry:10\n    style Rxt stroke:#333,stroke-width:1px,rx:10,ry:10\n\n\n Possible locations of bugs in a reactive model\nUnderstanding the interplay of reactivity, lazy evaluation, and asynchronous execution will help us diagnose and resolve bugs in our Shiny app. We have to employ specific strategies and tools to handle Shiny bugs effectively, and some of the traditional debugging approaches can fall short in reactive contexts.",
    "crumbs": [
      "Debug"
    ]
  },
  {
    "objectID": "debug.html#debuggers",
    "href": "debug.html#debuggers",
    "title": "Debug",
    "section": "Debuggers",
    "text": "Debuggers\n10  Debuggers covers the interactive debugger in the Positron  IDE.\n\n10.1 Interactive debugging\n\n10.1.1 Reactive browsing\n\n\n10.2 Example: ggplot2movies app\n\n10.2.1 IDE Changes\n\n10.2.2 Variables and values\n\n10.2.3 Inspecting variables\n\n10.2.4 Inspecting values",
    "crumbs": [
      "Debug"
    ]
  },
  {
    "objectID": "debug.html#print-debugging",
    "href": "debug.html#print-debugging",
    "title": "Debug",
    "section": "Print debugging",
    "text": "Print debugging\n11  Print debugging describes adapting common methods for debugging R code for Shiny applications.\n\n11.1 Exposing variables and values\n\n11.2 Reactive printing\n\n11.3 Reactive values",
    "crumbs": [
      "Debug"
    ]
  },
  {
    "objectID": "debug.html#debugging-apps",
    "href": "debug.html#debugging-apps",
    "title": "Debug",
    "section": "Debugging apps",
    "text": "Debugging apps\n12  Debugging apps dives deeper into debugging modules and the server logic in our app-package.\n\n12.1 Abstract syntax trees\n\n12.2 Debugging modules\n\n12.2.1 Input modules\n\n\n12.3 UI function debugging\n\n12.4 Server function debugging\n\n12.5 Module communication",
    "crumbs": [
      "Debug"
    ]
  },
  {
    "objectID": "debug.html#logging",
    "href": "debug.html#logging",
    "title": "Debug",
    "section": "Logging",
    "text": "Logging\n13  Logging covers using logging to keep track of application and session behaviors.\n\n13.1 Why Use Logging?\n\n13.1.1 App architecture\n13.1.2 Validating inputs\n13.1.3 Handling errors\n13.2 Base R logging\n\n13.2.1 Logging events\n\n\n13.3 Logging with logger\n\n13.3.1 Log levels\n\n13.3.2 Storing log files\n\n13.3.3 Custom logger functions\n\n\n13.4 Logging and debugging\n\n13.4.1 App architecture\n\n\n13.5 Package startup messages",
    "crumbs": [
      "Debug"
    ]
  },
  {
    "objectID": "debug.html#footnotes",
    "href": "debug.html#footnotes",
    "title": "Debug",
    "section": "",
    "text": "Our variable input model is in R/mod_var_input.R.↩︎\nThe graph display module is in R/mod_scatter_display.R.↩︎\nThe graph utility function is in R/scatter_plot.R↩︎\nThe definition in this article from AWS gives a great general overview of debugging.↩︎",
    "crumbs": [
      "Debug"
    ]
  },
  {
    "objectID": "debugger.html",
    "href": "debugger.html",
    "title": "10  Debuggers",
    "section": "",
    "text": "10.1 Interactive debugging\nBugs can cause our app to crash, produce incorrect results or displays, and result in other unexpected behaviors. Fixing bugs in our app-package is an important step to ensure our application continues behaving as expected. This chapter will cover how to use Positron’s  interactive debugger to help us find the root cause of bugs and errors.1\nInteractive debugging (e.g., using browser() or setting a breakpoint) allows us to ‘peek inside’ a function’s scope to view intermediate values/variables and break down the execution line by line.\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n        Start([\"Begin&lt;br&gt;Execution\"])\n        Browser{{\"Breakpoint&lt;br&gt;or &lt;code&gt;browser&lt;/code&gt;?\"}}\n        subgraph Debugger [\"&lt;strong&gt;Debugger&lt;/strong&gt;\"]\n            Step(\"Enter&lt;br&gt;debugger\")\n            Step --&gt; |\"Step Through&lt;br&gt;Code\"|Debug{{\"Done&lt;br&gt;debugging?\"}}\n\n            Debug --&gt;|\"No\"| Step\n            Debug --&gt;|\"Yes\"| Exit(\"Exit&lt;br&gt;debugger\")\n    \n        end\n        Resume([\"Resume&lt;br&gt;Execution\"])\n    \n    Start --&gt; Browser\n    Browser --&gt;|\"Yes\"| Debugger\n    Exit --&gt; Resume\n    Browser --&gt;|\"No\"| Resume\n\n\n Interactive debugger with browser() or breakpoint\nUnfortunately, using browser() and breakpoints are not as straightforward within reactive contexts. browser() interacts with the R interpreter by temporarily suspending execution and redirecting the input to evaluate R expressions in the context of the function or script that called it.\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"14px\"}}}%%\nflowchart TD\n        Running([\"Being&lt;br&gt;execution\"]) \n            subgraph Browse[\"&lt;strong&gt;browser() Scope&lt;/strong&gt;\"]\n                Browser(\"&lt;code&gt;browser()&lt;/code&gt;\")\n                subgraph Debugger[\"&lt;strong&gt;Interactive Debugger&lt;/strong&gt;\"]\n                 Step[\\\"Inspect variables&lt;br&gt;and values\"/]\n                end\n        end\n        Resume([\"Resume&lt;br&gt;execution\"])\n\nRunning --&gt;|\"Encounter\"| Browser --&gt; |\"Enter\"|Step --&gt;|\"Exit\"|Resume\n    \n    %% subgraphs\n    %% style Function fill:#FFF,color:#000,stroke:#333,font-size:14px %%\n    %% style BrowserStep stroke:#4CBB9D,color:#000,stroke-width:3px,rx:10,ry:10,font-size:14px  %%\n    %% style Debugger fill:#F8F8FA,color:#000,stroke:#4CB7DB,stroke-width:3px,rx:10,ry:10,font-size:14px %%\n    \n    %% nodes \n    %% style Running fill:#FFF,color:#000,stroke:#333,rx:10,ry:10,font-size:14px %%\n    %% style Encounter fill:#4CBB9D,color:#FFFFFF,stroke:none,rx:10,ry:10,font-size:14px %%\n    %% style Step1 fill:#4CB7DB,color:#000,stroke:none,rx:15,ry:15,font-size:14px %%\n    %% style Step2 fill:#4CB7DB,color:#000,stroke:none,rx:10,ry:10,font-size:14px %%\n    %% style ExitBrowser fill:#4CBB9D,color:#FFFFFF,stroke:none,rx:20,ry:10,font-size:14px %%\n    %% style Resume fill:#FFF,color:#000,stroke:#333,rx:10,ry:10,font-size:14px %%\n    \n\n\n How browser() works in regular R function\nShiny’s asynchronous execution makes it difficult for browser() to pause the flow of execution, making maintaining an interactive debugging session challenging.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debugger.html#sec-debug-browser",
    "href": "debugger.html#sec-debug-browser",
    "title": "10  Debuggers",
    "section": "",
    "text": "10.1.1 Reactive browsing\nIn a Shiny context, code inside the server function is executed asynchronously in response to user inputs or reactive dependencies. Shiny does not directly expose the control flow to the user, but we want to pause this execution without altering or stopping the reactive flow.\nFortunately, Shiny already has a function that performs this: observe(). Within a Shiny server() function, any call to observe() creates a reactive observer that ‘listens’ for changes to reactive dependencies (and runs any enclosed code whenever those dependencies change).\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"14px\"}}}%%\nflowchart TD\n        Running([\"Being&lt;br&gt;execution\"]) \n        subgraph Observe[\"&lt;strong&gt;observe() Scope&lt;/strong&gt;\"]\n                Observer(\"&lt;code&gt;observe({&lt;br&gt;&lt;br&gt;})&lt;/code&gt;\")\n            subgraph Browse[\"&lt;strong&gt;browser() Scope&lt;/strong&gt;\"]\n                Browser(\"&lt;code&gt;browser()&lt;/code&gt;\")\n                subgraph Debugger[\"&lt;strong&gt;Interactive Debugger&lt;/strong&gt;\"]\n                 Step[\\\"Inspect variables&lt;br&gt;and reactives\"/]\n                end\n            end\n        end\n        Resume([\"Resume&lt;br&gt;execution\"])\n\nRunning --&gt;|\"Encounter\"| Observer --&gt; Browser --&gt; |\"Enter\"|Step --&gt;|\"Exit\"|Resume\n\n    %% style Server fill:#FFF,color:#000,stroke:#333,font-size:14px\n    %% style StartReact fill:#FFF,color:#000,stroke:#333,font-size:14px\n    %% style EndReact fill:#FFF,color:#000,stroke:#333,font-size:14px\n\n    %% style Observer fill:#FFF,stroke:#FEDBC1,stroke-width:3px,font-size:14px\n    %% style ObserveExecution fill:#FEDBC1,stroke:none,rx:10,ry:10,font-size:14px\n    \n    %% style Browser fill:#4CBB9D,color:#000,stroke:none,rx:20,ry:10,font-size:14px\n    %% style Browse stroke:#4CBB9D,color:#000,fill:#FFF,stroke-width:3px,rx:10,ry:10,font-size:14px\n    \n    %% style Debugger fill:#F8F8FA,stroke:#4CB7DB,stroke-width:3px,rx:10,ry:10,font-size:14px\n    %% style Step fill:#4CB7DB,stroke:none,rx:10,ry:10\n\n    %% style ExitBrowser fill:#4CBB9D,color:#000,stroke:none,rx:20,ry:10,font-size:14px\n    %% style ExitObserver fill:#FEDBC1,color:#000,stroke:none,rx:20,ry:10,font-size:14px\n\n\n Reactive browser() in an observe()er \n\n\n\nWhen browser() is called from within the observe() scope, the code execution pauses and temporarily suspends the reactive flow so we can inspect the environment (without altering or stopping the reactive flow).",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debugger.html#sec-debugger-example",
    "href": "debugger.html#sec-debugger-example",
    "title": "10  Debuggers",
    "section": "10.2 Example: ggplot2movies app",
    "text": "10.2 Example: ggplot2movies app\nIn the Resources chapter we developed a slight variation of our app with the ggplot2movies data.2 In the following sections we’re going to use the interactive debugger to see the inner workings of the ‘Remove missing’ checkbox.\n\n\n\n\n\n\n\nRemove missing checkbox in ggplot2movies development application (click to enlarge)\n\n\nWe’ll begin by placing the observe() and browser() breakpoint inside the module server function containing the ‘Remove missing’ input (right after the moduleServer() function). We’ll close the observe() scope after the reactive inputs() are created:\n\n\nshow/hide debugging functions in the module server function\ndev_mod_scatter_server &lt;- function(id, var_inputs) {\n  moduleServer(id, function(input, output, session) {\n1    observe({\n2      browser()\n      \n3      all_data &lt;- fst::read_fst(\"tidy_movies.fst\")\n\n4      graph_data &lt;- reactive({\n        if (input$missing) {\n          tidyr::drop_na(data = all_data)\n        } else {\n          all_data\n        }\n      }) |&gt;\n        bindEvent(input$missing)\n\n5      inputs &lt;- reactive({\n        plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = var_inputs()$alpha,\n          size = var_inputs()$size,\n          plot_title = plot_title\n        )\n      })\n    })\n    \n6    observe({\n      output$scatterplot &lt;- renderPlot({\n        plot &lt;- sap::scatter_plot(\n          df = graph_data(),\n          x_var = inputs()$x,\n          y_var = inputs()$y,\n          col_var = inputs()$z,\n          alpha_var = inputs()$alpha,\n          size_var = inputs()$size\n        )\n        plot +\n          ggplot2::labs(\n            title = inputs()$plot_title,\n            x = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$x), \"_\", \" \"),\n            y = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$y), \"_\", \" \")\n          ) +\n          ggplot2::theme_minimal() +\n          ggplot2::theme(legend.position = \"bottom\")\n      })\n    }) |&gt;\n      bindEvent(graph_data(), inputs())\n    \n  })\n}\n\n\n\n1\n\nObserver scope\n\n\n2\n\nCall to browser() (execution paused)\n\n3\n\nRead tidy_movies.fst data\n\n\n4\n\nMissing data checkbox logic\n\n\n5\n\nReactive values from user inputs\n\n6\n\nModule graph code (outside of observe() scope)\n\n\n\n\nThen we’ll load the changes:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nAnd launch the app using:\n\nlaunch_app(app = \"ggp2\")\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('10_debugger')\n\nAs noted above, browser() pauses code execution and activates the interactive debugger mode, allowing us to view objects, execute code, and ‘step through’ the function line-by-line.\n\n10.2.1 IDE Changes\nWhen the app is launched, Positron  alerts us that we’re in debugging mode by making a few changes to the IDE:3\n\nSidebar\n\nThe Run and Debug sidebar menu item is displayed and the footer is highlighted in blue4\n\n\n\n\n\n\n\n\nPositron IDE in debugger mode (click to enlarge)\n\n\n\n\nEditor\nThe dev_mod_scatter.R file in the Editor highlights the browser() function in yellow\n\n\n\n\n\n\n\nDebugger in file Editor (click to enlarge)\n\n\n\n\nConsole\nThe Console tells us browser() was ‘Called from: observe()’ and displays the interactive debugger prompt:\n\n\n\n\n\n\n\nDebugger in file Editor (click to enlarge)\n\n\nobserve() does not inherently pause or interrupt other reactive processes—it just triggers when changes occur within its scope. So when we’re using observe() for debugging, we need to define the context (or scope) for its behavior.\nThe output in the Console tells us the tidy_movies.fst data are downloaded, but our placement suspends the execution of the application before these data are loaded and the graph is rendered in the UI.\n\n\n\n\n\n\n\n\n\nDebugger in Console (click to enlarge)\n\n\n\n\n\n\n\nSuspended ggplot2movies data app (click to enlarge)\n\n\n\n\n\nThe interactive debugger can only access variables and values inside the observe() scope, but this process can be incredibly useful for addressing bugs (and for exploring how an application works). In the next sections, we’ll ‘step through’ the module function to explore how the missing values are removed from the graph.\n\n\n\n10.2.2 Variables and values\nWe want to use the interactive debugger to proceed through the module function until the data object enters the logic for the missing checkbox, and then we can confirm its structure.\n\n\nStep through/execute each line of code by entering n in the Console.\n\nBrowse[1]&gt; n\n\nAs we ‘step through’ the function, Positron’s  Console displays the debug at location, followed by the code line number:\n\n\n\n\n\n\n\nFull path and line number to the file containing our call to browser() (click to enlarge)\n\n\nIn the Editor, the same line of code is highlighted in yellow:\n\n\n\n\n\n\n\nCorresponding line number in Editor (click to enlarge)\n\n\nThe line creating graph_data gives us a hint for how the missing data are removed (i.e., with bindEvent()), but we’ll explore this more in Print debugging.\n\n\n\n\n\n\n\ngraph_data() reactive creation (click to enlarge)\n\n\nUnder Locals in the DEBUG VARIABLES sidebar, we can see all_data is listed as a &lt;data.frame&gt;, and graph_data are listed as a &lt;reactive.event&gt;:\n\n\n\n\n\n\n\nClick to enlarge DEBUG VARIABLES in sidebar\n\n\nIn the next section, we’ll explore these variables (and the reactive inputs).\n\n\n10.2.3 Inspecting variables\nWe can use the Console to evaluate code while the interactive debugger is running. This comes in handy if we want to check the structure of an object inside a module (like all_data).\n\n\n\n\n\n\nBrowse[1]&gt; str(all_data)\n\n\n'data.frame':   58788 obs. of  10 variables:\n$ title      : chr  \"$\" \"$1000 a Touchdown\" ...\n$ year       : int  1971 1939 1941 1996 1975 ...\n$ length     : int  121 71 7 70 71 91 93 25 97 ...\n$ budget     : int  NA NA NA NA NA NA NA NA NA ...\n$ rating     : num  6.4 6 8.2 8.2 3.4 4.3 5.3 ...\n$ votes      : int  348 20 5 6 17 45 200 24 18 51 ...\n$ mpaa       : Factor w/ 5 levels \"G\",\"PG\",\"PG-13\" ...\n$ genre_count: int  2 1 2 1 0 1 2 2 1 0 ...\n$ genres     : chr  \"Comedy, Drama\" \"Comedy\" ...\n$ genre      : Factor w/ 8 levels \"Action\": 6 3 6 ...\n\n\n\nThis gives us an idea of the total rows before missing are removed.\n\n\n10.2.4 Inspecting values\nThe reactive values and inputs can also be viewed in the Console, and we can see graph_data() is ‘bound’ to input$missing with bindEvent(). We can confirm the input$missing value in the Console:\n\n\n\n\n\n\nBrowse[1]&gt; input$missing\n\n\n[1] TRUE\n\n\n\nThis tells us the ‘Remove missing’ checkbox has been selected, and we can verify the missing values have been removed from graph_data():\n\n\n\n\n\n\nBrowse[1]&gt; identical(\n              nrow(tidyr::drop_na(all_data)), \n              nrow(graph_data())\n            )\n\n\n[1] TRUE\n\n\n\nUsing browser() to ‘step through’ an application gives us a better understanding of the ‘order of execution’, and it lets us see how input$missing and bindEvent() work together to remove the missing values with the checkbox.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debugger.html#recap",
    "href": "debugger.html#recap",
    "title": "10  Debuggers",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: Interactive Debuggers\n\n\n\n\n\n\nDuring regular development, an interactive debugger can let us inspect variables and execute the code line-by-line. In Shiny functions, the debugger lets us track the execution of reactive expressions and observers, which allows us to unravel reactivity-related issues that are often difficult to diagnose.\nbrowser() and observe() are powerful tools for debugging our application. Navigating a function using the interactive debugger gives us control over the execution of each line.\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debugger.html#footnotes",
    "href": "debugger.html#footnotes",
    "title": "10  Debuggers",
    "section": "",
    "text": "Debugging in RStudio  is covered in Debugging with the RStudio IDE. Debugging is also covered in Advanced R, 2ed and Mastering Shiny.↩︎\nYou can refresh your memory on the ggplot2movies application in Section 9.2.1.↩︎\nWatch this video to learn more about Positron.↩︎\nPrevious versions of Positron highlighted the footer in red.↩︎",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debug_print.html",
    "href": "debug_print.html",
    "title": "11  Print debugging",
    "section": "",
    "text": "11.1 Exposing variables and values\nIn the previous chapter we covered the interactive debugger in Positron  with browser() and observe(). In this chapter, we’ll explore another commonly used technique for identifying and resolving issues or errors: print debugging.\nPrint debugging uses a simpler approach than the interactive debugger, and it’s well-suited for a variety of development workflows. Print debugging involves inserting a print() (or cat()) statement into the body of a function to output variables, values, or other important information at various points.\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"14px\"}}}%%\nflowchart LR\n    Insert([\"Insert call&lt;br&gt;to &lt;code&gt;print()&lt;/code&gt;&lt;br&gt;\"])\n    Print(\"Encounter&lt;br&gt;&lt;code&gt;print()&lt;/code&gt; or&lt;br&gt;&lt;code&gt;cat()&lt;/code&gt;\")\n    Insert --&gt; Exec\n    Exec(\"Execute&lt;br&gt;function\") --&gt; Print(\"Encounter&lt;br&gt;&lt;code&gt;print()&lt;/code&gt;\")  \n    Print --&gt; Issue{{\"&lt;strong&gt;&lt;em&gt;Output&lt;br&gt;reveals&lt;br&gt;issue?&lt;/em&gt;&lt;/strong&gt;\"}}\n    Issue -- \"Yes\" --&gt; Mod([\"Modify&lt;br&gt;function\"])\n    Issue -- \"No\" --&gt; Insert\n\n\n Print debugging with print() function calls",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_print.html#sec-print-debug-expose-vars",
    "href": "debug_print.html#sec-print-debug-expose-vars",
    "title": "11  Print debugging",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('11_debug-print')",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_print.html#sec-print-debug-observe-cat-print",
    "href": "debug_print.html#sec-print-debug-observe-cat-print",
    "title": "11  Print debugging",
    "section": "11.2 Reactive printing",
    "text": "11.2 Reactive printing\nTo track reactivity, we need to place the print functions in a reactive expression, observer, or event handler. This allows us to see when these values are triggered (and any other values they work with).\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"14px\"}}}%%\nflowchart LR\n        Insert([\"Insert call&lt;br&gt;to &lt;code&gt;print()&lt;/code&gt;\"]) \n        Exec(\"Execute&lt;br&gt;function\") \n        Insert --&gt; Exec --&gt; Print(\"Encounter&lt;br&gt;&lt;code&gt;print()&lt;/code&gt;\") \n        subgraph Reactive[\"Reactive Context\"]\n            Print \n            Issue{{\"&lt;strong&gt;&lt;em&gt;Output&lt;br&gt;reveals&lt;br&gt;issue?&lt;/em&gt;&lt;/strong&gt;\"}}\n            Print --&gt; Issue\n        end\n        Issue -- \"Yes\" --&gt; Mod([\"Modify&lt;br&gt;function\"])\n        Issue -- \"No\" --&gt; Insert\n\n\n Reactive print debugging with print() function calls \n\n\n\nUsing well-placed calls to print() or cat() allows us to display input values, which helps us to understand the inner-workings of our application.\nFor example, placing the code below in the server function of our variable input module will print the selected variables to the console:\n\nmod_var_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n\n1    observe({\n2      cat(\"Selected x, y, and color:\\n\")\n3      print(c('x' = input$x,\n              'y' = input$y, \n              'color' = input$z))\n    }) |&gt;\n4      bindEvent(c(input$x, input$y, input$x))\n    \n    return(\n      reactive({\n        list(\n          \"y\" = input$y,\n          \"x\" = input$x,\n          \"z\" = input$z,\n          \"alpha\" = input$alpha,\n          \"size\" = input$size,\n          \"plot_title\" = input$plot_title\n        )\n      })\n    )\n\n  })\n}\n\n\n1\n\nWrap in observe() to provide reactive context for printing\n\n\n2\n\nPrint message with cat()\n\n3\n\nPrint reactives with print()\n\n\n4\n\nBind this event to print whenever the variable inputs change\n\n\n\n\nAfter running the function, we can view the output in the Console (or log file).\n\n\n\n\n\n\n\nVariables printed to Console (click to enlarge)\n\n\nUnfortunately, print() and cat() can only provide a snapshot of values or variables at the location and time of the print call. This limits their usefulness in exploring the other parts of the environment or interacting with the running application.\nHowever, we can place verbatimTextOutput() in our module UI function:\n\n\nshow/hide updated mod_var_input_ui()\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n1    verbatimTextOutput(ns(\"vars\")),\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n1\n\nPrint the values to the UI\n\n\n\n\nAnd an accompanying renderPrint() in the module server function to print the values in the UI:\n\n\nshow/hide updated mod_var_input_server()\nmod_var_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n\n1    observe({\n2      cat(\"Selected x, y, and color:\\n\")\n3      print(c('x' = input$x,\n              'y' = input$y, \n              'color' = input$z))\n      \n4      output$vars &lt;- renderPrint({\n        list('x' = input$x, \n             'y' = input$y, \n             'color' = input$z) \n      })\n    }) |&gt;\n5      bindEvent(c(input$x, input$y, input$x))\n    \n    return(\n      reactive({\n        list(\n          \"y\" = input$y,\n          \"x\" = input$x,\n          \"z\" = input$z,\n          \"alpha\" = input$alpha,\n          \"size\" = input$size,\n          \"plot_title\" = input$plot_title\n        )\n      })\n    )\n\n  })\n}\n\n\n\n1\n\nReactive context\n\n2\n\nPrint message with cat()\n\n3\n\nPrint to inputs with print()\n\n4\n\nPrint inputs to UI\n\n\n5\n\nBind this event to print whenever the variable inputs change\n\n\n\n\n\n\n\n\n\n\n\nVariables printed to UI (click to enlarge)\n\n\nThis allows us to view the inputs in the UI as they change in the server.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_print.html#sec-print-debug-reactive-values-to-list",
    "href": "debug_print.html#sec-print-debug-reactive-values-to-list",
    "title": "11  Print debugging",
    "section": "11.3 Reactive values",
    "text": "11.3 Reactive values\nA powerful tool for capturing and printing input values in the server is reactiveValuesToList():\n\n1reactiveValuesToList(x = , all.names = )\n\n\n1\n\nI recommend setting all.names to TRUE.\n\n\n\n\nThis function can be used inside server-side code (modules or server functions) to collect all the input values. When placed in the app server function, the function will return the inputs from both modules.\nBelow is an example of using reactiveValuesToList() inside the our app server function:\n\nmovies_server &lt;- function(input, output, session) {\n\n      output$vals &lt;- renderPrint({\n        app_vals &lt;- reactiveValuesToList(x = input, all.names = TRUE)\n        str(app_vals)\n      })\n      \n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\nWe’ll also add the following to the bslib = TRUE section of movies_ui() to print the output of the reactive list to the UI:\n\nmovies_ui &lt;- function(bslib = FALSE) {\n  addResourcePath(\n    prefix = 'www',\n    directoryPath = system.file('www/', package = 'sap'))\n  if (isFALSE(bslib)) {\n    tagList(\n        bslib::page_fillable(\n          h1(\"Movie Reviews\"),\n          bslib::layout_sidebar(\n            sidebar =\n              bslib::sidebar(\n                title = tags$h4(\"Sidebar inputs\"),\n                img(\n                  src = \"www/shiny.png\",\n                  height = 60,\n                  width = 55,\n                  style = \"margin:10px 10px\"\n                ),\n                mod_var_input_ui(\"vars\")\n              ),\n            bslib::card(\n              full_screen = TRUE,\n              bslib::card_header(\n                tags$h4(\"Scatter Plot\")\n              ),\n              bslib::card_body(fillable = TRUE,\n                mod_scatter_display_ui(\"plot\")\n              ),\n              bslib::card_footer(\n                tags$blockquote(\n                  tags$em(\n                    tags$p(\n                      \"The data for this application comes from the \",\n                      tags$a(\"Building web applications with Shiny\",\n                        href = \"https://rstudio-education.github.io/shiny-course/\"\n                      ),\n                      \"tutorial\"\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n  } else {\n    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            mod_var_input_ui(\"vars\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n                bslib::card_header(\n                  tags$img(\n                  src = \"www/bootstrap.png\",\n                  height = 80,\n                  width = 100,\n                  style = \"margin:10px 10px\"\n                )\n              ),\n             bslib::card_body(\n1              verbatimTextOutput(outputId = \"vals\"),\n              mod_scatter_display_ui(\"plot\")\n            )\n          )\n        )\n      )\n    )\n  }\n} \n\n\n1\n\nPrinted reactive value outputs\n\n\n\n\nAfter loading the changes to our package, we can view the application with the captured and printed reactive values:\n\n\n\n\n\n\n\nClick to enlarge\n\n\nNote the difference between the two printed values: the output in the sidebar has been printed from within the module server function, so the input names are contained within that namespace (i.e., x, y, etc.). However, the list returned from reactiveValuesToList() has been placed in the app server function, so we can see the module id appended to the input name (i.e., vars-y, vars-x, etc.).",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_print.html#recap",
    "href": "debug_print.html#recap",
    "title": "11  Print debugging",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: Print Debugging\n\n\n\n\n\n\nThe advantages of print debugging are 1) it’s easy to insert a few lines of code and run the program, 2) it works in any programming environment, even if sophisticated debugging tools aren’t available, and 3) it doesn’t require special configurations or debugging tools.\nHowever, the downside is we can’t pause execution or inspect the app state in real-time. We only can see what we explicitly print, and if we miss a key variable or condition, we have to to insert, remove, or adjust print functions, which can be time-consuming. Excessive print functions can also clutter the code and output especially in large or complex application.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_apps.html",
    "href": "debug_apps.html",
    "title": "12  Debugging apps",
    "section": "",
    "text": "12.1 Abstract syntax trees\nIn the previous chapters we demonstrated how to:\nThis chapter covers using abstract syntax trees to help understand the structure of an application’s modules, and how to use the two previously described debugging methods to understand bugs and errors.\nShiny app-packages can quickly become a complex and intertwined web of functions: utility functions, modules, user interface (UI) elements, server logic, etc. Before we jump into debugging modules, we’ll revisit their function and purpose by considering the following description of namespaces from the NS() function documentation:\nTo visualize the hierarchical relationship between the functions in our app, we’ll use abstract syntax trees (ast()) from the lobstr package.1\nAbstract folder trees can be used to help construct a simplified call stack for applications (especially if we are using multiple utility functions or nested modules).",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-apps-abstract-syntax-trees",
    "href": "debug_apps.html#sec-debug-apps-abstract-syntax-trees",
    "title": "12  Debugging apps",
    "section": "",
    "text": "“a namespace is to an ID as a directory is to a file.”\n\n\n\n\n\n\n\n\nFor example, launch_app() calls the display_type() utility function, then movies_ui() and movies_server():\n\n\n\n█─launch_app \n├─█─display_type \n├─█─movies_ui \n└─█─movies_server \n\n\n\n\n\n\n\n\n\n\nmovies_ui() and movies_server() call their respective UI and server module functions:\n\n\n\n█─launch_app \n├─█─display_type \n├─█─movies_ui \n│ ├─█─mod_var_input_ui \n│ └─█─mod_scatter_display_ui \n└─█─movies_server \n  ├─█─mod_var_input_server \n  └─█─mod_scatter_display_server \n\n\n\n\n\n\n\n\n\n\nAnd mod_scatter_display_server() calls the scatter_plot() utility function:\n\n\n\n█─launch_app \n├─█─display_type \n├─█─movies_ui \n│ ├─█─mod_var_input_ui \n│ └─█─mod_scatter_display_ui \n└─█─movies_server \n  ├─█─mod_var_input_server \n  └─█─mod_scatter_display_server \n    └─█─scatter_plot",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-apps-modules",
    "href": "debug_apps.html#sec-debug-apps-modules",
    "title": "12  Debugging apps",
    "section": "12.2 Debugging modules",
    "text": "12.2 Debugging modules\nIn this branch of sap, the inputs has been split into two separate modules: variable inputs and aesthetic inputs. The variable input module collects and returns the selected columns from the movies data, and the aesthetics input module collects and returns the alpha, point size, and (optional) graph title.\nThis updates our abstract syntax tree to the following:\n\n\n█─launch_app \n├─█─display_type \n├─█─movies_ui \n│ ├─█─mod_var_input_ui \n│ ├─█─mod_aes_input_ui \n│ └─█─mod_scatter_display_ui \n└─█─movies_server \n  ├─█─mod_var_input_server \n  ├─█─mod_aes_input_server \n  └─█─mod_scatter_display_server \n    └─█─scatter_plot \n\n\n\n12.2.1 Input modules\nThe diagram below illustrates the changes to the variable input module.\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    User([\"User\"])\n    mod_var_input_ui[\"&lt;strong&gt;mod_var_input_ui()&lt;/strong&gt;\"]\n    mod_aes_input_ui[\"&lt;strong&gt;mod_aes_input_ui()&lt;/strong&gt;\"]\n    \n    subgraph mod_var_input_server[\"&lt;strong&gt;mod_var_input_server()&lt;/strong&gt;\"]\n        VarReactives[/\"input$x&lt;br&gt;input$y&lt;br&gt;input$z\"/]\n    end\n    subgraph mod_aes_input_server[\"&lt;strong&gt;mod_aes_input_server()&lt;/strong&gt;\"]\n        AesReactives[/\"input$alpha&lt;br&gt;input$size&lt;br&gt;input$plot_title\"/]\n    end\n\n    selected_vars[/\"selected variables\"/]\n    selected_aes[/\"selected aesthetics\"/]\n    \n    User --&gt; |\"&lt;em&gt;Selects X, Y, and Color...&lt;/em&gt;\"|mod_var_input_ui\n    User --&gt; |\"&lt;em&gt;Selects Size, Alpha and optional Title...&lt;/em&gt;\"|mod_aes_input_ui\n    mod_var_input_ui --&gt; |\"&lt;em&gt;Collects&lt;br&gt;variables...&lt;/em&gt;\"|mod_var_input_server\n    mod_aes_input_ui --&gt; |\"&lt;em&gt;Collects aesthetics...&lt;/em&gt;\"|mod_aes_input_server\n    VarReactives --&gt; selected_vars\n    AesReactives --&gt; selected_aes\n    \n    style mod_var_input_ui stroke-width:2px,rx:3,ry:3\n    style mod_aes_input_ui stroke-width:2px,rx:3,ry:3\n    style mod_var_input_server stroke-width:2px,rx:3,ry:3\n    style mod_aes_input_server stroke-width:2px,rx:3,ry:3\n    style VarReactives font-size: 14px\n    style AesReactives font-size: 14px\n\n\n Variable Inputs modules \n\n\n\nmod_var_input_ui(): Our variable input module will now only collect the x, y, and color variables from the movies data.\n\n\nshow/hide R/mod_var_input.R\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    )\n  )\n}\n\nmod_var_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n    \n    return(\n      reactive({\n        list(\n1          \"y\" = input$y,\n2          \"x\" = input$x,\n3          \"z\" = input$z\n        )\n      })\n    )\n\n  })\n}\n\n\n\n1\n\nReturned x axis variable\n\n\n2\n\nReturned y axis variable\n\n\n3\n\nReturned color variable\n\n\n\n\nmod_aes_input_ui(): The new aesthetic input module will collect the alpha, size, and optional plot title values.\n\n\nshow/hide R/mod_aes_input.R\nmod_aes_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"x\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\nmod_aes_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n    \n    return(\n      reactive({\n        list(\n1          \"alpha\" = input$alpha,\n2          \"size\" = input$size,\n3          \"plot_title\" = input$x\n        )\n      })\n    )\n\n  })\n}\n\n\n\n1\n\nReturned alpha aesthetic\n\n\n2\n\nReturned size aesthetic\n\n\n3\n\nReturned plot title\n\n\n\n\nEach module will have a dedicated namespace inside the movies_ui() and movies_server() functions, but this requires a minor adjustment to the mod_scatter_display_server() and movies_server() functions:\nmod_scatter_display_server(): We need to adjust the function arguments and the creation of the inputs() reactive:\n\n\nshow/hide mod_scatter_display_server()\n1mod_scatter_display_server &lt;- function(id, var_inputs, aes_inputs) {\n\n  moduleServer(id, function(input, output, session) {\n\n    inputs &lt;- reactive({\n2      plot_title &lt;- tools::toTitleCase(aes_inputs()$plot_title)\n        list(\n4          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n3          alpha = aes_inputs()$alpha,\n          size = aes_inputs()$size,\n          plot_title = plot_title\n        \n        )\n    })\n    \n    output$scatterplot &lt;- renderPlot({\n      plot &lt;- scatter_plot(\n        # data --------------------\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n            x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n            y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n1\n\nAdd function argument for aesthetics\n\n\n2\n\nOptional title input\n\n\n3\n\nAlpha and size inputs\n\n\n4\n\nVariable reactive inputs\n\n\n\n\nmovies_server(): We now have two reactive variables: the selected_vars and selected_aes:\n\n\nshow/hide\nmovies_server &lt;- function(input, output, session) {\n      \n1      selected_vars &lt;- mod_var_input_server(\"vars\")\n  \n2      selected_aes &lt;- mod_aes_input_server(\"aes\")\n\n      mod_scatter_display_server(\"plot\", \n3                                  var_inputs = selected_vars,\n4                                  aes_inputs = selected_aes)\n      \n}\n\n\n\n1\n\nCollected variable inputs\n\n\n2\n\nCollected aesthetic inputs\n\n\n3\n\nVariable input argument for graph display\n\n\n4\n\nAesthetic input argument for graph display\n\n\n\n\nThe diagram below illustrates the changes to the functions above:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"14px\"}}}%%\nflowchart TD\n    User([\"&lt;strong&gt;User&lt;/strong&gt;\"])\n    mod_var_input_ui[\"&lt;strong&gt;mod_var_input_ui()&lt;/strong&gt;\"]\n    mod_aes_input_ui[\"&lt;strong&gt;mod_aes_input_ui()&lt;/strong&gt;\"]\n    mod_scatter_display_ui[\"&lt;strong&gt;mod_scatter_display_ui&lt;/strong&gt;\"] \n    \n    subgraph mod_scatter_display_server[\"&lt;strong&gt;mod_scatter_display_server()&lt;/strong&gt;\"]\n        var_inputs[\\\"var_inputs\"\\]\n        aes_inputs[\\\"aes_inputs\"\\]\n        inputs[/\"inputs()\"/]\n        scatter_plot(\"scatter_plot()\")\n    end\n    \n    subgraph mod_var_input_server[\"&lt;strong&gt;mod_var_input_server()&lt;/strong&gt;\"]\n        VarReactives[/\"input$x&lt;br&gt;input$y&lt;br&gt;input$z\"/]\n    end\n    subgraph mod_aes_input_server[\"&lt;strong&gt;mod_aes_input_server()&lt;/strong&gt;\"]\n        AesReactives[/\"input$alpha&lt;br&gt;input$size&lt;br&gt;input$plot_title\"/]\n    end\n\n    selected_vars[/\"selected variables\"/]\n    selected_aes[/\"selected aesthetics\"/]\n    \n    User --&gt; |\"&lt;em&gt;Selects X, Y, and Color...&lt;/em&gt;\"|mod_var_input_ui\n    User --&gt; |\"&lt;em&gt;Selects Size, Alpha and optional Title...&lt;/em&gt;\"|mod_aes_input_ui\n    mod_var_input_ui --&gt; |\"&lt;em&gt;Collects&lt;br&gt;variables...&lt;/em&gt;\"|mod_var_input_server\n    mod_aes_input_ui --&gt; |\"&lt;em&gt;Collects aesthetics...&lt;/em&gt;\"|mod_aes_input_server\n    VarReactives ==&gt; selected_vars\n    AesReactives ==&gt; selected_aes\n    selected_vars ==&gt;|\"&lt;em&gt;Input argument for...&lt;/em&gt;\"|var_inputs\n    selected_aes ==&gt;|\"&lt;em&gt;Input argument for...&lt;/em&gt;\"|aes_inputs\n    var_inputs & aes_inputs --&gt; inputs --&gt; scatter_plot\n    scatter_plot --&gt;|\"&lt;em&gt;Renders plot...&lt;/em&gt;\"|mod_scatter_display_ui\n    mod_scatter_display_ui --&gt;|\"&lt;em&gt;Displays output...&lt;/em&gt;\"|Display([\"&lt;strong&gt;Graph&lt;/strong&gt;\"])\n    \n    style User font-size:18px\n    style Display font-size:18px\n\n    style mod_scatter_display_ui fill:#eee,font-size:13px,stroke-width:1px,rx:3,ry:3\n    style mod_scatter_display_server fill:#eee,font-size:13px,stroke-width:1px,rx:3,ry:3\n    style mod_var_input_server fill:#eee,font-size:14px,stroke-width:1px,rx:3,ry:3\n    style mod_var_input_ui fill:#eee,font-size:14px,stroke-width:1px,rx:3,ry:3\n    style mod_aes_input_server fill:#eee,font-size:14px,stroke-width:1px,rx:3,ry:3\n    style mod_aes_input_ui fill:#eee,font-size:14px,stroke-width:1px,rx:3,ry:3\n    \n    style AesReactives fill:#fff,stroke:#bbb,stroke-width:2px\n    style VarReactives fill:#fff,stroke:#bbb,stroke-width:2px\n    style selected_vars fill:#fff,stroke:#000,stroke-width:2px\n    style selected_aes fill:#fff,stroke:#000,stroke-width:2px\n    style var_inputs fill:#fff,stroke:#bbb,stroke-width:2px\n    style aes_inputs fill:#fff,stroke:#bbb,stroke-width:2px\n    style inputs fill:#fff,stroke:#bbb,stroke-width:2px\n\n    style scatter_plot fill:#444,color:#FFF,stroke:#000,stroke-width:2px,rx:10,ry:10\n    \n    style VarReactives font-size: 14px\n    style AesReactives font-size: 14px\n\n\n Variable and aesthetic input modules \n\n\n\nUncoupling the input modules will make it easier to independently modify and debug their corresponding graph elements.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-ui",
    "href": "debug_apps.html#sec-debug-ui",
    "title": "12  Debugging apps",
    "section": "12.3 UI function debugging",
    "text": "12.3 UI function debugging\nIn mod_var_input_ui() and mod_aes_input_ui(), the NS() function is used to encapsulate input IDs within a namespace.\nWe will place a verbatimTextOutput() in both UI module functions:2\n\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n1    strong(\n      code(\"var_input\"),\n      \"module reactive \",\n      code(\"inputs\")\n      ),\n2    verbatimTextOutput(ns(\"vals\"))\n  )\n}\n\n\n1\n\nOptional label\n\n\n2\n\nInclude the ns() for the inputId\n\n\n\n\n\nmod_aes_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"x\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    ),\n1    strong(\n      code(\"aes_input\"),\n      \"module reactive \",\n      code(\"inputs\")\n      ),\n2    verbatimTextOutput(ns(\"vals\"))\n  )\n}\n\n\n1\n\nOptional label\n\n\n2\n\nInclude the ns() for the inputId",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-server",
    "href": "debug_apps.html#sec-debug-server",
    "title": "12  Debugging apps",
    "section": "12.4 Server function debugging",
    "text": "12.4 Server function debugging\nIn the corresponding server functions, we’ll capture the reactive values and print the list using lobstr::tree():3\n\nmod_var_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n\n    observe({\n2      output$vals &lt;- renderPrint({\n1        all_vals &lt;- reactiveValuesToList(input,\n3                                         all.names = TRUE)\n4        lobstr::tree(all_vals)\n      })\n    }) |&gt; \n5      bindEvent(c(input$x, input$y, input$x))\n    \n    return(\n      reactive({\n        list(\n          \"y\" = input$y,\n          \"x\" = input$x,\n          \"z\" = input$z\n        )\n      })\n    )\n\n  })\n}\n\n\n1\n\nCollect reactive values in module\n\n\n2\n\nPrint these values to the UI\n\n\n3\n\nInclude all reactive objects\n\n\n4\n\nVisualize using lobstr::tree()\n\n\n5\n\nBind to inputs\n\n\n\n\n\nmod_aes_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n\n    observe({\n2      output$vals &lt;- renderPrint({\n1        all_vals &lt;- reactiveValuesToList(input,\n3                                         all.names = TRUE)\n4        lobstr::tree(all_vals)\n      })\n    }) |&gt; \n5      bindEvent(c(input$alpha, input$size, input$x))\n    \n    return(\n      reactive({\n        list(\n          \"alpha\" = input$alpha,\n          \"size\" = input$size,\n          \"plot_title\" = input$x\n        )\n      })\n    )\n\n  })\n}\n\n\n1\n\nCollect reactive values in module\n\n\n2\n\nPrint these values to the UI\n\n\n3\n\nInclude all reactive objects\n\n\n4\n\nVisualize using lobstr::tree()\n\n\n5\n\nBind to inputs\n\n\n\n\nWe see the following in the sidebar after loading, documenting, installing and launching our app;\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\n\n\n\n\n\nReactive values for the variable input module:\n\n\n\n\n\n\n\n\n\nReactive values in variable input module\n\n\n\n\n\n\n\n\n\n\n\nReactive values for the aesthetic input module:\n\n\n\n\n\n\n\n\n\nReactive values in aesthetics input module\n\n\n\n\n\nIn the variable and aesthetic module namespaces, NS() ensures all the inputs are unique within the module (even when multiple modules are used in the same application).\n\n&lt;list&gt;\n├─y: \"audience_score\"\n├─x: \"imdb_rating\"\n└─z: \"mpaa_rating\"\n\nYou probably noticed that I’ve renamed the inputId for the plot title to x, but we avoid any namespace collisions because each ID is stored safely within a module.\n\n&lt;list&gt;\n├─alpha: 0.5\n├─size: 2\n└─x: \"\"\n\nThis encapsulation is similar to how a directory provides a distinct context for files, preventing naming conflicts within a file system.\nIf we repeat this method in movies_ui() and movies_server():\n\n\nshow/hide movies_ui()\nmovies_ui &lt;- function(bslib = FALSE) {\n  addResourcePath(\n    prefix = 'www',\n    directoryPath = system.file('www/', package = 'sap'))\n  if (isFALSE(bslib)) {\n    tagList(\n        bslib::page_fillable(\n          h1(\"Movie Reviews\"),\n          bslib::layout_sidebar(\n            sidebar =\n              bslib::sidebar(\n                title = tags$h4(\"Sidebar inputs\"),\n                img(\n                  src = \"www/shiny.png\",\n                  height = 60,\n                  width = 55,\n                  style = \"margin:10px 10px\"\n                ),\n                mod_var_input_ui(\"vars\"),\n                mod_aes_input_ui(\"aes\")\n              ),\n            bslib::card(\n              full_screen = TRUE,\n              bslib::card_header(\n                tags$h4(\"Scatter Plot\")\n              ),\n              bslib::card_body(fillable = TRUE,\n1                strong(\n                  code(\"movies_server()\"),\n                  \"reactive values\"\n                  ),\n                verbatimTextOutput(outputId = \"vals\"),\n                mod_scatter_display_ui(\"plot\")\n              ),\n              bslib::card_footer(\n                tags$blockquote(\n                  tags$em(\n                    tags$p(\n                      \"The data for this application comes from the \",\n                      tags$a(\"Building web applications with Shiny\",\n                        href = \"https://rstudio-education.github.io/shiny-course/\"\n                      ),\n                      \"tutorial\"\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n  } else {\n    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            mod_var_input_ui(\"vars\"),\n            mod_aes_input_ui(\"aes\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n                bslib::card_header(\n                  tags$img(\n                  src = \"www/bootstrap.png\",\n                  height = 80,\n                  width = 100,\n                  style = \"margin:10px 10px\"\n                )\n              ),\n             bslib::card_body(\n2              strong(\n                code(\"movies_server()\"),\n                \"reactive values\"\n                ), \n              verbatimTextOutput(outputId = \"vals\"),\n              mod_scatter_display_ui(\"plot\")\n            )\n          )\n        )\n      )\n    )\n  }\n} \n\n\n\n1\n\nLabel and output for printed reactive values\n\n\n2\n\nLabel and output for printed reactive values (bslib UI option)\n\n\n\n\n\n\nshow/hide movies_server()\nmovies_server &lt;- function(input, output, session) {\n\n2      output$vals &lt;- renderPrint({\n1        app_vals &lt;- reactiveValuesToList(x = input,\n                                      all.names = TRUE)\n3        lobstr::tree(app_vals)\n      })\n      \n      selected_vars &lt;- mod_var_input_server(\"vars\")\n      selected_aes &lt;- mod_aes_input_server(\"aes\")\n\n      mod_scatter_display_server(\"plot\", \n                                  var_inputs = selected_vars, \n                                  aes_inputs = selected_aes)\n}\n\n\n\n1\n\nCapture reactive values\n\n\n2\n\nRender reactive values\n\n\n3\n\nPrint list as folder tree\n\n\n\n\nLoad the package and run the app:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nThe printed output from movies_ui() andmovies_server() is prefixed with the namespace (i.e., vars- or aes-), reflecting the hierarchical organization of the input IDs, much like file paths in a directory structure.\n\n\n\n\n\n\n\nReactive values in movies_ui()\n\n\nBy using reactiveValuesToList() and lobstr::tree() in combination with verbatimTextOutput() and renderPrint(), we are effectively debugging and inspecting the module’s reactive inputs.\n\n&lt;list&gt;\n├─vars-y: \"audience_score\"\n├─vars-x: \"imdb_rating\"\n├─vars-z: \"mpaa_rating\"\n├─aes-alpha: 0.5\n├─aes-size: 2\n└─aes-x: \"\"\n\nCapturing and rendering reactive values in the UI gives us the benefits of print debugging while our Shiny app is running. When it’s combined with observe() and browser(), we can get a direct view of the application state and the program flow at specific execution points.\n\n\nLaunch app with the shinypak package:\n\nlaunch('12.1_debug-mods')",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-apps-module-comms",
    "href": "debug_apps.html#sec-debug-apps-module-comms",
    "title": "12  Debugging apps",
    "section": "12.5 Module communication",
    "text": "12.5 Module communication\nWhen we load, document, install and view the application in this branch we find an error with the graph display:\n\n\n\n\n\n\n\nError in graph display\n\n\nThe call stack (printed to the Console) displays the following information:\n\nWarning: Error in tools::toTitleCase: 'text' must be a character vector\n  208: stop\n  207: tools::toTitleCase\n  206: &lt;reactive&gt;\n  204: .func\n  201: contextFunc\n  200: env$runWith\n  189: ctx$run\n  188: self$.updateValue\n  186: inputs\n  178: renderPlot\n  176: func\n  136: drawPlot\n  122: &lt;reactive:plotObj&gt;\n  102: drawReactive\n   89: renderFunc\n   88: output$plot-scatterplot\n    3: runApp\n    2: print.shiny.appobj\n    1: &lt;Anonymous&gt;\n\nThe output in the Console is helpful (we know the error is coming from the tools::toTitleCase() function), but we need to narrow it down because we’re using this function in multiple places.\nTo use the interactive debugger, we’ll add browser() and observe() in the movies_server() function to capture the behaviors of both the variables and aesthetics modules:\n\nmovies_server &lt;- function(input, output, session) {\n\n      output$vals &lt;- renderPrint({\n        app_vals &lt;- reactiveValuesToList(x = input, all.names = TRUE)\n        lobstr::tree(app_vals)\n      })\n1      observe({\n2        browser()\n      \n      selected_vars &lt;- mod_var_input_server(\"vars\")\n  \n      selected_aes &lt;- mod_aes_input_server(\"aes\")\n\n      mod_scatter_display_server(\"plot\", \n                                  var_inputs = selected_vars, \n                                  aes_inputs = selected_aes)\n        \n    })\n      \n}\n\n\n1\n\nObserver scope\n\n\n2\n\nActivate debugger\n\n\n\n\nThen we’ll load, document, install and launch the app:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nThe application launches, but browser() pauses the execution of the modules and activates the IDE’s debugger. This allows us to view the objects that are available in movies_server() before the variables are passed to the graph rendering functions.\nWe’ll proceed with the interactive debugger until both selected_vars and selected_aes are returned from the input modules:\n\nBrowse[1]&gt; n\nBrowse[1]&gt; n\nBrowse[1]&gt; n\n\n\n\n\n\n\n\n\nReactive inputs returned from modules\n\n\nThis tells us both objects are returned from their respective module server functions. But we should pause and examine the structure of selected_aes:\n\nBrowse[1]&gt; str(selected_aes)\n\nfunction ()  \n - attr(*, \"observable\")=Classes 'Observable', 'R6' reactive({\n    list(alpha = input$alpha, size = input$size, plot_title = input$x)\n}) \n - attr(*, \"cacheHint\")=List of 1\n  ..$ userExpr: language {  list(alpha = input$alpha, size = input$size, \n      plot_title = input$x) }\n - attr(*, \"class\")= chr [1:3] \"reactiveExpr\" \"reactive\" \"function\"\nThe output above display selected_vars the method, not the selected input values. To view these, we need to include the parentheses:\n\nBrowse[1]&gt; str(selected_aes())\n\nList of 3\n $ alpha     : num 0.5\n $ size      : int 2\n $ plot_title: chr \"\"\nThis confirms that the UI values are being collected by the aesthetic input module and stored in selected_aes, so the error must be coming from inside one of the modules.\n\n\n\n\n\n\nWe’ve inspected the values in the exchange between movies_ui() and movies_server():\n\n\n\n█─launch_app \n├─█─movies_ui \n└─█─movies_server \n\n\n\n\nWe’ll remove (or comment out) the calls to observe() and browser() from movies_server() and repeat a similar process in mod_scatter_display_server(), but include the calls to observe() and browser() after moduleServer().\n\nmod_scatter_display_server &lt;- function(id, var_inputs, aes_inputs) {\n\n  moduleServer(id, function(input, output, session) {\n\n1    observe({\n      browser()\n\n    inputs &lt;- reactive({\n      plot_title &lt;- tools::toTitleCase(aes_inputs()$x)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = aes_inputs()$alpha,\n          size = aes_inputs()$size,\n          plot_title = plot_title\n        \n        )\n    })\n    \n    output$scatterplot &lt;- renderPlot({\n      plot &lt;- scatter_plot(\n        # data --------------------\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n            x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n            y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n      \n    })\n\n  })\n\n}\n\n\n1\n\nWrap browser() in observe() and place after the call to moduleServer()\n\n\n\n\nThen we’ll load, document, and install the package and run the application again:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvance the debugger to the line after inputs() is created with var_inputs() and aes_inputs() (the line with output$scatterplot should be highlighted).\n\n\n\n\n\n\n\n\n\ninputs() reactive created in mod_scatter_display_server()\n\n\n\n\n\n\n\n\n\n\n\nWe can see the input()$plot_title appears to be a character, but the structure of inputs() returns the error we saw in the Console\n\n\n\n\n\n\n\n\n\nError in graph inputs()\n\n\n\n\n\n\n12.5.1 Verifying inputs\nNow that we’ve isolated the error to the tools::toTitleCase() call in the creation of the inputs() reactive. We can confirm this in the interactive debugger:\nBrowse[1]&gt; tools::toTitleCase(aes_inputs()$x)\nError in tools::toTitleCase(aes_inputs()$x) : \n  'text' must be a character vector\nUpon further inspection, we discover the source of the error:\n\n\n\n\n\n\nBug\n\n\nFix\n\n\n\n\n\n\n\n\n\ntools::toTitleCase(aes_inputs()$x)\n\n\ntools::toTitleCase(aes_inputs()$plot_title)\n\n\n\nThe approach above have shown us 1) all modules are communicating properly, and 2) where to make changes in the scatter plot display module to render the graph.\n\n\n\n\n\n\n\nModule communication\n\n\nI’ve reverted the code to display the error in this branch so it’s easier to follow along. Each of the apps in the inst/ folder have also been updated, and I encourage you to explore how the bug effects launching each app structure.\n\n\n\n\n\n\nDebugging Apps\n\n\n\n\n\n\nThe Shiny documentation also has a list of methods for debugging apps, and learning how to read call stacks (or a stacktrace) will help you debug your shiny app.4, 5\n\n\n\n\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('12.2_debug-mods')",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#footnotes",
    "href": "debug_apps.html#footnotes",
    "title": "12  Debugging apps",
    "section": "",
    "text": "Create abstract syntax trees with the ast() function and read the Code is a tree section in Advanced R, 2ed.↩︎\nWe covered using reactiveValuesToList(), renderPrint() and verbatimTextOutput() in Section 11.3.↩︎\nWe covered using reactiveValuesToList(), renderPrint() and verbatimTextOutput() in Section 11.3.↩︎\nWatch this video to learn about call stacks and abstract folder trees with lobstr.↩︎\nStack traces are also covered in Advanced R, 2ed, Mastering Shiny, and in the Shiny documentation. I’ve summarized some tips on reading Shiny call stacks in the stack traces section on the Appendix.↩︎",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "logging.html",
    "href": "logging.html",
    "title": "13  Logging",
    "section": "",
    "text": "13.1 Why Use Logging?\nA proactive method for debugging Shiny applications is implementing logging. Logs are essential for debugging, auditing, and monitoring, particularly in Shiny app development and R packages. This chapter discusses integrating logging into a Shiny app-package to improve debugging and issue-tracking efficiency.\nLogging enables us to monitor application flow and user interactions while identifying runtime errors and unexpected behaviors. It offers more structure and flexibility than print statements or interactive debuggers. Logs are particularly beneficial in production environments where direct debugging isn’t possible. Logs can also be saved for future analysis even after the application has stopped.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#sec-logging-why",
    "href": "logging.html#sec-logging-why",
    "title": "13  Logging",
    "section": "",
    "text": "13.1.1 App architecture\nWe’re going to start logging the behaviors of our app in the inst/tidy-movies folder. The architecture of this application has been updated to include the two new input modules (review these changes in Section 9.2.1):\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart LR\n        subgraph R[\"&lt;strong&gt;R/ folder&lt;/strong&gt;\"]\n            subgraph launch[\"launch_app('ggp2')\"]\n                display_type[\"display_type()\"]\n            end\n                mod_aes_input_ui[\"mod_aes_input_ui()\"]\n                mod_aes_input_server[\"mod_aes_input_server\"]\n                mod_var_input_server[\"mod_var_input_server()\"]\n                scatter_plot[\"scatter_plot()\"]\n        end\n\n        subgraph tidy_movies[\"&lt;strong&gt;inst/tidy-movies/&lt;/strong&gt;\"]\n\n                subgraph SubR[\"&lt;strong&gt;inst/tidy-movies/R/&lt;/strong&gt;\"]\n                devUI[\"devUI()\"]\n                dev_mod_vars_ui[\"dev_mod_vars_ui()\"]\n                dev_mod_scatter_ui[\"dev_mod_scatter_ui()\"]\n                devUI --&gt;|\"&lt;em&gt;Calls&lt;/em&gt;\"|dev_mod_vars_ui & dev_mod_scatter_ui\n                devServer[\"devServer()\"]\n                dev_mod_scatter_server[\"dev_mod_scatter_server()\"]\n                devServer --&gt;|\"&lt;em&gt;Calls&lt;/em&gt;\"|dev_mod_scatter_server\n                end\n\n            data[(\"&lt;code&gt;tidy_movies.fst\"&lt;/code&gt;)]\n            img[/\"&lt;code&gt;imdb.png&lt;/code&gt;\"\\]\n            appdotr(\"&lt;code&gt;app.R&lt;/code&gt; file\")\n        end\n        \n\n        launch ==&gt; |\"&lt;strong&gt;&lt;code&gt;shinyAppDir()&lt;/code&gt;&lt;/strong&gt;\"|appdotr\n        mod_aes_input_ui -.-&gt;|\"&lt;em&gt;Called from&lt;/em&gt;\"|devUI\n        mod_var_input_server & mod_aes_input_server -.-&gt;|\"&lt;em&gt;Called from&lt;/em&gt;\"|devServer\n        scatter_plot --&gt; |\"&lt;em&gt;Called from&lt;/em&gt;\"|dev_mod_scatter_server\n        \n        \n    %% R/\n    style R fill:#f3f3f3,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% standalone app function\n    style launch fill:#F6F6F6,color:#000,stroke:#333,stroke-width:1px,rx:10,ry:10\n    %% modules \n    style mod_var_input_server font-size:14px,color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style mod_aes_input_ui font-size:14px,color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style mod_aes_input_server font-size:14px,color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    %% utility functions\n    style scatter_plot fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    style display_type fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    \n    %% tidy-movies/ \n    style tidy_movies fill:#f3f3f3,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% tidy-movies/R\n    style SubR fill:#fcfcfc,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% tidy-movies/R/ files\n    style devUI stroke:#333,stroke-width:1px,rx:6,ry:6\n    style devServer stroke:#333,stroke-width:1px,rx:6,ry:6\n    style dev_mod_scatter_server font-size:14px,color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style dev_mod_scatter_ui font-size:14px,color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style dev_mod_vars_ui font-size:14px,color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    %% files \n    style data fill:#ffffff,color:#000,stroke:#333,stroke-width:1px,rx:6,ry:6\n    style img fill:#ffffff,color:#000,stroke:#333,stroke-width:1px,rx:6,ry:6\n    style appdotr fill:#ffffff,color:#000,stroke:#333,stroke-width:1px,rx:6,ry:6\n\n\n Architecture of app functions in inst/tidy-movies/ folder \n\n\n\nTo launch the inst/tidy-movies app, load, document, and install sap and run:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlaunch_app(\"ggp2\")\n\n\n\n\n\n\n\n\nLaunching inst/tidy-movies app with launch_app()\n\n\nThe reactive values from the R/mod_var_input.R are printed to the Console from the previous chapter (review this in Section 12.3).\nValidation and error handling ensures both expected and unexpected issues are managed effectively. Below I’ll briefly cover Shiny’s validate() function to check if input values or conditions are valid before executing server code and tryCatch() for handling unexpected runtime errors.\n\n\n13.1.2 Validating inputs\nvalidate() can be used to prevent unexpected errors by preventing the execution of subsequent code if the validation conditions fail.\n\nInside validate(), we can use need() to check if a condition is met\n\ntry() will catch any errors that occur if the inputs are NULL or missing.\n\nIf an error occurs, try() prevents the application from crashing and instead returns an error message:\n\n\n\nvalidate(\n  need(\n    try(some code),\n    \"Error message\"\n  )\n)\nBelow are example of validate(), try() and need() for the alpha and size inputs:\n\ninput$alpha\n\nvalidate(\n  need(\n    try(input$alpha &gt;= 0 & input$alpha &lt;= 1),\n    \"Alpha must be between 0 and 1\"\n  )\n)\n\nValues and behaviors:\n\n\n\ninput$alpha\nBehavior\n\n\n\n\n0.5 (valid)\n✅ Passes validation\n\n\n1.5 (invalid)\n❌ Error: \"Alpha must be between 0 and 1\"\n\n\nNULL\n❌ Error: \"Alpha must be between 0 and 1\"\n\n\nNA\n❌ Error: \"Alpha must be between 0 and 1\"\n\n\n\"high\" (string)\n❌ Error: \"Alpha must be between 0 and 1\"\n\n\n\n\n\ninput$size\n\nvalidate(\n  need(\n    try(input$size &gt; 0),\n    \"Size must be positive\"\n  )\n)\n\nValues and behaviors:\n\n\n\ninput$size\nBehavior\n\n\n\n\n3 (valid)\n✅ Passes validation\n\n\n-2 (invalid)\n❌ Error: \"Size must be positive\"\n\n\nNULL\n❌ Error: \"Size must be positive\"\n\n\nNA\n❌ Error: \"Size must be positive\"\n\n\n\"large\" (string)\n❌ Error: \"Size must be positive\"\n\n\n\nvalidate(), need() and try() can prevent unnecessary computations when an input is missing or incorrect, and they provide a user-friendly message instead of a cryptic error.\n\n\n\n13.1.3 Handling errors\nThe base R tryCatch function can also be used to log unexpected errors gracefully. What does gracefully mean? In this case, it means we can decide what we want to do if a particular function fails. Below is an example of using it with reactive() and combining it message():\n\nsafe_reactive &lt;- reactive({\n    tryCatch({\n        # Code that might throw an error\n        \n    }, error = function(e) {\n        message(paste0(\"An error occurred:\", e$message))\n    })\n})\n\ntryCatch() will catch unpredictable errors (e.g., missing file, incorrect format) and prevent our entire Shiny app from stopping due to a single point of failure.\nCombining Shiny’s validation functions with tryCatch() ensures both expected and unexpected issues are managed effectively, making our apps more resilient, user-friendly, and stable.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#sec-logging-funs",
    "href": "logging.html#sec-logging-funs",
    "title": "13  Logging",
    "section": "13.2 Base R logging",
    "text": "13.2 Base R logging\nCustom logging functions can be written entirely using base R (i.e., without adding any dependencies to our app-package). Below is an example logging utility function I’ve added to the R/ folder to use in our app(s):\n\n#' Log Application Behaviors\n#'\n#' A simple logging function for logging Shiny events and behaviors.\n#' \n#' @param message log message\n#' @param log_file name of log file (defaults to \"app_log.txt\")\n#' @param save print or save log file\n#'\n#' @return A log message to the console and the `log_file`.\n#'\n#' @family **Utility Functions**\n#' \n#' @examples\n#' if (interactive()) {\n#'   log_message(\"message\")\n#' }\n#' \n#' @export\nlog_message &lt;- function(message, log_file = \"logs/app_log.txt\", save = FALSE) {\n  timestamp &lt;- format(Sys.time(), \"%Y-%m-%d %H:%M:%S\")\n  # log entry\n1  log_entry &lt;- sprintf(\"[%s] %s\", timestamp, message)\n  # save\n  if (save) {\n2    log_dir &lt;- dirname(log_file)\n3    if (!dir.exists(log_dir)) {\n      dir.create(log_dir, recursive = TRUE)\n    }\n4    tryCatch(\n      {\n5        cat(log_entry, \"\\n\", file = log_file, append = TRUE)\n      },\n      error = function(e) {\n        warning(sprintf(\"Failed to write to log file '%s': %s\", log_file, e$message))\n      }\n    )\n  }\n  # print\n6  message(log_entry)\n}\n\n\n1\n\nThe sprintf() function is preferred over cat() or paste0() for clearer and faster string formatting. \n\n2\n\nThis function uses dirname() to dynamically extract the directory path from log_file.\n\n\n3\n\ndir.exists() and dir.create() ensure the folder exists (recursive = TRUE is for nested directories).\n\n\n4\n\nThe file-writing logic is wrapped in tryCatch() to gracefully handle errors (e.g., file permission issues), and we’ve added a warning() if writing to the log file fails.\n\n\n5\n\nWe explicitly add the newline (\\n) directly in the cat() function, ensuring the log entry is written properly even if message lacks a newline.\n\n\n6\n\nFinally, the message() is preferred here instead of print() for consistent output formatting.\n\n\n\n\nIn the inst/tidy-movies/ app, we could use log_message() and tryCatch() like so:\n\n    all_data &lt;- tryCatch({\n      \n1      log_message(message = \"Loading fst data\",\n        log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n      \n      fst::read_fst(\"tidy_movies.fst\")\n      \n    }, error = function(e) {\n      \n2      log_message(message = sprintf(\"Error loading fst data: %s\", e$message),\n        log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n      \n3      stop(\"Data loading failed.\")\n\n    })\n\n\n1\n\nSaving to _logs because it’s easier to separate from other app folders.\n\n\n2\n\nPrint error message from tryCatch()\n\n\n3\n\nStop creation of reactive.\n\n\n\n\nAfter loading and installing our package, the output from the log is saved in the log file (and printed to the Console) when our app stops running:\n\n\n\n\n\n\n\nLogging data upload with log_message()\n\n\n\n13.2.1 Logging events\nWe’ll continue to integrate log messages into the inst/tidy-movies app by inserting log_message() at critical points, such creating reactive expressions. For example, dev_mod_scatter_server() creates the graph_data() reactive based on the missing data checkbox user input:\n\ngraph_data &lt;- reactive({\n  if (input$missing) {\n    graph_data &lt;- tidyr::drop_na(data = all_data)\n  } else {\n    graph_data &lt;- all_data\n  }\n}) |&gt;\n  bindEvent(input$missing)\n\nWe’ll add validate() and tryCatch() with a log_message() to log if 1) graph_data() contains all of the observations or the missing values have been removed, and 2) if the reactive was created successfully.\n\ngraph_data &lt;- reactive({\n  \n1  validate(\n    need(try(is.logical(input$missing)), \n          \"Missing must be logical\")\n  )\n  \n    tryCatch({\n      if (input$missing) {\n        \n2        log_message(message = \"Removing missing values.\",\n                    log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n        graph_data &lt;- tidyr::drop_na(data = all_data)\n        \n      } else {\n        \n3        log_message(message = \"Using all data.\",\n                    log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n        graph_data &lt;- all_data\n        \n      }\n      \n      graph_data\n      \n    }, error = function(e) {\n      \n4      log_message(message = sprintf(\"Error processing graph data: %s\", e$message),\n        log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n5      NULL\n      \n    })\n}) |&gt; \n  bindEvent(input$missing)\n\n\n1\n\nValidation for missing checkbox input\n\n\n2\n\nConfirm missing values and create graph_data\n\n\n3\n\nUse all data and create graph_data\n\n\n4\n\nPrint and log message is error occurs\n\n5\n\nReturn null value for error\n\n\n\n\nThese logs will tell us the application loaded the .fst data and removed the missing values, but we should also check what happens when we change something, so we’ll adapt the code used to create our inputs() reactive with the log_message() function:\n\ninputs &lt;- reactive({\n\n  tryCatch({\n    plot_title &lt;- tools::toTitleCase(aes_inputs()$plot_title)\n    \n1    if (nchar(plot_title) &gt; 0) {\n      log_message(\n        sprintf(\"Processing plot title: '%s'\", plot_title), \n        log_file = \"_logs/ggp2_log.txt\")\n    }\n    \n      input_list &lt;- list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = aes_inputs()$alpha,\n        size = aes_inputs()$size,\n        plot_title = plot_title\n      )\n    \n2    log_message(\n      sprintf(\"Inputs: %s\", \n              paste(\n                names(input_list), input_list, sep = \" = \", collapse = \", \")\n              ),\n            log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n    \n    input_list\n  }, error = function(e) {\n    \n3    log_message(\n      sprintf(\"Error in processing inputs: %s\", conditionMessage(e)),\n      log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n    \n4    NULL\n  })\n})\n\n\n1\n\nLog the plot title.\n\n\n2\n\nLog the final input list.\n\n\n3\n\nLog the error if anything goes wrong.\n\n\n4\n\nReturn NULL on error to prevent breaking downstream dependencies.\n\n\n\n\nAfter loading and installing sap, we launch the inst/tidy-movies app again, but this time we un-check the remove missing checkbox and add a new plot title before stopping the application.\n\nlaunch_app(\"ggp2\")\n\n\n\n\n\n\n\n\nLog messages from inputs()\n\n\nTo view the log file, we need to use system.file() (we’re launching the app from the installed location, not the version we’re developing in the inst/tidy-movies/ folder). I’ve added readLines() and writeLines() so it prints nicely to the Console:\n\nsystem.file('tidy-movies', '_logs', 'ggp2_log.txt', \n            package = 'sap') |&gt; \n            readLines() |&gt; \n            writeLines()\n\n[2025-01-29 11:34:40] Loading fst data \n[2025-01-29 11:34:40] Removing missing values. \n[2025-01-29 11:34:40] Inputs: x = year, y = budget, z = mpaa, alpha = 0.5, size = 2, plot_title =  \n[2025-01-29 11:35:46] Loading fst data \n[2025-01-29 11:35:46] Removing missing values. \n[2025-01-29 11:35:46] Inputs: x = year, y = budget, z = mpaa, alpha = 0.5, size = 2, plot_title =  \n[2025-01-29 11:35:52] Loading fst data \n[2025-01-29 11:35:52] Removing missing values. \n[2025-01-29 11:35:52] Inputs: x = year, y = budget, z = mpaa, alpha = 0.5, size = 2, plot_title =  \n[2025-01-29 11:35:57] Inputs: x = year, y = budget, z = mpaa, alpha = 0.5, size = 2, plot_title = Title \nIn practice, we’d insert logging messages with log_message() and tryCatch() for application startup, loading data/connecting to databases, API calls, and when using Shiny’s internal validation/error handling functions. In the next section, we’re going to explore using add-on packages to implement logging in our app-package.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#sec-logging-logger",
    "href": "logging.html#sec-logging-logger",
    "title": "13  Logging",
    "section": "13.3 Logging with logger",
    "text": "13.3 Logging with logger\n\n\n\n\n\n\nLogging frameworks\n\n\n\n\n\n\nThe R ecosystem offers several libraries for logging.\nThe most popular options are:\n\nfutile.logger: A lightweight and flexible logging package.\nlogger: A modern, extensible, and user-friendly library.\nlog4r: Inspired by the Java log4j library, suitable for structured logging.\n\n\n\n\n\nThis section will focus on the logger package because it is simple, easy to integrate with Shiny, and extensible.\n\ninstall.packages(\"pak\")\npak::pak(\"daroczig/logger\")\n\nAdd logger to the package dependencies in the DESCRIPTION file and use the logger::fun() syntax to avoid adding @import or @importFrom roxygen tags.\n\nusethis::use_package('logger')\n\n\n13.3.1 Log levels\nThe logger package has a few configurations that can be very helpful for app-package development. We’ll start with a basic example using logger::log_info():\n\nname &lt;- \"world\"\nlogger::log_info('Hello, {name}')\n\nINFO [2025-01-22 11:07:52] Hello, world\nThe output is a nicely formatted log message, and by default logger supports glue syntax. However, the following function (logger::log_debug()) doesn’t return a log message to the Console:\n\nlogger::log_debug('Hello, {name}')\n\nThis is because the logger package has a threshold configuration that controls the ‘verbosity’ of the logs printed to the Console. If we check the log_threshold(), we see it’s set to INFO:\n\nlogger::log_threshold()\n\nLog level: INFO\nIf we reset the logger::log_threshold() to DEBUG, we will see the call in the Console.\n\nlogger::log_threshold('DEBUG')\nlogger::log_debug('Hello, {name}')\n\nDEBUG [2025-01-22 11:08:36] Hello, world\nWe can set the log threshold dynamically to control the verbosity of logs:\n\nlogger::log_threshold('TRACE') # fine-grained, verbose logging for development\nlogger::log_threshold('DEBUG') # verbose logging for development\nlogger::log_threshold('WARN')  # only warnings and errors for production\n\nWhile developing app-packages, I recommend broadly characterizing the logger log levels into the following categories:\n\n\n\n\n\n\n\nDevelopment\nDescriptive messages for easier debugging\n\n\n\n\n\n\n\n\n\nLevel\nDetails\n\n\n\n\nTRACE\nFine-grained tracking for debugging flows (e.g., reactive updates, function calls).\n\n\nDEBUG\nDiagnostic information for inputs, intermediate states, and outputs.\n\n\n\n\n\n\n\n\n\n\n\n\nProduction\nLower verbosity levels\n\n\n\n\n\n\n\n\n\nLevel\nDetails\n\n\n\n\nINFO\nSession-level events and significant actions (e.g., app startup, data loading).\n\n\nWARN\nSuspicious but non-fatal conditions (e.g., unusual input values or data sizes).\n\n\nERROR\nHandled errors with appropriate messaging and graceful recovery.\n\n\nFATAL\nCritical failures leading to app crashes or irrecoverable states.\n\n\n\n\n\n\n\n13.3.2 Storing log files\nBy default, logger logs are written to the console, but the logger::appender_file() function can direct log messages to a file (or to a database or external logging system).1\nWe also want to periodically archive old logs to prevent storage issues. Storing log messages as JSON objects is sometimes preferred because JSON files are structured, machine-readable, and can easily integrate with logging tools like Logstash, Kibana (ELK Stack) or other log management solutions.\n\n\n13.3.3 Custom logger functions\nWe’ll write a custom logging function with logger to so our app logs are formatted and managed a consistent manner. Below is a logr_msg() utility function for inserting logger-style logs in our application.\n\nlogr_msg &lt;- function(message, level = \"INFO\", log_file = NULL, json = FALSE) {\n  \n1  logger::log_appender(appender = logger::appender_console)\n  \n  if (!is.null(log_file)) {\n2    if (json) {\n      logger::log_layout(layout = logger::layout_json())\n3    } else {\n      logger::log_appender(appender = logger::appender_tee(log_file))\n    }\n  }\n  \n4  logger::log_formatter(formatter = logger::formatter_glue)\n  \n5  switch(\n    level,\n    \"FATAL\" = logger::log_fatal(\"{message}\"),\n    \"ERROR\" = logger::log_error(\"{message}\"),\n    \"WARN\" = logger::log_warn(\"{message}\"),\n    \"SUCCESS\" = logger::log_success(\"{message}\"),\n    \"INFO\" = logger::log_info(\"{message}\"),\n    \"DEBUG\" = logger::log_debug(\"{message}\"),\n    \"TRACE\" = logger::log_trace(\"{message}\"),\n6    logger::log_info(\"{message}\")\n  )\n}\n\n\n1\n\nAll logs print to console\n\n2\n\nWrite logs to JSON if the json = TRUE\n\n\n3\n\nDefault appender_tee for plain text logs\n\n\n4\n\nSet the default formatter\n\n\n5\n\nHandle all log levels\n\n\n6\n\nDefault to INFO\n\n\n\n\nlog_appender controls where the log messages go. It specifies the “destination” for each log message, whether that’s the Console, a file, or both.\nlog_formatter is like a template for log messages–it determines how log each message is structured and displayed. We can control what information is included in each message (like the timestamp, log level, and the actual message), and how this information is formatted. Predefined formatters (like formatter_glue) uses glue syntax to create flexible and readable formats.\nWe’ll demonstrate logr_msg() with the mod_var_input_server() function, which returns the variable inputs from the UI. The message in logr_msg() is built with glue::glue() and includes the three reactive inputs from this module. We’re also appending the log output to a new log file (_logs/app_log.txt).\n\nmod_var_input_server &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    \n1    logr_msg(\"mod_var_input_server started\",\n      level = \"TRACE\", log_file = \"_logs/app_log.txt\")\n    \n    observe({\n2        logr_msg(\n          glue::glue(\"Reactive inputs: \n                      x = {input$x}, y = {input$y}, z = {input$z}\"),\n          level = \"DEBUG\", log_file = \"_logs/app_log.txt\")\n    }) |&gt; \n      bindEvent(c(input$x, input$y, input$z))\n\n    return(\n      reactive({\n3        logr_msg(\n          glue::glue(\"Reactive inputs returned: \n                      x = {input$x}, y = {input$y}, z = {input$z}\"),\n          level = \"DEBUG\", log_file = \"_logs/app_log.txt\")\n        list(\n          \"x\" = input$x,\n          \"y\" = input$y,\n          \"z\" = input$z\n        )\n      })\n    )\n  })\n}\n\n\n1\n\nTRACE log for starting the module\n\n\n2\n\nDEBUG log for collecting inputs\n\n3\n\nDEBUG log for returning inputs\n\n\n\n\nAn advantage to using the logger package is that our log messages are automatically printed to the Console while the application is launched, although when we load and install sap and launch the inst/tidy-movies app, we don’t see any logs:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlaunch_app(\"ggp2\")\n\n\n\n\n\n\n\n\nInitial messages from logr_msg()\n\n\nTo view the log in our app, we need to set the log threshold:\n\nlogger::log_threshold('TRACE')\nlaunch_app(\"ggp2\")\n\nThe logs are now printed to the console and we can see the level, timestamp, and message:\n\n\n\n\n\n\n\nUpdates from logr_msg()",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#sec-logging-debugging",
    "href": "logging.html#sec-logging-debugging",
    "title": "13  Logging",
    "section": "13.4 Logging and debugging",
    "text": "13.4 Logging and debugging\nOur primary application (i.e. the app launched with launch_app()) is currently displaying and error message:\n\n\n\n\n\n\n\nError message in launch_app()\n\n\nBefore adding our new custom logger function, we’ll review the architecture of this application and it’s modules.\n\n13.4.1 App architecture\nThe diagram below illustrates the namespaces and module communication in our movies app. The ‘variables’ and ‘aesthetics’ modules pass user inputs into the ‘scatter display’ module in movies_server():\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    subgraph Launch[\"&lt;strong&gt;launch_app()&lt;/strong&gt;\"]\n        subgraph Server[\"&lt;strong&gt;movies_server()&lt;/strong&gt;\"]\n            subgraph VarServerNS[\"&lt;strong&gt;Variable Namespace&lt;strong&gt;\"]\n                VarInpuServer[\"mod_var_input_server()\"]\n            end\n            subgraph AesServerNS[\"&lt;strong&gt;Aesthetics Namespace&lt;strong&gt;\"]\n                AesInpuServer[\"mod_aes_input_server()\"]\n            end\n            subgraph GraphServerNS[\"&lt;strong&gt;Graph Namespace&lt;strong&gt;\"]\n                DisplayServer[\"mod_scatter_display_server()\"]\n                PlotUtil[\"scatter_plot()\"]\n            end\n        end\n        subgraph UI[\"&lt;strong&gt;movies_ui()&lt;/strong&gt;\"]\n            subgraph VarUINS[\"&lt;strong&gt;Variable Namespace&lt;strong&gt;\"]\n                VarInpuUI[\"mod_var_input_ui()\"]\n            end\n            subgraph AesUINS[\"&lt;strong&gt;Aesthetics Namespace&lt;strong&gt;\"]\n                AesInpuUI[\"mod_aes_input_ui()\"]\n            end\n            subgraph GraphUINS[\"&lt;strong&gt;Graph Namespace&lt;strong&gt;\"]\n                DisplayUI[\"mod_scatter_display_ui()\"]\n            end\n        end\n\n        VarInpuUI &lt;--&gt; VarInpuServer\n        AesInpuUI &lt;--&gt; AesInpuServer\n        DisplayServer &lt;--&gt; PlotUtil &lt;--&gt; DisplayUI\n    end\n\n    VarInpuServer &lt;-.-&gt;|\"&lt;em&gt;Communicates&lt;br&gt;&lt;code&gt;selected_vars&lt;/code&gt;&lt;br&gt;across modules&lt;/em&gt;\"| DisplayServer\n    AesInpuServer &lt;-.-&gt;|\"&lt;em&gt;Communicates&lt;br&gt;&lt;code&gt;selected_aes&lt;/code&gt;&lt;br&gt;across modules&lt;/em&gt;\"| DisplayServer\n    \n    %% standalone app function \n    style Launch fill:#F6F6F6,color:#000,stroke:#333\n    \n    %% modules\n    style VarInpuUI font-size:14px,color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    style VarInpuServer font-size:14px,color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    style AesInpuServer font-size:14px,color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    style AesInpuUI font-size:14px,color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    style DisplayServer font-size:12px,color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    style DisplayUI font-size:14px,color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    \n    %% Utility Functions\n    style PlotUtil fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    \n    %% namespaces\n    style VarServerNS fill:#fcfcfc,stroke:#000,stroke-width:1px,rx:6,ry:6\n    style VarUINS fill:#fcfcfc,stroke:#000,stroke-width:1px,rx:6,ry:6\n    style AesServerNS fill:#fcfcfc,stroke:#000,stroke-width:1px,rx:6,ry:6\n    style AesUINS fill:#fcfcfc,stroke:#000,stroke-width:1px,rx:6,ry:6\n    style GraphServerNS fill:#fcfcfc,stroke:#000,stroke-width:1px,rx:6,ry:6\n    style GraphUINS fill:#fcfcfc,stroke:#000,stroke-width:1px,rx:6,ry:6\n    \n    %% UI and Server\n    style Server fill:#eaeaea,stroke-width:1px,rx:12,ry:12\n    style UI fill:#eaeaea,stroke-width:1px,rx:12,ry:12\n\n\n Primary launch_app() app \n\n\n\nThe diagram above gives us an idea of the critical events we’ll want to log in the movies app. Below are examples of TRACE, INFO, WARN, ERROR, and FATAL log levels using logr_msg().\n\n\n13.4.2 TRACE logs\n\nIn movies_server(), a TRACE log message will signal the server function has executed:\n\n\n  logr_msg(message = \"Server function execution completed\", \n           level = \"TRACE\", log_file = \"_logs/app_log.txt\")\n\n\nIn mod_scatter_display_server(), a TRACE log message for initiating the scatterplot graph:\n\n\nlogr_msg(\"Preparing scatterplot in mod_scatter_display_server\", \n          level = \"TRACE\", log_file = \"_logs/app_log.txt\")\n\n\n\n13.4.3 INFO logs\n\nIn launch_app(), an INFO log message prints the application being launched with the app argument:\n\n\n  logr_msg(glue::glue(\"Launching app: {app}\"), level = \"INFO\",\n    log_file = \"_logs/app_log.txt\")\n\n\nIn movies_ui(), an INFO log message prints the value of the bslib argument\n\n\n  logr_msg(\n    glue::glue(\"Launching UI with bslib = {bslib}\"),\n    level = \"INFO\", log_file = \"_logs/app_log.txt\")\n\n\n\n13.4.4 WARN logs\n\nIn mod_aes_input_server(), a WARN log message (with validate) prints input warnings:\n\n\n      validate(\n        need(try(input$alpha &gt;= 0 & input$alpha &lt;= 1), \n              \"Alpha must be between 0 and 1\")\n      )\n      if (input$alpha &lt; 0 || input$alpha &gt; 1) {\n        logr_msg(message = \"Alpha value out of range: {alpha}\", \n        level = \"WARN\", log_file = \"_logs/app_log.txt\")\n      }\n\n\n\n13.4.5 ERROR logs\n\nIn movies_ui(), logic and an ERROR log message monitors the format of the bslib argument:\n\n\nif (!is.logical(bslib)) {\n  logr_msg(\"Argument 'bslib' must be a logical value\", \n    level = \"ERROR\", log_file = \"_logs/app_log.txt\")\n    stop(\"Invalid argument: 'bslib' must be TRUE or FALSE.\")\n  }\n\n\nIn mod_scatter_display_server(), an ERROR log message (with tryCatch()) monitors the rendered output:\n\n\n  tryCatch({\n    plot &lt;- scatter_plot(\n      # data --------------------\n      df = movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size\n    )\n    plot +\n      ggplot2::labs(\n        title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n      ) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  }, error = function(e) {\n  \n  logr_msg(glue::glue(\"Failed to render scatterplot. Reason: {e$message}\"), \n           level = \"ERROR\", log_file = \"_logs/app_log.txt\")\n  \n  })\n\n\n\n13.4.6 FATAL logs\n\nIn launch_app(), a FATAL log message (along with tryCatch() and stop()) monitors the application being launched:\n\n\n  tryCatch({\n    \n    if (app == \"bslib\") {\n      shinyApp(\n        ui = movies_ui(bslib = TRUE),\n        server = movies_server,\n        options = options\n      )\n    } else if (app == \"ggp2\") {\n      shinyAppDir(\n        appDir = system.file(\"tidy-movies\", package = \"sap\"),\n        options = options\n      )\n    } else if (app == \"quarto\") {\n      quarto::quarto_preview(\n        system.file(\"quarto\", \"index.qmd\", package = \"sap\"), \n        render = \"all\"\n      )\n    } else {\n      app &lt;- \"movies\"\n      shinyApp(\n        ui = movies_ui(...),\n        server = movies_server,\n        options = options\n      )\n    }\n    \n  }, error = function(e) {\n    \n    logr_msg(glue::glue(\"Application failed to launch. Reason: {e$message}\"), \n             level = \"FATAL\",\n             log_file = \"_logs/app_log.txt\")\n    \n    stop(\"Application launch failed. Check logs for details.\")\n    \n  })\n\nDuring development, I recommend setting the log threshold to TRACE or DEBUG after loading and installing sap:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlogger::log_threshold('TRACE')\nlaunch_app()\n\n\n\n\n\n\n\n\nLog error message in launch_app()\n\n\nThe logs successfully capture all events up to and including the error message. While developing our application, we can run the app interactively and monitor the logs in the console. If the application has been deployed, we can search the log files using R (or the command line):\nIn R:\n\nreadLines(\"_logs/app_log.txt\") |&gt; \n  stringr::str_view(\"ERROR\")\n\n│ &lt;ERROR&gt; [2025-01-29 13:55:36] Failed to render scatterplot. \n  Reason: 'text' must be a character vector\nAt the command line:\ncat _logs/app_log.txt | grep \"ERROR\"\nERROR [2025-01-29 13:55:36] Failed to render scatterplot. \n  Reason: 'text' must be a character vector",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#sec-logging-pkg-startup-msg",
    "href": "logging.html#sec-logging-pkg-startup-msg",
    "title": "13  Logging",
    "section": "13.5 Package startup messages",
    "text": "13.5 Package startup messages\nPackage startup messages help create a welcoming and professional impression when users load your app-package. These messages can also inform users of any specific requirements, dependencies, or potential conflicts. Package startup messages can also include the logging system (i.e., logger) being used, which can be helpful for debugging or monitoring during development or runtime.\n\n13.5.1 .onAttach()\nWrite package startup messages in the .onAttach() function (stored in R/zzz.R).2 The example below includes a welcome message, the current Git branch, dependencies (imports, depends, and suggests), and the path where this package is loaded from.\n\n.onAttach &lt;- function(libname, pkgname) {\n  \n1    branch &lt;- if (isTRUE(system(\"git rev-parse --is-inside-work-tree\", intern = TRUE) == \"true\")) {\n2    tryCatch({\n      system(\"git rev-parse --abbrev-ref HEAD\", intern = TRUE)\n    }, error = function(e) \"unknown\")\n  } else {\n    \"not a Git repository\"\n  }\n\n3  version &lt;- utils::packageVersion(pkgname)\n\n4  description &lt;- utils::packageDescription(pkgname)\n  imports &lt;- description$Imports\n  suggests &lt;- description$Suggests\n  depends &lt;- description$Depends\n\n5  parse_dependencies &lt;- function(dep_string) {\n    if (is.null(dep_string)) return(\"None\")\n    deps &lt;- strsplit(dep_string, \",\\\\s*\")[[1]]\n    paste(deps, collapse = \", \")\n  }\n\n6  imports &lt;- parse_dependencies(imports)\n  suggests &lt;- parse_dependencies(suggests)\n  depends &lt;- parse_dependencies(depends)\n  \n7  cli::cli_inform(\"{.strong Welcome to the {.pkg {pkgname}} package (version {version}) {cli::symbol$smiley}!}\",\n    class = \"packageStartupMessage\")\n  \n8  cli::cli_inform(\"{.strong Current branch:}\", class = \"packageStartupMessage\")\n  cli::cli_inform(\"{.emph {cli::symbol$pointer} {branch}}\", class = \"packageStartupMessage\")\n\n9  cli::cli_inform(\"{.strong Dependencies:}\", class = \"packageStartupMessage\")\n10  cli::cli_inform(\"{.emph {cli::symbol$pointer} Imports: {imports}}\", class = \"packageStartupMessage\")\n11  cli::cli_inform(\"{.emph {cli::symbol$pointer} Suggests: {suggests}}\", class = \"packageStartupMessage\")\n12  cli::cli_inform(\"{.emph {cli::symbol$pointer} Depends: {depends}}\", class = \"packageStartupMessage\")\n\n13  cli::cli_inform(\"{.strong Loaded from:}\", class = \"packageStartupMessage\")\n14  cli::cli_inform(\"{.emph {cli::symbol$pointer} {libname}}\", class = \"packageStartupMessage\")\n}\n\n\n1\n\nCheck if the current folder is a Git repo.\n\n\n2\n\nCapture the current branch if it’s a Git repo.\n\n\n3\n\nPackage version.\n\n\n4\n\nDependencies from DESCRIPTION.\n\n\n5\n\nParse and format dependencies function.\n\n\n6\n\nCleaned dependencies.\n\n\n7\n\nWelcome message.\n\n\n8\n\nGit branch.\n\n\n9\n\nDependencies (header).\n\n\n10\n\nDependencies (Imports from DESCRIPTION).\n\n\n11\n\nDependencies (Suggests from DESCRIPTION).\n\n\n12\n\nDependencies (Depends from DESCRIPTION).\n\n\n13\n\nSource of installed packages.\n\n\n14\n\nlibname (a character string giving the library directory where the package defining the namespace was found.)\n\n\n\n\n\nWhen we loading sap, we see the output from our startup message:\n\n\n\n\n\n\n\nPackage startup message in sap\n\n\nIncluding a startup message is a helpful tool, but it should be thoughtfully crafted to enhance the user experience without being intrusive. Avoid including a startup message if the app-package if the message doesn’t add meaningful value and becomes unnecessary “noise” for users.\nAlso, be sure to allow users to disable the message if possible (e.g., using suppressPackageStartupMessages()):\n\ninstall.packages('pak')\npak::pak('mjfrigaard/sap')\nsuppressPackageStartupMessages(library(sap))\n\n\n\n\n\n\n\nInitialize logging with .onLoad()\n\n\n\n\n\n\nWe can set up logger’s logging configuration in an onLoad function of the zzz.R file:\n.onLoad &lt;- function(libname, pkgname) {\n    # configure logger log messages to console\n    logger::log_appender(logger::appender_console)\n    # configure logger log messages to file\n    logger::log_appender(logger::appender_file('sap_apps.log'))\n    # set default log level to DEBUG\n    logger::log_threshold('DEBUG') \n}\nThis setup ensures that logging is ready as soon as your package is loaded.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#recap",
    "href": "logging.html#recap",
    "title": "13  Logging",
    "section": "Recap",
    "text": "Recap\nThe techniques discussed in this chapter will help you efficiently diagnose and resolve issues, making your Shiny app-package more robust and reliable.\n\n\n\n\n\n\nRecap: Logging\n\n\n\n\n\n\nLogging is an invaluable tool for debugging Shiny app-packages. By strategically placing log messages and configuring log levels, you can gain deep insights into your application’s behavior.\n\nUse log levels to differentiate between logs.\nConfigure log settings with .onLoad() (stored in R/zzz.R)\nStore package startup messages in onAttach() (stored in R/zzz.R)\nBe selective with logging and avoid exposing or storing sensitive data.\n\nBy integrating structured logging, we can proactively detect issues, debug efficiently, and maintain application stability in production environments.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#footnotes",
    "href": "logging.html#footnotes",
    "title": "13  Logging",
    "section": "",
    "text": "Integrate with external logging systems (e.g., Syslog or Telegram) using custom appenders.↩︎\nRead more in the ‘Hooks for Namespace Events’ documentation.↩︎",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "tests.html",
    "href": "tests.html",
    "title": "Tests",
    "section": "",
    "text": "Testing your app\nExpand the callout boxes below to review what we’ve covered in the previous chapters on debugging:\nWe’re now ready to test the code and features in our app-package. The next section covers the following topics:",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#test-suite",
    "href": "tests.html#test-suite",
    "title": "Tests",
    "section": "Test suite",
    "text": "Test suite\nTest suite starts by showing how to create the testthat infrastructure then, dives into creating test files, the mechanics unit tests and expectations, and running tests during development:\n\n14.2 Setting up testthat tests\n14.3 Creating unit tests\n\n14.3.2 test_that() tests\n14.3.3 expect_ations\n14.3.4 BDD test functions\n\n14.4 Running tests\n\n14.4.1 Keyboard shortcuts",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#specifications",
    "href": "tests.html#specifications",
    "title": "Tests",
    "section": "Specifications",
    "text": "Specifications\nSpecifications discusses how to collect and organize information to write tests for your application:\n\n15.1 Application requirements\n\n15.1.1 User Specifications\n15.1.2 Features, and\n15.1.3 Functional Requirements\n\n15.3 BDD and testthat\n\n15.4 Traceability Matrix\n\nThis chapter also gives examples of behavior-driven development tests features and how to track specifications and tests together.",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#test-tools",
    "href": "tests.html#test-tools",
    "title": "Tests",
    "section": "Test tools",
    "text": "Test tools\nTest tools was updated recently to include the new ensure package, which was designed for “drafting testthat unit testing code using LLMs.”\n\n16.1 Unit tests & LLMs\n\n16.1.2 Test scope\n\n16.1.3 Test fixtures\n\n\n16.2 Test data\n16.3 Test logging\n\n16.3.1 Test helpers\n16.3.2 Test development\n\n\n16.4 Test snapshots\n\n16.4.1 Reviewing _snaps/\n\n\nEach tool can contribute to testing your Shiny app-package in a unique way (they’re also relatively recent additions to the testthat framework).",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#testing-modules",
    "href": "tests.html#testing-modules",
    "title": "Tests",
    "section": "Testing modules",
    "text": "Testing modules\nShiny’s testServer() function can be useful for performing integration tests with module server functions. Testing modules gives examples of using testServer() to verify module communication (i.e., passing data between modules):\n\n17.2 Testing return values\n\n17.3 Testing module inputs\n\n17.4 Module test coverage\n\n17.4.1 Testing module outputs",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#system-tests",
    "href": "tests.html#system-tests",
    "title": "Tests",
    "section": "System tests",
    "text": "System tests\nThe final chapter in this section covers setting up and running system (or end-to-end tests with shinytest2):\n\n18.2 Setting up shinytest2\n\n18.3 Record a test\n\n18.4 shinytest2 and BDD\n\n18.5 The test.mode option\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "test_suite.html",
    "href": "test_suite.html",
    "title": "14  Test suite",
    "section": "",
    "text": "14.1 testthat framework\nTesting Shiny applications poses some unique challenges. Shiny functions are written in the context of its reactive model,1 so some standard testing techniques and methods for regular R packages don’t directly apply. This chapter covers setting up the testthat’s infrastructure, keyboard shortcuts for commonly used functions, and running tests in RStudio  vs. Positron .\ntestthat is the standard package for testing in R packages and one of the most widely used and supported packages on CRAN. Its widespread adoption is due to its ability to simplify the setup, creation, and execution of unit tests.\nIn our app-package, we’ll use testthat unit tests to ensure the underlying logic (i.e., non-reactive utility functions) behaves correctly. We can extend testthat’s framework for integration tests with Shiny’s testServer() function and system tests with the shinytest2 package. Together, these tools provide a comprehensive testing suite for an app-package.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#sec-tests-suite-use-testthat",
    "href": "test_suite.html#sec-tests-suite-use-testthat",
    "title": "14  Test suite",
    "section": "14.2 Setting up testthat tests",
    "text": "14.2 Setting up testthat tests\nThe testthat package has been around for over a decade and thus has undergone various changes that require us to specify the edition we intend to use (currently, it’s the third):2\n\nusethis::use_testthat(3)\n\nSetting up your testing infrastructure with use_testthat() does the following:\n\nIn the DESCRIPTION file, testthat (&gt;= 3.0.0) is listed under Suggests\nConfig/testthat/edition: 3 is also listed in the DESCRIPTION to specify the testthat edition\nA new tests/ folder is created, with a testthat/ subfolder\nThe tests/testthat/testthat.R file is created\n\nWe now have a tests/ folder to store our testthat tests.\n\ntests/\n  ├── testthat/\n1  └── testthat.R\n\n2 directories, 1 file\n\n\n1\n\nReferred to as the ‘test runner,’ because it runs all our tests (do not edit this file).",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#sec-tests-suite-use-test",
    "href": "test_suite.html#sec-tests-suite-use-test",
    "title": "14  Test suite",
    "section": "14.3 Creating unit tests",
    "text": "14.3 Creating unit tests\n\n\nLaunch app with the shinypak package:\n\nlaunch('10_test-suite')\n\nThe standard workflow for writing testthat unit tests consists of the following:\nNew tests are created with usethis::use_test():\n\nusethis::use_test(\"scatter_plot\") \n\n\ntestthat recommends having a corresponding test file in tests/testthat/ (with the test- prefix) for the files in R/.\n\n\n14.3.1 test- files\nTest files: the IDE will automatically create and open the new test file:\n✔ Writing 'tests/testthat/test-scatter_plot.R'\n• Modify 'tests/testthat/test-scatter_plot.R'\n\n\n14.3.2 test_that() tests\nEach new test file contains a boilerplate test_that() test:\n\n1test_that(desc = \"multiplication works\", code = {\n \n})\n\n\n1\n\ndesc is the test context (supplied in \"quotes\"), and code is the test code (supplied in {curly brackets}).\n\n\n\n\n\n\n14.3.3 expect_ations\nThe expectations typically have two arguments: observed and expected.\n\n1expect_equal(\n2  object = 2 * 2,\n3  expected = 4\n  ) \n\n\n1\n\nA testthat expectation function\n\n\n2\n\nThe output or behavior being tested\n\n\n3\n\nA predefined output or behavior\n\n\n\n\nThe observed object is an artifact of some code we’ve written, and it’s being compared against an expected result.\n\n\n14.3.4 BDD test functions\n\n\n\n\n\n\n Positron Version\n\n\n\n\n\n\nAt the time of this writing, the 2024.09.0-1 pre-release of Positron was available for testing.\n\n\n\n\ntestthat also has two behavior-driven development (BDD) functions for performing tests: describe() and it().\n\n“Use describe() to verify that you implement the right things and use [it()] to ensure you do the things right.” - testthat documentation\n\n\n1describe(\"Description of feature or specification\",\n      code = { \n2    it(\"Functionality under test\",\n3        code = {\n            expect_equal( \n            object = 2 * 2, \n            expected = 4 \n            )\n        })\n    })\n\n\n1\n\ndescribe() the feature or specification\n\n\n2\n\nCapture it() in a test\n\n\n3\n\nWrite expectations\n\n\n\n\nWe’ll cover BDD more in the next chapter, but for now just know that each call to it() behaves like test_that().",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#sec-tests-suite-running-tests",
    "href": "test_suite.html#sec-tests-suite-running-tests",
    "title": "14  Test suite",
    "section": "14.4 Running tests",
    "text": "14.4 Running tests\nAnother devtools habit to adopt is regularly writing and running tests. Below we’ll cover writing and running tests in RStudio  and Positron .\n\n14.4.1 Keyboard shortcuts\nR Packages, 2ed also suggests binding test_active_file() and test_coverage_active_file() to keyboard shortcuts. I highly recommend using a shortcut while developing tests because it will improve your ability to iterate quickly.\n\n\n\n\n\n\ndevtools function\n\n\n \n\n\nKeyboard shortcut\n\n\n\n\n\n\n\n\n\ntest()\n\n\n \n\n\nCtrl/Cmd + Shift + T\n\n\n\n\n\n\n\n\n\ntest_active_file()\n\n\n \n\n\nCtrl/Cmd + T\n\n\n\n\n\n\n\n\n\ntest_coverage_active_file()\n\n\n \n\n\nCtrl/Cmd + Shift + R\n\n\n\n\nFollow these instructions to create a new keyboard shortcut in RStudio . Positron  already includes the devtools::test() shortcut, but the other two (test_active_file() and test_coverage_active_file()) will have to be added manually (see instructions here).\n\n\n14.4.2 Tests in RStudio \nIn RStudio , test_active_file() (or Ctrl/Cmd + T) will test the current test file:\n\n\n\ntest_active_file() or Ctrl/Cmd + T in RStudio\n\n\nThe output will provide feedback on whether the test passes or fails (and occasionally some encouragement).\nWhen we’ve written multiple test files, we can run all the tests in our app-package using the Build pane or the keyboard shortcut (Ctrl/Cmd + Shift + T)\n\n\n\n\n\n\n\n\n\nRun all tests\n\n\n\n\n\n\n\ndevtools::test()\n\n\n\n\n\nRStudio  can be configured to include additional columns, which can be helpful during test development. Below is an example workflow with the R/scatter_plot.R file, it’s accompanying test file, the Build pane, and the Console.\n\n\n\n\n\n\n\nTest workflow in RStudio\n\n\n\n\n14.4.3 Tests in Positron \nIf we click on the Testing sidebar menu item with our test file open, Positron  will display the hierarchy of the describe() and it() functions:\n\n\n\n\n\nTesting icon in Positron sidebar menu\n\n\n\n\n\n\n\n\n\nBDD testing functions in Positron\n\n\nPositron  gives us multiple options for running tests. For running individual tests, we can use the Run Test icons:\n\n\n\n\n\n\n\n\n\nRun Test in Testing sidebar menu item\n\n\n\n\n\n\n\nRun Test in test file\n\n\n\n\n\nWhen testing the active file in Positron , the results are displayed in the Console:\n\n\n\n\n\n\n\ntest_active_file() in Positron\n\n\nTo run all the tests in our app-package, we can use the keyboard shortcut or the Run Tests icon:\n\n\n\n\n\n\n\n\n\nRun Tests in Testing sidebar menu item\n\n\n\n\n\n\n\nRun Tests in test file\n\n\n\n\n\nThe Ctrl/Cmd + Shift + T shortcut will call devtools::test() and display the results in a new R Terminal task:",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#recap",
    "href": "test_suite.html#recap",
    "title": "14  Test suite",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRECAP   \n\n\n\n\n\n\n\ntestthat setup\n\nuse_testthat(): sets up testing infrastructure in your app-package\n\nTest files\n\nuse_test(): creates new test files (with test- prefix). The test file names should generally match the file names be belowR/.\n\nBDD test functions\n\ndescribe(): Feature descriptions and any relevant background information\nit(): Scenarios and test code with expectations (Then statement = functional requirement).\n\nRunning tests\n\ntest_active_file(): runs tests in the current open test file\ntest_coverage_active_file(): test coverage for the current open test file\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#footnotes",
    "href": "test_suite.html#footnotes",
    "title": "14  Test suite",
    "section": "",
    "text": "The ‘Reactivity - An overview’ article gives an excellent description (and mental module) of reactive programming.↩︎\nRead more about changes to the third edition to testthat in R Packages, 2ed↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_specs.html",
    "href": "test_specs.html",
    "title": "15  Specifications",
    "section": "",
    "text": "15.1 Application requirements\nThis chapter focuses on what to test–or specifically, how to figure out what to test. This process usually involves converting a list of user needs into testable requirements. The following chapters in this section have examples of tests, but don’t go into depth on how to write tests. Excellent resources exist for writing unit tests 1 and testing shiny apps.2 The goal of this chapter is to illustrate the connections between the user’s needs, the code below R/, and developing tests.3\nInformation about the various tasks and activities an application is expected to perform in typically stored in some kind of software requirements specification (SRS) document.4 The SRS can include things like distinct design characteristics, budgetary, technological, or timeline restrictions, etc. This document breaks down an application’s intended purpose (i.e., the problem it’s designed to solve) into three general areas: user specifications, features, and functional requirements.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#sec-tests-specs-app-reqs",
    "href": "test_specs.html#sec-tests-specs-app-reqs",
    "title": "15  Specifications",
    "section": "",
    "text": "15.1.1 User Specifications\n\n\nLaunch app with the shinypak package:\n\nlaunch('15_specs')\n\nThe user specifications are the goals and objectives stakeholders want to achieve with the application. They use terms like ‘deliver value’ and ‘provide insight’ and provide the basis for deriving the application’s features. 5\n\n\n15.1.2 Features\nFeatures translate the user expectations into an application capabilities. Generally speaking, features capture the tasks and activities user should “be able to” accomplish with the application (i.e., explore data with a graph).\n\n\n15.1.3 Functional Requirements\nFunctional requirements are written for developers and provide the technical details on each feature. A single feature often gives rise to multiple functional requirements (these are where users needs come into direct contact with code)6\n\nIn summary\nThe areas above help direct the development process, albeit from slightly different perspectives.\n\nThe user specifications capture the needs and expectations of the end-user.\nThe features describe the high-level capabilities of the application.\nFunctional requirements are the testable, specific actions, inputs, and outputs.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#application-developemnt",
    "href": "test_specs.html#application-developemnt",
    "title": "15  Specifications",
    "section": "15.2 Application developemnt",
    "text": "15.2 Application developemnt\nThe Shiny application development process follows something like the figure below:\n\n\n\nGeneral application development process\n\n\nThe figure above is an oversimplification, but it highlights a common separation (or ‘hand-off’) between users/stakeholders and developers. In the sections below, we’ll look at two common development processes: test-driven and behavior-driven development.\n\nTest-driven development\nIf sap was built using test-driven development (TDD), the process might look something like this:\n\nGather user needs and translate into application features:\n\nDocument the application’s capabilities for exploring movie review variables from IMDB and Rotten Tomatoes.\nInclude feature descriptions for displaying continuous variables (i.e., ‘critics score’ and ‘audience score’) categorical variables (i.e., ‘MPAA’ ), graph visual attributes (size, color, opacity), and an optional plot title.\n\nWrite Tests:\n\nWrite tests to ensure the graph displays relationships between a set of continuous and categorical variables when the app launches.\n\nRun Tests:\n\nBefore writing any code, these tests will fail.\n\nDevelop Features:\n\nWrite UI, server, module, and utility functions for user inputs and graph outputs.\n\nRerun Tests:\n\nIf the graph has been correctly implemented in the application, the tests should pass.\n\nWrite more Tests:\n\nAdd more tests for additional functionalities (e.g., an option to remove missing values from graph).\n\n\nStarting with tests and writing just enough code to get them to pass often results in developing less (but better) code. The drawback to this approach is a strict focus on the function being tested and not the overall objective of the application.\n\n\nBehavior-driven development\nIn behavior-driven development (BDD) (or behavior-driven testing), users and developers work together to understand, define and express application behaviors in non-technical language, 7\n\n“Using conversation and examples to specify how you expect a system to behave is a core part of BDD” - BDD in Action, 2ed\n\nPlacing an emphasis on writing human-readable expectations for the application’s behaviors makes it easier to develop tests that can focus on verifying each user need exists (and is functioning properly). In BDD, the application’s expected capabilities are captured in Features and illustrated with concrete examples, or Scenarios.\n\nFeatures\nIn BDD, a Feature describes an implemented behavior or capability in the application, from a user’s perspective. Typically, these are written in the Gherkin format using specific keywords:8\n\nAs a ...\n\nI want ...\n\nSo that ...\n\nBelow is an example Gherkin Feature for the graph in launch_app():\nFeature: Visualization\n    As a user\n    I want to see the changes in the plot\n    So that I can visualize the impact of my customizations\nAs you can see, the feature uses plain language and the wording is user-centric, so it remains accessible to both developers and users (or other non-technical stakeholders).\n\n\nScenarios\nA Gherkin Scenario provides a concrete example of how the Feature works and has the following general format:\n\nGiven ...\n\nWhen ...\n\nThen ...\n\nAn example Scenario for launch_app() might be:\n  Scenario: Viewing the Data Visualization\n    Given I have launched the application\n    And it contains movie review data from IMDB and Rotten Tomatoes\n    And the data contains variables like 'Critics Score' and 'MPAA'\n    When I interact with the controls in the sidebar panel\n    Then the graph should update with the selected options\n\n\nBackgrounds\nInstead of repeating any pre-conditions in each Scenario (i.e., the steps contained in the “Given” and first “And” statement), we can establish the context with a Background:\n  Background: Launching the application\n    Given I have launched the application\n    And it loads with movie review data from IMDB and Rotten Tomatoes\n    \n  Scenario: Viewing the Data Visualization\n    Given the data contains variables like 'Critics Score' and 'MPAA'\n    When I interact with the controls in the sidebar panel\n    Then the graph should update with the selected options\nAdopting the Gherkin format (or something similar) provides a common language to express an application’s behavior:\n\nAs developers, we can work with users and shareholders to write specifications that describe the expected behavior of each Feature\nWhen developing tests, we can group the tests by their Feature and Scenarios\nEach test can execute a step (i.e., the Then statements).\n\nIn the next section we’ll cover how to map test code for each Scenario step with testthat.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#sec-tests-specs-bdd-testthat",
    "href": "test_specs.html#sec-tests-specs-bdd-testthat",
    "title": "15  Specifications",
    "section": "15.3 BDD and testthat",
    "text": "15.3 BDD and testthat\ntestthat’s BDD functions (describe() and it()) allow us add Gherkin-style features and scenarios to our test files, ensuring the application remains user-centric while meeting the technical specifications.9\n\n15.3.1 Describe the feature\nWe can use the language from our Feature, Background, and Scenario to in the description in the argument of describe():\n\ndescribe(\n  description = \"Feature: Visualization\n                   As a user\n                   I want to see the changes in the plot\n                   So that I can visualize the impact of my customizations\",\n  code = {\n  \n})\n\nWe can also nest describe() calls, which means we can include the Background (or other relevant information):\n\n1describe(\n  \"Feature: Visualization\n      As a user\n      I want to see the changes in the graph\n      So that I can visualize the impact of my customizations.\", \n  code = {\n    \n2  describe(\n    \"Background: Launching the application\n        Given I have launched the application\n        And it loads with movie review data from IMDB and Rotten Tomatoes\", \n    code = {   \n               \n      })\n    \n  })\n\n\n1\n\nBDD Feature (title and description)\n\n\n2\n\nBackground (preexisting conditions before each scenario)\n\n\n\n\n\n\n15.3.2 Confirm it with a test\nInside describe(), we can include multiple it() blocks which “functions as a test and is evaluated in its own environment.”\nIn the example below, we’ll use an it() block to test the example scenario from above:10\n\n1describe(\n  \"Feature: Visualization\n      As a user\n      I want to see the changes in the graph\n      So that I can visualize the impact of my customizations.\", \n  code = {\n  \n2  describe(\n    \"Background: Launching the application\n        Given I have launched the application\n        And it loads with movie review data from IMDB and Rotten Tomatoes\",\n      code = {\n      \n3    it(\n      \"Scenario: Viewing the Data Visualization\n         Given the data contains variables like 'Critics Score' and 'MPAA'\n         When I interact with the controls in the sidebar panel\n         Then the graph should update with the selected options\",\n        code = {\n4          # test code\n        })\n      \n    })\n  \n})\n\n\n1\n\nBDD Feature (title and description)\n\n\n2\n\nBackground (preexisting conditions before each scenario)\n\n3\n\nScenario (a concrete examples that illustrates a feature)\n\n4\n\nTest code\n\n\n\n\nIn the scenario above, Then contains the information required for the testthat expectation. This could be expect_snapshot_file() or vdiffr::expect_doppelganger()–whichever makes sense from the user’s perspective.\nThese are generic examples, but hopefully the tests in the upcoming chapters convey how helpful and expressive BDD functions can be (or they inspire you to properly implement what I’m attempting to do in your own app-packages).11",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#sec-tests-specs-traceability-matrix",
    "href": "test_specs.html#sec-tests-specs-traceability-matrix",
    "title": "15  Specifications",
    "section": "15.4 Traceability Matrix",
    "text": "15.4 Traceability Matrix\nAfter translating the user needs into functional requirements, we can identify what needs to be tested by building a look-up table (i.e., a matrix).\nI like to store early drafts of the requirements and traceability matrix in a vignette:12\n\nusethis::use_vignette(\"specs\")\n\nAdding our first vignette to the vignettes/ folder does the following:\n\nAdds the knitr and rmarkdown packages to the Suggests field in DESCRIPTION13\n\nSuggests: \n    knitr,\n    rmarkdown\n\nAdds knitr to the VignetteBuilder field14\n\nVignetteBuilder: knitr\n\nAdds inst/doc to .gitignore and *.html, *.R to vignettes/.gitignore\n\nThe first column in the traceability matrix contains the user specifications, which we can ‘trace’ over to the functional requirements and their relevant tests.15\n\n\nTraceability Matrix\n\n\n\n\n\n\n\n\nSpecifications\nFeatures\nRequirements\nTest\n\n\n\n\nS1: The application should source movie review data from platforms like IMDB or Rotten Tomatoes\nF1.1:\nFeature: Movie Review Dataset Variables\nAs a user\nI want to have a dataset with variables from IMDB and Rotten Tomatoes\nIn order to provide comprehensive movie reviews\nBackground:\nGiven the application has access to IMDB and Rotten Tomatoes APIs\nScenario: Movie Review Continuous and Categorical Variables\nWhen the application loads from IMDB and Rotten Tomatoes movie review data\nThen the dataset should include a continuous critic ratings variable\nAnd the dataset should include a continuous audience ratings variable\nAnd the dataset should include a categorical mpaa ratings variable\nAnd the dataset should include a categorical genres variable\n\n\n\n\n\nBuilding a traceability matrix ensures:\n\nAll user specifications have accompanying application features.\nEach feature has been broken down into precise, measurable, and testable functional requirements.\nTests have been written for each functional requirement.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#recap",
    "href": "test_specs.html#recap",
    "title": "15  Specifications",
    "section": "Recap",
    "text": "Recap\n\n\nLaunch app with the shinypak package:\n\nlaunch('15_pecs')\n\nUnderstanding the relationship between user specifications, features, and functional requirements gives us the information we need to build applications that satisfy the technical standards while addressing user needs. Documenting requirements in Gherkin-style features and scenarios allows us to capture the application’s behavior without giving details on how the functionality is implemented.\nIn the next chapter, we’re going to cover various tools to improve the tests in your app-package. The overarching goal of these tools is to reduce code executed outside of your tests (i.e., placed above the call to test_that() or it()).\n\n\n\n\n\n\nRecap: Test Specifications\n\n\n\n\n\n\nSpecifications outline software goals and needs, and the functional requirements provide the technical details to achieve them.\n\nUser specifications: descriptions of what a user expects the application to do (i.e., the user ‘wish list’ of features they want in the application).\nFeatures: detailed list of the main capabilities and functions the application needs to offer to users.\nFunctional requierments: testable, specific step-by-step instructions for ensuring the application does what it’s supposed to do.\nTraceability matrix: tracking tool for connecting the users ‘wish list’ (i.e, specifications) to what’s being tested.\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#footnotes",
    "href": "test_specs.html#footnotes",
    "title": "15  Specifications",
    "section": "",
    "text": "Unit tests are covered extensively in R Packages, 2ed and the testthat documentation↩︎\nMastering shiny dedicates an entire Chapter to Testing. shinytest2 also has excellent documentation (and videos), and I highly recommend reading through those resources.↩︎\nThe next chapter covers a few tips and tricks for testing module server functions with testServer() because they’re not in the documentation.↩︎\nRead more about what goes in the Software Requirements Specification↩︎\nUser Specifications are sometimes referred to as “user stories,” “use cases,” or “general requirements”↩︎\n‘Features’ and ‘functional requirements’ are sometimes used interchangeably, but they refer to different aspects of the application. Features are high-level capabilities an application should have, and often contain a collection of smaller functionalities (broken down into the specific functional requirements).↩︎\nRead more about behavior-driven development↩︎\nGherkin is the domain-specific language format used for expressing software behaviors. Tools like Cucumber or SpecFlow maps and executes the Gherkin descriptions against the code to generate a pass/fail report status for each requirement.↩︎\nRead more about describe() and it() in the testthat documentation. and in the appendix.↩︎\nEach it() block contains the expectations (or what you would traditionally include in test_that()).↩︎\nFor an excellent description on the relationships between behavior-driven development, test-driven development, and domain-driven design, I highly recommend BDD in Action, 2ed by John Ferguson Smart and Jan Molack.↩︎\nStoring the traceability matrix in a vignette is great for developers, but using an issue-tracking system with version control is also a good idea, like GitHub Projects or Azure DevOps.↩︎\nWe briefly covered the Suggests field in Dependencies, but in this case it specifically applies to “packages that are not necessarily needed. This includes packages used only in examples, tests or vignettes…” - Writing R Extensions, Package Dependencies↩︎\nThe documentation on VignetteBuilder gives a great example of why knitr and rmarkdown belong in Suggests and not Imports.↩︎\nWhen building tables in vignettes, I highly recommend using the Visual Markdown mode.↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_tools.html",
    "href": "test_tools.html",
    "title": "16  Test tools",
    "section": "",
    "text": "16.1 Unit tests & LLMs\nThis chapter introduces some tools to help write clean and efficient tests. We’ll cover using the ensure package to help write tests, where to store test data, snapshots, and more. Most of topics and methods covered in R Packages, 2ed and the testthat documentation, but within the context of a standard R package .1\nI recommend using the ensure package to help write tests in your app-package. If you’re already using LLMs to help write code, ensure is a nice addition to your toolbox because of it’s focus on testing (we’ll cover these tools more in the Shiny Tools section).\nFollow the setup instructions to activate the addin (and I highly recommend creating a keyboard shortcut).",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#sec-test-tools-help",
    "href": "test_tools.html#sec-test-tools-help",
    "title": "16  Test tools",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('16.1_test-help')\n\n\n“The ensurer is familiar with testthat 3e as well as tidy style, and incorporates context from the rest of your R package to write concise and relevant tests.” - ensure documentation\n\n\n\n16.1.1 Help, not automation\nThe ensure package does a great job when writing basic unit tests, but as you’ll see, it doesn’t have a solid understanding of the specification or functional requirements of your application (only you know these). The test code created by ensure often needs some editing.\nFor example, the following test code was created for R/scatter_plot.R function:\n\ntest_that(\"scatter_plot creates a ggplot object\", {\n  \n  p &lt;- scatter_plot(mtcars, \"mpg\", \"hp\", \"cyl\", 0.7, 3)\n  \n  expect_s3_class(p, \"gg\")\n  expect_equal(ggplot2::ggplot_build(p)$layout$panel_ranges[[1]]$x.range,\n    range(mtcars$mpg))\n  expect_equal(ggplot2::ggplot_build(p)$layout$panel_ranges[[1]]$y.range,\n    range(mtcars$hp))\n})\n\ntest_that(\"scatter_plot handles different alpha and size values\", {\n  \n  p1 &lt;- scatter_plot(mtcars, \"mpg\", \"hp\", \"cyl\", 0.5, 2)\n  p2 &lt;- scatter_plot(mtcars, \"mpg\", \"hp\", \"cyl\", 1, 4)\n  \n  expect_true(p1$layers[[1]]$aes_params$alpha &lt; p2$layers[[1]]$aes_params$alpha)\n  expect_true(p1$layers[[1]]$aes_params$size &lt; p2$layers[[1]]$aes_params$size)\n})\n\nBased on the descriptions, these would test two important functional requirements of our application. However, two of these tests fail:\n[ FAIL 2 | WARN 0 | SKIP 0 | PASS 3 ]\n\n── Failure (test-scatter_plot.R:6:3): scatter_plot creates a ggplot object ─────\nggplot2::ggplot_build(p)$layout$panel_ranges[[1]]$x.range (`actual`) not equal to range(mtcars$mpg) (`expected`).\n\n`actual` is NULL\n`expected` is a double vector (10.4, 33.9)\n\n── Failure (test-scatter_plot.R:8:3): scatter_plot creates a ggplot object ─────\nggplot2::ggplot_build(p)$layout$panel_ranges[[1]]$y.range (`actual`) not equal to range(mtcars$hp) (`expected`).\n\n`actual` is NULL\n`expected` is a double vector (52, 335)\n[ FAIL 2 | WARN 0 | SKIP 0 | PASS 3 ]\nThis might lead us to believe our utility function is not behaving as expected. But when we dig into the method and values these tests are using, we discover it’s an issue with the test:\n\n# build plot\np &lt;- scatter_plot(mtcars, \"mpg\", \"hp\", \"cyl\", 0.7, 3)\n# check x \nggplot2::ggplot_build(p)$layout$panel_ranges[[1]]$x.range\n\nNULL\n\n# check y \nggplot2::ggplot_build(p)$layout$panel_ranges[[1]]$y.range\n\nNULL\nThe correct code for these tests would be the panel_params (not panel_ranges), but these aren’t going to work either, because ggplot2 automatically adjusts the axis limits based on the data and potential aesthetic mappings (which we can confirm with waldo::compare()):2\n\nwaldo::compare(\n  x = ggplot2::ggplot_build(p)$layout$panel_params[[1]]$x.range, \n  y = range(mtcars$mpg))\n\n`old`:  9.2 35.1\n`new`: 10.4 33.9\n\nwaldo::compare(\n  x = ggplot2::ggplot_build(p)$layout$panel_params[[1]]$y.range, \n  y = range(mtcars$hp))\n\n`old`: 37.9 349.1\n`new`: 52.0 335.0\nWe can continue trying to find something produced by ggplot2::ggplot_build(), but this test confirms the “scatter_plot creates a ggplot object”, so why not just use ggplot2::is.ggplot():\n\ntest_that(\"scatter_plot creates a ggplot object\", {\n  p &lt;- scatter_plot(mtcars, \"mpg\", \"hp\", \"cyl\", 0.7, 3)\n  expect_true(ggplot2::is.ggplot(p))\n})\ntest_that(\"scatter_plot handles different alpha and size values\", {\n  p1 &lt;- scatter_plot(mtcars, \"mpg\", \"hp\", \"cyl\", 0.5, 2)\n  p2 &lt;- scatter_plot(mtcars, \"mpg\", \"hp\", \"cyl\", 1, 4)\n  expect_true(p1$layers[[1]]$aes_params$alpha &lt; p2$layers[[1]]$aes_params$alpha)\n  expect_true(p1$layers[[1]]$aes_params$size &lt; p2$layers[[1]]$aes_params$size)\n})\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\nI’ve provided this example because it illustrates some important limitations when using ensure (or any LLMs) to help write code: Don’t confuse volume with precision. LLMs are great at generating copius amounts of code, but have no way of checking if the code is functional or accurate. In this case, it arguably would’ve taken less time to do the research and write the correct test (instead of debugging the one created by ensure).\nIt’s also worth pointing out that if the original test code did pass, the test_that() description wouldn’t the expectation (these belong in a “scatter_plot x and y limits match true range of values” test).\n\n\n16.1.2 Test scope\nOne of the recent updates to the testthat package (version 3.2.0) emphasizes limiting code that exists outside of our tests.3\n\n“Eliminating (or at least minimizing) top-level code outside of test_that() will have the beneficial effect of making your tests more hermetic. This is basically the testing analogue of the general programming advice that it’s wise to avoid unstructured sharing of state.” - Self-sufficient tests, R Packages, 2ed\n\nStrategies for reducing or removing the code outside of test_that() tests include:4\n\n\nMove file-scope logic to either narrower scope (just this test) or a broader scope (all files).\nIt’s ok to copy and paste: test code doesn’t have to be super DRY. Obvious &gt;&gt;&gt; DRY\n\n\nCode outside of test_that() usually serves a specific purpose (load or manipulate data, set options, create folders or files, etc). The section below describes methods for including these behaviors in tests without placing code outside the test scope.\n\n\n16.1.3 Test fixtures\n\nTest fixtures can be anything used to create repeatable test conditions (data, file paths, functions, etc.). Good test fixtures provide a consistent, well-defined test environment, and then are removed/destroyed when the test is executed. This ensures any changes made during the test don’t persist or interfere with future tests.5\nIn R packages, test fixtures are stored in the tests/testthat/fixtures/ folder:6\n\ntests/\n├── testthat/\n│   └── fixtures/                                         \n└── testthat.R",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#sec-test-data",
    "href": "test_tools.html#sec-test-data",
    "title": "16  Test tools",
    "section": "16.2 Test data",
    "text": "16.2 Test data\nLarge static data files are an example of a test fixture.7 Any code used to create test data should be stored with the output file (using a clear naming convention).\n\n\nLaunch app with the shinypak package:\n\nlaunch('16.2_test-data')\n\nFor example, I’ve stored the code used to create a ‘tidy’ version of the ggplot2movies::movies data along with the output dataset in tests/testthat/fixtures/:\n\ntests\n├── testthat\n│   ├── fixtures\n1│   │   ├── make-tidy_ggp2_movies\n2│   │   └── tidy_ggp2_movies.rds\n│   └── test-scatter_plot.R\n└── testthat.R\n\n3 directories, 4 files\n\n\n1\n\nThe code used to create the test data (make-make_tidy_ggp2_movies.R)\n\n2\n\nThe test data file (i.e., tidy_ggp2_movies.rds):\n\n\n\n\nData files stored in tests/testthat/fixtures/ can be accessed with testthat::test_path() inside each test.\nBelow is a test for the scatter_plot() utility function that answers the question, ‘does the plot generate without producing an error?’ using the tidy_ggp2_movies.rds test fixture:\n\n1describe(\n  \"Feature: Scatter plot data visualization\n     As a film data analyst\n     I want to explore IMDB.com movie review data \n     So that I can examine relationships between movie reivew metrics\n   Background:\n     Given I have IMDB movie reviews data  \n     And the data contains continuous variables like 'rating'\n     And the data contains categorical variables like 'mpaa'\", \n     code = {\n2    it(\n      \"Scenario: Scatter plot initial x, y, color values \n         When I launch the Scatter Plot Data Visualization\n         And I have a IMDB dataset of movie reviews \n         Then the plot should show 'Rating' on the x-axis\n         And the plot should show 'Length' on the y-axis\n         And the points on the plot should be colored by 'MPAA' rating\", \n        code = {\n3    ggp2_scatter_inputs &lt;- list(\n          x = \"rating\",\n          y = \"length\",\n          z = \"mpaa\",\n          alpha = 0.75,\n          size = 3,\n          plot_title = \"Enter plot title\"\n        )\n4    tidy_ggp2_movies &lt;- readRDS(test_path(\"fixtures\",\n                                \"tidy_ggp2_movies.rds\"))\n5    app_graph &lt;- scatter_plot(tidy_ggp2_movies,\n      x_var = ggp2_scatter_inputs$x,\n      y_var = ggp2_scatter_inputs$y,\n      col_var = ggp2_scatter_inputs$z,\n      alpha_var = ggp2_scatter_inputs$alpha,\n      size_var = ggp2_scatter_inputs$size\n    )\n6    expect_true(ggplot2::is.ggplot(app_graph))\n  }) \n\n})\n\n\n1\n\nFeature\n\n\n2\n\nScenario\n\n\n3\n\nTest inputs\n\n\n4\n\nTest fixture\n\n\n5\n\nCreate observed object\n\n\n6\n\nExpectation\n\n\n\n\nThis type of test is appropriate because we want to confirm the tidy movies data will generate a plot object when passed to our graphing utility function, not necessarily to verify the specific contents of the graph.8\nIf the tidy_ggp2_movies.rds file in the tests/testthat/fixtures/ folder are going to be used repeatedly, it might make sense to store the data in inst/extdata/ or data-raw/. Test fixtures are described in-depth in R Packages, 2ed and in the testthat documentation.\n\nTests in RStudio Tests in Positron \n\n\nIf we’ve created the keyboard shortcut for devtools::test_active_file() in RStudio, we’ll see the following in the Console.\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + T\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest active file in RStudio (click to enlarge)\n\n\n\n\nIn Positron, the Testing menu gives us a hierarchical breakdown of the describe() and it() testing functions. When we click on the Run Tests icon, we’ll see the following in the Test Results.\n\n\n\n\n\n\n\nRun tests in Positron (click to enlarge)",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#sec-test-logger",
    "href": "test_tools.html#sec-test-logger",
    "title": "16  Test tools",
    "section": "16.3 Test logging",
    "text": "16.3 Test logging\nAs we covered in the previous section (Chapter 13), we can create a test_logger() helper function to monitor our tests and provide additional context:\n\n#' Log test messages (helper)\n#'\n#' `test_logger()` logs informational messages using the `cli` package. It \n#' allows optional `start` and `end` tags to indicate the beginning and end of\n#' a process.\n#'\n#' @param start A character string indicating the start tag. Default is `NULL`.\n#' @param end A character string indicating the end tag. Default is `NULL`.\n#' @param msg A character string containing the log message.\n#'\n#' @details\n#' - If both `start` and `end` are `NULL`, logs only the message.\n#' - If `start` is provided and `end` is `NULL`, logs a message prefixed with \n#' `START &lt;start&gt; = &lt;msg&gt;`.\n#' - If `start` is `NULL` and `end` is provided, logs a message prefixed with \n#' `END &lt;end&gt; = &lt;msg&gt;`.\n#' - If both `start` and `end` are provided, logs both `START` and `END`\n#'  messages.\n#'\n#' @return Logs messages and returns `NULL` (used for side effects).\n#'\n#' @examples\n#' test_logger(msg = \"Processing started\")\n#' test_logger(start = \"Step1\", msg = \"Loading data\")\n#' test_logger(end = \"Step1\", msg = \"Data loaded successfully\")\n#' test_logger(start = \"Step2\", end = \"Step2\", msg = \"Performing computation\")\n#'\n#' @keywords internal\n#' \n#' @export\ntest_logger &lt;- function(start = NULL, end = NULL, msg) {\n  if (is.null(start) & is.null(end)) {\n    cat(\"\\n\")\n    cli::cli_inform(\"TEST:[{format(Sys.time(), '%Y-%m-%d %H:%M:%S')}] = {msg}\")\n  } else if (!is.null(start) & is.null(end)) {\n    cat(\"\\n\")\n    cli::cli_inform(\"\\nTEST: START [{format(Sys.time(), '%Y-%m-%d %H:%M:%S')}] {start} = {msg}\")\n  } else if (is.null(start) & !is.null(end)) {\n    cat(\"\\n\")\n    cli::cli_inform(\"\\nTEST: END [{format(Sys.time(), '%Y-%m-%d %H:%M:%S')}] {end} = {msg}\")\n  } else {\n    cat(\"\\n\")\n    cli::cli_inform(\"\\nTEST: START [{format(Sys.time(), '%Y-%m-%d %H:%M:%S')}]{start} = {msg}\")\n    cat(\"\\n\")\n    cli::cli_inform(\"\\nTEST: END [{format(Sys.time(), '%Y-%m-%d %H:%M:%S')}] {end} = {msg}\")\n  }\n}\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('16.3_test-logger')\n\ntest_logger() can be used to log the start and end of each test, and it includes a message argument (msg) we can use to reference the test description in each test_that() or it() call.9\nAn example of using test_logger() with the movies data is below:\n\ndescribe(\n  \"Feature: Scatter plot data visualization\n     As a film data analyst\n     I want to explore movie review data\n     So that I can examine relationships between movie reivew metrics\n   Background:\n     Given I have movie reviews data\n     And the data contains continuous variables like 'IMDB rating'\n     And the data contains categorical variables like 'mpaa'\",\n     code = {\n    test_that(\n      \"Scenario: Scatter plot initial x, y, color values \n         When I launch the Scatter Plot Data Visualization\n         And I have a IMDB dataset of movie reviews \n         Then the plot should show 'IMDB rating' on the x-axis\n         And the plot should show 'Audience score' on the y-axis\n         And the points on the plot should be colored by 'MPAA' rating\", \n        code = {\n          \n    ggp2_scatter_inputs &lt;- list(y = 'audience_score', \n                                x = 'imdb_rating',\n                                z = 'mpaa_rating',\n                                alpha = 0.5,\n                                size = 2,\n                                plot_title = 'Enter plot title')\n    \n1    test_logger(start = \"Step1\", msg = \"loading movies data\")\n    movies &lt;- sap::movies\n    test_logger(end = \"Step1\", msg = \"movies data loaded successfully\")\n    \n2    test_logger(start = \"Step2\", msg = \"creating graph\")\n    app_graph &lt;- scatter_plot(movies,\n      x_var = ggp2_scatter_inputs$x,\n      y_var = ggp2_scatter_inputs$y,\n      col_var = ggp2_scatter_inputs$z,\n      alpha_var = ggp2_scatter_inputs$alpha,\n      size_var = ggp2_scatter_inputs$size\n    )\n    test_logger(end = \"Step2\", msg = \"graph created\")\n    \n3    expect_true(ggplot2::is.ggplot(app_graph))\n  }) \n\n})\n\n\n1\n\nLog the data loading\n\n\n2\n\nLog the scatter_plot() function execution\n\n\n3\n\nRun the test\n\n\n\n\nWhen the test is run, the following output is printed to the Console:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nTEST: START [2025-02-06 07:50:53] Step1 = loading movies data\n\nTEST: END [2025-02-06 07:50:53] Step1 = movies data loaded successfully\n\nTEST: START [2025-02-06 07:50:53] Step2 = creating graph\n\nTEST: END [2025-02-06 07:50:53] Step2 = graph created\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nThere’s nothing prohibiting placing test_logger() in a testing utility file (R/testthat.R) below the R/ folder. Including testing functions in the R/ folder also ensures they’re documented (and any dependencies become part of your app-package).10\n\n16.3.1 Test helpers\n\n\n“Helper files are a mighty weapon in the battle to eliminate code floating around at the top-level of test files.” Testthat helper files, R Packages, 2ed\n\nTest helpers reduce repeated/duplicated test code. In general, objects or values that aren’t large enough to justify storing as static test fixtures can be created with helper functions. Helper functions are stored in tests/testthat/helper.R, which is automatically loaded with devtools::load_all():\n\ntests/\n  ├── testthat/\n1  │   ├── fixtures/\n  │   │   ├── make-tidy_ggp2_movies.R\n  │   │   └── tidy_ggp2_movies.rds\n2  │   ├── helper.R\n3  │   └── test-scatter_plot.R\n  └── testthat.R\n\n\n1\n\nTest fixture scripts and .rds files\n\n\n2\n\nHelper functions\n\n\n3\n\nTest file\n\n\n\n\nTest helpers should only be created if they make testing easier when the tests fail. The article, ‘Why Good Developers Write Bad Unit Tests’, provides great advice on complexity vs. clarity when writing unit tests,\n\n‘think about what will make the problem obvious when a test fails. Refactoring may reduce duplication, but it also increases complexity and potentially obscures information when things break.’\n\nR programmers resist copy + paste programming, and in most cases this makes sense. After all, R is a functional programming language, so it’s tempting to bundle any repeated code into a function and store it in the tests/testthat/helper.R file.\nHowever, when we’re writing tests, it’s more important that tests are easy to read and understand when they fail.\nFor example, consider the ggp2_scatter_inputs inputs passed to the scatter_plot() function in the previous test:\n\nggp2_scatter_inputs &lt;- list(  \n        x = \"rating\",\n        y = \"length\",\n        z = \"mpaa\",\n        alpha = 0.75,\n        size = 3,\n        plot_title = \"Enter plot title\"\n)            \n\nWe could write a var_inputs() function that stores these values in a list. In our tests, this would allow us to use var_inputs() with the same ‘reactive syntax’ we use with scatter_plot() in the module server function:\n\nvar_inputs &lt;- function() {\n   list(x = \"rating\",\n        y = \"length\",\n        z = \"mpaa\",\n        alpha = 0.75,\n        size = 3,\n        plot_title = \"Enter plot title\")\n}\nvar_inputs()\n## $x\n## [1] \"rating\"\n## \n## $y\n## [1] \"length\"\n## \n## $z\n## [1] \"mpaa\"\n## \n## $alpha\n## [1] 0.75\n## \n## $size\n## [1] 3\n## \n## $plot_title\n## [1] \"Enter plot title\"\n\nWhile this removes duplicated code, it also makes it less clear for the reader what var_inputs() contains and where it was created (without opening the helper.R file).\n\n1tidy_ggp2_movies &lt;- readRDS(test_path(\"fixtures\",\n                                \"tidy_ggp2_movies.rds\"))\n  \napp_graph &lt;- scatter_plot(\n  tidy_ggp2_movies,\n2  x_var = var_inputs()$x,\n  y_var = var_inputs()$y,\n  col_var = var_inputs()$z,\n  alpha_var = var_inputs()$alpha,\n  size_var = var_inputs()$size)\n\ntestthat::expect_true(ggplot2::is.ggplot(app_graph))\n\n\n1\n\nLoad test fixture\n\n\n2\n\nIdentical to the code in mod_scatter_display_server()\n\n\n\n\nIn contrast, the make_ggp2_inputs() function below creates inputs for the scatter_plot() utility function:\n\nmake_ggp2_inputs &lt;- function() {\n  glue::glue_collapse(\"list(x = 'rating',\n     y = 'length',\n     z = 'mpaa',\n     alpha = 0.75,\n     size = 3,\n     plot_title = 'Enter plot title'\n     )\"\n  )\n}\n\nI can call make_ggp2_inputs() in the Console and it will return the list of values to paste into each test:\n\nmake_ggp2_inputs()\n## list(x = 'rating',\n##      y = 'length',\n##      z = 'mpaa',\n##      alpha = 0.75,\n##      size = 3,\n##      plot_title = 'Enter plot title'\n##      )\n\nWhile copying and pasting this list into the test doesn’t reduce the number of keystrokes per test, it also doesn’t obscure the source of the values in the test (like with var_inputs()).\nglue::glue_collapse() is your friend when you want to quickly reproduce code for your tests. make_var_inputs() creates the list of inputs for testing the original movies data:\n\nmake_var_inputs &lt;- function() {\n  glue::glue_collapse(\"list(y = 'audience_score', \n     x = 'imdb_rating',\n     z = 'mpaa_rating',\n     alpha = 0.5,\n     size = 2,\n     plot_title = 'Enter plot title'\n    )\")\n}\n\n\n\n\n\n\n\nViolating the DRY principle\n\n\n\n\n\n\nIf you have repeated code in your tests, consider the following questions below before creating a helper function:\n\nDoes the code help explain what behavior is being tested?\nWould a helper make it harder to debug the test when it fails?\n\nIt’s more important that test code is obvious than DRY, because it’s more likely you’ll be dealing with this test when it fails (and you’re not likely to remember why all the top-level code is there).\n\n\n\n\n\n\n16.3.2 Test development\nWhile developing, using keyboard shortcuts makes it easier to iterate between building fixtures, writing and running tests, and checking code coverage.\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + R\n\n\n\n\n\n\n\n\ndevtools:::test_coverage_active_file()\n\n\n\n\n\n\n\n\nTest coverage on active file\n\n\nWe can see the test coverage on the scatter_plot() function is 100%, but this only covers a small percentage of the code in our app-package.\n\ndevtools:::test_coverage()\n\n\n\n\n\n\n\n\nTest coverage on sap package",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#sec-test-snapshots",
    "href": "test_tools.html#sec-test-snapshots",
    "title": "16  Test tools",
    "section": "16.4 Test snapshots",
    "text": "16.4 Test snapshots\n\n\n\n\n\n\nMocking\n\n\n\n\n\n\nTest mocks are covered in Appendix F, but the example isn’t from our app-package (it comes from the package development masterclass given at posit::conf(2023)).\n\n\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('16.4_test-snapshots')\n\nIf the expected output we’re interesting in testing is cumbersome to describe programmatically, we can consider using a snapshot tests.\nExamples of this include UI elements (which are mostly HTML created by Shiny’s UI layout and input/output functions) and data visualizations. Writing tests for these outputs can be difficult because their “correctness” is somewhat subjective and requires human judgment. 11\nI’ve included a small UI function (text_logo()) in the R/ folder of sap:\n\n\nshow/hide text_logo()\n#' Create a Text-based Logo in HTML\n#'\n#' `text_logo()` generates a text-based logo enclosed within HTML tags, allowing\n#' for the specification of the heading size (h1 through h6). The logo features\n#' a stylized representation of a face within arrows, using ASCII characters.\n#'\n#' @param size A character string specifying the heading size for the logo. \n#' Valid options include \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", and \"h6\". \n#' Defaults to \"h3\".\n#'\n#' @return An HTML object containing the logo. This object can be directly used\n#' in R Markdown documents or Shiny applications to render the logo in a web page.\n#'\n#' @examples\n#' # Generate a logo with default size h3\n#' text_logo()\n#'\n#' # Generate a logo with size h1\n#' text_logo(size = \"h1\")\n#'\n#'\n#' @export\ntext_logo &lt;- function(size = 'h3') {\n  if (any(size %in% c(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"))) {\n  htmltools::HTML(\n    paste0(\n    \"&lt;span&gt;\\n\", \n      paste0(\"  &lt;\", size, \"&gt;\", collapse = \"\"), \"\\n\",\n      \"    &lt;code&gt;√\\\\/--‹(•_•)›--√\\\\/&lt;/code&gt;\\n\", \n      paste0(\"  &lt;\", size, \"/&gt;\", collapse = \"\"), \"\\n\",\n    \"&lt;/span&gt;\\n\"\n      )\n    )\n  } else {\n    rlang::abort(paste(size, \"isnt supported\", sep = \" \"))\n  }\n}\n\n\nThis function generates the HTML so we can include a small logo in the UI.12\n\n\n\n\n\n\nThe output in the UI:\n\n\ntext_logo()\n\n\n\n\nThe pre-rendered HTML:\n\n\n&lt;span&gt;\n  &lt;h3&gt;\n    &lt;code&gt;√\\/--‹(•_•)›--√\\/&lt;/code&gt;\n  &lt;/h3&gt;\n&lt;/span&gt;\n\n\n\nReviewing the entire HTML contents of movies_ui() to see if text_logo() is working isn’t practical, but we can store it’s results in a snapshot file using expect_snapshot(). In tests/testthat/test-text_logo.R, I’ll write the following tests:13\n\nConfirm the default size argument:\n\ndescribe(\n    \"Scenario: Generating a logo with default size\n    Given the user did not specify a [size] in text_logo()\n    When text_logo() is invoked without a [size] argument\n    Then the correct HTML for a ['h3'] text logo is returned\",\n    code = {\n\n    test_that(\"text_logo()\", code = {\n      test_logger(start = \"snap\", msg = \"text_logo()\")\n      expect_snapshot(text_logo())\n      test_logger(end = \"snap\", msg = \"text_logo()\")\n    })\n  })\n\nConfirm a new size argument:\n\n  describe(\n    \"Scenario: Generating a logo of a specified size\n    Given the user wants a ['h1'] sized text logo\n    When text_logo(size = 'h1') is invoked \n    Then the correct HTML for a ['h1'] text logo is returned\", \n    code = {\n\n    test_that(\"text_logo('h1')\", code = {\n      test_logger(start = \"snap\", msg = \"text_logo('h1')\")\n      expect_snapshot(text_logo(\"h1\"))\n      test_logger(end = \"snap\", msg = \"text_logo('h1')\")\n    })  \n  })\n\nConfirm an invalid size argument:\n\ndescribe(\n  \"Scenario: Attempting to generate a logo with an invalid size\n  Given the user specifies an invalid [size] for the text logo\n  When text_logo() is invoked with an invalid [size] argument\n  Then an error is returned stating the [size] is not recognized\", \n  code = {\n  test_that(\"text_logo('invalid')\", code = {\n    test_logger(start = \"snap\", msg = \"text_logo('invalid')\")\n    expect_error(text_logo(\"massive\"), NULL)\n    test_logger(end = \"snap\", msg = \"text_logo('invalid')\")\n    })\n  })\n\n\nWhen we test this file, we see the following warnings about the creating of the snapshot files:\n\ndevtools:::test_active_file()\n\n\n\n\n\n\n\n\nTest snapshot warnings\n\n\n\n16.4.1 Reviewing _snaps/\nSnapshots are stored in the tests/testthat/_snaps/ folder. The output from expect_snapshot_file() is a markdown file with contents similar to what we saw above in the warning message. Should the markdown file contents change in future test runs, the tests will fail and we’ll be prompted to review the changes. 14\nFor example, if the &lt;span&gt; changed to a &lt;div&gt; in text_logo() and caused a test failure, I could review the changes in tests/testthat/_snaps/text_logo.md with testthat::snapshot_review('text_logo'):\n\n\n\n\n\n\n\n\n\n(a) testthat::snapshot_review('text_logo')\n\n\n\n\n\nFigure 16.1: Click Accept: Accepting snapshot: 'tests/testthat/_snaps/text_logo.md'\n\n\n\nFor examples of snapshot tests for graphical outputs, review the examples in Appendix F.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#recap",
    "href": "test_tools.html#recap",
    "title": "16  Test tools",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: Test tools\n\n\n\n\n\n\n\nTest tools\n\nIn this chapter, we’ve covered powerful testing tools provided by the testthat package. Let’s briefly recep what we’ve learned:\n\nTest Fixtures: We’ve seen how test fixtures are reliable for setting up a consistent testing environment. Using fixtures to load test data ensures that each test runs under uniform conditions. This approach enhances our tests’ reliability and simplifies the testing process by abstracting standard setup and teardown tasks.\n\nFixtures prepare the test environment and the initial state. The tidy_ggp2_movies.rds data is a test fixture, and it creates the tidy_ggp2_movies data within the test scope.\n\nTest Helpers: Helpers allow us to encapsulate repetitive tasks or setup configurations, making our tests cleaner, more readable, and easier to maintain. Whether it’s a custom function to create mock Shiny sessions or a utility for simulating user input, helpers streamline the testing workflow significantly.\n\nIf find yourself writing small, reusable pieces of code to perform specific tasks inside your tests, consider converting them into a function in tests/testthat/helper.R.\n\nTest Snapshots: Snapshot testing introduces the tests/testthat/_snaps folder for capturing and comparing the Shiny application state over time. Snapshot testing helps ensure that changes to the application do not unintentionally alter its behavior or appearance, and snapshot files allow us to quickly identify and address regressions by automatically detecting differences between the expected and actual snapshots.\n\nTest complex outputs using snapshots, but cautiously. Snapshots are susceptibile to failure with small (sometimes inconsequential) changes, which produce false negatives test failures.\n\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#footnotes",
    "href": "test_tools.html#footnotes",
    "title": "16  Test tools",
    "section": "",
    "text": "The three chapters in R Packages, 2ed, dedicated to testing are Testing basics, Designing your test suite, and Advanced testing techniques↩︎\nRead more about numeric position scales in the Position scales and axes chapter of ggplot2, 3e↩︎\nRead a summary of the changes to the testthat package on the tidyverse blog↩︎\nthese tips (and more!) were covered in the Package Development Masterclass delivered at posit::conf(2023)↩︎\nFor a concrete example, see this article on self-cleaning tests.↩︎\nThe name ‘fixtures’ isn’t required (you can name this folder anything).↩︎\nCreating a tidied version of ggplot2movies::movies would be costly to re-create with every test, so it’s advised to store it as an static test fixture.↩︎\nSnapshot tests would be more appropriate for answering the question, ‘is the plot visually correct?’.↩︎\nCheck out the logger package for more information on logging your app-package.↩︎\nPlacing common files for testing below R/ is covered in R Packages, 2ed↩︎\nGraph snapshots are covered in Appendix E.↩︎\nThis is a simple example, but I chose it because it needs some tricky escape characters to work.↩︎\nMastering Shiny covers creatng a snapshot file to test UI elements, but also notes this is probably not the best approach.↩︎\nWe’ll encounter this folder again in the Chapter 18 on system tests with shinytest2.↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_modules.html",
    "href": "test_modules.html",
    "title": "17  Testing modules",
    "section": "",
    "text": "17.1 Integration tests\nIn the previous chapters we covered using fixtures and helpers to our test suite. In this chapter, we’re going briefly discuss some tips for testing modules with Shiny’s testServer() function–specifically, how to verify modules are collecting and returning values correctly.\nIntegration tests verify that functions and components work together, and often involves instantiating multiple objects to interact with each other in a single test. In Shiny apps, integration tests typically involve using testServer() function to test reactive interactions between modules.\nFor example, to confirm that the UI module functions are working (i.e., that user-inputs are updating in the application), we need to test the following changes:\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TD\n    subgraph Inputs[\"Inputs\"]\n        subgraph Variables[\"mod_var_input\"]\n        var_input[/\"&lt;code&gt;input$x&lt;/code&gt;&lt;br&gt;&lt;code&gt;input$y&lt;/code&gt;&lt;br&gt;&lt;code&gt;input$z&lt;/code&gt;\"/]\n        end\n        subgraph Aesthetics[\"mod_aes_input\"]\n        aes_input[/\"&lt;code&gt;input$alpha&lt;/code&gt;&lt;br&gt;&lt;code&gt;input$size&lt;/code&gt;\"/]\n        plot_title[/\"&lt;code&gt;input$plot_title&lt;/code&gt;\"/]\n        end\n        \n    end\n    subgraph React[\"Server\"]\n        subgraph Display[\"mod_scatter_display\"]\n        var_inputs&gt;\"&lt;code&gt;var_inputs&lt;/code&gt; \"]\n        aes_inputs&gt;\"&lt;code&gt;aes_inputs&lt;/code&gt; \"]\n        inputs&gt;\"&lt;code&gt;inputs()&lt;/code&gt;\"]\n        end\n    end\n    subgraph Output[\"Output\"]\n        output[\\\"output$scatterplot\"\\]\n    end\n\n    var_input &lt;--&gt; |\"Pre-selected&lt;br&gt;values\"|var_inputs \n    aes_input &lt;--&gt; |\"Pre-selected&lt;br&gt;values\"|aes_inputs \n    plot_title -.-&gt; |\"User&lt;br&gt;input\"|aes_inputs \n    var_inputs & aes_inputs &lt;--&gt; |\"Assembled into..\"|inputs\n    inputs &lt;--&gt; |\"Rendered as...\"|output\n    \n    style var_input stroke:#333,stroke-width:1px,rx:5,ry:5 \n    style aes_input stroke:#333,stroke-width:1px,rx:5,ry:5\n    \n\n\n Module communication between UI and server",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#integration-tests",
    "href": "test_modules.html#integration-tests",
    "title": "17  Testing modules",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('17_test-modules')\n\n\n\nInput values collected in the UI are returned from mod_var_input and mod_aes_input modules\n\nThe returned values are passed into mod_scatter_display and rendered in the UI\n\n\n\n\n\n\n\n\n\n\nBDD refresher: features & scenarios\n\n\n\n\n\n\nIn BDD, requirements are written plain language ‘feature files’ using a series of keywords:\n\n1Feature:\n  As a\n  I want\n  So that\n  \n2  Background:\n3    Given\n    And\n    \n4  Scenario:\n5    When\n6    And\n7    Then\n\n\n1\n\nHigh-level description (title and description)\n\n\n2\n\nSteps or conditions that exist before each scenario\n\n\n3\n\nUsed to describe the initial context or preconditions for the scenario\n\n\n4\n\nA series of steps outlining a concrete examples that illustrates a feature\n\n\n5\n\nUsed to describe an event, or an action\n\n\n6\n\nUse to combine Given, When, or Then\n\n\n7\n\nUse to verify expected outcomes that are observable by a user\n\n\n\n\nFeature and Background information can be included in nested describe() blocks, but every Scenario (i.e., Then) keyword should have a corresponding it() or test_that() call.\nRead more about Gherkin on the Cucumber website..",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#sec-tests-mods-returned",
    "href": "test_modules.html#sec-tests-mods-returned",
    "title": "17  Testing modules",
    "section": "17.2 Testing return values",
    "text": "17.2 Testing return values\nWe’ll start with a test for the mod_var_input_server() function. Let’s simplify the diagram above to visualize what we’re attempting to capture in this test:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart \n    subgraph VarModule[\"Variable Module\"]\n        VarInputs[/\"Selected&lt;br&gt;Variables\"/]\n    end\n    subgraph AesModule[\"Aesthetic Module\"]\n        AesInputs[/\"Selected&lt;br&gt;Aesthetics\"/]\n    end\n    subgraph GraphDisplay[\"Display Module\"]\n        ScatterDiplay[\\\"Graph Display\"\\]\n    end\n    \n    VarInputs -.-&gt;|\"Returns x, y&lt;br&gt;and color\"|ScatterDiplay\n    AesInputs -.-&gt;|\"Returns size, &lt;br&gt;alpha and title\"|ScatterDiplay\n\n\n\n Variable and aesthetic returned values \n\n\n\nBased on our diagram, we’ll write feature, background, and scenario for the default values:\n\ndescribe(\n  \"Feature: Scatter Plot Configuration in Movie Review Application\n      As a user\n      I want the initial graph pre-configured with variables,\n      So that I can change the inputs and see a meaningful visualization.\",\n  code = {\n    describe(\n      \"Background: Initial scatter plot x, y, color values\n         Given the movie review application is loaded\n         And the initial x-axis value is [IMDB Rating]\n         And the initial y-axis value is [Audience Score]\n         And the initial color value is [MPAA Rating]\",\n      code = {\n        it(\"Scenario: Changing scatter plot x, y, and color values\n             Given the movie review application is loaded\n             When I choose the [Critics Score] for the x-axis\n             And I choose the [Runtime] for the y-axis\n             And I choose the [Title type] for color\n             Then the scatter plot should show [Critics score] on the x-axis\n             And the scatter plot should show [Runtime] on the y-axis\n             And the points on the scatter plot should be colored by [Title type]\", \n          code = {\n         \n         shiny::testServer(app = mod_var_input_server, expr = {\n            \n           # test code ----- \n           \n         })  \n       })\n    })\n})\n\nInside testServer():\n\nWe can create a list of initial graph inputs (test_vals), then\nPass identical values to session$setInputs(), and\nConfirm the returned object with session$returned() vs. test_vals,1 and finally\n\nWe’ll end the test by flushing the reactives set by session$setInputs() 2\n\n\ntestServer(app = mod_var_input_server, expr = { \n\n1    test_vals &lt;- list(\n      x = \"audience_score\",\n      y = \"imdb_rating\",\n      z = \"mpaa_rating\")\n    \n    test_logger(start = \"RETURNED\", msg = \"test_vals vs. session$returned()\")\n  \n2    session$setInputs(\n      x = \"audience_score\",\n      y = \"imdb_rating\",\n      z = \"mpaa_rating\")\n\n3    expect_equal(\n      object = session$returned(),\n      expected = test_vals)\n    \n    test_logger(end = \"RETURNED\", msg = \"test_vals vs. session$returned()\")\n    \n4    session$flushReact()\n  \n})\n\n\n1\n\nCreate output values for comparison\n\n\n2\n\nSet each input using setInputs(input = )\n\n3\n\nConfirm returned values against test_vals\n\n\n4\n\nFlush reactives\n\n\n\n\nThe test above confirms the initial values can be returned from mod_var_input_server() and the result of running test_active_file() on test-mod_var_input.R is below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nTEST: START [2025-02-06 08:43:46] RETURNED = test_vals vs. session$returned()\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nTEST: END [2025-02-06 08:43:47] RETURNED = test_vals vs. session$returned()",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#sec-tests-mods-args-list",
    "href": "test_modules.html#sec-tests-mods-args-list",
    "title": "17  Testing modules",
    "section": "17.3 Testing module inputs",
    "text": "17.3 Testing module inputs\nNow that we’ve confirmed the variable input module is returning the initial values from the UI, we want to make sure the reactive values are passed correctly into the graph display module. We’ll update our diagram for the module input arguments:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart \n    subgraph VarModule[\"Variable Module\"]\n        VarInputs[/\"Selected&lt;br&gt;Variables\"/]\n    end\n    subgraph AesModule[\"Aesthetic Module\"]\n        AesInputs[/\"Selected&lt;br&gt;Aesthetics\"/]\n    end\n    subgraph GraphDisplay[\"Display Module\"]\n        ScatterDiplay[\\\"Graph Display\"\\]\n    end\n    \n    VarInputs &lt;--&gt;|\"Collects x, y&lt;br&gt;and color\"|ScatterDiplay\n    AesInputs &lt;--&gt;|\"Collects size, &lt;br&gt;alpha and title\"|ScatterDiplay\n\n\n\n Variable and aesthetic collected values \n\n\n\nI’ve included the movies_server() function below to refresh our memory of how this should work:\n\nmovies_server &lt;- function(input, output, session) {\n      \n1  logr_msg(message = \"New user session started\", level = \"INFO\")\n            \n2  tryCatch({\n    selected_vars &lt;- mod_var_input_server(\"vars\")\n  }, error = function(e) {\n    logr_msg(glue::glue(\"Error in variable selection module: {e$message}\"), level = \"ERROR\") \n  })\n\n3  tryCatch({\n    selected_aes &lt;- mod_aes_input_server(\"aes\")\n  }, error = function(e) {\n    logr_msg(glue::glue(\"Error in aesthetics selection module: {e$message}\"),\n           level = \"ERROR\")\n  })\n\n4  tryCatch({\n    mod_scatter_display_server(\"plot\", \n                              var_inputs = selected_vars, \n                              aes_inputs = selected_aes)\n  }, error = function(e) {\n    logr_msg(glue::glue(\"Error in scatter display: {e$message}\"), \n    level = \"ERROR\")\n  })\n\n5  logr_msg(message = \"Server function execution completed\",\n           level = \"TRACE\")\n}\n\n\n1\n\nUser session log message\n\n\n2\n\nSelected variable inputs\n\n\n3\n\nSelected aesthetic inputs\n\n\n4\n\nVariables and aesthetics passed to scatter display module\n\n\n5\n\nServer execution log message\n\n\n\n\n\n17.3.1 Debugging and testing\nDebugging is your friend when you’re writing tests. We covered using browser() and the interactive debugger in the Debuggers chapter. browser() is a powerful tool for interactive debugging during development, and tests ensure long-term stability and reliability. I recommend using both in tandem, because the interactive debugger can help us understand reactivity, and then we can write tests to prevent bugs and errors and confirm fixes.\nFor example, if we pause execution with the interactive debugger in movies_server(), we can see the difference between calling selected_vars and selected_vars():\n\n\n\n\n\n\n\nselected_vars vs. selected_vars()\n\n\nWhen we pass selected_vars and selected_aes to the var_inputs and aes_inputs arguments, we’re not passing the returned values (this is why we don’t need the parentheses).\n\nmod_scatter_display_server(\"plot\", \n                          var_inputs = selected_vars, \n                          aes_inputs = selected_aes)\n\nWithout the parentheses, we’re calling on the method (or function) created by the call to reactive() (inside mod_var_input_server()).3\n\nBrowse[1]&gt; selected_vars\n\nreactive({\n    logr_msg(glue::glue(\"Reactive inputs returned: x = {input$x}, y = {input$y}, z = {input$z}\"), \n        level = \"DEBUG\")\n    list(x = input$x, y = input$y, z = input$z)\n}) \nViewing selected_vars() in the interactive debugger with the parentheses, we see the actual values from the mod_var_input module:\n\nBrowse[1]&gt; selected_vars()\n\n$x\n[1] \"imdb_rating\"\n\n$y\n[1] \"audience_score\"\n\n$z\n[1] \"mpaa_rating\"\nThis distinction is important because we need to know what to pass into the var_inputs and aes_inputs arguments when we test the mod_scatter_display_server() function.\nWe’ll start by writing the feature and scenario for this functionality using testthat’s BDD functions below:\n\ndescribe(\n  \"Feature: Scatter Plot Configuration in Movie Review Application\n      As a user \n      I want the initial graph pre-configured with variables and aesthetics,\n      So that I can immediately see a meaningful visualization.\",\n  code = {\n    it(\n      \"Scenario: Scatter plot initial x, y, color values \n         Given the movie review application is loaded\n         When I view the initial scatter plot\n         Then the scatter plot should show 'IMDB Rating' on the x-axis\n         And the scatter plot should show 'Audience Score' on the y-axis\n         And the points on the scatter plot should be colored by 'MPAA Rating'\n         And the size of the points should be set to '2'\n         And the opacity of the points should be set to '0.5'\n         And the plot title should be 'New Plot Title'\",\n      code = {\n        \n        # testServer() code\n        \n      })\n  })\n\nWe’re going to break the contents of testServer() down sequentially based on what we saw in the interactive debugger and the functionality of mod_scatter_display_server. We know we’re testing a module function that collects the reactive values, so we need to wrap those values in reactive() in the args() argument: 4\n\nshiny::testServer(\n  app = mod_scatter_display_server,\n  args = list(\n1    var_inputs =\n3      reactive(\n        list( \n            x = \"critics_score\",\n            y = \"imdb_rating\",\n            z = \"mpaa_rating\"\n          )\n        ),\n\n2      aes_inputs =\n4        reactive(\n          list( \n            alpha = 0.5,\n            size = 2,\n            plot_title = \"enter plot title\"\n            )\n          )\n\n  ),\n  expr = {\n\n})\n\n\n1\n\nvar_inputs argument in mod_scatter_display_server\n\n2\n\naes_inputs argument in mod_scatter_display_server\n\n3\n\nList of reactive variable inputs\n\n\n4\n\nList of reactive aesthetic inputs\n\n\n\n\nWe know that inside mod_scatter_display_server, the values collected from var_inputs and aes_inputs are assembled into a single inputs() reactive. We also know the plot title will be converted to title case before it’s rendered in the UI, so we need to account for this in the expected values.\n\nshiny::testServer(\n  app = mod_scatter_display_server,\n  args = list(\n1    var_inputs =\n3      reactive(\n        list( \n            x = \"critics_score\",\n            y = \"imdb_rating\",\n            z = \"mpaa_rating\"\n          )\n        ),\n\n2      aes_inputs =\n4        reactive(\n          list( \n            alpha = 0.5,\n            size = 2,\n            plot_title = \"enter plot title\"\n            )\n          )\n\n  ),\n  expr = {\n    test_logger(start = \"COLLECT\", msg = \"collected module values\")\n    expect_equal(\n5      object = inputs(),\n      expected = list(\n        x = \"critics_score\",\n        y = \"imdb_rating\",\n        z = \"mpaa_rating\",\n        alpha = 0.5,\n        size = 2,\n6        plot_title = \"Enter Plot Title\"\n      )\n    )\n    test_logger(end = \"COLLECT\", msg = \"collected module values\")\n})\n\n\n1\n\nvar_inputs argument in mod_scatter_display_server\n\n2\n\naes_inputs argument in mod_scatter_display_server\n\n3\n\nList of reactive variable inputs\n\n\n4\n\nList of reactive aesthetic inputs\n\n5\n\nCompare inputs() to initial values\n\n\n6\n\nTitle case plot title\n\n\n\n\nThe test_logger() can tell us when the expr begins (so we can assume there aren’t errors in the input arguments to args list).\n\ndevtools::test_active_file()\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nTEST: START [2025-02-06 08:20:36] COLLECT = collected module values\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nTEST: END [2025-02-06 08:20:36] COLLECT = collected module values\nI’ve included the example above because it’s not included on the testServer() documentation, and I’ve found this method works well if you want to confirm two modules are communicating (i.e., returning and collecting outputs). System test with shinytest2 are a better option if we’re trying to capture a more comprehensive execution path (i.e., user scenario) in the application.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#sec-tests-mods-coverage",
    "href": "test_modules.html#sec-tests-mods-coverage",
    "title": "17  Testing modules",
    "section": "17.4 Module test coverage",
    "text": "17.4 Module test coverage\nWhen we check the code coverage for the test above, we can see it confirms var_inputs is communicating the reactive values to inputs() in mod_scatter_display_server(), but this test doesn’t execute the call to plotOutput():\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + R\n\n\n\n\n\n\n\n\ndevtools:::test_coverage_active_file()\n\n\n\n\n\n\n\n17.4.1 Testing module outputs\nTo confirm the plot is being created properly in mod_scatter_display_server(), we can’t use the ggplot2::is.ggplot() function because the plot is being rendered by renderPlot(). However, we can verify the structure of the output$scatterplot object using any of the following expectations:\n\nexpect_true(\n  object = is.list(output$scatterplot))\n\nexpect_equal(\n  object = names(output$scatterplot),\n  expected = c(\"src\", \"width\", \"height\", \"alt\", \"coordmap\"))\n\nexpect_equal(\n  object = output$scatterplot[[\"alt\"]],\n  expected = \"Plot object\")\n\nIt’s also possible to build the graph inside the test using the same code from the module server function, then confirm it with ggplot2::is.ggplot():\n\n1    plot &lt;- scatter_plot(movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size) +\n    ggplot2::labs(\n      title = inputs()$plot_title,\n      x = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$x), \"_\", \" \"),\n      y = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$y), \"_\", \" \")) +\n    ggplot2::theme_minimal() +\n    ggplot2::theme(legend.position = \"bottom\")\n    \n2    testthat::expect_true(ggplot2::is.ggplot(plot))\n\n\n1\n\nBuild graph (same code from module function)\n\n\n2\n\nConfirm ggplot2 object is built\n\n\n\n\nIf we’re still skeptical this test is confirming the plot is being built correctly, we can pass plot to print() in the test and the plot will appear in the Plots pane.\n\n\n\n\n\n\n\nPassing plot to print() will send the graph to the Plots pane",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#recap",
    "href": "test_modules.html#recap",
    "title": "17  Testing modules",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: testing modules\n\n\n\n\n\n\n\n\nTesting modules\n\nThis chapter delves into the intricacies of testing Shiny modules. Let’s briefly recap the key points covered:\n\nsession$returned(): allows us to capture and examine the values returned by server-side functions, which is essential for validating the behavior of modules in response to user inputs and server-side processing.\nsession$flushReact() is crucial for testing reactive expressions and observers.\n\nUsing session$flushReact() forces the reactive system to execute, enabling us to test the outcomes of reactive expressions and observe their effects within the context of the module’s functionality.\n\nargs = list(): We discussed the importance of parameterizing module server functions using args = list() to facilitate more flexible and comprehensive testing.\n\nparameterizing modules can easily simulate various scenarios and inputs, enhancing test coverage and the robustness of each module’s functionality.\n\nModule Test Coverage: we outlined strategies for identifying critical paths through our module’s functionality, testing a range of inputs and user interactions, and ensuring that tests are efficient and maintainable.\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#footnotes",
    "href": "test_modules.html#footnotes",
    "title": "17  Testing modules",
    "section": "",
    "text": "Read more about returned values in the section titled, ‘Modules with return values’ in the Shiny documentation.↩︎\nRead more about flushing reactive values in the section titled, ‘Flushing Reactives’ in the Shiny documentation.↩︎\nselected_vars are the reactive variable names returned from mod_var_input_server() and selected_aes are the reactive size, alpha, and title values returned from mod_aes_input_server().↩︎\nRead more about adding parameters to testServer() in the section titled, ‘Modules with additional parameters’ in the Shiny documentation.↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_system.html",
    "href": "test_system.html",
    "title": "18  System tests",
    "section": "",
    "text": "18.1 Current tests\nThis chapter covers using shinytest2 and testthat to perform system tests on the features and scenarios in your app-package.\nSystem (or end-to-end) tests simulate real user interactions in a ‘pre-production’ environment to verify the whole application (or system) works.1 Approaches to system testing vary, but in general, we’ll want to run a system test for each feature in our application before a release.\nIf we’ve been documenting our unit and integration tests with BDD feature and scenario descriptions, the system tests can be used to confirm the functional requirements for the primary execution path (or user experience) before release.\nThe current files in our tests folder are below:\nThe output from devtools::test() is below:\ndevtools::test()",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#current-tests",
    "href": "test_system.html#current-tests",
    "title": "18  System tests",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('17_test-modules')\n\n\ntests\n├── testthat\n│   ├── _snaps\n│   │   └── text_logo.md\n│   ├── fixtures\n│   │   ├── make-tidy_ggp2_movies.R\n│   │   └── tidy_ggp2_movies.rds\n│   ├── helper.R\n│   ├── setup-shinytest2.R\n│   ├── test-mod_scatter_display_server.R\n│   ├── test-mod_var_input_server.R\n│   ├── test-scatter_plot.R\n│   └── test-text_logo.R\n└── testthat.R\n\n4 directories, 10 files\n\n\n✔ | F W  S  OK | Context\n⠏ |          0 | mod_scatter_display_server                                               \nTEST: START [2025-02-12 07:47:04] COLLECT = collected module values\n\nTEST: END [2025-02-12 07:47:04] COLLECT = collected module values\n\nTEST: START [2025-02-12 07:47:04] OUTPUT = is list\n⠙ |          2 | mod_scatter_display_server                                               \nTEST: END [2025-02-12 07:47:04] OUTPUT = is list\n\nTEST: START [2025-02-12 07:47:04] OUTPUT = names\n\nTEST: END [2025-02-12 07:47:04] OUTPUT = names\n\nTEST: START [2025-02-12 07:47:04] OUTPUT = Plot object\n⠸ |          4 | mod_scatter_display_server                                               \nTEST: END [2025-02-12 07:47:04] OUTPUT = Plot object\n\nTEST: START [2025-02-12 07:47:04] OUTPUT = is ggplot\n\nTEST: END [2025-02-12 07:47:04] OUTPUT = is ggplot\n✔ |          5 | mod_scatter_display_server\n⠏ |          0 | mod_var_input_server                                                     \nTEST: START [2025-02-12 07:47:05] RETURNED = test_vals vs. session$returned()\n\nTEST: END [2025-02-12 07:47:05] RETURNED = test_vals vs. session$returned()\n✔ |          1 | mod_var_input_server\n⠏ |          0 | scatter_plot                                                             \nTEST: START [2025-02-12 07:47:05] Step1 = loading movies data\n\nTEST: END [2025-02-12 07:47:05] Step1 = movies data loaded successfully\n\nTEST: START [2025-02-12 07:47:05] Step2 = creating graph\n\nTEST: END [2025-02-12 07:47:05] Step2 = graph created\n✔ |          1 | scatter_plot\n⠏ |          0 | text_logo                                                                \nTEST: START [2025-02-12 07:47:05] snap = text_logo()\n\nTEST: END [2025-02-12 07:47:05] snap = text_logo()\n\nTEST: START [2025-02-12 07:47:05] snap = text_logo('})')\n⠙ |          2 | text_logo                                                                \nTEST: START [2025-02-12 07:47:05] snap = text_logo('h1')\n\nTEST: START [2025-02-12 07:47:05] snap = text_logo('invalid')\n\nTEST: END [2025-02-12 07:47:05] snap = text_logo('invalid')\n✔ |          3 | text_logo\n\n══ Results ════════════════════════════════════════════════════════════════\nDuration: 1.8 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]\n\n\nNice code.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#sec-tests-system-shinytest2",
    "href": "test_system.html#sec-tests-system-shinytest2",
    "title": "18  System tests",
    "section": "18.2 Setting up shinytest2",
    "text": "18.2 Setting up shinytest2\nshinytest2 requires a few steps to get up and running (most notably the chromote package), but you’ll find excellent documentation on the package website.2\nThe shinytest2::use_shinytest2() performs the following setup steps:\n\n✔ Adding shinytest2::load_app_env() to tests/testthat/setup-shinytest2.R\n✔ Adding *_.new.png to .gitignore\n✔ Adding _\\\\.new\\\\.png$ to .Rbuildignore\n✔ Adding shinytest2 to Suggests field in DESCRIPTION\n\nWe also get some advice on using shinytest2 functions in our code:\n• In your package code, use `rlang::is_installed(\"shinytest2\")` or\n  `rlang::check_installed(\"shinytest2\")` to test if shinytest2 is installed\n• Then directly refer to functions with `shinytest2::fun()`\nAfter setting up shinytest2, be sure you can create a new chromote session like the one below:\n\nlibrary(chromote)\nb &lt;- ChromoteSession$new()\nb$view()\n\n\n\n\n\n\n\n\n\n\n(a) Chromium headless browser\n\n\n\n\n\nFigure 18.1: A new Chromote session\n\n\n\nIf you run into problems running shinytest2 tests, you can upgrade chromium (if you’re on Mac using homebrew):\n\nbrew install --cask chromium",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#sec-tests-system-recording-tests",
    "href": "test_system.html#sec-tests-system-recording-tests",
    "title": "18  System tests",
    "section": "18.3 Record a test",
    "text": "18.3 Record a test\nIf we launch the test recorder with shinytest2::record_test(), change the inputs in our application, click on Expect Shiny values and Save test and exit, a test is recorded to a new test file: tests/testthat/test-shinytest2.R\n\n\n\nCreating a test with shinytest2::record_test()\n\n\nThe test runs and saves the PNG snapshot and test values to the tests/testthat/_snaps/ folder:\nLoading required package: shiny\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\n── Warning (test-shinytest2.R:10:3): {shinytest2} recording: sap-feature-01 ────────\nAdding new file snapshot: 'tests/testthat/_snaps/sap-feature-01-001_.png'\n\n── Warning (test-shinytest2.R:10:3): {shinytest2} recording: sap-feature-01 ────────\nAdding new file snapshot: 'tests/testthat/_snaps/sap-feature-01-001.json'\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\n\n\n\n\n\nloadSupport warning with shinytest2\n\n\n\n\n\n\nAfter setting up shinytest2, the tests/testthat/setup-shinytest2.R file contains a call to shinytest2::load_app_env(). This runs automatically with shinytest2 tests and produces a familiar warning:\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears\n  to contain an R package. Sourcing files in R/ may cause unexpected behavior.\nWe covered this warning message in the Launch chapter, and it’s being addressed in a future release of shinytest2\n\n\n\n\nIf we view the contents test-shinytest2.R we find each action we performed in the test recorder has a corresponding call in the test:\n\nlibrary(shinytest2)\ntest_that(\"{shinytest2} recording: sap-feature-01\", {\n1  app &lt;- AppDriver$new(name = \"sap-feature-01\", height = 887, width = 1241)\n2  app$set_inputs(`vars-y` = \"imdb_num_votes\")\n3  app$set_inputs(`vars-x` = \"critics_score\")\n4  app$set_inputs(`vars-z` = \"genre\")\n5  app$set_inputs(`aes-alpha` = 0.7)\n6  app$set_inputs(`aes-size` = 3)\n7  app$set_inputs(`aes-plot_title` = \"New plot title\")\n8  app$expect_values()\n})\n\n\n1\n\nInitialize the AppDriver$new() with the name of the test and the dimensions of the Chromium browser.\n\n\n2\n\nChange the y axis (vars-y) to ‘IMBD number of votes’ (imdb_num_votes)\n\n\n3\n\nChange the x axis (vars-x) to ‘Critics Score’ (critics_score)\n\n\n4\n\nChange the color by (vars-z) to ‘Genre’ (genre)\n\n\n5\n\nChange the point opacity (aes-alpha) to ‘0.7’\n\n\n6\n\nChange the point size (aes-alpha) to ‘3’\n\n\n7\n\nChange the plot title to (aes-plot_title) to ‘New plot title’\n\n8\n\nExport the test values\n\n\n\n\nWe’ll use this initial test as a template for writing the steps in our test Scenarios.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#sec-tests-system-shinytest2-bdd",
    "href": "test_system.html#sec-tests-system-shinytest2-bdd",
    "title": "18  System tests",
    "section": "18.4 shinytest2 and BDD",
    "text": "18.4 shinytest2 and BDD\nThere are multiple ways to approach your test layout with testthat’s describe(), it() and/or test_that() functions. Below is an example with dedicated Feature and Scenario descriptions, and a reference to the feature number in an it() call:\n\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie reivew sources\", {\n             \ndescribe(\"Scenario: Change dropdown values for plotting\n            Given the movie review application is loaded\n            When I choose the variable [ ] for the x-axis\n            And I choose the variable [ ] for the y-axis\n            And I choose the variable [ ] for the color\n            And I choose the size of the points to be [ ]\n            And I choose the opacity of the points to be [ ]\n            And I enter '[ ]' for the plot title\n           \n            Then the scatter plot should show [ ] on the x-axis\n            And the scatter plot should show [ ] on the y-axis\n            And the points on the scatter plot should be colored by [ ]\n            And the size of the points on the scatter plot should be [ ]\n            And the opacity of the points on the scatter plot should be [ ]\n            And the title of the plot should be '[ ]'\", {\n              \n              it(\"Feature 01\", {\n                    app &lt;- AppDriver$new(name = \"feature-01\", \n                                       height = 800, width = 1173)\n                  app$set_inputs(`vars-y` = \"imdb_num_votes\")\n                  app$set_inputs(`vars-x` = \"critics_score\")\n                  app$set_inputs(`vars-z` = \"genre\")\n                  app$set_inputs(`aes-alpha` = 0.7)\n                  app$set_inputs(`aes-size` = 3)\n                  app$set_inputs(`aes-plot_title` = \"New plot title\")\n                  app$expect_values()\n              })\n      })\n})\n\nWith this approach, you can create the test file as soon as you have a Feature description (and come back later to fill in the Scenarios and tests).\nAn alternative approach is to use nested describe() functions with each Then step in the it() call (these are what will actually be tested):\n\nlibrary(shinytest2)\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie review sources\", {\n1\n  describe(\"Scenario A: Change dropdown values for plotting \n             Given the movie review application is loaded\n             When I choose the variable [ ] for the x-axis\n             And I choose the variable [ ] for the y-axis\n             And I choose the variable [ ] for the color\", {\n        it(\"Then the scatter plot should show [ ] on the x-axis\n             And the scatter plot should show [ ] on the y-axis\n             And the points on the scatter plot should be colored by [ ]\", {\n              app &lt;- AppDriver$new(name = \"feature-01-scenario-a\",\n                                     height = 800, width = 1173)\n                app$set_inputs(`vars-y` = \"imdb_num_votes\")\n                app$set_inputs(`vars-x` = \"critics_score\")\n                app$set_inputs(`vars-z` = \"genre\")\n                app$expect_values()\n       })\n     }) \n\n2\n  describe(\"Scenario B: Change dropdown values for plotting\n              Given the movie review application is loaded\n              When I choose the size of the points to be [ ]\n              And I choose the opacity of the points to be [ ]\n              And I enter '[ ]' for the plot title\", {\n         it(\"Then the size of the points on the scatter plot should be [ ]\n              And the opacity of the points on the scatter plot should be [ ]\n              And the title of the plot should be '[ ]'\", {\n              app &lt;- AppDriver$new(name = \"feature-01-scenario-b\",\n                                     height = 800, width = 1173)\n                app$set_inputs(`aes-alpha` = 0.7)\n                app$set_inputs(`aes-size` = 3)\n                app$set_inputs(`aes-plot_title` = \"New plot title\")\n                app$expect_values()\n        })\n      })\n\n})\n\n\n1\n\nTest for scenario A\n\n\n2\n\nTest for scenario B\n\n\n\n\nAn important note with this approach is the different names for each AppDriver$new() (otherwise we’d be overwriting the previous snapshot/values).\n\n18.4.1 Testing multiple apps\nIf we want to test a feature for one of our alternative applications in the inst/ folder, we can use system.file() to pass their location to the app_dir argument of AppDriver$new().\nIn the test below, the scenario describes changing inputs for x, y, and color:\n\nlibrary(shinytest2)\ndescribe(\n  \"Feature 1: Scatter plot data visualization dropdowns\n     As a film data analyst\n     I want to explore movie review variables \n     So that I can analyze relationships between movie attributes and ratings\", {\n  describe(\n    \"Scenario: Change dropdown values for plotting\n        Given the movie review application is loaded\n        When I choose the variable ['Critics Score'] for the x-axis\n        And I choose the variable ['IMDB number of votes'] for the y-axis\n        And I choose the variable ['Genre'] for the color\", code = {\n    it(\"Then the scatter plot should show ['Critics Score'] on the x-axis\n        And the scatter plot should show ['IMDB number of votes'] on the y-axis\n        And the points on the scatter plot should be colored by ['Genre']\", {\n            \n    test_logger(start = 'prod-feat-01', msg = \"update x, y, and z\")\n      \n1    app &lt;- AppDriver$new(system.file(\"prod/app\", package = \"sap\"),\n                         name = \"prod-feat-01\", \n2                         wait = FALSE, timeout = 3000,\n                         height = 800, width = 1173)\n    \n          app$set_inputs(`vars-y` = \"imdb_num_votes\")\n          app$set_inputs(`vars-x` = \"critics_score\")\n          app$set_inputs(`vars-z` = \"genre\")\n          app$set_inputs(`aes-alpha` = 0.7)\n          app$set_inputs(`aes-size` = 3)\n          app$set_inputs(`aes-plot_title` = \"New plot title\")\n\n          app$expect_values()\n          \n      test_logger(end = 'prod-feat-01', msg = \"update x, y, and z\")\n      \n      })\n   })\n})\n\n\n1\n\nUse system.file() to access application in inst/tidy-data\n\n\n2\n\nAdjust the wait and timeout so the test will run\n\n\n\n\nNote that I’ve changed the wait and timeout arguments in AppDriver$new() because this tests takes over 10 seconds to complete (which I can see with my test_logger() output). When I confirm this in the output png file, I can see the x, y, and color values have been changed (and the missing values have been removed).\n\n\n\nFile saved in tests/testthat/_snaps/prod-feat-01-001_.png'",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#sec-tests-system-test-mode",
    "href": "test_system.html#sec-tests-system-test-mode",
    "title": "18  System tests",
    "section": "18.5 The test.mode option",
    "text": "18.5 The test.mode option\nWe’ve included an argument in both of the standalone app functions to allow for options to be passed to shinyApp():\n\nlaunch_app(options = list())\n\nIf we’re testing our application, we can include the test.mode = TRUE option, which will return any values passed to exportTestValues():\n\nlaunch_app(options = list(test.mode = TRUE), run = 'p')\n\nWe can also include this in our .Rprofile as:3\n\noptions(shiny.testmode = TRUE)",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#sec-tests-system-export-values",
    "href": "test_system.html#sec-tests-system-export-values",
    "title": "18  System tests",
    "section": "18.6 Exporting test values",
    "text": "18.6 Exporting test values\nTo export values, place the name of exported reactive values in curly brackets ({}). Below is an example using the inputs() reactive object in the mod_scatter_display_server():\n\nexportTestValues(\n   x = { inputs()$x },\n   y = { inputs()$y },\n   z = { inputs()$z },\n   alpha = { inputs()$alpha },\n   size = { inputs()$size },\n   title = { inputs()$plot_title }\n  )\n\nIn our test, we can create the AppDriver$new() object, extract the values with get_values():\n\napp &lt;- AppDriver$new(name = \"test-values\",\n                     height = 800, width = 1173,\n                     wait = FALSE, timeout = 300000)\n\ntest_values &lt;- app$get_values()\n\ntest_values[['export']]\n\n$`plot-alpha`\n[1] 0.5\n\n$`plot-size`\n[1] 2\n\n$`plot-title`\n[1] \"\"\n\n$`plot-x`\n[1] \"imdb_rating\"\n\n$`plot-y`\n[1] \"audience_score\"\n\n$`plot-z`\n[1] \"mpaa_rating\"\nNow we can write tests against any of the exported values:\n\nexpect_equal(object = test_values[['export']]$`plot-alpha`, expected = 0.5)\nexpect_equal(object = test_values[['export']]$`plot-size`, expected = 2)\nexpect_equal(object = test_values[['export']]$`plot-title`, expected = \"\")\nexpect_equal(object = test_values[['export']]$`plot-x`, expected = \"imdb_rating\")\nexpect_equal(object = test_values[['export']]$`plot-y`, expected = \"audience_score\")\nexpect_equal(object = test_values[['export']]$`plot-z`, expected = \"mpaa_rating\")",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#test-failures",
    "href": "test_system.html#test-failures",
    "title": "18  System tests",
    "section": "18.7 Test failures",
    "text": "18.7 Test failures\nIn Positron , the Testing menu item gives us a display of the test files and individual tests.\n\n\n\n\n\n\n\nTests in Positron (click to enlarge)\n\n\nWhen a test fails, we’re alerted of the failure and the specific test the output didn’t meet the expectation:\n\n\n\n\n\n\n\nTest failures in Positron (click to enlarge)\n\n\nIn this case, we can see it’s just a typo in the expected output. After making the change, we can re-run the tests and view the output in the TEST RESULTS:\n\n\n\n\n\n\n\nFixing test failures in Positron (click to enlarge)\n\n\nTEST RESULTS also keeps a record of the previous test runs for us to review.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#test-_snaps",
    "href": "test_system.html#test-_snaps",
    "title": "18  System tests",
    "section": "18.8 Test _snaps/",
    "text": "18.8 Test _snaps/\nAfter writing our system tests and running devtools::test(), the tests/testthat/_snaps/ folder contains the follow folders and files:\ntests/testthat/_snaps/\n├── shinytest2\n│   ├── feature-01-scenario-a-001.json\n│   ├── feature-01-scenario-a-001_.png\n│   ├── feature-01-senario-b-001.json\n│   └── feature-01-senario-b-001_.png\n├── shinytest2-prod\n│   ├── prod-feat-01-001.json\n│   └── prod-feat-01-001_.png\n└── text_logo.md\n\n3 directories, 7 files\nThese outputs correspond to the test files that create snapshots in the tests/testthat/ folder:\ntests/testthat/\n├── test-shinytest2-export.R\n├── test-shinytest2-prod.R\n└── test-shinytest2.R\n\n\n\n\n\n\nThe _snaps folder\n\n\n\n\n\n\nI’ve removed the tests/testthat/_snaps/ folder from the GitHub repo, so users can run the tests and generate the snapshots in their local environment.\n\n\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('18_tests-system')",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#recap",
    "href": "test_system.html#recap",
    "title": "18  System tests",
    "section": "Recap",
    "text": "Recap\nAdopting a behavior-driven development approach in system testing can help to fill the gulf between non-technical stakeholders and developers by encouraging natural, descriptive language. Using complete sentences to describe to define and communicate the application requirements will make it easier for anyone to catch unexpected behaviors.\nUsing ‘Features’ (As a , I want, So that) and ‘Scenarios’ (Given, When, Then) make system tests clear (and easier to update if the specifications change).\n\n\n\n\n\n\nRecap   \n\n\n\n\n\n\n\nSystem tests\n\n\nrecord_test() simplifies the creation of system tests by recording interactions with your Shiny app.\n\nUsing record_test() accelerates test creation and ensures our tests accurately reflect user behavior, making it easier to catch issues that could affect user experience.\n\nUse AppDriver$new() to manually create tests for more control and customization.\n\nScripting tests with shinytest2 allows for detailed user interactions and testing specific functionalities in isolation or under unique conditions, offering a granular approach to system testing.\n\nUse exportTestValues() in tandem with test.mode to expose and verify the internal state of a Shiny app during tests.\n\nThis technique is crucial for testing the logic and data behind your app’s UI, ensuring that the app looks right and operates correctly under various scenarios.\n\n\nBDD functions\n\nUsing testthat’s BDD functions makes system tests easier to update if the features and scenarios change.\n\nCapturing the application’s desired behaviors in Features (As a , I want, So that) and Scenarios (Given, When, Then) provides a testing script that’s clear and easy to follow.\n\nuse describe() and it() to add features and sceanrios in test files.\ndescribe('Feature...', code = {\n    it('Scenario...', code = { ... })\n})\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#footnotes",
    "href": "test_system.html#footnotes",
    "title": "18  System tests",
    "section": "",
    "text": "System tests should strive to replicate the production conditions, even when/if it’s not possible to perfectly replicate the environment.↩︎\nA great place to start is the Getting Started vignette.↩︎\nWe covered the .Rprofile in Section 4.7.3.↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "deploy.html",
    "href": "deploy.html",
    "title": "Deploy",
    "section": "",
    "text": "Deploy\nExpand the callout boxes below to review the previous testing chapters:\nThis section covers four common ways for deploying a Shiny app-package: 1) launching an app on shinyapps.io, 2) Docker images and containers, 3) using GitHub Actions for Continuous Integration (CI) and Continuous Deployment (CD), and 4) building and deploying a package website with pkgdown.",
    "crumbs": [
      "Deploy"
    ]
  },
  {
    "objectID": "deploy.html#shinyapps.io",
    "href": "deploy.html#shinyapps.io",
    "title": "Deploy",
    "section": "Shinyapps.io",
    "text": "Shinyapps.io\nShinyapps.io is a self-service publishing platform operated by Posit. Users can deploy applications, reports, and APIs to the cloud on shared servers. This chapter covers:\n\n19.1 Publishing with rsconnect\n\n19.2 Deploy logs\n\n19.3 The rsconnect folder\n\n19.4 App logs",
    "crumbs": [
      "Deploy"
    ]
  },
  {
    "objectID": "deploy.html#docker",
    "href": "deploy.html#docker",
    "title": "Deploy",
    "section": "Docker",
    "text": "Docker\nDocker covers how using Docker can simplify setting up your R environment and reduce the “it works on my machine” problem:\n\n20.1 What is Docker  ?\n\n20.2 Installing Docker\n\n20.3 Writing a Dockerfile\n\n20.4 Build the Docker image\n\n20.5 Running the container\n\n20.6 Docker & golem\n\n20.7 Docker in app-packages",
    "crumbs": [
      "Deploy"
    ]
  },
  {
    "objectID": "deploy.html#github-actions",
    "href": "deploy.html#github-actions",
    "title": "Deploy",
    "section": "GitHub Actions",
    "text": "GitHub Actions\nContinuous Integration/Continuous Deployment (CI/CD) can be implemented for your Shiny app-package using GitHub actions. This chapter covers the following workflows:\n\n21.1 Code styling and linting\n\n21.2 Shiny app deployment\n\n21.3 Actions, Shiny & Docker",
    "crumbs": [
      "Deploy"
    ]
  },
  {
    "objectID": "deploy.html#package-websites",
    "href": "deploy.html#package-websites",
    "title": "Deploy",
    "section": "Package websites",
    "text": "Package websites\npkgdown helps us easily create websites for our app-packages. This chapter covers:\n\n22.1 Setting up pkgdown\n\n22.2 Building site\n\n22.3 Customize layout\n\n22.3.3 Function reference\n\n22.4 Deploying your site",
    "crumbs": [
      "Deploy"
    ]
  },
  {
    "objectID": "shinyappsio.html",
    "href": "shinyappsio.html",
    "title": "19  shinyapps.io",
    "section": "",
    "text": "19.1 Publishing with rsconnect\nThis chapter covers deploying your app-package to shinyapps.io, a cloud-based hosting service provided by Posit (formerly RStudio) for deploying and managing Shiny applications, Quarto/RMarkdown reports, APIs, and other content. We deployed the production version of our application in the previous Section 9.4.2, but we will go into more depth below.\nBelow we’ll cover deploying your Shiny app-package in RStudio  and Positron . The Positron  IDE was still in the early stages of development when this section was written, so some of these steps may change in future versions.\nMake sure the rsconnect package is installed and loaded:\ninstall.packages(\"rsconnect\")\nlibrary(rsconnect)",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "shinyappsio.html#sec-shinyappsio-publish",
    "href": "shinyappsio.html#sec-shinyappsio-publish",
    "title": "19  shinyapps.io",
    "section": "",
    "text": "19.1.1 In RStudio \nRStudio  can be configured to work with your shinyapps.io account by clicking on Tools &gt; Global options &gt; Publishing and following the documentation.\n\n\n\n\n\n\n\nshinyapps.io account added to RStudio\n\n\nYou can also manually set the shinyapps.io account info using rsconnect::setAccountInfo():\n\nrsconnect::setAccountInfo(\n  name = 'your_username',\n  token = 'your_token',\n  secret = 'your_secret')\n\nAfter configuring our shinyapps.io account and loading, documenting, and installing the sap package, we can launch the application and click on the Publish icon:\n\n\n\n\n\n\n\nSend app.R to Console and click Publish\n\n\nMake sure all the files in the package are selected, enter an app title, then click Publish:\n\n\n\n\n\n\n\nPublishing apps to shinyapps.io\n\n\nThe Deploy pane will open and you’ll see a deployment log as your application is sent to the server:\n── Preparing for deployment ────────────────────────────────────────────────────\n✔ Deploying \"movie-reviews\" using \"server: shinyapps.io / username: paradigmdata\"\nℹ Creating application on server...\n✔ Created application with id 14030745\nℹ Bundling 72 files: .Rbuildignore, .Rprofile, .vscode/tasks.json, app.R, \ndata/movies.rda, data/movies.RData, data-raw/tidy_movies.R, DESCRIPTION, \nNAMESPACE, README.md, vignettes/specs.Rmd, inst/extdata/movies.fst, \ninst/prod/app/.DS_Store, inst/prod/app/app.R, inst/quarto/_quarto.yml, \ninst/quarto/.gitignore, inst/quarto/index.html, inst/quarto/index.qmd, …, \ntests/testthat/test-text_logo.R, and tests/testthat.R\nℹ Capturing R dependencies\n✔ Found 103 dependencies\n✔ Created 3,283,848b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 9818877\n── Deploying to server ─────────────────────────────────────────────────────────\nWaiting for task: 1510689240\n  building: Parsing manifest\n  building: Building image: 12075212\n  building: Installing system dependencies\n  building: Fetching packages\n  building: Installing packages\nbuilding: Installing files\n  building: Pushing image: 12075212\n  deploying: Starting instances\n  rollforward: Activating new instances\n  success: Stopping old instances\n── Deployment complete ─────────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://yourusername.shinyapps.io/app-name/&gt;\nDeployment completed: https://yourusername.shinyapps.io/app-name//\n\n\n19.1.2 In Positron \nAfter authenticating shinyapps.io, loading, documenting, and installing our app-package, we can deploy it in Positron  using the rsconnect::deployApp() function.\n\nrsconnect::deployApp(\n  appDir = getwd(),\n  appName = \"movie-reviews\")\n\n\n\n\nDeploying Shiny app from Positron’s Console\n\n\nAs we can see, Positron doesn’t open a Deploy window or separate Terminal task for launching the application (it’s printed directly to the Console).",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "shinyappsio.html#sec-shinyappsio-deploy-log",
    "href": "shinyappsio.html#sec-shinyappsio-deploy-log",
    "title": "19  shinyapps.io",
    "section": "19.2 Deploy logs",
    "text": "19.2 Deploy logs\nOn shinyapps.io, the deployment log shows the loadSupport() warning persists (but the application still deploys). The server-side warning is a known issue.1\nshinyapps[12692760]: Running as user: uid=10001(shiny) gid=10001(shiny) groups=10001(shiny)\nshinyapps[12692760]: Connect version: 2024.05.0\nshinyapps[12692760]: LANG: C.UTF-8\nshinyapps[12692760]: Working directory: /srv/connect/apps/movie-reviews\nshinyapps[12692760]: Using R 4.4.0\nshinyapps[12692760]: R.home(): /opt/R/4.4.0/lib/R\nshinyapps[12692760]: Content will use current R environment\nshinyapps[12692760]: R_LIBS: (unset)\nshinyapps[12692760]: .libPaths(): /usr/lib/R, /opt/R/4.4.0/lib/R/library\nshinyapps[12692760]: shiny version: 1.9.1\nshinyapps[12692760]: httpuv version: 1.6.15\nshinyapps[12692760]: rmarkdown version: (none)\nshinyapps[12692760]: knitr version: (none)\nshinyapps[12692760]: jsonlite version: 1.8.8\nshinyapps[12692760]: RJSONIO version: (none)\nshinyapps[12692760]: htmltools version: 0.5.8.1\nshinyapps[12692760]: reticulate version: (none)\nshinyapps[12692760]: Using pandoc: /opt/connect/ext/pandoc/2.16\nshinyapps[12692760]: \nshinyapps[12692760]: Starting R with process ID: '31'\nshinyapps[12692760]: Shiny application starting ...\n1shinyapps[12692760]: Warning in warn_if_app_dir_is_package(appDir) :\nshinyapps[12692760]:   Loading R/ subdirectory for Shiny application, \n  but this directory appears to contain an R package. Sourcing files \n  in R/ may cause unexpected behavior. See `?loadSupport` for more details.\nshinyapps[12692760]: ℹ Loading sap\nshinyapps[12692760]: \nshinyapps[12692760]: Listening on http://127.0.0.1:123456\n\n1\n\nloadSupport() warning",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "shinyappsio.html#sec-shinyappsio-rsconnect-dir",
    "href": "shinyappsio.html#sec-shinyappsio-rsconnect-dir",
    "title": "19  shinyapps.io",
    "section": "19.3 The rsconnect folder",
    "text": "19.3 The rsconnect folder\nWhen deploying a Shiny app, the rsconnect/ folder is automatically created to store configuration settings and deployment metadata for the app.\nrsconnect/\n└── shinyapps.io\n    └── paradigmdata\n        └── movie-reviews.dcf\n\n3 directories, 1 file\nrsconnect/ contains deployment-related metadata, including information about our shinyapps.io account, and app-specific deployment history and settings.\nThe rsconnect/ folder should not be included in your Git repository because it contains machine-specific settings and is not required for running the app locally. This folder can also lead to conflicts when multiple users work on the same repo.\nTo ensure the rsconnect folder is not included in your Git repository, add rsconnect/ to .gitignore:\n.Rproj.user\n.Rhistory\n.RData\n.Ruserdata\n.DS_Store\nsap.Rcheck/\nsap*.tar.gz\nsap*.tgz\nrsconnect/\n\n/.quarto/\ninst/doc\n# {shinytest2}: Ignore new debug snapshots for `$expect_values()`\n*_.new.png\nIf you need to remove rsconnect/ from Git because it’s already been committed, remove it with the following commands:\n\ngit rm -r --cached rsconnect/\ngit commit -m \"Remove rsconnect folder from repository\"\ngit push origin main\n\nThis will remove it from the Git history while keeping it locally. If we need to share deployment details with our team, we can document the deployment process in the README.Rmd or create a deploy.Rmd vignette.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "shinyappsio.html#sec-shinyappsio-app-logs",
    "href": "shinyappsio.html#sec-shinyappsio-app-logs",
    "title": "19  shinyapps.io",
    "section": "19.4 App logs",
    "text": "19.4 App logs\nWe’ve covered the deployment logs that are generated when we publish our app to shinyapps.io, but what about the logs we’re using to track our application’s behavior (we covered this in Section 13.3)? In this branch, I’ve added the store_log argument to logr_msg() that toggles a ‘save log to external log file’ functionality:\n\n\nshow/hide logr_msg()\nlogr_msg &lt;- function(message, level = \"INFO\", log_file = \"app_log.txt\", json = FALSE, store_log = TRUE) {\n  \n  # Console logging \n  logger::log_formatter(formatter = logger::formatter_glue)\n  logger::log_layout(layout = logger::layout_glue_generator())\n  \n1  if (store_log) {\n    log_dir &lt;- dirname(log_file)\n    if (!dir.exists(log_dir)) {\n      dir.create(log_dir, recursive = TRUE)\n    }\n    if (!file.exists(log_file)) {\n      file.create(log_file)\n    }\n    \n2    if (json) {\n      logger::log_appender(appender = logger::appender_tee(log_file))\n      logger::log_layout(layout = logger::layout_json())\n    } else {\n      logger::log_appender(appender = logger::appender_tee(log_file))\n      logger::log_layout(layout = logger::layout_glue_generator())\n    }\n3  } else {\n    logger::log_appender(appender = logger::appender_console)\n  }\n  \n  # levels\n  switch(\n    level,\n    \"FATAL\" = logger::log_fatal(\"{message}\"),\n    \"ERROR\" = logger::log_error(\"{message}\"),\n    \"WARN\" = logger::log_warn(\"{message}\"),\n    \"SUCCESS\" = logger::log_success(\"{message}\"),\n    \"INFO\" = logger::log_info(\"{message}\"),\n    \"DEBUG\" = logger::log_debug(\"{message}\"),\n    \"TRACE\" = logger::log_trace(\"{message}\"),\n    logger::log_info(\"{message}\") # default to INFO if level is invalid\n  )\n}\n\n\n\n1\n\nConfigure file logging\n\n2\n\nLog as JSON file\n\n3\n\nPrevent file logging\n\n\n\n\nI’ve set the default value of store_log to FALSE, but we can change this TRUE and logr_msg() will automatically save the logs (after loading, documenting, and installing the package).\nTo ensure the logs are stored when the application is deployed, we need to add a logger::log_threshold() argument in inst/prod/app/app.R:\n\nlibrary(sap)\nlogger::log_threshold('TRACE')\nlaunch_app(app = \"bslib\")\n\nAfter loading, documenting and installing sap, we can re-deploy with rsconnect::deployApp() (with the forceUpdate = TRUE argument, because we’re updating an existing application).\n\nrsconnect::deployApp(\n  appDir = getwd(), \n  appName = \"movie-reviews\", \n  forceUpdate = TRUE)\n\nAfter the application re-deploys, we can view and/or download the Logs in the shinyapps.io interface:\n\n\n\n\n\n\n\nlogs in the shinyapps.io interface\n\n\nIt’s also possible to get the application logs remotely using rsconnect::showLogs(). We can also download the code image from the Overview tab.\n\n\n\n\n\n\n\nDownload image from shinyapps.io interface\n\n\nThe downloaded image will contain the files we’ve published. A downloaded image is stored in the inst/image folder of this branch:\ninst/image/e47f9753baa54a599719c0b68c05521f/\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── data.R\n│   ├── display_type.R\n│   ├── launch_app.R\n│   ├── log_message.R\n│   ├── logr_msg.R\n│   ├── mod_aes_input.R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   ├── movies_server.R\n│   ├── movies_ui.R\n│   ├── scatter_plot.R\n│   ├── testthat.R\n│   ├── text_logo.R\n│   └── zzz.R\n├── README.md\n├── app.R\n├── data\n│   ├── movies.RData\n│   └── movies.rda\n├── data-raw\n│   └── tidy_movies.R\n├── inst\n│   ├── extdata\n│   ├── prod\n│   ├── quarto\n│   ├── tidy-movies\n│   └── www\n├── man\n│   ├── display_type.Rd\n│   ├── launch_app.Rd\n│   ├── log_message.Rd\n│   ├── logr_msg.Rd\n│   ├── mod_aes_input_server.Rd\n│   ├── mod_aes_input_ui.Rd\n│   ├── mod_scatter_display_server.Rd\n│   ├── mod_scatter_display_ui.Rd\n│   ├── mod_var_input_server.Rd\n│   ├── mod_var_input_ui.Rd\n│   ├── movies.Rd\n│   ├── movies_server.Rd\n│   ├── movies_ui.Rd\n│   ├── scatter_plot.Rd\n│   ├── test_logger.Rd\n│   └── text_logo.Rd\n1├── manifest.json\n├── tests\n│   ├── testthat\n│   └── testthat.R\n└── vignettes\n    └── specs.Rmd\n\n14 directories, 40 files\n\n1\n\nmanifest of application dependencies\n\n\nThe manifest.json contains the application dependencies (similar to the lock file created by renv).",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "shinyappsio.html#recap",
    "href": "shinyappsio.html#recap",
    "title": "19  shinyapps.io",
    "section": "Recap",
    "text": "Recap\nDeploying a Shiny app-package to shinyapps.io requires keeping a clutter-free package structure, authenticating with rsconnect, and managing dependencies for a smooth workflow.\n\n\n\n\n\n\nRecap: shinyapps.io\n\n\n\n\n\n\n\nStore the app in the package so it can be accessed using system.file() (i.e., inst/) in an app.R file.\nBe able to run the app locally (i.e., using devtools::install() and sap::launch_app())\nInstall rsconnect and authenticate with shinyapps.io using setAccountInfo() or by accessing Tools &gt; Global Options &gt; Publishing in RStudio.\nDeplo the app by clicking on the Publish icon or by using rsconnect::deployApp().\nAdd rsconnect/ to the .gitignore file to keep deployment metadata out of Git.\n\nIf already committed, remove it:\n\ngit rm -r --cached rsconnect/\ngit commit -m 'Removed rsconnect folder'\ngit push origin main\nCheck logs if issues arise by downloading log file from shinyapps.io interface or using rsconnect::showLogs().",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "shinyappsio.html#footnotes",
    "href": "shinyappsio.html#footnotes",
    "title": "19  shinyapps.io",
    "section": "",
    "text": "You can learn more about this warning by reading these posts on StackOverflow: How can I deploy my shiny app as a package?; Problem with directory when deploying app on shinyapps, and this post on Posit Community: Errors when deploying app on shinyapps.io.↩︎",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "docker.html",
    "href": "docker.html",
    "title": "20  Docker",
    "section": "",
    "text": "20.1 What is Docker  ?\nDocker ensures your Shiny applications are deployed with the necessary resources (dependencies, libraries, etc.) without significantly interfering with the host operating system or hardware.\nWith Docker, each Shiny application runs from an image in an isolated container, which ensures your app works consistently, regardless of where it’s deployed.1\nImagine a computer as a building and the operating system (OS) is like the big kitchen where everyone cooks. If someone’s (i.e., a software application) recipe calls for the oven to be at a specific temperature or requires a particular ingredient, this can interfere with what someone else (i.e., other applications) wants to make. This situation is somewhat analogous to the competition for resources all software applications have while running on a particular machine.\nDocker images are like different recipes for running software applications, with each recipe requiring different ingredients (requirements, dependencies, libraries, etc.). Docker containers are similar to individual, self-contained mini-kitchens. The mini-kitchens operate independently (with their own appliances, ingredients, and utensils), regardless of what’s happening in the other mini-kitchens.2",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-what-is-docker",
    "href": "docker.html#sec-docker-what-is-docker",
    "title": "20  Docker",
    "section": "",
    "text": "The common problem Docker solves when shipping applications\n\n\n\n\n\n20.1.1 How Docker works\nThe three important concepts to understand when deploying Shiny apps with Docker are Dockerfiles, images, and containers.\n\nDockerfile: The text file containing instructions on how to build the Docker image.\nDocker Image: A instantiated snapshot of the Shiny application and its dependencies, which is built based on the Dockerfile.\nDocker Container: A runtime instance of the Docker image, isolated from the host system, ensuring consistent behavior across environments. When we instantiate an image, Docker creates a container from that image.3\n\nContainers and images work together but they serve different purposes in the Docker ecosystem.\nWe can place a series of instructions inside a Dockerfile that define how to build a Docker image. The docker build command packages our application, its dependencies, and configurations into a portable image, which can then be used to create and run containers.\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\n\nflowchart TB\n    subgraph AP[\"App-Package\"]\n        subgraph DockFile[\"&lt;strong&gt;Dockerfile&lt;/strong&gt;\"]\n            Instructions[[\"&lt;em&gt;Stores instructions&lt;br&gt;for building image&lt;/em&gt;\"]]\n        end\n    end\n        subgraph DockImg[\"&lt;strong&gt;Docker Image&lt;/strong&gt;\"]\n            Image[\"Shiny app dependencies\"]\n        end\n\n        subgraph DockCont[\"&lt;strong&gt;Docker Container&lt;/strong&gt;\"]\n            R[\"Installs R version\"]\n            Pkg[\"Installs app-package\"]\n            ShinyDep[\"Runs Shiny server\"]\n        end\n\n    DockFile --&gt;|\"&lt;code&gt;docker build&lt;/code&gt; &lt;em&gt;creates instance of image&lt;/em&gt;\"| DockImg\n    DockImg --&gt; |\"&lt;code&gt;docker run&lt;/code&gt; &lt;em&gt;creates runtime instance of image&lt;/em&gt;\"|DockCont\n\n    style DockFile fill:#FFFFFF,color:#000000,stroke:#333,stroke-width:1px,rx:10,ry:10\n    style DockImg fill:#FFFFFF,color:#000000,stroke:#333,stroke-width:1px,rx:10,ry:10\n    style DockCont fill:#FFFFFF,color:#000000,stroke:#333,stroke-width:1px,rx:10,ry:10\n\n\n\n\n\n\nThe image containing our applications’ dependencies is safely stored within the container, ensuring consistency across environments. The container also isolates the image (and the application) from the host system.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-install",
    "href": "docker.html#sec-docker-install",
    "title": "20  Docker",
    "section": "20.2 Installing Docker",
    "text": "20.2 Installing Docker\nFollow the instructions found on the Docker website to install Docker Desktop. I’ll be demonstrating how to use Docker on a macOS (but it’s available on most operating systems).\nAfter installation, Docker Desktop will initially show no active images/containers:4\n\n\n\n\n\n\n\nDocker Desktop Containers (Mac)\n\n\nThe development process for your Shiny app-package doesn’t change until you’re ready to deploy your application.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-dockerfile",
    "href": "docker.html#sec-docker-dockerfile",
    "title": "20  Docker",
    "section": "20.3 Writing a Dockerfile",
    "text": "20.3 Writing a Dockerfile\nWe’ll be using the sap example from the previous chapter as an example (the folder/file structure is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('20_docker')\n\n\n\nview app-package folder tree\n├── DESCRIPTION\n├── Dockerfile\n├── NAMESPACE\n├── R\n│   ├── data.R\n│   ├── display_type.R\n│   ├── launch_app.R\n│   ├── log_message.R\n│   ├── logr_msg.R\n│   ├── mod_aes_input.R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   ├── movies_server.R\n│   ├── movies_ui.R\n│   ├── scatter_plot.R\n│   ├── testthat.R\n│   ├── text_logo.R\n│   └── zzz.R\n├── README.md\n├── app.R\n├── data\n│   ├── movies.RData\n│   └── movies.rda\n├── data-raw\n│   └── tidy_movies.R\n├── inst\n│   ├── extdata\n│   │   └── movies.fst\n│   ├── prod\n│   │   └── app\n│   │       └── app.R\n│   ├── quarto\n│   │   ├── _quarto.yml\n│   │   ├── index.html\n│   │   ├── index.qmd\n│   │   └── www\n│   │       ├── quarto.png\n│   │       └── styles.scss\n│   ├── tidy-movies\n│   │   ├── R\n│   │   │   ├── devServer.R\n│   │   │   ├── devUI.R\n│   │   │   ├── dev_mod_scatter.R\n│   │   │   └── dev_mod_vars.R\n│   │   ├── _logs\n│   │   ├── app.R\n│   │   ├── app_log.txt\n│   │   ├── imdb.png\n│   │   └── tidy_movies.fst\n│   └── www\n│       ├── bootstrap.png\n│       └── shiny.png\n├── man\n│   ├── display_type.Rd\n│   ├── launch_app.Rd\n│   ├── log_message.Rd\n│   ├── logr_msg.Rd\n│   ├── mod_aes_input_server.Rd\n│   ├── mod_aes_input_ui.Rd\n│   ├── mod_scatter_display_server.Rd\n│   ├── mod_scatter_display_ui.Rd\n│   ├── mod_var_input_server.Rd\n│   ├── mod_var_input_ui.Rd\n│   ├── movies.Rd\n│   ├── movies_server.Rd\n│   ├── movies_ui.Rd\n│   ├── scatter_plot.Rd\n│   ├── test_logger.Rd\n│   └── text_logo.Rd\n├── sap.Rproj\n├── tests\n│   ├── testthat\n│   │   ├── fixtures\n│   │   │   ├── make-tidy_ggp2_movies.R\n│   │   │   └── tidy_ggp2_movies.rds\n│   │   ├── helper.R\n│   │   ├── setup-shinytest2.R\n│   │   ├── test-mod_scatter_display_server.R\n│   │   ├── test-mod_var_input_server.R\n│   │   ├── test-scatter_plot.R\n│   │   ├── test-shinytest2-export.R\n│   │   ├── test-shinytest2-prod.R\n│   │   ├── test-shinytest2.R\n│   │   └── test-text_logo.R\n│   └── testthat.R\n└── vignettes\n    └── specs.Rmd\n\n19 directories, 69 files\n\n\nWhen our application is ready to deploy, we’ll create a Dockerfile, which is a plain-text file (no extension). Dockerfiles are a blend of commands, numeric values, and character strings with the following general conventions:\n\nEach line in the Dockerfile starts with an instruction. These aren’t case-sensitive, but it’s common practice to capitalize each command. Each instruction in the Dockerfile generates a new layer in the image (the layered filesystem and caching is part of what makes Docker efficient).\nComments or explanatory notes begin with #. These will be ignored by the Docker engine.\n\nBelow are two lines from the Dockerfile found in the excellent post titled, R Shiny Docker: How To Run Shiny Apps in a Docker Container. This is a great place to familiarize yourself with deploying a non-package Shiny application with Docker.5\n\n# build image \nFROM rocker/shiny\n\n# create location for app\nRUN mkdir /home/shiny-app\n\nAs you can see, the Dockerfile combines instructions (FROM, RUN) with command-line arguments (mkdir). You don’t have to be a command-line expert to write a Dockerfile (but knowing a few can get you out of a jam 6).\n\n20.3.1 Create image\nDocker files start by building an image. In our case, we want an image configured to run R, which has been provided for us by the generous folks at the rocker project.\nThe Shiny rocker image is for Shiny apps:\n\nFROM rocker/shiny\n\n\n\n20.3.2 Install dependencies\nUse RUN and R -e to install dependencies for our app in the container from CRAN.7\n\nRUN R -e 'install.packages(c(\"rlang\", \"stringr\", \"shiny\", \"ggplot2\", \"remotes\"))'\n\n\n\n20.3.3 Create location for app\n\nRUN mkdir creates a new /deploy directory in the container\nADD . /deploy copies the files from the current directory (on the host machine) into the /deploy directory inside the container\nWORKDIR /deploy sets the /deploy directory as the working directory for any subsequent instructions.\n\n\nRUN mkdir /deploy\nADD . /deploy\nWORKDIR /deploy\n\n\n\n20.3.4 Install app-package\nremotes::install_local() will the R package specified in the local directory (where our Shiny app-package lives), without upgrading dependencies.\n\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\n\n\n\n20.3.5 Clean up\nRUN rm -rf /deploy cleans up and reduces the size of the container.\n\nRUN rm -rf /deploy\n\n\n\n20.3.6 Expose port\nMake our Shiny app available on EXPOSE 8180.\n\nEXPOSE 8180\n\n\n\n20.3.7 Launch app\nWhen the container starts, set Shiny to listen on port 8180, then launch the Shiny app from our sap package. The port we exposed in the Dockerfile should match the shiny.port option.\n\nCMD R -e \"options('shiny.port'=8180,shiny.host='0.0.0.0');library(sap);sap::launch_app()\"",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-build-image",
    "href": "docker.html#sec-docker-build-image",
    "title": "20  Docker",
    "section": "20.4 Build the Docker image",
    "text": "20.4 Build the Docker image\nThe final Dockerfile we’ll use to launch our application is below:\n\nFROM rocker/shiny\nRUN R -e 'install.packages(c(\"rlang\", \"stringr\", \"shiny\", \"ggplot2\", \"remotes\"))'\nRUN mkdir /deploy\nADD . /deploy\nWORKDIR /deploy\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\nRUN rm -rf /deploy\nEXPOSE 8180\nCMD R -e \"options('shiny.port'=8180,shiny.host='0.0.0.0');library(sap);sap::launch_app()\"\n\nTo build the Docker image and create a new container, run the docker build command in the Terminal with a tag (-t), a name for the image (movies-app-docker-demo), and the location (.):\n\ndocker build -t movies-app-docker-demo .\n\nAs the docker image builds you’ll see the output in the Terminal:\n\n\n\n\n\nAfter the image is built, we’ll see a new image listed in Docker desktop:\n\n\n\n\n\n\n\nNew Docker image\n\n\nEach Docker image consists of layers, which we can see if we click on the image in Docker Desktop:\n\n\n\n\n\n\n\nDocker image layers\n\n\nThese layers give us some insight into what the image contains. We can see the R version is specified and other scripts are copied from the rocker/shiny image.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-run-container",
    "href": "docker.html#sec-docker-run-container",
    "title": "20  Docker",
    "section": "20.5 Running the container",
    "text": "20.5 Running the container\nAfter building the image, we can run the new container using docker run\n\ndocker run -p 8180:8180 movies-app-docker-demo\n\nIn the Terminal, we’ll see an R session initialize, and the R function calls from the last line of our Dockerfile:\nR version 4.4.2 (2024-10-31) -- \"Pile of Leaves\"\nCopyright (C) 2024 The R Foundation for Statistical Computing\nPlatform: x86_64-pc-linux-gnu\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n1&gt; options('shiny.port'=8180,shiny.host='0.0.0.0');library(sap);sap::launch_app()\n2INFO [2025-02-25 17:28:17] Launching app: movies\nINFO [2025-02-25 17:28:17] Launching UI with bslib = FALSE\nLoading required package: shiny \n\n3Listening on http://0.0.0.0:8180\n\n1\n\nFinal line in our Dockerfile\n\n\n2\n\nLog comments from our app code\n\n\n3\n\nPort we specified in docker run\n\n\nCopy the hyperlink above and place it in the browser to view the application:\n\n\n\n\n\n\n\nApp launched in Docker container\n\n\nNew Docker containers are named using a random combination of adjectives and famous scientists’ surnames (unless the --name flag is added).\n\n\n\n\n\n\n\nDocker initial container\n\n\nYou can change the name of a Docker image by stopping the container and passing docker rename &lt;old_name&gt; &lt;new_name&gt; to the Terminal:\n\ndocker rename unruffled_bhabha launch_app\n\nEach Docker container is created from the image (which is specified in the Dockerfile). The image serves as a blueprint for the containers, and we could create multiple containers from the same image:\n\n\n\n\n\n\n\nRunning and stopping Docker containers",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-golem",
    "href": "docker.html#sec-docker-golem",
    "title": "20  Docker",
    "section": "20.6 Docker & golem",
    "text": "20.6 Docker & golem\nThe golem package has multiple functions for building Docker files and images. There are a few notable points to make about some of the Docker images created with golem:\n\ngolem’s Docker functions can produce multiple Docker files (golem::add_dockerfile_with_renv() creates a tmp/deploy folder and adds the following files)\n\n\nView deploy/ folder\ndeploy/\n  ├── Dockerfile\n  ├── Dockerfile_base\n  ├── README\n  ├── gap_0.0.0.9000.tar.gz\n  └── renv.lock.prod\n\n\ngolem’s Docker files typically use the R build from rocker (and include a version):\n\n\nView R version build\nFROM rocker/verse:4.3.2\n\n\ngolem Docker files might also include additional commands for installing/updating command-line (linux) tools for downloading/exchanging data:\n\n\nView apt-get commands\nRUN apt-get update && apt-get install -y  libcurl4-openssl-dev libicu-dev libssl-dev libxml2-dev make pandoc zlib1g-dev\n\n\nThey also usually the remotes package to specify the version of each package and whether to upgrade (or not):\n\n\nView remotes::install_version()\nRUN R -e 'install.packages(\"remotes\")'\nRUN Rscript -e 'remotes::install_version(\"rlang\",upgrade=\"never\",version=\"1.1.2\")'\nRUN Rscript -e 'remotes::install_version(\"stringr\",upgrade=\"never\",version=\"1.5.1\")'\nRUN Rscript -e 'remotes::install_version(\"shiny\",upgrade=\"never\",version =\"1.8.0\")'\nRUN Rscript -e 'remotes::install_version(\"ggplot2\",upgrade=\"never\",version=\"3.4.4\")'\n\n\n\n\n\n\n\n\n\nRUN R -e vs RUN Rscript -e\n\n\n\n\n\n\nBoth R -e and RUN Rscript -e will execute R expressions from the command line.\n\nR -e is straightforward and typically used to evaluate a single expression (i.e., install.packages())\nRUN Rscript -e is more commonly used for running scripts or more specialized commands:\n\npkgs &lt;- c('glue', 'cli')\ninstall.packages(pkgs)\n\n\n\n\nThere are additional differences, but these are important if you want to include additional requirements or control the version of R (or a package dependency). golem’s Docker images are more (you guessed it) opinionated, but every time I’ve used one it works right “out of the box.”",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-app-packages",
    "href": "docker.html#sec-docker-app-packages",
    "title": "20  Docker",
    "section": "20.7 Docker in app-packages",
    "text": "20.7 Docker in app-packages\nYou can include a Dockerfile in an app-package by adding it to the .Rbuildignore file.8\n\n^.*\\.Rproj$\n^\\.Rproj\\.user$\n^sap\\.Rcheck$\n^sap.*\\.tar\\.gz$\n^sap.*\\.tgz$\n^Dockerfile$\n\nThis will ensure it won’t interfere with your app-package builds. Docker also has it’s own ignore file (.dockerignore), which can include similar contents to the .gitignore:\n\n.RData\n.Rhistory\n.git\n.gitignore\nmanifest.json\nrsconnect/\n.Rproj.user\n\nNote that if you include a .dockerignore file, you should also include this pattern in the .Rbuildignore:\n\n^.*\\.Rproj$\n^\\.Rproj\\.user$\n^sap\\.Rcheck$\n^sap.*\\.tar\\.gz$\n^sap.*\\.tgz$\n^Dockerfile$\n^\\.dockerignore$",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#recap",
    "href": "docker.html#recap",
    "title": "20  Docker",
    "section": "Recap",
    "text": "Recap\nThis has been a brief overview of using Docker to deploy your Shiny App-Package.\n\n\n\n\n\n\nRecap: \n\n\n\n\n\n\nDocker files are used to build images, which defines an environment for the Shiny application to run. The container is the actual running instance of that environment.\n\nDocker images are immutable, meaning they do not change. Once an image is created, it remains unchanged inside a container.\nDocker containers can be started, stopped, moved, and deleted, but each time a container is run, it’s created from an image.\n\n\n\n\n\nDocker is covered again in the golem chapter and on the Shiny frameworks supplemental website. If you’d like to learn more, Appsilon has a great introduction to Docker (mentioned above).9 I also found the Dockerizing shiny applications post helpful. 10\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#footnotes",
    "href": "docker.html#footnotes",
    "title": "20  Docker",
    "section": "",
    "text": "Read more about Docker in the official documentation.↩︎\nDocker containers are similar to virtual machine environments (like VMware), but don’t use a significant portion of the hardware system’s resources.↩︎\nA Docker image can exist without a container, but all containers must be instantiated from an image.↩︎\nIf you follow the Docker ‘Walkthroughs’ in the Learning Center, you might see the welcome-to-docker container listed.↩︎\nI’ve altered the comments of the original Dockerfile, so be sure to read the entire blog post before copying + pasting this into your workflow.↩︎\nI love the help files on https://linuxize.com/, and this tutorial is a nice introduction to the command-line.↩︎\nWe’ll need remotes to install our app-package locally (i.e., with remotes::install_local(upgrade=\"never\")).↩︎\n.Rbuildignore includes files that we need to have in our app-package, but don’t conform to the standard R package structure (and shouldn’t be included when building our app-package from the source files).↩︎\nAppsilon has a few posts on Docker: ‘R Shiny Docker: How To Run Shiny Apps in a Docker Container’ and ‘Renv with Docker: How to Dockerize a Shiny Application with an Reproducible Environment’↩︎\nThis is the second post in a series (see the first post here).↩︎",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "gha.html",
    "href": "gha.html",
    "title": "21  GitHub Actions",
    "section": "",
    "text": "GitHub Actions\nContinuous Integration (CI) and Continuous Deployment (CD) help automate software development tasks, especially testing and deployment. In the context of a Shiny app-package, CI/CD usually refers to GitHub Actions or Travis CI.\nThis chapter will only cover CI/CD with GitHub Actions. Travis-CI has been around longer than GitHub Actions, and if you’d like to compare the two, I recommend this article.\nWe can use Actions to create custom workflows for building, testing, and deploying our app-package.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#github-actions",
    "href": "gha.html#github-actions",
    "title": "21  GitHub Actions",
    "section": "",
    "text": "GitHub Actions (or Actions, for short) is a feature provided by GitHub that enables automation of various development workflows. These workflows are defined in YAML files and can automate some of the repetitive tasks in the development lifecycle, right within a GitHub repository.\n\n\n\n\n\n\n\n\n\nGitHub Actions\n\n\n\n\n\n\n\nWorkflows\nA workflow is a YAML file placed in a repository to automate processes and executes jobs. Workflows can be triggered manually or set to run on a schedule based on repository events.\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\n\nflowchart TD\n  workflow([\"Workflow\"]) --&gt;|\"&lt;em&gt;Triggered by&lt;em&gt;\"| event(\"&lt;strong&gt;Event&lt;/strong&gt;: push, pull request, etc.\")\n    \n\n\n\n\n\n\non\non defines the event(s) that trigger the workflow.\n\n\n\n\n\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\n\nAn event is any activity that triggers a workflow, such as a pull request, a new issue or pushed commits.1\n\n\n\nname\nname is an optional field to identify a workflow in the Actions tab of the GitHub repository.\n\n\n\n\n\n\nname: shiny\n\n\nIf name is not provided, GitHub will use the file path.\n\n\n\njobs\nA job consists of a sequence of steps defined in the workflow file.\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart \n  workflow([\"Workflow\"]) --&gt;|\"&lt;em&gt;Triggered by&lt;em&gt;\"| event(\"&lt;strong&gt;Event&lt;/strong&gt;: push, pull request, etc.\")\n\n  event --&gt; |\"&lt;em&gt;Executes&lt;/em&gt;\"| Jobs{\"&lt;strong&gt;Jobs&lt;/strong&gt;\"}\n\n\n\n\n\n\n\n\n\n\n\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n\n\nThe identifier (check in this case) is used to reference the runner, in this example it’s ubuntu-latest.\n\n\n\nA runner is a server (running Ubuntu Linux, Microsoft Windows, or macOS) that operates within a freshly provisioned virtual machine to execute the triggered workflow.\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\n\nflowchart \n  workflow([\"Workflow\"]) --&gt;|\"&lt;em&gt;Triggered by&lt;em&gt;\"| event(\"&lt;strong&gt;Event&lt;/strong&gt;: push, pull request, etc.\")\n  \n  subgraph VM[\"Virtual Machine\"]\n    subgraph runner02[\"&lt;strong&gt;Runner&lt;/strong&gt; 2\"]\n    end\n    subgraph runner01[\"&lt;strong&gt;Runner&lt;/strong&gt; 1\"]\n    end\n  end\n\n  event --&gt; |\"&lt;em&gt;Executes&lt;/em&gt;\"| Jobs{\"&lt;strong&gt;Jobs&lt;/strong&gt;\"}\n  Jobs --&gt; |\"&lt;em&gt;Launches&lt;/em&gt;\"|runner01 & runner02\n\n\n\n\n\n\nEach runner can run a single job at a time.\n\n\n\n\n\n\njobs:\n  check:\n    runs-on: ${{ matrix.config.os }}\n    \n\n\nmatrix runs jobs across different operating systems, programming language versions, etc.\n\n\n\n\n\n\n\n\n\n    name: ${{ matrix.config.os }} (${{ matrix.config.r }})\n    \n\n\n\n\n\n\n\n\n\n    strategy:\n      fail-fast: false\n      matrix:\n        config:\n          - {os: macos-latest,   r: 'release'}\n          - {os: windows-latest, r: 'release'}\n          - {os: ubuntu-latest,   r: 'release'}\n\n\nfail-fast: false means the workflow will continue running even if one of the matrix jobs fails.\n\n\n\nsteps\nEach step can be a shell script or an action, and they are executed in the order they are written. For example, checking out code from a repository, setting up R, installing a package, and launching an app.\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\n\nflowchart \n  workflow([\"Workflow\"]) --&gt;|\"&lt;em&gt;Triggered by&lt;em&gt;\"| event(\"&lt;strong&gt;Event&lt;/strong&gt;: push, pull request, etc.\")\n  \n  subgraph VM[\"Virtual Machine\"]\n    subgraph runner02[\"&lt;strong&gt;Runner&lt;/strong&gt; 2\"]\n        action02a(\"&lt;strong&gt;Action&lt;/strong&gt;: checkout code\")\n        action02b(\"&lt;strong&gt;Action&lt;/strong&gt;: set up R\")\n        step02a(\"&lt;strong&gt;Script&lt;/strong&gt;: launch app\")\n    end\n    subgraph runner01[\"&lt;strong&gt;Runner&lt;/strong&gt; 1\"]\n        action01a(\"&lt;strong&gt;Action&lt;/strong&gt;: checkout code\")\n        action01b(\"&lt;strong&gt;Action&lt;/strong&gt;: set up R\")\n        step01a(\"&lt;strong&gt;Script&lt;/strong&gt;: install package\")\n    end\n  end\n\n  event --&gt; |\"&lt;em&gt;Executes&lt;/em&gt;\"| Jobs{\"&lt;strong&gt;Jobs&lt;/strong&gt;\"}\n  Jobs --&gt; |\"&lt;em&gt;Launches&lt;/em&gt;\"|runner01 & runner02\n\n\n\n\n\n\n\n\n\n\n\n\nsteps:\n    - uses: actions/checkout@v2\n\n    - name: Set up R\n      uses: r-lib/actions/setup-r@v2\n\n    - name: Install package\n      run: |\n        install.packages('remotes')\n        remotes::install_local('.')\n      shell: Rscript {0}\n      \n\n\nsteps define a series of tasks or actions that the job will execute. These steps check out the code, set up the R environment, and install a local R package.\n\n\n\n\n\n\n\n\n\nWhat is shell: Rscript {0}?\n\n\n\n\n\n\n  name: Install packages\n  run: |\n    pkgs &lt;- c('glue', 'cli')\n    install.packages(pkgs)\n  shell: Rscript {0}\nThe command install.packages(pkgs) is run as an R script:\n\nshell specifies which command-line interpreter (bash, pwsh, python, or Rscript) to use for the run commands\nRscript is the command-line tool provided by R to execute R scripts and commands in a non-interactive environment.\n{0} is a placeholder for the R commands written in the run section.\n\n\n\n\n\nFinally, lines beginning with # will not be executed. It’s common to provide 1) a reference to the workflow source (r-lib/actions in this case) and 2) a link for help with debugging build failures.\n# Workflow derived from https://github.com/r-lib/actions/tree/v2/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\n\n\nPermissions\nIn order for workflows to run, we’ll need to make sure Actions have read and write permissions. We can do this by clicking on the repository’s Settings tab, then expand the Actions menu and select General:\n\n\n\nRepository Action settings\n\n\nIn the General settings, we want to confirm the workflow has Read and write permissions permissions (if this needs to be been changed, be sure to click Save).\n\n\n\nWorkflow permissions\n\n\nNow our workflows can commit and push changes to the repository.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#sec-gha-style",
    "href": "gha.html#sec-gha-style",
    "title": "21  GitHub Actions",
    "section": "21.1 Code styling and linting",
    "text": "21.1 Code styling and linting\n\n\n\n\n\n\nAccess the applications in this chapter\n\n\n\n\n\n\nI’ve created the shinypak R package in an effort to make each section accessible and easy to follow. Install shinypak using pak (or remotes):\ninstall.packages('pak')\npak::pak('mjfrigaard/shinypak')\nlibrary(shinypak)\nList the apps in this chapter:\nlist_apps(regex = '^21')\nLaunch apps with launch()\nlaunch(app = '21.1_gha-style')\nDownload apps with get_app()\nget_app(app = '21.1_gha-style')\n\n\n\n\nIn R packages, we can set up the GitHub Action infrastructure with usethis::use_github_action(). The name can be any of the workflow files available at r-lib/actions. The first workflow we’ll be demonstrating can be used to automate the code style in an app-package.\n\n\nLaunch app with the shinypak package:\n\nlaunch('21.1_gha-style')\n\n\nusethis::use_github_action(\"style\")\n\n✔ Setting active project to '/projects/apps/sap'\n✔ Creating '.github/'\n✔ Adding '*.html' to '.github/.gitignore'\n✔ Creating '.github/workflows/'\n✔ Saving 'r-lib/actions/examples/style.yaml@v2' to '.github/workflows/style.yaml'\nThe output tells us a local .github/workflows/style.yaml file has been copied from the r-lib/actions/examples/style.yaml@v2 into the .github/workflows folder:\n.github/\n  └── workflows\n    └── style.yaml\n\n2 directories, 1 file\nThe documentation for the style.yaml@v2 file tells us this workflow,\n\n“styles the R code in a package, then commits and pushes the changes to the same branch.”\n\nThe code styling in this workflow is handled by the styler package, which “formats your code according to the tidyverse style guide.”\nWe’ll make one small change to style.yaml before pushing it to GitHub. Instead of having the workflow automatically commit and push the styled code changes to the same branch, we’ll limit the code styling to the 21.1_gha-style branch:\non:\n  push:\n    branches: [21.1_gha-style]\n    paths: [\"**.[rR]\", \"**.[qrR]md\", \"**.[rR]markdown\", \"**.[rR]nw\", \"**.[rR]profile\"]\nThis change ensures our style workflow will be triggered only for pushes to the specified branches (and when changes are made to files with the specified extensions in path).\nAfter saving these changes to .github/workflows/style.yaml, we’ll add, commit, and push the changes to GitHub,\ngit add .\ngit commit -m \"updates to style workflow\"\n[21.1_gha-style 899bd38] updates to style workflow\n 4 files changed, 43 insertions(+), 45 deletions(-)\ngit push\nEnumerating objects: 17, done.\nCounting objects: 100% (17/17), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (8/8), done.\nWriting objects: 100% (9/9), 950 bytes | 25.00 KiB/s, done.\nTotal 9 (delta 6), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (6/6), completed with 6 local objects.\nTo https://github.com/mjfrigaard/sap.git\n   d366e0f..899bd38  21.1_gha-style -&gt; 21.1_gha-style\nIf we view the Actions tab, we’ll see the workflow listed with the name of our commit message:\n\n\n\nCurrently running workflows\n\n\nClicking on the workflow reveals the following:\n\n\n\nname of running workflow\n\n\nThe style widget contains each step in the workflow file. If we click on it we can see each step executed in real-time. Below we can see the dependencies installed from the pak lockfile:\n\n\n\n\n\n\n\n\n\nClick on the style widget\n\n\n\n\n\n\n\nView the Install styler and roxygen2 workflow step running\n\n\n\n\n\nThe actual styling comes is in the Style step:\n\n\n\nStyle workflow step running\n\n\nWhen the workflow has finished, we can pull the style changes to our local branch and view the styled files:2\ngit pull\nremote: Enumerating objects: 67, done.\nremote: Counting objects: 100% (67/67), done.\nremote: Compressing objects: 100% (7/7), done.\nremote: Total 34 (delta 28), reused 33 (delta 27), pack-reused 0 (from 0)\nUnpacking objects: 100% (34/34), 5.60 KiB | 86.00 KiB/s, done.\nFrom https://github.com/mjfrigaard/sap\n   5ccdc21..6296140  21.1_gha-style -&gt; origin/21.1_gha-style\nUpdating 5ccdc21..6296140\nFast-forward\n R/data.R                                         |  10 +++++-----\n R/display_type.R                                 |  16 ++++++++-------\n R/launch_app.R                                   |  88 +++++++++++++++++++++++++++++++++++++++++------------------------------------------\n R/log_message.R                                  |  10 +++++-----\n R/logr_msg.R                                     |  28 +++++++++++++--------------\n R/mod_aes_input.R                                |  54 ++++++++++++++++++++++++++++-----------------------\n R/mod_scatter_display.R                          | 121 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------------------------------------------------------\n R/mod_var_input.R                                |  67 ++++++++++++++++++++++++++++++++++-----------------------------\n R/movies_server.R                                |  69 ++++++++++++++++++++++++++++++++++++-----------------------------\n R/movies_ui.R                                    | 108 ++++++++++++++++++++++++++++++++++++++++++++++++++++-------------------------------------------------\n R/scatter_plot.R                                 |  34 +++++++++++++++++---------------\n R/testthat.R                                     |  16 +++++++--------\n R/text_logo.R                                    |  23 +++++++++++-----------\n R/zzz.R                                          |  58 +++++++++++++++++++++++++++----------------------------\n inst/quarto/index.qmd                            |  32 ++++++++++++++++--------------\n tests/testthat/fixtures/make-tidy_ggp2_movies.R  |   6 ++++--\n tests/testthat/helper.R                          |   7 +++----\n tests/testthat/test-mod_scatter_display_server.R |  88 +++++++++++++++++++++++++++++++++++++++++++++--------------------------------------\n tests/testthat/test-mod_var_input_server.R       |  25 ++++++++++++------------\n tests/testthat/test-scatter_plot.R               |  62 +++++++++++++++++++++++++++++-----------------------------\n tests/testthat/test-shinytest2-export.R          |  31 ++++++++++++++---------------\n tests/testthat/test-shinytest2-prod.R            |  43 ++++++++++++++++++++++-------------------\n tests/testthat/test-shinytest2.R                 |  45 +++++++++++++++++++++++--------------------\n tests/testthat/test-text_logo.R                  |  45 ++++++++++++++++++++++---------------------\n vignettes/specs.Rmd                              |   2 +-\n 25 files changed, 570 insertions(+), 518 deletions(-)",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#sec-gha-shiny",
    "href": "gha.html#sec-gha-shiny",
    "title": "21  GitHub Actions",
    "section": "21.2 Shiny app deployment",
    "text": "21.2 Shiny app deployment\nIn this section we’ll be adapting the GitHub Action workflow file provided for deploying a Shiny applications. Before we get to the workflow file, we need to address a few settings and configurations that need to take place outside of the workflow file.\n\n\nLaunch app with the shinypak package:\n\nlaunch('21.2_gha-shiny-deploy')\n\n\n21.2.1 Creating repository secrets\nWe need to make sure our rsconnect secrets are stored with the GitHub repository (so we can access them from within the workflow file). To do this, we’re going to return to the Settings tab on the sap repository, expand Secrets and variables under Security, and select Actions:3\n\n\n\n\n\n\n\nSecrets and variables for sap repository\n\n\nUse New repository secret to create three new secrets: RSCONNECT_USER, RSCONNECT_TOKEN, and RSCONNECT_SECRET. You can access these in your shinyapps.io account by clicking on the Tokens tab, then Show and Show secret:\n\n\n\n\n\n\n\nToken from shinyapps.io\n\n\n\n\n\n\n\n\n\nUser and Secret from shinyapps.io\n\n\nWhen you’re finished, should see the following three Repository secrets:\n\n\n\n\n\n\n\nRepository secrets in sap\n\n\n\n\n21.2.2 Enable private repositories\nWe also need to make sure our shinyapps.io account allows us to install from private GitHub repositories during a workflow deployment. We can do this in the Profile menu item in our dashboard:\n\n\n\n\n\n\n\nUpdate Authentication in shinyapps.io profile\n\n\nClicking Update Authentication will open your Posit profile settings, where you can enable private repositories.\n\n\n\n\n\n\n\nPrivate repo access also enabled\n\n\n\n\n21.2.3 Capture dependencies\nThe documentation for ‘Shiny App Deployment’ indicates we need to create a renv lockfile in the 21.2_gha-shiny-deploy branch.4\nWe can create the lockfile with the code below:\n\ninstall.packages('renv')\nrenv::init(force = TRUE)\n\nThis project contains a DESCRIPTION file.\nWhich files should renv use for dependency discovery in this project? \n\n1: Use only the DESCRIPTION file. (explicit mode)\n2: Use all files in this project. (implicit mode)\nWe’re going to use the explicit mode, because the dependencies in the DESCRIPTION should be all that’s needed to run and deploy the application.\nSelection: 1\nThis will update the renv.lock file with the packages, their dependencies, and the R version:\n- Linking packages into the project library ... Done!\nThe following package(s) will be updated in the lockfile:\nThe version of R recorded in the lockfile will be updated:\n- Lockfile written to \"~/projects/apps/R/sap/renv.lock\".\n- renv activated -- please restart the R session.\nWe will restart the session to finish creating the new project library.\nAfter renv has discovered and installed the dependencies, the R session will restart and we’ll see the following new folder/files:\n1├── .Rprofile\n├── renv/\n│   ├── activate.R\n2│   └── settings.json\n3└── renv.lock\n\n1\n\n.Rprofile contains a call to source(\"renv/activate.R\"), which manages the project-level dependencies\n\n\n2\n\nrenv settings\n\n\n3\n\nrenv lockfile\n\n\nWhen using renv in package development, we want to be sure to run renv::install() and renv::update():\n\nrenv::install()\n\n\n- There are no packages to install.\n\n\nrenv::update()\n\n\n- Checking for updated packages ... Done!\n- All packages appear to be up-to-date.\n\nNow that we’ve handled our secrets and tokens and have all of our dependencies captured, we can write our workflow file.\n\n\n21.2.4 shiny-deploy.yaml\nWe can include the ‘Shiny App Deployment’ workflow file in sap with usethis::use_github_action(\"shiny-deploy\"):5\n\nusethis::use_github_action(\"shiny-deploy\")\n\n\n✔ Creating .github/.\n✔ Adding \"*.html\" to .github/.gitignore.\n✔ Creating .github/workflows/.\n✔ Saving \"r-lib/actions/examples/shiny-deploy.yaml@v2\" to .github/workflows/shiny-deploy.yaml.\n☐ Learn more at &lt;https://github.com/r-lib/actions/blob/v2/examples/README.md&gt;.\n\nThis example workflow file is designed to deploy a Shiny application to a server. We’re going to make a few changes to shiny-deploy.yaml so it will deploy our application to shinyapps.io when we push to the 21.2_gha-shiny-deploy branch.\n\n21.2.4.1 Test run\nThe example shiny workflow includes calls to rsconnect::setAccountInfo() and rsconnect::deployApp(). We’ll perform a test run with these functions to confirm we can deploy the application using the information we’ve collected:\n\nStart by entering your rsconnect info:\n\n\ninstall.packages('rsconnect')\nrsconnect::setAccountInfo(\n  name = \"mjfrigaard\",\n  token = \"YOUR TOKEN\", \n  secret = \"YOUR SECRET\")\n\n\nThen try to deploy the application using rsconnect::deployApp():\n\n\nlibrary(sap)\nrsconnect::deployApp(\n  appName = \"shinyAppPkgsCICD\",\n  account = \"mjfrigaard\",\n  server = \"shinyapps.io\",\n  forceUpdate = TRUE)\n\nReading the deployment log will tells us if the secret, token, configuration, and lockfile are all working:\n\n── Preparing for deployment ──────────────────────────────────────────────────\n✔ Deploying \"shinyAppPkgsCICD\" using \"server: shinyapps.io / username: mjfrigaard\"\nℹ Bundling 50 files: .github/workflows/shiny-deploy.yaml, .Rbuildignore, ..., \ntests/testthat.R, and vignettes/test-specs.Rmd\nℹ Capturing R dependencies with renv\n✔ Found 99 dependencies\n✔ Created 2,431,325b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 8130675\n── Deploying to server ─────────────────────────────────────────────────────────\nWaiting for task: 1372980209\n  building: Processing bundle: 8130675\n  building: Building image: 9770352\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 9770352\n  deploying: Starting instances\n  unstaging: Stopping old instances\n── Deployment complete ─────────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://mjfrigaard.shinyapps.io/shinyAppPkgsCICD/&gt;\n\nMaking sure an application will deploy locally with the code we plan on putting into the workflow file builds confidence it run when it’s triggered. Now we’re ready to adapt the .github/workflows/shiny-deploy.yaml file.\n\n\n21.2.4.2 Event\nThe event we want to trigger this deployment is a push the 21.2_gha-shiny-deploy branch. We’ll also change of the name of this workflow to shiny.\n\n\n\n\n\n\non:\n  push:\n    branches: [21.2_gha-shiny-deploy]\n    \nname: shiny\n\n\n\nTriggered event on a push to the 21.2_gha-shiny-deploy branch\nChange name to shiny\n\n\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n  Push([\"Push to branch\"])\n  Push --&gt;|\"&lt;em&gt;Triggers&lt;/em&gt;\"| Shiny{\"&lt;strong&gt;Job&lt;/strong&gt;: &lt;code&gt;shiny&lt;/code&gt;\"}\n\n\n\n\n\n\n\n\n21.2.4.3 Jobs\nThe job will set up the runner and pass our stored GITHUB_TOKEN. runs-on launches a runner with the latest Ubuntu operating system and env maps the GITHUB_TOKEN environment variable (we can access those secrets with secrets.&lt;SECRET_NAME&gt;).\n\n\n\n\n\n\njobs:\n  shiny:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n\n\njobs remains unchanged, but the identifier should match the name.\n\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n  Push([\"Push to branch\"])\n  Push --&gt;|\"&lt;em&gt;Triggers&lt;/em&gt;\"| Shiny{\"&lt;strong&gt;Job&lt;/strong&gt;: &lt;code&gt;shiny&lt;/code&gt;\"}\n    subgraph ubuntu[\"&lt;strong&gt;Runner&lt;/strong&gt;\"]\n      Env(\"&lt;strong&gt;Env&lt;/strong&gt;: &lt;code&gt;GITHUB&lt;/code&gt;\")\n    end\n  Shiny --&gt;|\"&lt;em&gt;Runs on: Ubuntu Latest&lt;/em&gt;\"| ubuntu\n\n\n\n\n\n\n\n\n21.2.4.4 Steps\nThe first four steps are actions that clone our repo and set up the environment for performing the tasks in the workflow. The path to the action is passed to uses:, so actions/checkout@v4 uses the YAML file from the actions/checkout repo.\n\n\n\n\n\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: r-lib/actions/setup-pandoc@v2\n\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          use-public-rspm: true\n          r-version: renv\n\n      - uses: r-lib/actions/setup-renv@v2\n\n\n\nCheck out the repository code\nSet up Pandoc (document conversions)\nSet up R environment.6\nSet up renv to manage the project-specific dependencies captured in renv.lock\n\n\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n  Push([\"Push to branch\"])\n  Push --&gt;|\"&lt;em&gt;Triggers&lt;/em&gt;\"| Shiny{\"&lt;strong&gt;Job&lt;/strong&gt;: &lt;code&gt;shiny&lt;/code&gt;\"}\n    subgraph ubuntu[\"&lt;strong&gt;Runner&lt;/strong&gt;\"]\n        PAT(\"&lt;strong&gt;Env&lt;/strong&gt;: &lt;code&gt;GITHUB&lt;/code&gt;\")\n        Checkout(\"&lt;strong&gt;Action&lt;/strong&gt;: Checkout\")\n        SetupPandoc(\"&lt;strong&gt;Action&lt;/strong&gt;: Pandoc\")\n        SetupR(\"&lt;strong&gt;Action&lt;/strong&gt;: R env\")\n        SetupRenv(\"&lt;strong&gt;Action&lt;/strong&gt;: &lt;code&gt;renv&lt;/code&gt;\")\n    end\n  Shiny --&gt;|\"&lt;em&gt;Runs on: Ubuntu Latest&lt;/em&gt;\"| ubuntu\n  PAT --&gt; Checkout --&gt; SetupPandoc --&gt; SetupR\n  SetupR --&gt; SetupRenv\n\n\n\n\n\n\nThe following step is a script (i.e., run:) and it installs the rsconnect package:\n\n\n\n\n\n\n      - name: Install rsconnect\n        run: install.packages(\"rsconnect\")\n        shell: Rscript {0}\n\n\nInstall rsconnect uses R to install the rsconnect\n\n\n\nNext we use env again to map our account username (mjfrigaard) and app name (shinyDeployApp):\n\n\n\n\n\n\n    - name: Authorize and deploy app\n      env: \n        APPNAME: shinyDeployApp\n        ACCOUNT: mjfrigaard\n        SERVER: shinyapps.io \n\n\nSets up the environment variables APPNAME, ACCOUNT, and SERVER for authorization\n\n\n\nThe final run step sets the account information using rsconnect::setAccountInfo() and deploys the app to the specified server using rsconnect::deployApp() (we’ll add forceUpdate = TRUE):\n    run: |\n      rsconnect::setAccountInfo(\"${{ secrets.RSCONNECT_USER }}\", \"${{ secrets.RSCONNECT_TOKEN }}\", \"${{ secrets.RSCONNECT_SECRET }}\")\n      rsconnect::deployApp(appName = \"${{ env.APPNAME }}\", account = \"${{ env.ACCOUNT }}\", server = \"${{ env.SERVER }}\", forceUpdate = TRUE)\n    shell: Rscript {0}\nThis will deploy an application at https://&lt;ACCOUNT&gt;.shinyapps.io/&lt;APPNAME&gt;/.\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n  Push([\"Push to branch\"])\n  Push --&gt;|\"&lt;em&gt;Triggers&lt;/em&gt;\"| Shiny{\"&lt;strong&gt;Job&lt;/strong&gt;: &lt;code&gt;shiny&lt;/code&gt;\"}\n    subgraph ubuntu[\"&lt;strong&gt;Runner&lt;/strong&gt;\"]\n        PAT(\"&lt;strong&gt;Env&lt;/strong&gt;: &lt;code&gt;GITHUB&lt;/code&gt;\")\n        Checkout(\"&lt;strong&gt;Action&lt;/strong&gt;: Checkout\")\n        SetupPandoc(\"&lt;strong&gt;Action&lt;/strong&gt;: Pandoc\")\n        SetupR(\"&lt;strong&gt;Action&lt;/strong&gt;: R env\")\n        SetupRenv(\"&lt;strong&gt;Action&lt;/strong&gt;: &lt;code&gt;renv&lt;/code&gt;\")\n        InstallRsconnect(\"&lt;strong&gt;Script&lt;/strong&gt;: &lt;code&gt;rsconnect&lt;/code&gt;\")\n        Auth(\"&lt;strong&gt;Env&lt;/strong&gt;: &lt;code&gt;RSCONNECT&lt;/code&gt;\")\n        Deploy(\"&lt;strong&gt;Script&lt;/strong&gt;: Deploy\")\n    end\n  Shiny --&gt;|\"&lt;em&gt;Runs on: Ubuntu Latest&lt;/em&gt;\"| ubuntu\n  PAT --&gt; Checkout --&gt; SetupPandoc --&gt; SetupR\n  SetupR --&gt; SetupRenv --&gt; InstallRsconnect\n  InstallRsconnect --&gt; Auth --&gt; Deploy\n\n\n\n\n\n\nWhen we add, commit, and push the changes to the repo, we see the following deployment log:\ngit add .\ngit commit -m \"shiny deploy workflow\"\ngit push\n[21.2_gha-shiny 7953a5c] shiny deploy workflow\n 10 files changed, 2130 insertions(+)\n create mode 100644 .Rprofile\n create mode 100644 .github/.gitignore\n create mode 100644 .github/workflows/shiny-deploy.yaml\n create mode 100644 renv.lock\n create mode 100644 renv/.gitignore\n create mode 100644 renv/activate.R\n create mode 100644 renv/settings.json\n create mode 100644 rsconnect/shinyapps.io/mjfrigaard/shinyDeployApp.dcf\nOn GitHub, we can see the workflow running on the Actions tab of the sap repository:\n\n\n\n\n\n\n\nshiny deploy workflow running\n\n\nWhen it’s finished, we can see the deployment log from the workflow looks similar to the log we saw locally:\n\n\n\n\n\n\n\ndeploy log from workflow\n\n\nYou can view the deployed application here: https://mjfrigaard.shinyapps.io/shinyDeployApp/",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#sec-gha-shiny-docker",
    "href": "gha.html#sec-gha-shiny-docker",
    "title": "21  GitHub Actions",
    "section": "21.3 Actions, Shiny & Docker",
    "text": "21.3 Actions, Shiny & Docker\nWe covered Docker in the previous chapter, which builds and application in an image and containerizes it’s deployment. In this section we’ll combine Docker and GitHub Actions to automate deployment of our app. Automating app deployments will minimize the risk of environmental discrepancies (avoiding the “it works on my machine” problem) and manual deployment processes. Plus, if something goes wrong after a workflow run, rolling back to a previous version in Git is straightforward.\n\n\nLaunch app with the shinypak package:\n\nlaunch('21.3_gha-shiny-docker')\n\n\n21.3.1 Secrets and tokens\nMost of the steps below are covered in the excellent blog post by Nicola Rennie7 I’ve updated the contents to work with a Shiny app-package.\nTo make sure our Connect username, token, and secret travels with our Dockerfile, we will need to store them as environmental variables.\nEnvironmental variables can be set/unset with Sys.setenv()/Sys.unsetenv():\n\nSys.setenv(RSCONNECT_USER = '&lt;username&gt;', \n  RSCONNECT_TOKEN = '&lt;token&gt;', \n  RSCONNECT_SECRET = '&lt;secret&gt;')\n\nThese environmental variables are be passed to rsconnect::setAccountInfo() with a deploy.R file.\n\n\n21.3.2 deploy.R\ndeploy.R contains the calls to rsconnect::setAccountInfo() and rsconnect::deployApp() we had in our previous workflow file. Sys.getenv() will retrieve the username, token, and secret stored with Sys.setenv():\n\nrsconnect::setAccountInfo(name = Sys.getenv(\"RSCONNECT_USER\"),\n               token = Sys.getenv(\"RSCONNECT_TOKEN\"),\n               secret = Sys.getenv(\"RSCONNECT_SECRET\"))\nrsconnect::deployApp(appDir = \".\", \n  appName = \"shinyAppPkgsDockerCiCd\", \n  account = \"mjfrigaard\", \n    server = \"shinyapps.io\", \n    forceUpdate = TRUE)\n\nThe deploy.R script should be placed in the root folder of sap. By default, this will deploy the application launched with app.R. We’ll change this to the application launched with launch_app('ggp2') by changing the contents of app.R to the following:\n\n\nshow/hide updated app.R\nwithr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        library(sap)\n      },\n      error = function(e) {\n        pkgload::load_all()\n      }\n    )\n    shinyAppDir(appDir = system.file(\"prod/app\", package = \"sap\"))\n  } else {\n    pkgload::load_all()\n  }\n  launch_app(app = 'ggp2', options = list(test.mode = FALSE))\n})\n\n\n\n\n21.3.3 Dockerfile\nThe Dockerfile will look similar to the example in the Docker chapter, but with a few important changes:\n\nWhen we make the path /home/shinyAppPkgsDockerCiCd with mkdir, this is not only the image location we’ll be launching the application from, but it’s also the URL for the deployed app:\n\nhttps:// username .shinyapps.io/shinyAppPkgsDockerCiCd/\n\nWe’ll include the packages in the DESCRIPTION in our list of dependencies to install, and the remotes and rsconnect packages.\nThe final Rscript command will run the application using our deploy.R file.\n\nFROM rocker/shiny\nRUN mkdir /home/shinyAppPkgsDockerCiCd\nADD . /home/shinyAppPkgsDockerCiCd\nWORKDIR /home/shinyAppPkgsDockerCiCd\nRUN R -e 'install.packages(c(\"bslib\", \"cli\", \"fst\", \"ggplot2\", \"ggplot2movies\", \"logger\", \"pkgload\", \"quarto\", \"ragg\", \"remotes\", \"rlang\", \"rsconnect\", \"sass\", \"shiny\", \"shinytest2\", \"shinythemes\", \"stringr\", \"thematic\", \"tidyr\", \"testthat\", \"tools\", \"waldo\", \"withr\"))'\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\nEXPOSE 8180\nCMD Rscript deploy.R\n\n\n21.3.4 shiny-docker.yml\nIn the .github/workflows folder, we’ll create a shiny-docker.yml file with the following contents:\n\n\n\n\n\n\nname: docker-shiny, sap\n\non:\n  push:\n    branches: [ 21.3_gha-shiny-docker ]\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Build image\n        run: docker build -t sap . \n\n\n\nAdd a name for the Docker/Shiny workflow\nSpecify the triggering event the workflow will run on\nThe job will run on ubuntu-latest (with docker id)\nCheckout the code\nBuild the docker image with docker build\n\n\n\n\nThe final execute step is docker run and it passes our environment variables to the secrets we have stored in GitHub (i.e., with secrets.&lt;SECRET_NAME&gt;):\n      - name: execute\n        run: &gt;\n          docker run -e RSCONNECT_USER=${{ secrets.RSCONNECT_USER }} -e RSCONNECT_TOKEN=${{ secrets.RSCONNECT_TOKEN }}  -e RSCONNECT_SECRET=${{ secrets.RSCONNECT_SECRET }} sap  \n       \n\n\n21.3.5 App dependencies\nrsconnect has a handy appDependencies() function that returns a data.frame of packages, versions, and repositories for your application:\n\nhead(rsconnect:::appDependencies(appDir = \".\"))\n\n\n#        Package Version Source               Repository\n# 1         MASS  7.3-65   CRAN https://cran.rstudio.com\n# 2       Matrix   1.7-2   CRAN https://cran.rstudio.com\n# 3           R6   2.6.1   CRAN https://cran.rstudio.com\n# 4 RColorBrewer   1.1-3   CRAN https://cran.rstudio.com\n# 5         Rcpp  1.0.14   CRAN https://cran.rstudio.com\n# 6    base64enc   0.1-3   CRAN https://cran.rstudio.com\n\nPassing appDependencies() in your app-package’s root directory will tell you if any packages have missing Source or Repository values (this can cause the deployment to fail).\nI also recommend running attachment::att_amend_desc() to capture all the dependencies in the DESCRIPTION. For example, att_amend_desc() added the following packages to the Suggests field in the DESCRIPTION:8\n[+] 2 package(s) added: shinytest2, testthat.\n\n\n21.3.6 Docker build\nIn the docker workflow log, we can see the commands from our Dockerfile executed to install the necessary packages:\n\n\n\nInstalling R packages from Dockerfile\n\n\nAfter installing the dependencies, the sap.tar.gz is installed from *source*:\n\n\n\nBuilding our app-package from *source*\n\n\nThe output above should look familiar–it’s very similar to what we see when we run devtools::load_all().\nAfter installing the dependencies, we can see the Shiny deployment log execute in the workflow:\n\n\n\n\n\n\n\nDocker deploy log\n\n\nView the deployed application here.\n\n\n\n\n\n\nCapturing and recording dependencies with renv\n\n\n\n\n\n\nIn the Shiny workflow example above, we captured the application dependencies with renv. However, in this Docker and Shiny workflow, we didn’t create a renv.lock file or a renv/ folder.\nWe get away with this because when the workflow runs, renv is used to capture the dependencies (line 9-12 in the output below). We see a message about the packages listed in the Suggests field or our DESCRIPTION:\n\n\n\n\n\n\n\nDocker dependencies\n\n\nNot having shinytest2 and testthat packages installed won’t interfere with our application deploying because these packages are listed in the Suggests field in the DESCRIPTION file and are used intests/.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#recap",
    "href": "gha.html#recap",
    "title": "21  GitHub Actions",
    "section": "Recap",
    "text": "Recap\nGitHub Actions can be used to set up the necessary R environment and dependencies required to deploy the application from your app-package, while allowing secure account credentials stored in GitHub secrets.\n\n\n\n\n\n\nRecap: GitHub Actions\n\n\n\n\n\n\n\nWe’ve covered the GitHub Action examples for styling the code in our package, deploying our app, and running a docker container.\n\nGitHub Actions can streamline a secure deployment process, which allows you to focus more on developing your application.\nRead about GitHub Actions in the rhino framework in this appendix section\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#footnotes",
    "href": "gha.html#footnotes",
    "title": "21  GitHub Actions",
    "section": "",
    "text": "Triggers can also be configured to run at scheduled times.↩︎\nYou can find more examples of common GitHub Actions for R packages in r-lib/actions/examples.↩︎\nGitHub secrets should be specified by the user following the instructions in the Creating secrets for a repository article.↩︎\n“This action assumes you have an renv lockfile in your repository that describes the R packages and versions required for your Shiny application.” - Shiny App Deployment↩︎\nInstructions for the GitHub Action Shiny deployment can be found here↩︎\nuse-public-rspm is the public RStudio package manager and r-version: renv indicates the R version is captured with renv.↩︎\nAutomatically deploying a Shiny app for browsing #RStats tweets with GitHub Actions. Nicola Rennie. October 3, 2022.↩︎\natt_amend_desc() adds a dev folder with a YAML config file, but you can remove this before building/deploying.↩︎",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "pkgdown.html",
    "href": "pkgdown.html",
    "title": "22  pkgdown",
    "section": "",
    "text": "22.1 Setting up pkgdown\nIn this chapter, we’ll cover setting up a pkgdown website for our app-package. Building a package website isn’t required, but it’s a great way to confirm your package is documented and structured correctly, and it gives you an opportunity to share all of your hard work! pkgdown can be configured to automatically generate a beautiful website from a pre-specified Git branch GitHub Actions.\nA pkgdown website makes our Shiny app and its accompanying package more accessible to potential users by providing them with a central location for any information they need (app features, updates, etc.).\nThe magic of pkgdown is it’s conversion of an existing R package structure into a website with documentation for our application.\npkgdown has a usethis function similar to testthat for setup:1\nuse_pkgdown_github_pages() takes care of (most of) the setup for our app-package website, but we’ll break down the steps below.2",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-setup",
    "href": "pkgdown.html#sec-pkgdown-setup",
    "title": "22  pkgdown",
    "section": "",
    "text": "install.packages(\"pkgdown\")\n\nusethis::use_pkgdown_github_pages()\n\n\n22.1.1 _pkgdown.yml\nThe initial output after running use_pkgdown_github_pages() looks something like the following:\n\n\n\n\n\n\nuse_pkgdown_github_pages() output\n\n\n\n\n\n\nI’ve replaced my GitHub username with &lt;UserName&gt; and the name of the app-package/repository with &lt;pkgName&gt;\n\n\n\n\n✔ Setting active project to '/Users/&lt;UserName&gt;/projects/&lt;pkgName&gt;'\n✔ Adding '^_pkgdown\\\\.yml$', '^docs$', '^pkgdown$' to '.Rbuildignore'\n✔ Adding 'docs' to '.gitignore'\n✔ Writing '_pkgdown.yml'\n• Modify '_pkgdown.yml'\n✔ Recording 'https://&lt;UserName&gt;.github.io/&lt;pkgName&gt;/' as site's url in '_pkgdown.yml'\n✔ Adding 'https://&lt;UserName&gt;.github.io/&lt;pkgName&gt;/' to URL\n✔ Setting 'https://&lt;UserName&gt;.github.io/&lt;pkgName&gt;/' as homepage of GitHub repo '&lt;UserName&gt;/&lt;pkgName&gt;'\n_pkgdown.yml is initially created with only the url, template, and bootstrap version:\nurl: https://&lt;UserName&gt;.github.io/&lt;pkgName&gt;/\ntemplate:\n  bootstrap: 5\nThese fields are all that’s required to launch your pkgdown site, but in the following sections we’ll cover how to edit _pkgdown.yml to customize the fonts, colors, contents, and layout of our site.\n\n\n22.1.2 gh-pages branch\nuse_pkgdown_github_pages() sets up publishing our app-package site from an ‘orphan branch from GitHub pages’:\n✔ Initializing empty, orphan 'gh-pages' branch in GitHub repo '&lt;UserName&gt;/&lt;pkgName&gt;'\n✔ GitHub Pages is publishing from:\n• URL: 'https://&lt;UserName&gt;.github.io/&lt;pkgName&gt;/'\n• Branch: 'gh-pages'\n\n\n\n\n\n\n Orphan branches\n\n\n\n\n\n\nAn orphan branch is a new Git branch with no commit history, effectively starting a new ‘root’ in our project’s development history. For our app-package, the gh-pages branch serves as a new line of development, completely separated from all other branches.\n\n\n\n\nWe’re also told GitHub pages will be publishing our app-package website at the following URL: https://&lt;UserName&gt;.github.io/&lt;pkgName&gt;/\n\n\n22.1.3 .github/workflows/\nuse_pkgdown_github_pages() creates a GitHub Action workflow folder (.github/workflows/) with a YAML file (pkgdown.yaml):\n• Path: \"/\"\n✔ Adding \"*.html\" to .github/.gitignore.\n✔ Saving \"r-lib/actions/examples/pkgdown.yaml@v2\" to .github/workflows/pkgdown.yaml.\n☐ Learn more at &lt;https://github.com/r-lib/actions/blob/v2/examples/README.md&gt;.\nWe’re also told the contents in this file are copied from the r-lib/actions repository (which we’ve covered previously in Section 21.1 and Section 21.2).",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-site-contents",
    "href": "pkgdown.html#sec-pkgdown-site-contents",
    "title": "22  pkgdown",
    "section": "22.2 Building site",
    "text": "22.2 Building site\nusethis has two functions for building your pkgdown site:\n\nbuild_site()\nbuild_site_github_pages()\n\nWe used use_pkgdown_github_pages() to configure our app-package, so we’ll use build_site_github_pages() to build our site.\npkgdown::build_site_github_pages()\nIn the following sections, we’ll take a look at how the files and folders in our app-package are used to create the site’s contents. As mentioned above, the great thing about pkgdown sites is that they use our existing package structure to build a beautiful site that’s easy to navigate (with minimal changes).\n\n22.2.1 docs/\nThe docs/ folder contains the .html files for our website (that’s why ^docs$ was added to the .Rbuildignore and docs was added to the .gitignore). After creating a home for our site contents, the site initialization files are copied from the local pkgdown installation into docs/\n== Building pkgdown site ======================================================\nReading from: '/Users/&lt;UserName&gt;/&lt;pkgName&gt;'\nWriting to:   '/Users/&lt;UserName&gt;/&lt;pkgName&gt;/docs'\n\n\n22.2.2 README.md -&gt; index.html\nThe landing page (index.html) for our app-package website is built from the README.md file. An example of the site URL is below:\nhttps://&lt;UserName&gt;.github.io/&lt;pkgName&gt;/index.html\nThe &lt;UserName&gt; is our GitHub username, and the &lt;pkgName&gt; is the name of our package. The authors.html is built from the Author and Maintainer fields in the DESCRIPTION file. Long-form documentation can be stored in vignettes (Section 1.15.3) which will be converted into articles (covered below).\n\n\n\n\n\n\nStandard README for your app-package\n\n\n\n\n\n\nIf you’d like a boilerplate README.md for an R package, you can use usethis::use_readme_rmd():\nusethis::use_readme_rmd()\n✔ Setting active project to '/Users/&lt;UserName&gt;/projects/&lt;pkgName&gt;'\n✔ Writing 'README.Rmd'\n✔ Adding '^README\\.Rmd$' to '.Rbuildignore'\n• Modify 'README.Rmd'\n✔ Writing '.git/hooks/pre-commit'\nAt minimum, the README.Rmd should include:\n\nThe purpose/goal of your app-package\n\nInstructions for installation\n\nLinks to a deployed version (if applicable)\n\nSupporting packages\n\nIf I chose to use this README.md file, I usually remove the .git/hooks/pre-commit (so they don’t interfere with my personal add/commit/push process).\nunlink('.git/hooks/pre-commit')\n\n\n\n\n\n\n22.2.3 man/ -&gt; Reference\nThe functions documented in the man/ folder are converted into individual items in the Reference menu item (see Chapter 5). I’ve included two examples below:\n\n\n\n\n\n\nman/\n  ├── display_type.Rd\n  └── launch_app.Rd\n\n\n── Building function reference ───────────\nWriting reference/index.html\nReading man/display_type.Rd\nWriting reference/display_type.html\nReading man/launch_app.Rd\nWriting reference/launch_app.html\n\n\n\n\nFunctions will only be included in the Reference if they’ve been exported (see Section 6.2)\nThe @seealso and @family tags will create hyperlinks between our utility functions, modules, UI/server/standalone app functions (see Section 5.2)\nAll @examples will be run and displayed (Section 5.1.6)\n\n\n\n22.2.4 vignettes -&gt; Articles\nThe .Rmd files in the vignettes folder are rendered as HTML files and displayed under an Articles menu item. The exception to this is any vignettes with the same name as our app-package. This vignette will automatically be listed under a menu dropdown titled “Get Started”:3\n\n\n\n\n\n\nvignettes/\n  ├── sap.Rmd\n  └── specs.Rmd\n\n\n-- Building articles -------------\nWriting 'articles/index.html'\nReading 'vignettes/sap.Rmd'\nWriting 'articles/sap.html'\nReading 'vignettes/specs.Rmd'\nWriting 'articles/specs.html'\n== DONE ==========================\n\n\n\nThe final step in the build process is to add a .nojekyll file in the repository (this hidden file is necessary for pkgdown sites configured to deploy from GitHub pages).\n-- Extra files for GitHub pages ----------------------------------------------\nWriting '.nojekyll'",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-layouts",
    "href": "pkgdown.html#sec-pkgdown-layouts",
    "title": "22  pkgdown",
    "section": "22.3 Customize layout",
    "text": "22.3 Customize layout\nWe can customize the look of our pkgdown site by editing the contents of _pkgdown.yml.\n\n22.3.1 Themes, colors and fonts\nBelow are some examples of the fields that control the bootswatch theme (&lt;THEME&gt;), code syntax highlighting(&lt;HIGHLIGHTING&gt;):\n\n\n\n\n\n\nYAML Fields\ntemplate:\n  bootstrap: 5\n  bootswatch: &lt;THEME&gt;\n  theme: &lt;HIGHLIGHTING&gt;\n\n\nIn _pkgdown.yml\ntemplate:\n  bootstrap: 5\n  bootswatch: united\n  theme: atom-one-light\n\n\n\nWe can use the bslib package for additional control over the fonts and colors on our site. The &lt;COLOR&gt; should be replaced with a color hex, and &lt;FONT&gt; can include any freely available Google fonts.4\n\n\n\n\n\n\nYAML Fields\n  bslib:\n    primary: \"&lt;COLOR&gt;\"\n    code-color: \"&lt;COLOR&gt;\"\n    code-bg: \"&lt;COLOR&gt;\"\n    base_font:\n      google: &lt;FONT&gt;\n    heading_font:\n      google: &lt;FONT&gt;\n    code_font:\n      google: &lt;FONT&gt;\n\n\nIn _pkgdown.yml\n  bslib:\n    primary: \"#02577A\"\n    code-color: \"#007bff\"\n    code-bg: \"#EAE9EA\"\n    base_font:\n      google: Ubuntu\n    heading_font:\n      google: Fira Sans Condensed\n    code_font:\n      google: Ubuntu Mono\n\n\n\nYou can see the theme, color, and font choices below:\n\n\n\npkgdown template in yml\n\n\n\n\n22.3.2 Articles\nThe articles should include a link to the landing page for our app, and provide detailed examples of how it works, including links to any additional resources or documentation.\nThe navbar components can also be customized with titles, sections, and article names. In _pkgdown.yml, the articles are listed under components, and we will add a text title (Docs) and sub-heading (Specs):\n\n\n\n\n\n\nIn _pkgdown.yml\nnavbar:\n components:\n   articles:\n    text: Docs\n    menu:\n    - text: \"Specs\"\n\n\nOutput\n\n\n\nNavbar components\n\n\n\n\n\nAs noted above, any vignette with a filename that matches the package name will be automatically named ‘Getting Started’ in the navbar. We can also add sections with article titles by placing them in text fields. These are listed under the menu (note the indentation), with a path to the html file.\n\nI’ve listed the App Specifications vignette under a \"Specs\" section (see Chapter 15), and linked to articles/specs.html:\n\n\n\n\n\n\n\nIn _pkgdown.yml\n    text: Docs\n    menu:\n    - text: \"Specs\"\n    - text: App Specifications\n      href: articles/specs.html\n\n\nOutput\n\n\n\nArticle sections\n\n\n\n\n\nUse ------- with a text field to create horizontal separators between sections (without a corresponding href).\n\nI’ve added a Modules section and a Application Modules vignette (stored in vignettes/modules.Rmd and published to articles/modules.html):\n\n\n\n\n\n\n\nIn _pkgdown.yml\n    text: Docs\n    menu:\n    - text: \"Specs\"\n    - text: App Specifications\n      href: articles/specs.html\n    - text: -------\n    - text: \"Modules\"\n    - text: App Modules\n      href: articles/modules.html\n\n\nOutput\n\n\n\nArticles separator\n\n\n\n\n\n\n\n22.3.3 Function reference\npkgdown will automatically generate a Package index section for any object with an .Rd file in the man/ folder. This includes functions we’ve explicitly exported with (i.e., with @export) and functions we’ve documented with @keywords internal.5\nBy default, the function are sorted alphabetically, but we can customize them into sections with titles and descriptions using the fields below in _pkgdown.yml:\nreference:\n- title: \"&lt;TITLE&gt;\"\n  desc: &gt;\n    &lt;DESCRIPTION&gt;\n  contents:\n  - &lt;FUNCTION&gt;\nFor example, we can include a section for the modules we’re exporting from our app-package:\n\n\n\n\n\n\nIn _pkgdown.yml\nreference:\n- title: \"Modules\"\n  desc: &gt;\n    App modules\n\n\nOutput\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCustomizing Reference\n\n\n\n\n\n\nThe _pkgdown.yml file must include all exported functions if you customize the reference field. If not, you’ll see an error when you try to build your site:\n-- Building function reference ------------------------------------\nError in `check_missing_topics()`:\n! All topics must be included in reference index\n✖ Missing topics: &lt;FUN&gt;\nℹ Either add to _pkgdown.yml or use @keywords internal\n\n\n\n\nTo help organize and display the functions in your app-package, we can use tidyselect helpers6 in the bullets below contents.\nFor example, we can list modules with starts_with(\"mod\"):7\n\n\n\n\n\n\nIn _pkgdown.yml\nreference:\n- title: \"Modules\"\n  desc: &gt;\n    Application modules\n  contents:\n  - starts_with(\"mod\")\n\n\nOutput\n\n\n\n\n\n\n\n\nWe can also use _pkgdown.yml to list any datasets we’ve documented (see Section 7.3) in our app-package.\n\n\n\n\n\n\nIn _pkgdown.yml\n- title: \"Data\"\n  desc: \"App data\"\n  contents:\n  - movies\n\n\nOutput",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-workflow",
    "href": "pkgdown.html#sec-pkgdown-workflow",
    "title": "22  pkgdown",
    "section": "22.4 Deploying your site",
    "text": "22.4 Deploying your site\nThe .github/workflows/pkgdown.yaml file automates building and deploying our app-package’s pkgdown site. This workflow file is configured to be triggered by a specific GitHub event, build the website using the standard R package files, then deploys the site to GitHub Pages. Below we’ll breakdown the fields and values of the workflow (and their functions):\n\n22.4.1 Event\n\n\n\n\n\n\n1. Set to trigger on push to the 22_pkgdown branch\n\n\non:\n  push:\n    branches: [22_pkgdown]\n\n\n\n\n\n\n\n\n\n \n\n\na. Also triggers when a release is published, allowing the website to showcase the latest version of the package.8\n\n\n  release:\n    types: [published]\n\n\n\n\n\n\n\n\n\n \n\n\nb. workflow_dispatch allows the workflow to be manually triggered from the GitHub Actions web interface (for ad-hoc updates).9\n\n\n  workflow_dispatch:\n\n\n\n\n\n22.4.2 Jobs\n\n\n\n\n\n\n2. name defines a single job with the ID pkgdown.\n\n\nname: pkgdown\n\n\n\n\n\n22.4.3 Runner\n\n\n\n\n\n\n3. The pkgdown job ID runs on the latest Ubuntu runner provided by GitHub Actions.\n\n\njobs:\n  pkgdown:\n    runs-on: ubuntu-latest\n\n\n\n4. The comment Only restrict concurrency for non-PR jobs refers to the concurrency field,10 which prevents concurrent runs of the job for non-pull request events (avoiding conflicts or redundant deployments). group11 uses a dynamic expression to differentiate between pull_request events and github.event_name, using the run ID (github.run_id) for pull requests to allow concurrency.\n    # Only restrict concurrency for non-PR jobs\n    concurrency:\n      group: pkgdown-${{ github.event_name != 'pull_request' || github.run_id }}\n\n\n22.4.4 Map\n5. env maps the GITHUB_PAT environment variable using the GitHub token, secrets.GITHUB_TOKEN (which allows the workflow to authenticate and perform operations within the repository).\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n\n\n\n\n\n\n6. permissions explicitly grants the workflow write permissions to the repository, enabling it to push changes (like an updated website).\n\n\n    permissions:\n      contents: write\n\n\n\n\n\n22.4.5 Steps\n\n\n\n\n\n\n7. Checks out the repository’s code, making it available to subsequent steps.\n\n\n  steps:\n    - uses: actions/checkout@v4\n\n\n\n\n\n\n\n\n\n8. Installs pandoc, which is necessary for rendering markdown documents and vignettes.\n\n\n    - uses: r-lib/actions/setup-pandoc@v2\n\n\n\n\n\n\n\n\n\n9. Sets up the R environment and configures it to use the public RStudio package manager (use-public-rspm) for faster package installations.\n\n\n    - uses: r-lib/actions/setup-r@v2\n      with:\n        use-public-rspm: true\n\n\n\n\n\n\n\n\n\n10. Installs the dependencies required by our app-package and pkgdown.\n\n\n    - uses: r-lib/actions/setup-r-dependencies@v2\n\n\n\n\n\n\n\n\n\n \n\n\na. Specifies installing any::thing from pkgdown and the local:: package (our app-package).12\n\n\n      with:\n        extra-packages: any::pkgdown, local::.\n        needs: website\n\n\n\n11. Executes pkgdown::build_site_github_pages() within an R script shell to build the pkgdown website. It’s configured not to start a new R process for the build and not to install our app-package (assuming dependencies are already handled in step 10).\n    - name: Build site\n      run: pkgdown::build_site_github_pages(new_process = FALSE, install = FALSE)\n      shell: Rscript {0}\n12. Uses JamesIves/github-pages-deploy-action@v4.5.0 to deploy the site to GitHub Pages (provided the event is not a pull request).\n    - name: Deploy to GitHub pages 🚀\n      if: github.event_name != 'pull_request'\n      uses: JamesIves/github-pages-deploy-action@v4.5.0\n\n\n\n\n\n\n \n\n\na. Specifies not to clean the deployment branch, deploys it to the gh-pages branch, and sets the site content source folder to docs\n\n\n      with:\n        clean: false\n        branch: gh-pages\n        folder: docs\n\n\n\n.github/workflows/pkgdown.yaml performs more operations than the previous workflows. However, these extra steps allow us to use the gh-pages branch to maintain and showcase up-to-date package documentation for users, contributors, and collaborators. When we’re happy with the layout of our website in _pkgdown.yml, we can add, commit, and push the changes back to the repo:\ngit add .\ngit commit -m \"updates to _pkgdown.yml\"\ngit push",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-github",
    "href": "pkgdown.html#sec-pkgdown-github",
    "title": "22  pkgdown",
    "section": "22.5 GitHub",
    "text": "22.5 GitHub\nAfter pushing the changes to the 22_pkgdown branch, we can see our new 22_pkgdown workflow listed with the previous 21.1_gha-style (Section 21.1) and 21.2_gha-shiny-deploy (Section 21.2) workflows in the Actions tab:\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('22_pkgdown')\n\nThe pkgdown sites can take a few minutes to build, but we can monitor it’s progress from the Actions tab:\n\n\n\n\n\n\n\nWorkflow created on push to 22_pkgdown branch\n\n\nThe workflow file triggers the following steps:\n\n\n\n\n\n\n\nGitHub Pages Deploy Action\n\n\n\nBack in the Actions tab, we see a new pages build and deployment workflow has been created with a ‘bot’ tag:\n\n\n\n\n\nThe updates to _pkgdown.yml workflow represents the changes we committed and pushed to the 22_pkgdown branch (#21), but we configured our website to be served from the gh-pages branch (#22). Each time we push changes to 22_pkgdown and trigger the pkgdown workflow, a corresponding pages build and deployment workflow will be triggered to build and deploy the site:\n\n\n\n\n\n\n\nBuild and deploy pkgdown site\n\n\nThis automated deployment process is essential for maintaining up-to-date documentation or website content for R packages (like sap) without manual intervention, making it easier for developers to focus on development while ensuring that users always have access to the latest information.\nView the package website here.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#recap",
    "href": "pkgdown.html#recap",
    "title": "22  pkgdown",
    "section": "Recap",
    "text": "Recap\npkgdown is handy for creating beautiful, functional websites for your app-package. Package sites help share your app-package with others in a more engaging and informative way.\n\n\n\n\n\n\nRecap: \n\n\n\n\n\n\n\n\nInstallation\ninstall.packages('pkgdown)`\nSetup: create a configuration file that pkgdown will use to build your site with one of the usethis functions below:\nusethis::use_pkgdown_github_pages()\n# or\n# usethis::use_pkgdown() \n\nThese create a _pkgdown.yml configuration file that lets us customize how our site looks and which parts of our app-package are diplayed/highlighted.\n\nCustomize: we can change our pkgdown site theme, set colors and fonts, organize the navigation bar, and add custom sections and pages. For an app-package, this means we can create a landing page for our Shiny app, provide detailed articles on how it works, and link to any additional resources or documentation.\nBuilding Your Site\npkgdown::build_site_github_pages()\n# or \n# pkgdown::build_site()\nbuild_site_github_pages() goes through our app-package (function documentation, and examples, RMarkdown vignettes, README, NEWS, etc.) and assembles a coherent, navigable site.\nDeploying Your Site: after building a pkgdown site, we can use GitHub Actions to upload the generated website contents to GitHub Pages, which hosts our app-package site directly from a GitHub repository.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#footnotes",
    "href": "pkgdown.html#footnotes",
    "title": "22  pkgdown",
    "section": "",
    "text": "usethis also has a generic function for using pkgdown (use_pkgdown()), but we’re going to cover building and deploying our app-package site using GitHub pages. Read more about use_pkgdown() in the usethis documentation.↩︎\nInternally, this function calls usethis::use_pkgdown(), usethis::use_github_pages(), and usethis::use_github_action(\"pkgdown\"). Read more in the usethis documentation.↩︎\nI created this vignette with usethis::use_vignette(\"sap\") and included instructions for launching the various apps in sap.↩︎\nRead more about bslib in pkgdown sites in the documentation.↩︎\nFunctions with @keywords internal aren’t listed in the package index, but can be accessed with pkg:::fun() (like the test_logger() function in sap).↩︎\nRead more about how to build the function reference here↩︎\nUsing the mod_ as a prefix for module functions is a habit I’ve adopted from the golem package (specifically, the add_module() function).↩︎\n“You can create releases to bundle and deliver iterations of a project to users.”↩︎\n“To enable a workflow to be triggered manually, you need to configure the workflow_dispatch event.”↩︎\n“Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time.”↩︎\n“Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.”↩︎\nThe needs: website fields might be a placeholder? I’m unaware of the needs keyword applied within a with clause for setting up dependencies. This also could be intended as a comment or note for future adjustments…↩︎",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "frameworks.html",
    "href": "frameworks.html",
    "title": "Frameworks",
    "section": "",
    "text": "Shiny frameworks\nThis section covers three popular Shiny frameworks: golem, leprechaun, and rhino. These frameworks provide structure and modularity and encourage better development practices, but each has its own philosophy, strengths, and ideal use case. See the Shiny Frameworks supplemental website for more information on how each application was created.",
    "crumbs": [
      "Frameworks"
    ]
  },
  {
    "objectID": "frameworks.html#shiny-frameworks",
    "href": "frameworks.html#shiny-frameworks",
    "title": "Frameworks",
    "section": "",
    "text": "golem\nThe golem chapter creates gap (a golem app-package).\n\n\n\n\nTopics covered\n\n23.2 The dev/ scripts\n\n23.3 Set up\n\n23.4 Development\n\n23.4.1 The R/ folder\n\n23.4.2 The inst/ folder\n\n23.4.3 Data\n23.4.4 Documentation\n\n23.4.6 Tests\n\n23.4.7 Code coverage\n\n23.4.8 Continuous Integration (CI)\n\n\n23.5 Deployment\n\n23.6 Summary of golem features\n\n\n\n\n\n\n\nChapter 23 Applications\n\n\n\n\n\n\nThe applications in Chapter 23 (golem) can be accessed with the launch() or get() functions from the shinypak R package:\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\nlibrary(shinypak)\n\nChapter 23 applications:\n\nlist_apps(regex = '^23')\n## # A tibble: 1 × 2\n##   branch   last_updated       \n##   &lt;chr&gt;    &lt;dttm&gt;             \n## 1 23_golem 2025-03-25 11:43:13\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nVersion\nTitle\nDescription\n\n\n\n\ngolem\n0.5.1\nA Framework for Robust Shiny Applications\nAn opinionated framework for building a production-ready 'Shiny' application. This package contains a series of tools for building a robust 'Shiny' application from start to finish.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nleprechaun\nThe leprechaun chapter creates lap (a leprechaun app-package).\n\n\n\n\n\nTopics covered\n\n\n\n\n\n\nChapter 24 Applications\n\n\n\n\n\n\nThe applications in Chapter 24 (leprechaun) can be accessed with the launch() or get() functions from the shinypak R package:\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\nlibrary(shinypak)\n\nChapter 24 applications:\n\nlist_apps(regex = '^24')\n## # A tibble: 1 × 2\n##   branch        last_updated       \n##   &lt;chr&gt;         &lt;dttm&gt;             \n## 1 24_leprechaun 2025-04-06 22:46:54\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nVersion\nTitle\nDescription\n\n\n\n\nleprechaun\n1.0.0.9001\nCreate Simple 'Shiny' Applications as Packages\nCode generator for robust dependency-free 'Shiny' applications in the form of packages. It includes numerous convenience functions to create modules, include utility functions to create common 'Bootstrap' elements, setup a project from the ground-up, and much more.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrap\nrap is a rhino app (pseudo-package)1\n\n\n\n\n\n\n\n\n\nChapter 25 Applications\n\n\n\n\n\n\nThe applications in Chapter 25 (rhino) can be accessed with the launch() or get() functions from the shinypak R package:\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\nlibrary(shinypak)\n\nChapter 25 applications:\n\nlist_apps(regex = '^25')\n## # A tibble: 1 × 2\n##   branch   last_updated       \n##   &lt;chr&gt;    &lt;dttm&gt;             \n## 1 25_rhino 2024-08-24 05:20:05\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nVersion\nTitle\nDescription\n\n\n\n\nrhino\n1.11.0\nA Framework for Enterprise Shiny Applications\nA framework that supports creating and extending enterprise Shiny applications using best practices.",
    "crumbs": [
      "Frameworks"
    ]
  },
  {
    "objectID": "frameworks.html#footnotes",
    "href": "frameworks.html#footnotes",
    "title": "Frameworks",
    "section": "",
    "text": "rhino apps aren’t R packages–they’re dependencies are managed with a dependencies.R file and box modules.↩︎",
    "crumbs": [
      "Frameworks"
    ]
  },
  {
    "objectID": "golem.html",
    "href": "golem.html",
    "title": "23  golem",
    "section": "",
    "text": "23.1 gap (a golem app-package)\nThis chapter walks through building a version of the sap with the golem framework. Install the golem package from CRAN (or the development version):\nThe version/description of golem used in this Shiny app-package is:\nThis chapter is slightly different than the others. I’ll cover the golem method for creating app-packages, not necessarily the code itself. The application I’ll use is identical to the one we’ve built in previous chapters (using the movies data, with two input modules, one display module, and a utility function for building the scatter plot).\nAll golem apps export the standalone app function, run_app().\nlibrary(gap)\ngap::run_app()\nIn the sections below, I’ll note various features or tools that differ from the standard devtools/usethis app-package development we’ve covered so far. For a more comprehensive overview of golem Shiny app development, check out the Engineering Production-Grade Shiny Apps book and my Shiny frameworks website.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#gap-a-golem-app-package",
    "href": "golem.html#gap-a-golem-app-package",
    "title": "23  golem",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('23_golem')\n\n\n\n\n\n\n\nFigure 23.1: After loading, documenting, and installing gap, launch the movies with run_app()",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#sec-golem-dev-scripts",
    "href": "golem.html#sec-golem-dev-scripts",
    "title": "23  golem",
    "section": "23.2 The dev/ scripts",
    "text": "23.2 The dev/ scripts\nAfter creating a new golem app with golem::create_golem() or using the New Project Wizard in RStudio, you’ll see a dev/ folder with three scripts for setting up, developing, and launching/deploying your application.\n\ndev\n├── 01_start.R\n├── 02_dev.R\n└── 03_deploy.R\n\nThe package website has each script available in vignettes: 01_start, 02_dev, 03_deploy.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#sec-golem-start",
    "href": "golem.html#sec-golem-start",
    "title": "23  golem",
    "section": "23.3 Set up",
    "text": "23.3 Set up\n\n“01_start.R should be filled at start.”\n\nThe dev/01_start.R file opens when the new golem app-package launches and provides steps for setting up the following files, folders, and options:\n\nUse golem’s fill_desc() function for entering the necessary DESCRIPTION fields.1\ngolem has functions that automatically set multiple options in the golem-config.yml2 and package dependencies3\nusethis functions are called for:4\n\ncreating a LICENSE5\n\ncreating6 and building7 a README\n\ncreating a CODE_OF_CONDUCT.md8\n\nadding a Lifecycle badge9, and\n\nand the NEWS.md file.10\n\nIf you aren’t using Git, there are functions for initiating and configuring your repo.11\nThe app testing suite is set up using use_recommended_tests().12\ngolem apps also have custom functions for creating a series of UI13 and server14 utility functions (which we’ll cover below).",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#sec-golem-dev",
    "href": "golem.html#sec-golem-dev",
    "title": "23  golem",
    "section": "23.4 Development",
    "text": "23.4 Development\n\n“02_dev.R should be used to keep track of your development during the project.\n\nAfter setting up your golem app-package, the dev/02_dev.R file contains functions and tools for developing the application.\n\n23.4.1 The R/ folder\nThe dev/02_dev.R script contains the following functions for developing functions, modules, and other application code.\n\n\n\n\n\n\nPrimary app files\n\n\nAll golem apps come with primary app UI and server functions (R/app_ui.R and R/app_server.R) and a standalone app function (R/run_app.R.).\n\n\n\n\n\n\n\n\n\nModules\n\n\nadd_module() adds a .R file with a mod_ prefix (an optional test can be included with the with_test = TRUE argument)\n\n\n\n\n\n\n\n\n\nUtility functions\n\n\n\nUtility functions can be added with add_utils() or add_fct() (also includes the with_test option for tests).\nThe golem_utils_* files contain commonly used UI and server functions:\n\nuse_utils_ui() creates the R/golem_utils_ui.R file.\nuse_utils_server() creates the R/golem_utils_server.R file.\n\n\n\n\n\n\n\n\n\n\n\nOther R files\n\n\n\nR/_disable_autoload.R disables shiny::loadSupport() (an option we covered in the Launch chapter) \nR/app_config.R contains configuration functions:\n\n\napp_sys() is a wrapper for system.file() \nget_golem_config() reads environment variables (i.e., GOLEM_CONFIG_ACTIVE) and the contents of inst/golem-config.yml:\n\n\n\n\n\nBelow is the R/ folder after creating the modules and utility functions.\n\n\nshow/hide R folder\nR\n1├── _disable_autoload.R\n2├── app_config.R\n3├── app_server.R\n├── app_ui.R\n4├── data.R\n5├── golem_utils_server.R\n├── golem_utils_ui.R\n6├── mod_aes_inputs.R\n7├── mod_scatter_display.R\n8├── mod_var_inputs.R\n9├── run_app.R\n10├── utils_gap_theme.R\n11├── utils_scatter_display.R\n12└── utils_tests.R\n\n1 directory, 14 files\n\n\n\n1\n\nTurn off loadSupport()\n\n\n2\n\nConfigure app functions\n\n3\n\nApp UI and server functions\n\n\n4\n\nData documentation\n\n\n5\n\ngolem utility functions\n\n\n6\n\nAesthetics input module\n\n7\n\nScatter plot module\n\n\n8\n\nVariable input module\n\n\n9\n\nStandalone app function\n\n\n10\n\nbslib theme\n\n11\n\nScatter plot utility function (scatter_plot())\n\n\n12\n\nTest utility function (test_logger())\n\n\n\n\n\n\n\n\n\n\nCode file names\n\n\n\n\n\n\n Including the mod_/utils_ prefixes in the names of the .R scripts makes it easier to separate them from other code in your package namespace when using tab-completion or searching for a particular file using Ctrl + .:\n\n\n\n\n\n\n\n\nGo to File/Function in RStudio\n\n\n\n\n\n\n\n\n23.4.2 The inst/ folder\nThe inst/ folder has a special role in golem apps. Custom functions handle external resources to ensure these files are loaded when the application launches.\n\n\n\n\n\n\nThe inst/ folder\n\n\n\nThe app/ folder contains the application files.15\n\nwww/ contains an initial favicon.ico icon.\n\ngolem-config.yml is used to set various configuration options. 16\n\n\n\n\n\n\n\n\n\n\nExternal files\n\n\n\ngolem_add_external_resources() adds external files, which uses similar methods to Chapter 9.\n\ngolem_add_external_resources(), golem::add_resource_path(), and app_sys() are essentially wrappers for shiny::addResourcePath() and system.file().\nThe WORDLIST includes the word ‘golem’ and it’s an artifact from spellcheck argument in use_recommended_tests().17\n\n\n\n\n\n\n\n\n\n\n\nNon-R files\n\n\n\ndev/02_dev.R includes helpers for adding JavaScript, CSS, and other files to the inst/app/www/ folder:\n\ngolem::add_js_file()\ngolem::add_js_handler()\ngolem::add_css_file()\ngolem::add_sass_file()\ngolem::add_any_file()\n\n\n\n\n\n\ninst\n├── WORDLIST\n├── app\n│   └── www\n│       ├── favicon.ico\n│       └── golem.png\n├── extdata\n│   └── movies.RData\n└── golem-config.yml\n\n4 directories, 5 files\n\n\n\n23.4.3 Data\nData in golem app-packages function like the data files and folders in a standard R package (we covered these in Chapter 7).\n\n\n\n\n\n\nExternal data\n\n\ninst/extdata/ contains the external data files.18\n\n\n\n\ninst\n└── extdata\n    └── movies.RData\n\n2 directories, 1 file\n\n\n\n\n\n\n\nRaw data\n\n\ndata-raw/ contains movies.R, which is used to load extdata/movies.RData and create the data/movies.rda file.\n\n\n\n\ndata-raw\n├── movies.R\n└── movies.RData\n\n1 directory, 2 files\n\n\n\n\n\n\n\nPackage data\n\n\ndata/ contains the movies.rda file used in the application.\n\n\n\n\ndata\n└── movies.rda\n\n1 directory, 1 file\n\n\n\n23.4.4 Documentation\nThe roxygen2 documentation in golem app-package files comes with boilerplate tags and descriptions similar to those covered in Chapter 5.\n\n\n\n\n\n\nThe man/ folder\n\n\nBy default, modules created with add_module() or golem’s other file creation functions will have the @noRd tag, so the man/ folder will only contain functions we’ve manually exported:19\n\n\n\n\nman\n1├── gap_theme.Rd\n2├── movies.Rd\n3├── run_app.Rd\n4├── scatter_plot.Rd\n5└── test_logger.Rd\n\n1 directory, 5 files\n\n\n1\n\nbslib theme for (thematic)\n\n\n2\n\nData documentation\n\n\n3\n\nThe ‘pre-packaged’ standalone app function (only export from golem apps)\n\n\n4\n\nPlot utility function (exported from gap)\n\n\n5\n\nTest utility function (exported from gap)\n\n\n\n\n\n\n\n\n\n\nVignettes\n\n\nPackage vignettes in golem app-packages operate like vignettes in standard R packages.\n\n\n\n\nvignettes/\n├── shinytest2.Rmd\n└── tests_and_coverage.Rmd\n\n1 directory, 2 files\n\nI’ve stored the shinytest2 in the vignettes/shinytest2.Rmd vignette (more on this below).\n\n\n23.4.5 Dependencies\n\n\n\n\n\n\nDevelopment dependencies\n\n\n\nThe install_dev_deps() function from the dev/01_start.R script installs the packages needed to develop a golem app.\nInclude packages to the Imports field in the DESCRIPTION with attachment::att_amend_desc(), which parses the code under R/ to make sure the DESCRIPTION file is up-to-date.\n\n\n\n\n\n\n\n\n\n\nPackage dependencies\n\n\n\nInclude add-on packages with usethis::use_package() and use pkg::fun() in the roxygen2 documentation (see Section 6.3).\n\nFor example, we’ve included a thematic theme to match the golem package colors.\nAfter creating our theme in R/gap_theme.R, the golem_add_external_resources() function in R/app_ui.R can include this dependency with bslib::bs_theme_dependencies().\n\nModules and functions created with golem’s file creation helpers include @importFrom in their roxygen2 documentation.\n\n\n\n\n\n\n23.4.6 Tests\nThe test suite for golem app-packages is set up in the dev/01_start.R script.20 golem’s helper functions can potentially provide a lot of boilerplate tests, because any code files created with add_module(), add_utils(), and add_fct() will also include a test file if with_test is set to TRUE.\n\n\n\n\n\n\nThe tests/ folder\n\n\n\nA tests/README.md file is created by the covrpage package.\ntests/spelling.R adds functionality from the spelling package.21\n\n\n\n\n\n\n\n\n\n\nUnit tests\n\n\n\ntest-golem-recommended.R contains tests for the functions included in your new golem app.22\nThe two golem utility function files (golem_utils_server.R, and golem_utils_ui.R) have accompanying tests files.\n\ntest-golem_utils_server.R contains utility functions that might be useful in the server.\ntest-golem_utils_ui.R contains utility functions that might be useful in the UI.\n\ntest-utils_scatter_display.R tests our scatter_plot() utility function.\n\n\n\n\n\n\n\n\n\n\nModule tests\n\n\n\ntest-mod_var_inputs.R and test-mod_aes_inputs.R test our input modules (see Section 17.2).\nThe communication between our modules is tested in test-mod_scatter_display.R (see Section 17.3).\n\n\n\n\n\n\n\n\n\n\nSystem tests\n\n\n\nI’ve moved the two system tests to the shinytest2 vignette:\n\ntest-shinytest2.R is the initial resulting test from shinytest2::record_test() covered in Section 18.3.\ntest-app-feature-01.R tests the data visualization dropdown feature (see Section 18.4).\n\n\n\n\n\n\ntests/\n1├── README.md\n2├── spelling.R\n├── testthat\n3│   ├── helper.R\n4│   ├── test-golem-recommended.R\n5│   ├── test-golem_utils_server.R\n6│   ├── test-golem_utils_ui.R\n7│   ├── test-mod_aes_inputs.R\n8│   ├── test-mod_scatter_display.R\n9│   ├── test-mod_var_inputs.R\n10│   └── test-utils_scatter_display.R\n└── testthat.R\n\n3 directories, 11 files\n\n\n1\n\nCreated from covrpage package\n\n\n2\n\nCreated from spelling package\n\n\n3\n\nTest helpers\n\n\n4\n\nCreated with: golem::use_recommended_tests()\n\n5\n\nCreated with: golem::use_utils_ui(with_test = TRUE)\n\n6\n\nCreated with: golem::use_utils_server(with_test = TRUE)\n\n\n7\n\nCreated with: golem::add_module(name = 'aes_inputs', with_test = TRUE)\n\n8\n\nCreated with: golem::add_module(name = 'scatter_display', with_test = TRUE)\n\n9\n\nCreated with: golem::add_module(name = 'var_inputs', with_test = TRUE)\n\n10\n\nUtility function test (scatter_plot())\n\n\n\n\n\n\n\n\n\n\nloadSupport() warning\n\n\n\n\n\n\nRunning tests in your golem app may produce a familiar warning:\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears\n  to contain an R package. Sourcing files in R/ may cause unexpected behavior.\nWe covered this message in the Launch chapter, and it’s being addressed in a future release of shinytest2\n\n\n\n\n\n\n23.4.7 Code coverage\nCode test coverage is handled by usethis::use_coverage() and covrpage::covrpage().23 I’ve found the code coverage functions don’t play well with long descriptions in testthat’s BDD functions or shinytest2 tests (which is why I’ve placed these functions/tests in the vignettes).\n\n\n\n\n\n\nTest coverage\n\n\n\nuse_coverage() requires a type (“codecov” or “coveralls”).\nThe README.Rmd will include the results from devtools::check(quiet = TRUE) and a detailed report on tests coverage (see below).\ncovrpage() will create a tests/README.md file that contains detailed information on tests and coverage.\n\n\n\n\n\ndevtools::check(quiet = TRUE)\n#&gt; ℹ Loading gap\n#&gt; ── R CMD check results ──────────────────────────── gap 0.0.0.9000 ────\n#&gt; Duration: 42.5s\n#&gt; \n#&gt; ❯ checking for future file timestamps ... NOTE\n#&gt;   unable to verify current time\n#&gt; \n#&gt; ❯ checking top-level files ... NOTE\n#&gt;   Non-standard file/directory found at top level:\n#&gt;     ‘app.R’\n#&gt; \n#&gt; ❯ checking package subdirectories ... NOTE\n#&gt;   Problems with news in ‘NEWS.md’:\n#&gt;   No news entries found.\n#&gt; \n#&gt; ❯ checking R code for possible problems ... NOTE\n#&gt;   mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n#&gt;     variable ‘movies’\n#&gt;   Undefined global functions or variables:\n#&gt;     movies\n#&gt; \n#&gt; 0 errors ✔ | 0 warnings ✔ | 4 notes ✖\n\n\ncovr::package_coverage()\n#&gt; gap Coverage: 85.27%\n#&gt; R/run_app.R: 0.00%\n#&gt; R/utils_tests.R: 53.85%\n#&gt; R/mod_scatter_display.R: 56.76%\n#&gt; R/golem_utils_server.R: 77.78%\n#&gt; R/golem_utils_ui.R: 87.94%\n#&gt; R/app_config.R: 100.00%\n#&gt; R/app_server.R: 100.00%\n#&gt; R/app_ui.R: 100.00%\n#&gt; R/mod_aes_inputs.R: 100.00%\n#&gt; R/mod_var_inputs.R: 100.00%\n#&gt; R/utils_scatter_display.R: 100.00%\n\n\n\n23.4.8 Continuous Integration (CI)\nAll the continuous integration (CI) functions in dev/02_dev.R are from the usethis package (see Chapter 21). Many of these functions have been deprecated and/or should be used cautiously.\n\n\n\n\n\n\nGitHub Actions\n\n\n\nuse_github() has been deprecated favor of use_github_action().\nuse_github_action_check_release(), use_github_action_check_standard(), and use_github_action_pr_commands() are ‘deprecated in favor of use_github_action(), which can now suggest specific workflows to use.’\nuse_github_action_check_full() is ‘overkill for most packages and is not recommended.’\n\n\n\n\n\n\n\n\n\n\nOther CI Options\n\n\n\nuse_jenkins() adds a basic Jenkinsfile for R packages to the project root directory.\nuse_circleci(), use_circleci_badge(), and use_gitlab_ci() are ‘not actively used by the tidyverse team, and may not currently work. Use at your own risk.’",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#sec-golem-deploy",
    "href": "golem.html#sec-golem-deploy",
    "title": "23  golem",
    "section": "23.5 Deployment",
    "text": "23.5 Deployment\n\n“03_deploy.R should be used once you need to deploy your app.”\n\nWhen you’re ready to deploy your golem app, the dev/03_deploy.R file contains a ‘pre deployment checklist’ with multiple options for deploying your application.\n\n\n\n\n\n\nRunning checks\n\n\n\ndevtools::check() and rhub::check_for_cran()24 will checks your app-package under the assumption it’s being submitted to CRAN.\ndevtools::build() will create a tar.gz file (useful for downloads/installs or a package management system).\n\n\n\n\ngolem has functions for preparing to deploy your app to Posit products.\n\n\n\n\n\n\napp.R\n\n\n\nAll of these functions create an app.R file to the root of your app-package.\n\npkgload::load_all() is called in the new app.R file (so this package is added to the Imports field in the DESCRIPTION).\n\n\n\n\n\n\n# Launch the ShinyApp (Do not remove this comment)\n# To deploy, run: rsconnect::deployApp()\n# Or use the blue button on top of this file\n\npkgload::load_all(export_all = FALSE,\n  helpers = FALSE,\n  attach_testthat = FALSE)\noptions( \"golem.app.prod\" = TRUE)\ngap::run_app() # add parameters here (if any)\n\n\n\n\n\n\n\nR/_disable_autoload.R\n\n\nThese functions also add an empty R/_disable_autoload.R file to handle the loadSupport() warning.\n\n\n\n\n\n\n\n\n\nHidden files\n\n\nVarious hidden files are added (.rscignore) and included in the .Rbuildignore (\"^rsconnect$\" to ignore rsconnect folder, \"^app\\\\.R$\" to ignore the app.R file, etc.).\n\n\n\n\n\n\n\n\n\nDeploy code\n\n\ndev/03_deploy.R includes boilerplate code for deploying your application using rsconnect::deployApp().\n\n\n\n\nrsconnect::deployApp(\n  appName = desc::desc_get_field(\"Package\"),\n  appTitle = desc::desc_get_field(\"Package\"),\n  appFiles = c(\n    # Add any additional files unique to your app here.\n    \"R/\",\n    \"inst/\",\n    \"data/\",\n    \"NAMESPACE\",\n    \"DESCRIPTION\",\n    \"app.R\"\n  ),\n  appId = rsconnect::deployments(\".\")$appID,\n  lint = FALSE,\n  forceUpdate = TRUE\n)\n\ngolem also has multiple options for creating Docker files. I’ve included the golem::add_dockerfile_with_renv() below because we’re using renv.\n\n\n\n\n\n\nDocker\n\n\n\nadd_dockerfile_with_renv() creates a tmp/deploy folder and adds Dockerfile, Dockerfile_base, README, gap_0.0.0.9000.tar.gz, and renv.lock.prod (see below)\n\ngap_0.0.0.9000.tar.gz is a compressed version of our app-package to deploy in the Docker container.\nrenv.lock.prod is a JSON file with a list of packages used in our app-package.\n\n\n\n\n\nThe tmp/deploy folder from add_dockerfile_with_renv() is below:\n\ndeploy/\n  ├── Dockerfile\n  ├── Dockerfile_base\n  ├── README\n  ├── gap_0.0.0.9000.tar.gz\n  └── renv.lock.prod\n\n\n\nshow/hide golem::add_dockerfile_with_renv() README\ndocker build -f Dockerfile_base --progress=plain -t gap_base .\ndocker build -f Dockerfile --progress=plain -t gap:latest .\ndocker run -p 80:80 gap:latest\n# then go to 127.0.0.1:80\n\n\n\n\nshow/hide golem::add_dockerfile_with_renv() Dockerfile\nFROM gap_base\nCOPY renv.lock.prod renv.lock\nRUN R -e 'options(renv.config.pak.enabled = FALSE);renv::restore()'\nCOPY gap_*.tar.gz /app.tar.gz\nRUN R -e 'remotes::install_local(\"/app.tar.gz\",upgrade=\"never\")'\nRUN rm /app.tar.gz\nEXPOSE 80\nUSER rstudio\nCMD R -e \"options('shiny.port'=80,shiny.host='0.0.0.0');library(gap);gap::run_app()\"\n\n\n\n\nshow/hide golem::add_dockerfile_with_renv() Dockerfile_base\nFROM rocker/verse:4.4.2\nRUN apt-get update -y && apt-get install -y  make zlib1g-dev git libicu-dev && rm -rf /var/lib/apt/lists/*\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/\nRUN echo \"options(renv.config.pak.enabled = FALSE, repos = c(CRAN = 'https://cran.rstudio.com/'), download.file.method = 'libcurl', Ncpus = 4)\" | tee /usr/local/lib/R/etc/Rprofile.site | tee /usr/lib/R/etc/Rprofile.site\nRUN R -e 'install.packages(\"remotes\")'\nRUN R -e 'remotes::install_version(\"renv\", version = \"1.0.3\")'\nCOPY renv.lock.prod renv.lock\nRUN R -e 'renv::restore()'\n\n\nYou can read more details about deploying with Docker on the Shiny Frameworks supplemental website.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#sec-golem-summary",
    "href": "golem.html#sec-golem-summary",
    "title": "23  golem",
    "section": "23.6 Summary of golem features",
    "text": "23.6 Summary of golem features\ngolems helper functions and dev scripts make application development fast–I was able to create gap quickly, and all of the supporting packages (covrpage, attachment, spelling) make the development process faster/easier. Below is a brief summary of the steps it took to create gap:\n\nCreated the modules and utility function with add_module() and add_utils().\n\nAdded the bslib layout functions and the thematic theme to app_ui() and golem_add_external_resources().\n\nAdded module server logic to app_server().\n\nDownloaded the golem hex image to inst/app/www/.\n\nDownloaded the movies.RData file into inst/extdata/, then created data-raw/movies.R and created data/movies.rda.\n\nCalled usethis::use_vignette() to create shinytest2.Rmd and tests_and_coverage.Rmd.\n\nAdded the test_logger() utility function to R/utils_tests.R.\n\nRevised the unit tests and moved all system tests to vignettes/shinytest2.Rmd.\n\nIncluded code coverage in README.Rmd with usethis::use_coverage('codecov') and created the tests/README.md file with covrpage::covrpage().\n\nCalled attachment::att_amend_desc() to capture any dependencies.\n\nFinally, I loaded, documented, and installed the gap package and ran the application with gap::run_app().\n\nIf you’ve followed along with the preceding chapters, the golem framework will be familiar. In essence, golem takes many of the package development steps we’ve covered and bundles them into wrapper functions (i.e., add_module() is similar to running usethis::use_r() and usethis::use_test(), then adding an roxygen2 skeleton).",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#gap-dependencies",
    "href": "golem.html#gap-dependencies",
    "title": "23  golem",
    "section": "23.7 gap dependencies",
    "text": "23.7 gap dependencies\nIt’s also worth noting that using the golem framework adds golem as a dependency:\n\n# in the 23_golem branch of sap\npak::local_deps_explain(deps = 'golem', root = \".\")\n\ngap -&gt; golem \nFor comparison, if we look at the app-package from the previous branch (22_pkgdown) the dependency tree shows us that using devtools/usethis doesn’t make our app-package depend on these packages:\n\n\n\n\n\n\n\n\n\n\nSee the 22_pkgdown branch of sap.\n\n\n# in the 09d_inst-prod branch of sap\npak::local_deps_explain(deps = 'devtools', root = \".\")\n\nx devtools\n\n# in the 09d_inst-prod branch of sap\npak::local_deps_explain(deps = 'usethis', root = \".\")\n\nx usethis",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#recap",
    "href": "golem.html#recap",
    "title": "23  golem",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRECAP   \n\n\n\n\n\n\n\nThe golem framework is a huge time saver if you’re familiar with R package development (and you’d prefer if many of these steps were bundled and optimized for ‘production grade’ Shiny apps). However, if you’re not familiar with package development, you might end up with app-packages that have bugs you can’t diagnose or fix.\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#footnotes",
    "href": "golem.html#footnotes",
    "title": "23  golem",
    "section": "",
    "text": "We covered in the Packages chapter.↩︎\nOptions are set with with the options argument of golem::fill_desc() (which calls golem::set_golem_options()).↩︎\nDependencies are installed with golem::install_dev_deps()↩︎\nMany of these functions and files are covered in the Whole App Game chapter.↩︎\nCreated using usethis::use_mit_license().↩︎\nCreated using usethis::use_readme_rmd().↩︎\nBuilt using devtools::build_readme().↩︎\nCreated using usethis::use_code_of_conduct().↩︎\nCreated using usethis::use_lifecycle_badge().↩︎\nCreated using usethis::use_news_md().↩︎\nInitialize Git using usethis::use_git() and set the remote with usethis::use_git_remote().↩︎\nThe tests/ folder and testthat files included with golem::use_recommended_tests() are covered in the Test suite chapter.↩︎\nCreate UI utility functions using golem::use_utils_ui()↩︎\nCreate server utility functions using golem::use_utils_server()↩︎\nthe app/ folder is used to add external resources to the application (similar to the previous versions of sap).↩︎\ngolem apps use a golem-config.yml file for setting various options. These are initially set with set_golem_options() (and based on the config package).↩︎\nThe use_recommended_tests() is run in the dev/01_start.R file and if spellcheck is TRUE, creates the tests/spelling.R file and the inst/WORDLIST file.↩︎\nThis contains the movies.RData file for the original Shiny application.↩︎\nThe noRd tag is added to module files created with add_module(), but you can export these functions by setting the export argument to TRUE.↩︎\nThe testthat test suite is set up with golem::use_recommended_tests() function.↩︎\nThe spelling package will spell check vignettes, packages, etc.↩︎\ntest-golem-recommended.R contains the recommended tests for app_ui(), app_server(), app_sys(), and golem-config.yml.↩︎\nThe covrpage package is not on CRAN, but the development version always seems to work.↩︎\nrhub::check_for_cran() is “deprecated and defunct”, use rhub::rhubv2() instead.↩︎",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "leprechaun.html",
    "href": "leprechaun.html",
    "title": "24  leprechaun",
    "section": "",
    "text": "24.1 lap (a leprechaun app-package)\nThis chapter walks through building a version of the sap with the leprechaun framework. The resulting app-package (lap) is in the 24_leprechaun branch. For more information on buidling an application with the leprechaun framework, see my supplemental Shiny frameworks website.\nInstall leprechaun and packer to get started:\nI’ve included the version/description of both the leprechaun and packer packages we’ll use for the app-package:\nAfter checking out the 24_leprechaun branch, be sure to load, document, and install the application.\nlap exports the movies data and the standalone app function, run().\nlibrary(lap)\nlap::run()",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#lap-a-leprechaun-app-package",
    "href": "leprechaun.html#lap-a-leprechaun-app-package",
    "title": "24  leprechaun",
    "section": "",
    "text": "Ctrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('24_leprechaun')\n\n\n\n\nlap movies app",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#sec-leprechaun-setup",
    "href": "leprechaun.html#sec-leprechaun-setup",
    "title": "24  leprechaun",
    "section": "24.2 Set up",
    "text": "24.2 Set up\nCreating a new leprechaun app-package can be done with usethis::create_package()1 (which we covered in the packages chapter). After your app-package is created, leprechaun::scaffold() builds the core app files:2\nlap/\n├── DESCRIPTION\n├── NAMESPACE\n├── R/\n│   ├── _disable_autoload.R\n│   ├── assets.R\n│   ├── input-handlers.R\n│   ├── leprechaun-utils.R\n│   ├── run.R\n│   ├── server.R\n│   ├── ui.R\n│   └── zzz.R\n├── inst/\n│   ├── assets\n│   ├── dev\n│   ├── img\n│   └── run\n│       └── app.R\n└── lap.Rproj\n\n7 directories, 12 files",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#development",
    "href": "leprechaun.html#development",
    "title": "24  leprechaun",
    "section": "24.3 Development",
    "text": "24.3 Development\nThe sections below outline the steps for creating the sap movies review app from scratch using leprechaun.\n\n24.3.1 The R/ folder\nAll leprechaun apps come with primary app UI and server functions (R/ui.R and R/server.R) and a standalone app function (R/run.R.).\n\n\n\n\n\n\nUI\n\n\n\nui() defines the overall UI structure using navbarPage().\n\nassets() combines the output of serveAssets() (which gathers JS and CSS from inst/assets)\n\n\n\n\n\n\n\n\n\n\n\nServer\n\n\n\nserver() contains the server logic for the application.\n\nsend_message &lt;- make_send_message(session) sets up a utility that lets you easily send messages from R to JavaScript\n\n\n\n\n\n\n\n\n\n\n\nModules\n\n\n\nCreate new modules with leprechaun::add_module().\n\nThis creates a new R/module_*.R file (see example below).\n\n\n\n\n\n\n\nshow/hide R/module_vars.R file\n#' vars UI\n#' \n#' @param id Unique id for module instance.\n#' \n#' @keywords internal\nvarsUI &lt;- function(id){\n    ns &lt;- NS(id)\n\n    tagList(\n        h2(\"vars\")\n    )\n}\n\n#' vars Server\n#' \n#' @param id Unique id for module instance.\n#' \n#' @keywords internal\nvars_server &lt;- function(id){\n    moduleServer(\n        id,\n        function(\n            input, \n            output, \n            session\n            ){\n                \n            ns &lt;- session$ns\n            send_message &lt;- make_send_message(session)\n\n            # your code here\n        }\n    )\n}\n\n# UI\n# varsUI('id')\n\n# server\n# vars_server('id')\n\n\n\n\n\n\n\n\nRun\n\n\n\nR/run.R provides functions to launch your Shiny application in different modes:\n\nrun() is the main function that users will call to launch your application in normal mode.\nrun_dev() is for development purposes and launches a development version of the app.\n\n\n\n\n\n\n\n\n\n\n\nAssets\n\n\n\nThe R/assets.R file contains the following functions:\n\nserveAssets(): scans your package for JavaScript and CSS files, separates regular JavaScript files from “module” type JavaScript files, and bundles everything as proper HTML dependencies that Shiny can use.\nremove_modules(): filters out the module files from the list of all JavaScript files.\nget_modules(): extracts only the module files from the list of all JavaScript files.\ncollapse_files(): creates a regular expression pattern to match specific files.\n\n\n\n\n\nWe’ll use the functions in R/assets.R via the assets() function in the R/ui.R file, which calls serveAssets() to include all any front-end resources in our Shiny app.\n\n\n\n\n\n\nInput handlers\n\n\nR/input-handlers.R sets up custom data handling between your JavaScript front-end and R back-end.\n\n\n\n\n\n\n\n\n\nleprechaun utilities\n\n\nThe R/leprechaun-utils.R file provides a utility function (make_send_message()) — a helper to send custom messages from the server to the front-end (JavaScript) in a namespace-aware and modular way.\n\n\n\n\n\n\n\n\n\nR/zzz.R\n\n\n.onLoad() creates a static file server path for images and makes inst/img accessible to the web browser.3\n\n\n\n\n\n24.3.2 The inst/ folder\nleprechaun::scaffold() creates the following folders in inst/:\n\n\n\n\n\n\ninst/assets/\n\n\nContains any JavaScript and CSS files that are part of the application frontend.\n\n\n\n\n\n\n\n\n\ninst/dev/\n\n\nOptional directory used for custom dev scripts, build tools, or staging.\n\n\n\n\n\n\n\n\n\ninst/img/\n\n\nHolds static image files like logos, icons, or other assets we want to display in the UI.\n\n\n\n\n\n\n\n\n\ninst/run\n\n\nContains the app.R file used for development mode (i.e., with lap::run_dev()).\n\n\n\n\n24.3.2.1 Adding images\nAdding images is simplified with the .onLoad() function, which we can demonstrate by adding an image file to the UI function.\n\n\n\n\n\n\nPlace leprechaun-logo.png in inst/img/:\n\n\ninst/\n  └── img/\n       └── leprechaun-logo.png\n\n\n\n\n\n\n\n\n\nAdd file path to the UI:\n\n\nbslib::card_header(\n  tags$h4(tags$em(\"Brought to you by \",\n    tags$img(\n      src = \"img/leprechaun-logo.png\",\n      height = 100,\n      width = 100,\n      style = \"margin:10px 10px\"\n      )\n    )\n  )\n)\n\n\n\nLoad, document, and install the package, then launch the application with run():\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlap::run()\n\n\n\n24.3.2.2 use and build\nThe leprechaun workflow involves a combination of use_ functions that are combined with leprechaun::build() to add various functionality to your application. I’ll demonstrate adding JavaScript and SCSS below.\n\n\n24.3.2.3 Use JavaScript\n\n\n\n\n\n\nUsing packer\n\n\n\nWe’ll use the make_send_message() from the JavaScript example on the package website:\n\nRun packer::scaffold_leprechaun()\n\n\nDon’t be alarmed when scaffold_leprechaun() downloads multiple folders into the root directory. 4\n\n\nRun leprechaun::use_packer()\nRun leprechaun::build()\n\n\n\n\n\nThis creates inst/dev/packer.R and inst/assets/index.js.\n\ninst\n├── assets\n│   └── index.js\n├── dev\n│   └── packer.R\n├── extdata\n│   └── movies.RData\n├── img\n└── run\n    └── app.R\n\nAssign the output from make_send_message() to send_message() in R/server.R, then pass the msgId and text of the message:\n\nsend_message &lt;- make_send_message(session)\nsend_message(\"show-packer\",\n              text = \"a message from R/server.R\")\n\n\nCreate send_message()\n\nUse send_message() to send a message the UI.\n\nAfter loading, documenting, and installing your app-package:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nRun the application:\n\nlap::run()\n\n\n\n\nsend_message() in R/server.R\n\n\n\n\n\n\n\n\nJS Alerts in Positron\n\n\n\n\n\n\nIf you’re using Positron , you’ll have to display the application in the browser to view the alert.\n\n\n\n\n\n\n\n\n\n\n\nAdding images to inst/img/\n\n\n\n\n24.3.2.4 Use Sass\nTo add Sass styling, we can combine leprechaun’s use_sass() and build() functions.\n\n\n\n\n\n\nleprechaun::use_sass() adds scss/ folder with _core.scss and main.scss.\n\n\nscss\n├── _core.scss\n└── main.scss\n\n1 directory, 2 files\n\n\n\n\n\n\n\n\n\nThe original _core.scss file:\n\n\nhtml{\n    .error {\n        color: red\n    }\n}\n\n\n\n\n\n\n\n\n\nChange the color to green using $accent: #38B44A;\n\n\n$accent: #38B44A;\n\nhtml{\n    h4 {\n        color: $accent;\n    }\n}\n\n\n\n\n\n\n\n\n\nRun leprechaun::build():5\n\n\nleprechaun::build()\n✔ Running packer.R\n✔ Bundled       \n✔ Running sass.R\n\n\n\nOnce again, load, document(), and install lap, then launch the application with run():\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlap::run()\n\n\n\n\n\n\n\n\nRunning lap with new Sass\n\n\nIt’s important to note that adding features to your leprechaun app-package will add non-standard directories to the root folder:\n\n├── node_modules/ &lt;- too many sub-folders to list here!\n├── package-lock.json\n├── package.json\n├── scss/\n│   ├── _core.scss\n│   └── main.scss\n├── srcjs/\n│   ├── config\n│   ├── index.js\n│   └── modules\n├── webpack.common.js\n├── webpack.dev.js\n└── webpack.prod.js\n\nThese folders are necessary for adding JavaScript/SCSS functionality, so don’t remove them (just make sure they’re added to the .Rbuildignore/.gitignore)\n\n\n\n24.3.3 Data\nWe can add data to lap the same way we’d add data to any R package.\n\n\n\n\n\n\ninst/extdata/\n\n\nAdd the movies.RData file to inst/extdata/\n\n\n\n\n\n\n\n\n\ndata-raw/\n\n\nCreate the movies.R file in data-raw/ with usethis::use_data_raw(\"movies\")\n\n\n\n\n\n\n\n\n\ndata/\n\n\nLoad the movies.RData in data-raw/movies.R and export the file to data/movies.rda using usethis::use_data().\n\n\n\n\n\n\n\n\n\nR/\n\n\nDocument the dataset in R/data.R.\n\n\n\n\n\n24.3.4 Documentation\nleprechaun modules and functions include @keywords internal, which can be used in combination with a {pkgname}-package.R file. We can create this file using usethis::use_package_doc():\n\n\n\n\n\n\nAdd the following to lap-package.R.\n\n\n#' @keywords internal \n\"_PACKAGE\"\n\n\n\nThe documentation for lap is intentionally sparce:\n\n\n\n\n\n\n\nlap index\n\n\nBy default, run() is the only leprechaun funtion available in the package index (I’ve exported the theme, data, and utility functions).\n\n\n24.3.5 Dependencies\nleprechaun lists bslib, htmltools, and shiny when the app-package is initially buit. If using packer, this application is also added to the DESCRIPTION file with leprechaun::use_packer().\nTo keep track of the add-on packages, I recommend using the attachment package.\n\n\n24.3.6 Tests\nUnit tests in leprechaun apps should be written using the same process/tools as a standard R package/Shiny app.\n\n\n\n\n\n\nUnit tests\n\n\nUse testthat to set up the test suite and use_test() to create and open test files.\n\n\n\n\n\n\n\n\n\nIntegration tests\n\n\nUse testServer to create tests for module server functions.\n\n\n\n\n\n\n\n\n\nSystem tests\n\n\nUse shinytest2 for system tests.\n\n\n\n\n\n24.3.7 Deployment\nTo launch our app locally (or using rsconnect::deployApp()), leprechaun has a handy leprechaun::add_app_file() function that creates an app.R file in the root folder with the following contents:\n\n# Launch the ShinyApp \n# do not remove to keep push deploy button\n# from RStudio\npkgload::load_all(\n    reset = TRUE,\n    helpers = FALSE\n)\n\nrun()\n\nThis file shouldn’t be confused with inst/run/app.R:\n\n# do not deploy from this file\n# see leprechaun::add_app_file()\nleprechaun::build()\n\npkgload::load_all(\n    path = \"../../\",\n    reset = TRUE,\n    helpers = FALSE\n)\n\nrun()\n\nThe inst/run/app.R file is specifically used by the run_dev() function.\n\n\nRecap\nleprechaun app-packages have an unopinionated structure and extensive JavaScript frontend support.\n\nBuilding modules is made easier with the add_module() function (although the naming convention could be more consistent).\nThe application is split into separate UI, server, and standalone app functions/files.\nTesting support is not included (but testthat and shinytest2 can be easily implemented).\n\nThe leprechaun framework is ideal for any developer who is comfortable with JavaScript frameworks (e.g., Webpack, Babel, etc.) and want to build custom UIs with Shiny as a backend.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#footnotes",
    "href": "leprechaun.html#footnotes",
    "title": "24  leprechaun",
    "section": "",
    "text": "Remember to provide a list of fields to usethis::create_package() for the DESCRIPTION file (or edit this manually).↩︎\nleprechaun::scaffold() has arguments for ui (fluidPage or navbarPage) bs_version (bootstrap version) and overwrite (if you need to start over).↩︎\nR/zzz.R files are traditionally used for setup functions that run during package loading. The name ensures it’s loaded last alphabetically (though modern R doesn’t strictly require this naming convention anymore).↩︎\nsrcjs/, package-lock.json, package.json, webpack.common.js, webpack.dev.js and webpack.prod.js are added to the .Rbuildignore (and node_modules/ is added to the .gitignore).↩︎\nThe scss folder in the root directory is used by leprechaun::build() to create inst/tidy-data/sass.R.↩︎",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "rhino.html",
    "href": "rhino.html",
    "title": "25  rhino",
    "section": "",
    "text": "25.1 rap (a rhino app)\nThis chapter briefly describes a version of sap built using rhino. The resulting app (rap) is in the 21_rhino branch.\nThe branch in this chapter is slightly different than the previous golem and leprechaun branches, because instead of loading, documenting, and installing rap, we’re going to re-initialize the IDE by selecting Session &gt; Terminate R…\nWhen the IDE re-opens, we see the rap files and notice the Build pane has been removed:\nThe Build pane is deactivated because rhino applications aren’t R packages.1\nLaunch the application in rap by opening the app.R file and clicking Run App (or by passing rhino::app() into the Console).\nThe files in rap are below:\n1├── .Rprofile\n2├── .github/\n│   └── workflows\n├── .gitignore\n3├── .lintr\n4├── .renvignore\n├── .rscignore        \n├── README.md\n├── app\n│   ├── js\n│   ├── logic\n│   ├── main.R\n│   ├── static\n│   ├── styles\n│   └── view\n├── app.R\n├── config.yml\n5├── dependencies.R.\n├── sap.Rproj\n6├── renv\n│   ├── .gitignore.   \n│   ├── activate.R\n│   ├── library\n│   ├── settings.json\n│   └── staging\n├── renv.lock\n├── rhino.yml\n└── tests\n    ├── cypress\n    ├── cypress.json\n    └── testthat\n\n24 directories, 31 files\n\n\n1\n\nActivates the renv package\n\n2\n\nCI/CD via GitHub actions\n\n\n3\n\nLintr (from lintr package)\n\n\n4\n\nrenv ignore (works like .gitignore)\n\n\n5\n\nrhino app dependencies\n\n6\n\nrenv library of packages in app project\nAs we can see, most of the standard R package folders and files are missing from rap, because rhino applications use the box package for importing dependencies and organizing code.2",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#rhino-features",
    "href": "rhino.html#rhino-features",
    "title": "25  rhino",
    "section": "25.2 rhino features",
    "text": "25.2 rhino features\nThe rhino website explains the philosophy behind the application structure above, so I won’t repeat that information here. However, I highly recommend reading the available documentation on rhino and box before deciding to adopt this framework.3",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#box-modules",
    "href": "rhino.html#box-modules",
    "title": "25  rhino",
    "section": "25.3 box modules",
    "text": "25.3 box modules\nA box module (not to be confused with a Shiny module) is a collection of .R scripts in a specified folder. The modules in a new rhino app are stored in the app/logic/ and app/view/ folders:4\n\napp\n1├── js/\n2├── logic/\n3├── main.R\n4├── static/\n5├── styles/\n6└── view/\n\n6 directories, 1 file\n\n\n1\n\nJavaScript code\n\n2\n\nNon-shiny code\n\n\n3\n\nPrimary app file\n\n\n4\n\nStatic .js or .css\n\n\n5\n\nApp CSS files\n\n6\n\nShiny modules and app code\n\n\n\n\n\n25.3.1 Utility functions\nIn rap, I’ve placed the non-Shiny utility functions (i.e., the business logic) in app/logic:\n\napp/logic\n├── __init__.R\n1├── data.R\n2└── plot.R\n\n1 directory, 4 files\n\n\n1\n\nLoad movies data\n\n\n2\n\nscatter_plot() utility function\n\n\n\n\n\n\n25.3.2 Shiny modules\nOur Shiny box modules are placed in app/view, and separated into inputs and display:\n\napp/view\n├── __init__.R\n1├── display.R\n2└── inputs.R\n\n1 directory, 3 files\n\n\n1\n\nsimilar to the code from R/mod_var_input.R\n\n2\n\nsimilar to the code from R/mod_scatter_display.R\n\n\n\n\napp/view/inputs collects and returns the reactive values from the UI. The app/view/display module includes the app/logic/data and app/logic/plot modules.\n\n# app/view/display.R\n\n# import data and plot modules\nbox::use(\n  app / logic / data,\n  app / logic / plot\n)",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#appmain.r",
    "href": "rhino.html#appmain.r",
    "title": "25  rhino",
    "section": "25.4 app/main.R",
    "text": "25.4 app/main.R\nThe app/main.R file contains the primary UI and Server functions for the application. This file adds the shiny functions and the inputs and display modules from app/view:\n\n# app/main.R\n\n# shiny functions\nbox::use(\n  shiny[\n    NS, fluidPage, sidebarLayout, sidebarPanel,\n    mainPanel, fluidRow, column, tags, icon,\n    textOutput, moduleServer, renderText\n  ]\n)\n\n# import modules\nbox::use(\n  # load inputs module ----\n  app / view / inputs,\n  # load display module ----\n  app / view / display\n)\n\nNote that we don’t need to import app/logic modules in app/main.R, because they’re imported in their respective app/view modules.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#tests",
    "href": "rhino.html#tests",
    "title": "25  rhino",
    "section": "25.5 Tests",
    "text": "25.5 Tests\nrhino apps have support for testing with testthat, shiny::testServer(), shinytest2, and Cypress.\n\ntests/\n1├── cypress\n│   └── integration\n│       └── app.spec.js\n├── cypress.json\n2└── testthat\n    └── test-main.R\n\n4 directories, 3 files\n\n\n1\n\nCypress test infrastructure\n\n\n2\n\ntestthat test infrastructure\n\n\n\n\nBelow is the boilerplate test code in the tests/testthat/test-main.R file:\n\n1box::use(\n  shiny[testServer], \n  testthat[...],\n)\n\nbox::use(\n  app/main[...],\n)\n\n2test_that(\"main server works\", {\n  testServer(server, {\n    expect_equal(output$message, \"Hello!\")\n  })\n})\n\n\n1\n\nbox module importing test package functions\n\n2\n\nUsing shiny::testServer() and testthat::test_that() functions in test.\n\n\n\n\nI’ve included tests for the utility functions and modules in the 21_rhino branch, but I’ll cover testing with rhino elsewhere.5",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#rhino-dependencies",
    "href": "rhino.html#rhino-dependencies",
    "title": "25  rhino",
    "section": "25.6 rhino dependencies",
    "text": "25.6 rhino dependencies\nIn rhino apps, dependencies are managed by renv and the dependencies.R file. The renv package is designed to,\n\n“create[s] and manage[s] project-local R libraries, save[s] the state of these libraries to a ‘lockfile’, and later restore[s] the library as required.” 6\n\nThe rhino::pkg_install() helper function updates both the dependencies.R file and renv library. Using dependencies.R, renv, and box modules removes the need to manage dependencies in a DESCRIPTION or NAMESPACE file.7",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#recap",
    "href": "rhino.html#recap",
    "title": "25  rhino",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRECAP   \n\n\n\n\n\n\n\nrhino takes a novel and innovative approach to developing Shiny applications (and covering all the ways they differ from app-packages is beyond the scope of this book). Feel free to review the code in the 21_rhino branch for a better understanding of how the box modules are structured and used within the ui and server.\nThe rhino framework isn’t used as wildly golem,8 but it’s been gaining popularity (and has been used in a recent pilot FDA submission).\n\n\n\n\n\n\n\nrhino CRAN downloads\n\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#footnotes",
    "href": "rhino.html#footnotes",
    "title": "25  rhino",
    "section": "",
    "text": "I re-initialize the session on the 21_rhino branch so I’m not tempted to load, document, install, or test the code using the IDE.↩︎\nImported dependencies in rhino apps use box modules instead of the DESCRIPTION and NAMESPACE.↩︎\nBe sure to read up on testing box modules and rhino applications with cypress and shinytest2.↩︎\nrhino recommends placing non-Shiny code in the app/logic folder and keeping all Shiny modules and reactive code in app/view.↩︎\nSee the Shiny frameworks supplemental website for more information on testing your rhino app.↩︎\nAs described in renv’s DESCRIPTION file↩︎\nBe sure to read the renv configuration article for a better understanding on how it works with rhino apps.↩︎\nCheck for yourself on cran-downloads↩︎",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "tools.html",
    "href": "tools.html",
    "title": "Shiny Tools",
    "section": "",
    "text": "Shiny Assistant\nSince I began writing this book1, the number of AI tools for building Shiny apps has grown significantly. The chapters in this section introduce a few popular tools I’ve personally used to develop applications. For a comprehensive review of LLMs R packages, please checkout the excellent Large Language Model tools for R book by Luis D. Verde Arregoitia.\nGiven the rapidly evolving landscape and nature of these tools, I expect these chapters to change frequently. Please open a GitHub issue if there is anything outdated, incorrect, or missing.\nThe Shiny Assistant is a browser-based LLM chat tool you can use to help build a Shiny app. The UI gives you the ability to submit prompts (questions or instructions), view the code, and launch the application. 26  Shiny Assistant covers:",
    "crumbs": [
      "Shiny Tools"
    ]
  },
  {
    "objectID": "tools.html#shiny-assistant",
    "href": "tools.html#shiny-assistant",
    "title": "Shiny Tools",
    "section": "",
    "text": "26.1 Chat + IDE\n\n26.1.1 Prompt 1: Build an app\n\n26.1.2 Prompt 2: Refine\n\n26.1.3 Prompt 3: Functionalize\n\n26.1.4 Prompt 4: Structure\n\n26.1.5 Prompt 5: Error\n\n26.1.6 Bonus: Theme\n26.2 Finishing touches",
    "crumbs": [
      "Shiny Tools"
    ]
  },
  {
    "objectID": "tools.html#ellmer",
    "href": "tools.html#ellmer",
    "title": "Shiny Tools",
    "section": "ellmer",
    "text": "ellmer\nThe ellmer package provides easy access to many LLMs in the R environment (Positron or RStudio).\n\n27.1 Installing ellmer\n\n27.1.2 Using the chat\n\n27.1.3 Prompts\n\n\n27.2 Movie explorer redux\n\n27.2.1 System Prompt\n\n27.2.2 Prompt 1: update\n\n27.2.3 Prompt 2: refactor\n\n27.2.4 Prompt 3: overhaul\n\n\n27.3 Finishing touches",
    "crumbs": [
      "Shiny Tools"
    ]
  },
  {
    "objectID": "tools.html#shinychat",
    "href": "tools.html#shinychat",
    "title": "Shiny Tools",
    "section": "shinychat",
    "text": "shinychat\nshinychat is…",
    "crumbs": [
      "Shiny Tools"
    ]
  },
  {
    "objectID": "tools.html#chores",
    "href": "tools.html#chores",
    "title": "Shiny Tools",
    "section": "chores",
    "text": "chores\nThe chores package…\n\n“Think of AI tools as a friend who is a know-it-all, over-confident, presumptuous, and lacks self-awareness. Despite these imperfections, they remain your friend.”",
    "crumbs": [
      "Shiny Tools"
    ]
  },
  {
    "objectID": "tools.html#footnotes",
    "href": "tools.html#footnotes",
    "title": "Shiny Tools",
    "section": "",
    "text": "I put the first ‘complete’ edition online in late 2023.↩︎",
    "crumbs": [
      "Shiny Tools"
    ]
  },
  {
    "objectID": "shiny_assist.html",
    "href": "shiny_assist.html",
    "title": "26  Shiny Assistant",
    "section": "",
    "text": "26.1 Chat + IDE\nThe Shiny Assistant is an AI-powered chat bot anyone can use to help them build a Shiny application.\nThe UI for Shiny Assistant looks like a standard chat, but if you ask it to “Open the editor”, we see an interface with a script editor, console, and viewer pane:\nShiny Assistant is great for trying different UI components, layouts, and styling (color palettes, themes, fonts, etc.). We will walk through using the Assistant for building an Shiny app-package, but we’ll limit the number of prompts to keep this chapter brief. If you’d like to read a more comprehensive example of using Shiny Assistant to build an application, I recommend reading this post on Appsilon’s blog.\nI think you’ll be convinced that the Shiny Assistant is an impressively helpful tool to have in your Shiny toolbox, even with a limited number of prompts. Let’s get started!",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Shiny Assistant</span>"
    ]
  },
  {
    "objectID": "shiny_assist.html#sec-shiny-assist-ui",
    "href": "shiny_assist.html#sec-shiny-assist-ui",
    "title": "26  Shiny Assistant",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('23_llm-shiny-assist')\n\n\n\n\n\n\n\n\n\nShiny Assist Editor\n\n\n\n\n\n\n\n\nAccessing the code examples\n\n\n\n\n\n\nI’ve created the shinypak R package In an effort to make each section accessible and easy to follow:\nInstall shinypak using pak (or remotes):\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\n\nReview the chapters in each section:\n\nlibrary(shinypak)\nlist_apps(regex = '23')\n## # A tibble: 1 × 2\n##   branch   last_updated       \n##   &lt;chr&gt;    &lt;dttm&gt;             \n## 1 23_golem 2025-03-25 11:43:13\n\nLaunch an app:\n\nlaunch(app = \"23_llm-shiny-assist\")\n\n\n\n\n\n\n\n\n26.1.1 Prompt 1: Build an app\nLet’s start with trying to reproduce some of the applications we have in sap. I typically have data before I have an idea for a dashboard or app, so we’ll pass the structure of simplified version our movies data to the Assistant with some instructions on what we’d like to see:2\nPrompt: Create a shiny application that visualizes IMDB movie data using a scatter plot. Include inputs for x, y, color, size, and transparency.\nThe column names are below:\n```\nRows: 651\nColumns: 18\n$ title             …\n$ genre             …\n$ runtime           …\n$ year              …\n$ top200_box        …\n$ director          …\n$ mpaa_rating       …\n$ imdb_rating       …\n$ critics_rating    …\n$ audience_rating   …\n$ imdb_num_votes    …\n$ critics_score     …\n$ audience_score    …\n$ best_pic_nom      …\n$ best_pic_win      …\n$ best_actor_win    …\n$ best_actress_win  …\n$ best_dir_win      …\n```\n\nUse the data stored in this URL:\nhttps://raw.githubusercontent.com/mjfrigaard/sap/refs/heads/23_llm-shiny-assist/data-raw/movies_sample.csv\n\n\n\n\n\n\n\n\nTip: Providing data\n\n\n\n\n\n\nI’ve found providing a data structure (from str() or dplyr::glimpse()) is incredibly helpful when guiding AI chat bots on building dashboards. Shiny Assistant is great because we can even pass it a URL with a .csv data file.\n\n\n\n\nBelow we can see the initial app:\n\n\n\n\n\n\n\nShiny Assistant: initial app\n\n\nThe initial application has nearly identical input, outputs, and layout. However, we can see an additional checkbox for Show Movie Titles and the Size by input has been mapped to a variable (not a numerical value).\nIn our next prompt, we’ll refine the app to more closely match what we have in our sap app-package.\n\n\n26.1.2 Prompt 2: Refine\nPrompt:  Change the size to a numeric slider and include a text input for a plot title. \nThe application is updated with the changes and we can view the changes to app.R in the Shiny Assistant UI:\n\n\n\n\n\n\n\nShiny Assistant: initial app\n\n\n\n\n\n\n\n\nWarning: aes_string()\n\n\n\n\n\n\nWe can see the following warning regarding the ggplot2 graph:\n\n\n\n\n\n\n\nShiny Assistant: ggplot2 warning\n\n\nWe avoided this warning with the scatter_plot() utility function in previous branches, but for now we will just note this is something we should return to and refactor after our application in a more complete state.\n\n\n\n\n\n\n26.1.3 Prompt 3: Functionalize\nNow that we have a UI with the correct inputs and outputs, we’ll convert these into modules and separate the application into it’s respective components.\nPrompt:  Convert the inputs and outputs into modules and create a standalone app function that calls separate UI and server functions. \nThe response to this prompt won’t change the app, but we’re given a summary of the changes in the chat:\n\n\n\n\n\n\n\nShiny Assistant: app functions and files\n\n\nResponse:\n\n\nI’ve modified the code to use a modular structure following these changes:\n\nCreated separate modules for:\n\nControls (inputs) - controlsUI and controlsServer\nPlot (output) - plotOutputUI and plotOutputServer\nAbout data section - aboutDataUI (UI only as it’s static)\n\nCreated standalone UI and server functions:\n\nui_function() - assembles all UI components\nserver_function() - coordinates between modules\n\nCreated an application function:\n\nmovie_visualization_app() - bundles everything together\n\nThe communication between modules:\n\nThe controls module returns all inputs as a reactive list\nThe plot module takes two parameters: the data and controls reactives\n\n\nThis modular approach makes the code more maintainable and easier to extend. Each component has a well-defined responsibility, and they communicate through clear interfaces.\n\n\nI’ve left the Shiny Assistant chat setting to Verbose, but this can be changed to return less descriptive details on the code being produced:\n\n\n\nShiny Assistant Chat setting\n\n\n\n\n26.1.4 Prompt 4: Structure\nNow we’re reading to start structure the application as an R package. We’ll attempt to create the files and documentation with a single prompt.\nPrompt:  Store the modules, UI, server, and standalone app functions in separate files and include roxygen2 documentation. \nThis results in an error when the Shiny Assistant tries to run our updates:\n\n\n\n\n\n\n\nShiny Assistant: error\n\n\nThe summary tells us what changed, but doesn’t give us advice on (or even acknowledge) the error.\nResponse:\n\n\nI’ve reorganized the code into separate files with roxygen2 documentation:\n\ncontrols_module.R: Contains the UI and server functions for the controls module with full roxygen2 documentation including parameters, return values, and imported functions.\nplot_module.R: Contains the UI and server functions for the plot output module with documentation for both components.\nabout_module.R: Contains the UI function for the about data section.\n**ui.R*: Contains the main UI function that assembles all UI components.\nserver.R: Contains the main server function that coordinates between modules.\napp.R: Contains the standalone app function that sources all other files and runs the application.\n\nEach function includes proper roxygen2 documentation with:\n\nFunction descriptions\nParameter descriptions\nReturn value descriptions\n@importFrom tags for explicit dependencies\n@export tags for functions that should be exported\n\nThe app.R file also includes logic to run the app only if the file is being executed directly in an interactive session.\n\n\n\n\n26.1.5 Prompt 5: Error\nThe error above tells us the bslib::page_sidebar() function isn’t being loaded before runApp() is being called, but the call to library(bslib) is in the app.R file. We’ll see if providing some direction on function/file names and where to call shinyApp() will resolve this error:\nPrompt:  An error occurred because the page_sidebar function could not be found. The app.R file needs to contain the library() and source() calls before the call to shinyApp(). Also, rename the ui.R and server.R to app_ui.R and app_server.R. \nThis results in the following changes to the app code structure:\nResponse:\n\n\nI’ve made the following changes to fix the issues:\n\nRenamed the files:\n\nChanged ui.R to app_ui.R\nChanged server.R to app_server.R\n\nModified the app.R file to:\n\nLoad all required libraries at the beginning of the file\nSource all module and function files\nDefine the movie_visualization_app() function\nCall the function directly (removed the if (interactive()) check to ensure it runs)\n\nMaintained the same structure for all modules and functions\n\nThese changes ensure that:\n\nAll necessary files are sourced before using their functions\nThe application will properly find all functions when running\nThe organization follows a more standard Shiny module structure\n\nThe application should now run without the “page_sidebar function could not be found” error since we’re properly sourcing all the module files before they’re used in the UI and server functions.\n\n\nIn the app.R file, if we explicitly run the call to library(bslib) and then source(\"app_ui.R\") (which contains the call to page_sidebar()), we see these are executed without errors in the Console:\n\n\n\n\n\n\n\nShiny Assistant: library() and source() calls\n\n\nHowever, when we try to source and call the standalone app function, we see the following error:\n\n\n\n\n\n\n\nShiny Assistant: runApp() error\n\n\nError in runApp(x) :\n  Can't call `runApp()` from within `runApp()`. If your application code contains\n  `runApp()`, please remove it.\nThis error is a little tricky, because we’re calling shinyApp(), but this is happening because we’re trying to explicitly call shinyApp() (and the UI works by call runApp()).\nWe can fix this by clicking on the icon in the UI to run the app:\n\n\n\n\n\n\n\nShiny Assistant: run the app using the ‘Run App’ icon\n\n\n\n\n26.1.6 Bonus: Theme\nNow that we have our modules, app functions and roxygen2 documentation, we’ll finish by adding a dark thematic theme:\nPrompt:  Add a dark theme using the thematic package: https://rstudio.github.io/thematic/ \nThe updated app includes a dark theme:\n\n\n\n\n\n\n\nShiny Assistant: thematic theme\n\n\nAnd the summary of changes is below:\nResponse:\n\n\nI’ve integrated the thematic package to add a dark theme to the application. Here are the changes I made:\n\nAdded library(thematic) to the app.R file to load the thematic package.\nAdded thematic_shiny(font = \"auto\") to automatically adjust plot themes to match the app theme. This automatically styles the ggplot2 visualizations to match the Shiny app’s theme.\nModified the UI function in app_ui.R to use a dark theme:\n\nCreated a dark theme using bs_theme() from bslib with dark background colors, light text, and appropriate accent colors\nApplied the theme to the page_sidebar() using the theme parameter\n\nUpdated the plot_module.R to work with thematic:\n\nRemoved the explicit theme_minimal() call since thematic will handle the base theming\nKept specific theme adjustments for title styling and legend positioning\n\n\nThe thematic package now automatically coordinates the ggplot2 theme with the application’s dark theme, creating a cohesive dark mode experience throughout the entire application. The plots will automatically inherit the dark background and appropriate colors for text and elements.\n\n\nAfter confirming the new theme works, we’ll download the app files by clicking on the cloud icon in the upper right corner:\n\n\n\n\n\n\n\nDownload files",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Shiny Assistant</span>"
    ]
  },
  {
    "objectID": "shiny_assist.html#sec-shiny-assist-finishing-touches",
    "href": "shiny_assist.html#sec-shiny-assist-finishing-touches",
    "title": "26  Shiny Assistant",
    "section": "26.2 Finishing touches",
    "text": "26.2 Finishing touches\nWe’ll place the downloaded files in the inst/shiny-assist/movies folder in sap, and after some minor changes to the files/folder organization (we’ll move the standalone app function into it’s own file in the R/ folder):\ninst/shiny-assist/\n└── movies\n1    ├── R\n    │   ├── about_module.R\n    │   ├── app_server.R\n    │   ├── app_ui.R\n    │   ├── controls_module.R\n2    │   ├── movie_visualization_app.R\n    │   └── plot_module.R\n    └── app.R\n\n3 directories, 7 files\n\n1\n\nR/ folder for modules and functions\n\n2\n\nStandalone app function\n\n\nThe app-package structure starting to take shape!\n\n26.2.1 The app.R file\nThe app.R file no longer needs to source() the modules and app functions if they are placed in an R/ folder.3\n\n# Load required libraries\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(bslib)\nlibrary(thematic)\n\n# Setup thematic to automatically adjust plot theme to match app theme\nthematic_shiny(font = \"auto\")\n\n# Run the application \nmovie_visualization_app()\n\nNow app.R only loads the packages, theme, and launches the app.\nIn Positron, we can see the Run App icon is present at the top of app.R, and it’s fully functional:\n\n\n\n\n\n\n\nShiny Assistant app launced in Positron\n\n\n\n\n26.2.2 ggplot2 warnings\nWe have a persistent warning printed to the console about the use of aes_string() in our plot_module.R.\n\n\n\n\n\n\n\nggplot2::aes_string() warning\n\n\nThe solution is to convert the aes_string() to use rlang::sym() and !!.\n\n\n\n\n\n\naes_string()\n# Create base plot\np &lt;- ggplot2::ggplot(data(), \n        ggplot2::aes_string(\n        x = ctrl$x_var, \n        y = ctrl$y_var)\n      )\n\n\nrlang::sym() & !!\n# convert to symbols \nx_var &lt;- rlang::sym(ctrl$x_var)\ny_var &lt;- rlang::sym(ctrl$y_var)\n\n# Create base plot\np &lt;- ggplot2::ggplot(\n          data(), \n        ggplot2::aes(\n          # use double bang!!\n            x = !!x_var, \n            y = !!y_var\n            )\n          )\n\n\n\n\n\n\n\n\n\naes_string()\n# Add color if selected\nif (ctrl$color_var != \"none\") {\n\n  p &lt;- p + aes_string(\n              color = ctrl$color_var\n              )\n  \n}\n\n\nrlang::sym() & !!\n# Add color if selected\nif (ctrl$color_var != \"none\") {\n\n  # convert to symbols \n  color_var &lt;- rlang::sym(ctrl$color_var)\n\n  p &lt;- p + ggplot2::aes(\n              # use double bang!!\n              color = !!color_var\n              )\n}\n\n\n\nFinally, we’ll add this app to our launch_app() function:\n\n\nshow/hide updated launch_app() function\nlaunch_app &lt;- function(app = NULL, options = list(), run = \"p\", ...) {\n  if (interactive()) {\n    display_type(run = run)\n  }\n\n  if (is.null(app)) {\n    app &lt;- \"movies\"\n  }\n\n  logr_msg(glue::glue(\"Launching app: {app}\"),\n    level = \"INFO\"\n  )\n\n  tryCatch({\n      if (app == \"bslib\") {\n        shinyApp(\n          ui = movies_ui(bslib = TRUE),\n          server = movies_server,\n          options = options\n        )\n      } else if (app == \"ggp2\") {\n        shinyAppDir(\n          appDir = system.file(\"tidy-movies\", package = \"sap\"),\n          options = options\n        )\n      } else if (app == \"quarto\") {\n        quarto::quarto_preview(\n          system.file(\"quarto\", \"index.qmd\", package = \"sap\"),\n          render = \"all\"\n        )\n1      } else if (app == \"assist\") {\n        shinyAppDir(\n          appDir = system.file(\"shiny-assist\", package = \"sap\"),\n          options = options\n        )\n      } else {\n        shinyApp(\n          ui = movies_ui(...),\n          server = movies_server,\n          options = options\n        )\n      }\n    }, error = function(e) {\n      logr_msg(glue::glue(\"FATAL: Application failed to launch. Reason: {e$message}\"),\n        level = \"FATAL\"\n      )\n\n      stop(\"Application launch failed. Check logs for details.\")\n    }\n  )\n}\n\n\n\n1\n\nNew Shiny Assistant application",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Shiny Assistant</span>"
    ]
  },
  {
    "objectID": "shiny_assist.html#recap",
    "href": "shiny_assist.html#recap",
    "title": "26  Shiny Assistant",
    "section": "Recap",
    "text": "Recap\nThis chapter covered building a Shiny app ‘fit for a package’ using the Shiny Assistant. As you can see, in just a few prompts, we can have a Shiny application that ~80% ready to be loaded, installed, and launched. The callout box below includes a few items to watch out for when using Shiny Assistant to build apps:\n\n\n\n\n\n\nRecap: Shiny Assistant\n\n\n\n\n\n\nShiny Assistant is a powerful tool for building Shiny apps. With the right prompting, the application code can be easily structured into an R package. The only caveats I’ve found are:\n\nDeprecated functions: the ggplot2 (aes_string()) warning is an example of somthing that might require more specific prompting (or knowledge of rlang/ggplot2).\nDocumentation/Dependencies: the roxygen2 documentation generated by Shiny Assistant used copius @importFrom and @import tags, which is something we want to avoid.\nModule structure: Shiny Assistant came up with a different module structure than we had in our previous branches, but that’s not to say it’s incorrect. However, it’s important to check the reactivity and understand how the namespaces and reactive inputs are managed in the application before putting it into production.",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Shiny Assistant</span>"
    ]
  },
  {
    "objectID": "shiny_assist.html#footnotes",
    "href": "shiny_assist.html#footnotes",
    "title": "26  Shiny Assistant",
    "section": "",
    "text": "Read more in the Shiny Assistant post on the Shiny blog.↩︎\nI’ve included a .csv version of these data in the data-raw/ folder of this branch.↩︎\nloadSupport() was covered back in Section 2.3.↩︎",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Shiny Assistant</span>"
    ]
  },
  {
    "objectID": "ellmer.html",
    "href": "ellmer.html",
    "title": "27  ellmer",
    "section": "",
    "text": "27.1 Installing ellmer\nThe ellmer package servers as the ‘backbone’ to using LLMs in R (we used it to set up the ensure package for writing unit tests in Section 16.1). The package has been thoughtfully developed, is easy to use, and has excellent documentation and examples. This chapter will briefly cover using ellmer’s chat tool in app-package development.\nInstall ellmer like you would any other package:\ninstall.packages('ellmer')\n# or the dev version\npak::pak('tidyverse/ellmer')",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>ellmer</span>"
    ]
  },
  {
    "objectID": "ellmer.html#sec-ellmer-install",
    "href": "ellmer.html#sec-ellmer-install",
    "title": "27  ellmer",
    "section": "",
    "text": "27.1.1 LLM Provider\nAfter installing the package, we need to set up an LLM model provider. ellmer provides 10+ LLM provider options, but for this example, I’ll use the OpenAI model, which requires an API key (OPENAI_API_KEY) which can be set in the .Renviron file.1\n\n\n27.1.2 Using the chat\nTo start a chat, we can call ellmer::chat_openai() and specify the model we want to use.2 We should also be sure to record any system_prompts and the number of turns we’ll be using.\n\nlibrary(ellmer)\nchat &lt;- chat_openai(model = \"o1-mini\")\n\nUsing model = \"o1-mini\".\nThe chat object can be used directly in the console to submit prompts and get responses.\n\nchat$chat(\"\n  What are the benefits of developing my Shiny application in an R package?\n  Answer in a markdown-formatted bulleted list.\n\")\n\n\n- **Enhanced Code Organization**\n  - Structure your application with a standardized file hierarchy, making the codebase \neasier to navigate and maintain.\n\n- **Reusable Components**\n  - Develop modular functions and components that can be easily reused across different\nprojects or parts of the application.\n\n- **Dependency Management**\n  - Clearly specify and manage package dependencies, ensuring that all necessary \nlibraries are installed and up to date.\n\n- **Simplified Testing**\n  - Utilize built-in testing frameworks to implement unit tests and ensure the \nreliability of your application.\n\n- **Comprehensive Documentation**\n  - Provide detailed documentation for functions and features using tools like \nRoxygen2, improving understandability for users and contributors.\n\n- **Namespace Control**\n  - Avoid function name conflicts and manage the scope of your functions effectively \nthrough namespaces.\n\n- **Ease of Distribution**\n  - Share your Shiny application effortlessly by distributing it as an R package \nthrough platforms like CRAN or GitHub.\n\n- **Version Control Integration**\n  - Manage and track changes systematically with version control systems, facilitating \ncollaboration and rollback capabilities.\n\n- **Streamlined Deployment**\n  - Leverage package tools for easier deployment to servers or Shiny hosting services, \nensuring a smoother launch process.\n\n- **Community Contributions**\n  - Enable others to contribute to your application more easily by following standard \npackage development practices, fostering community growth.\n\nWe can copy and paste the output into any Markdown document (vignettes, README, etc.).\n\n\n27.1.3 Prompts\nIf we plan on having a conversation with an LLM, we should pick a location to store our prompts (and responses). The ellmer authors recommend storing these in inst/prompts, with a sensible naming convention.3",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>ellmer</span>"
    ]
  },
  {
    "objectID": "ellmer.html#sec-ellmer-shinydb",
    "href": "ellmer.html#sec-ellmer-shinydb",
    "title": "27  ellmer",
    "section": "27.2 Movie explorer redux",
    "text": "27.2 Movie explorer redux\nWe’re going to use ellmer to help us convert an existing Shiny app into a Shiny app-package. The application comes from the Shiny Examples GitHub repo. The README.md from the original app is available below:\n\n\nLaunch app with the shinypak package:\n\nlaunch('24_llm-ellmer')\n\n\n\n\n\n\n\n051-movie-explorer app\n\n\n\n\nThis is the source code for a movie explorer app which runs on R and Shiny. The data is a subset of data from OMDb, which in turn is from IMDb and Rotten Tomatoes. The data is saved in a SQLite database.\nTo run it locally, you’ll need to install the latest versions of ggvis, Shiny, and dplyr, as well as RSQLite.\ninstall.packages(c('shiny', 'ggvis', 'dplyr', 'RSQLite'))\nYou may need to restart R to make sure the newly-installed packages work properly.\nAfter all these packages are installed, you can run this app by entering the directory, and then running the following in R:\nshiny::runApp()\n\n\n\nThe application files are also stored in the inst/51-movie-explorer folder of this branch:\ninst/51-movies-explorer/\n├── DESCRIPTION\n├── README.md\n├── global.R\n├── movies.db\n├── server.R\n└── ui.R\n\n1 directory, 6 files\n\n27.2.1 System Prompt\nWe’ll start by passing a system_prompt to chat$chat() to provide some additional information on how the model should respond:\n\n\n\n\n\n\nSystem prompts\n\n\n\n\n\n\n\n\nshow/hide system_prompt\nlibrary(ellmer)\nchat &lt;- chat_openai(model = \"o1\", \n    system_prompt = \"\n  You are an expert Shiny developer and R package author. Return responses in \n  markdown.\n  \n  Follow the tidyverse style guide:\n  * Limit code to 80 characters per line   \n  * File names should be machine readable (no spaces, symbols, or special \n    characters)   \n  * Variables and function names should all be `snake_case` (i.e., lowercase \n    letters, numbers, and underscores to separate words within a name).   \n  * Place a space before and after `=`   \n  * Avoid empty lines at the start or end of functions   \n  * Only use a single empty line when needed to separate functions or pipes   \n  * Use verbs for function names   \n  * If a function name and definition can’t fit on a single line, indent the \n    argument name with a single indent (i.e. two spaces).   \n  * Comments should be in sentence case   \n  * Spread long function calls across multiple lines    \n  * Always use double quotes for strings   \n  * Use double quotes, not single quotes, for quoting text   \n  * Use base pipe `|&gt;` (not `%&gt;%`)    \n  \")\n\n\n\n\n\n\nI’ve modeled this system_prompt off the example in the ellmer documentation,4 but this can be used to specify expertise, coding style preferences (tidyverse/base R), etc.\n\n\n27.2.2 Prompt 1: update\nPrompt 1: The first prompt (stored in inst/prompts/prompt-01-refactor-mods-functions.md) will focus on creating modules, UI and server functions, and a standalone app function. We’ll provide the ui.R and server.R code, and some instructions for module and function names. It’s recommended to provide prompts using Markdown,5 and I’d used escape characters for the R code chunks.\n\n\n\n\n\n\nPrompt text 1\n\n\n\n\n\nExpand the code chunk below to view the first prompt.\n\n\n\nshow/hide prompt 1\nchat$chat(\"\n1. Convert the following Shiny application (stored in ui.R and server.R) to use\nmodules for inputs and outputs (i.e., `mod_graph_inputs_ui()` and \n`mod_graph_inputs_server()`, `mod_graph_output_ui()` and \n`mod_graph_output_server()`).\n\n2. Convert the ggvis graph output to a plotly output.\n\n3. Place the module functions in separate app UI and server functions (i.e., \n`db_app_ui()` and `db_app_server()`)\n\n4. Create a standalone app function (`launch_db_app()`) that launches the app \nusing: `shiny::shinyApp(ui = db_app_ui(), server = db_app_server)`\n\nThe app `ui.R` code: \n\n\\`\\`\\`r\nlibrary(ggvis)\n\n# For dropdown menu\nactionLink &lt;- function(inputId, ...) {\n  tags$a(href='javascript:void',\n         id=inputId,\n         class='action-button',\n         ...)\n}\n\nfluidPage(\n  titlePanel('Movie explorer'),\n  fluidRow(\n    column(3,\n      wellPanel(\n        h4('Filter'),\n        sliderInput('reviews', 'Minimum number of reviews on Rotten Tomatoes',\n          10, 300, 80, step = 10),\n        sliderInput('year', 'Year released', 1940, 2014, value = c(1970, 2014),\n          sep = ''),\n        sliderInput('oscars', 'Minimum number of Oscar wins (all categories)',\n          0, 4, 0, step = 1),\n        sliderInput('boxoffice', 'Dollars at Box Office (millions)',\n          0, 800, c(0, 800), step = 1),\n        selectInput('genre', 'Genre (a movie can have multiple genres)',\n          c('All', 'Action', 'Adventure', 'Animation', 'Biography', 'Comedy',\n            'Crime', 'Documentary', 'Drama', 'Family', 'Fantasy', 'History',\n            'Horror', 'Music', 'Musical', 'Mystery', 'Romance', 'Sci-Fi',\n            'Short', 'Sport', 'Thriller', 'War', 'Western')\n        ),\n        textInput('director', 'Director name contains (e.g., Miyazaki)'),\n        textInput('cast', 'Cast names contains (e.g. Tom Hanks)')\n      ),\n      wellPanel(\n        selectInput('xvar', 'X-axis variable', axis_vars, selected = 'Meter'),\n        selectInput('yvar', 'Y-axis variable', axis_vars, selected = 'Reviews'),\n        tags$small(paste0(\n          'Note: The Tomato Meter is the proportion of positive reviews',\n          ' (as judged by the Rotten Tomatoes staff), and the Numeric rating is',\n          ' a normalized 1-10 score of those reviews which have star ratings',\n          ' (for example, 3 out of 4 stars).'\n        ))\n      )\n    ),\n    column(9,\n      ggvisOutput('plot1'),\n      wellPanel(\n        span('Number of movies selected:',\n          textOutput('n_movies')\n        )\n      )\n    )\n  )\n)\n\\`\\`\\`\n\nThe app `server.R` code:\n\n\\`\\`\\`r\nlibrary(ggvis)\nlibrary(dplyr)\nif (FALSE) {\n  library(RSQLite)\n  library(dbplyr)\n}\n\n# Set up handles to database tables on app start\ndb &lt;- src_sqlite('movies.db')\nomdb &lt;- tbl(db, 'omdb')\ntomatoes &lt;- tbl(db, 'tomatoes')\n\n# Join tables, filtering out those with &lt;10 reviews, and select specified columns\nall_movies &lt;- inner_join(omdb, tomatoes, by = 'ID') %&gt;%\n  filter(Reviews &gt;= 10) %&gt;%\n  select(ID, imdbID, Title, Year, Rating_m = Rating.x, Runtime, Genre, Released,\n    Director, Writer, imdbRating, imdbVotes, Language, Country, Oscars,\n    Rating = Rating.y, Meter, Reviews, Fresh, Rotten, userMeter, userRating, \n    userReviews, BoxOffice, Production, Cast)\n\n\nfunction(input, output, session) {\n\n  # Filter the movies, returning a data frame\n  movies &lt;- reactive({\n    # Due to dplyr issue #318, we need temp variables for input values\n    reviews &lt;- input$reviews\n    oscars &lt;- input$oscars\n    minyear &lt;- input$year[1]\n    maxyear &lt;- input$year[2]\n    minboxoffice &lt;- input$boxoffice[1] * 1e6\n    maxboxoffice &lt;- input$boxoffice[2] * 1e6\n\n    # Apply filters\n    m &lt;- all_movies %&gt;%\n      filter(\n        Reviews &gt;= reviews,\n        Oscars &gt;= oscars,\n        Year &gt;= minyear,\n        Year &lt;= maxyear,\n        BoxOffice &gt;= minboxoffice,\n        BoxOffice &lt;= maxboxoffice\n      ) %&gt;%\n      arrange(Oscars)\n\n    # Optional: filter by genre\n    if (input$genre != 'All') {\n      genre &lt;- paste0('%', input$genre, '%')\n      m &lt;- m %&gt;% filter(Genre %like% genre)\n    }\n    # Optional: filter by director\n    if (!is.null(input$director) && input$director != '') {\n      director &lt;- paste0('%', input$director, '%')\n      m &lt;- m %&gt;% filter(Director %like% director)\n    }\n    # Optional: filter by cast member\n    if (!is.null(input$cast) && input$cast != '') {\n      cast &lt;- paste0('%', input$cast, '%')\n      m &lt;- m %&gt;% filter(Cast %like% cast)\n    }\n\n    m &lt;- as.data.frame(m)\n\n    # Add column which says whether the movie won any Oscars\n    # Be a little careful in case we have a zero-row data frame\n    m$has_oscar &lt;- character(nrow(m))\n    m$has_oscar[m$Oscars == 0] &lt;- 'No'\n    m$has_oscar[m$Oscars &gt;= 1] &lt;- 'Yes'\n    m\n  })\n\n  # Function for generating tooltip text\n  movie_tooltip &lt;- function(x) {\n    if (is.null(x)) return(NULL)\n    if (is.null(x$ID)) return(NULL)\n\n    # Pick out the movie with this ID\n    all_movies &lt;- isolate(movies())\n    movie &lt;- all_movies[all_movies$ID == x$ID, ]\n\n    paste0('&lt;b&gt;', movie$Title, '&lt;/b&gt;&lt;br&gt;',\n      movie$Year, '&lt;br&gt;',\n      '$', format(movie$BoxOffice, big.mark = ',', scientific = FALSE)\n    )\n  }\n\n  # A reactive expression with the ggvis plot\n  vis &lt;- reactive({\n    # Lables for axes\n    xvar_name &lt;- names(axis_vars)[axis_vars == input$xvar]\n    yvar_name &lt;- names(axis_vars)[axis_vars == input$yvar]\n\n    # Normally we could do something like props(x = ~BoxOffice, y = ~Reviews),\n    # but since the inputs are strings, we need to do a little more work.\n    xvar &lt;- prop('x', as.symbol(input$xvar))\n    yvar &lt;- prop('y', as.symbol(input$yvar))\n\n    movies %&gt;%\n      ggvis(x = xvar, y = yvar) %&gt;%\n      layer_points(size := 50, size.hover := 200,\n        fillOpacity := 0.2, fillOpacity.hover := 0.5,\n        stroke = ~has_oscar, key := ~ID) %&gt;%\n      add_tooltip(movie_tooltip, 'hover') %&gt;%\n      add_axis('x', title = xvar_name) %&gt;%\n      add_axis('y', title = yvar_name) %&gt;%\n      add_legend('stroke', title = 'Won Oscar', values = c('Yes', 'No')) %&gt;%\n      scale_nominal('stroke', domain = c('Yes', 'No'),\n        range = c('orange', '#aaa')) %&gt;%\n      set_options(width = 500, height = 500)\n  })\n\n  vis %&gt;% bind_shiny('plot1')\n\n  output$n_movies &lt;- renderText({ nrow(movies()) })\n}\n\\`\\`\\`\n\n\")\n\n\n\n\n\n\n\n27.2.2.1 Response 1: update\nThe response is generated in the Console:\n\n\n\n\n\n\n\nellmer chat response\n\n\nWe can see the response contains the modules and functions in separate code chunks. I’ve organized them into the callout box below:\n\n\n\n\n\n\nResponse text 1\n\n\n\n\n\n\n\n\nshow/hide mod_graph_inputs.R\n# mod_graph_inputs.R\nmod_graph_inputs_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::wellPanel(\n      shiny::h4(\"Filter\"),\n      shiny::sliderInput(\n        inputId = ns(\"reviews\"),\n        label = \"Minimum number of reviews on Rotten Tomatoes\",\n        min = 10,\n        max = 300,\n        value = 80,\n        step = 10\n      ),\n      shiny::sliderInput(\n        inputId = ns(\"year\"),\n        label = \"Year released\",\n        min = 1940,\n        max = 2014,\n        value = c(1970, 2014),\n        sep = \"\"\n      ),\n      shiny::sliderInput(\n        inputId = ns(\"oscars\"),\n        label = \"Minimum number of Oscar wins (all categories)\",\n        min = 0,\n        max = 4,\n        value = 0,\n        step = 1\n      ),\n      shiny::sliderInput(\n        inputId = ns(\"boxoffice\"),\n        label = \"Dollars at Box Office (millions)\",\n        min = 0,\n        max = 800,\n        value = c(0, 800),\n        step = 1\n      ),\n      shiny::selectInput(\n        inputId = ns(\"genre\"),\n        label = \"Genre (a movie can have multiple genres)\",\n        choices = c(\n          \"All\", \"Action\", \"Adventure\", \"Animation\", \"Biography\", \"Comedy\",\n          \"Crime\", \"Documentary\", \"Drama\", \"Family\", \"Fantasy\", \"History\",\n          \"Horror\", \"Music\", \"Musical\", \"Mystery\", \"Romance\", \"Sci-Fi\",\n          \"Short\", \"Sport\", \"Thriller\", \"War\", \"Western\"\n        ),\n        selected = \"All\"\n      ),\n      shiny::textInput(\n        inputId = ns(\"director\"),\n        label = \"Director name contains (e.g., Miyazaki)\"\n      ),\n      shiny::textInput(\n        inputId = ns(\"cast\"),\n        label = \"Cast names contains (e.g. Tom Hanks)\"\n      )\n    ),\n    shiny::wellPanel(\n      shiny::selectInput(\n        inputId = ns(\"xvar\"),\n        label = \"X-axis variable\",\n        choices = axis_vars,\n        selected = \"Meter\"\n      ),\n      shiny::selectInput(\n        inputId = ns(\"yvar\"),\n        label = \"Y-axis variable\",\n        choices = axis_vars,\n        selected = \"Reviews\"\n      ),\n      shiny::tags$small(\n        shiny::p(\n          paste0(\n            \"Note: The Tomato Meter is the proportion of positive reviews \",\n            \"(as judged by the Rotten Tomatoes staff), and the Numeric rating \",\n            \"is a normalized 1-10 score of those reviews which have star \",\n            \"ratings (for example, 3 out of 4 stars).\"\n          )\n        )\n      )\n    )\n  )\n}\n\nmod_graph_inputs_server &lt;- function(id, all_movies) {\n  shiny::moduleServer(\n    id,\n    function(input, output, session) {\n      # Filter movies based on user inputs\n      movies &lt;- shiny::reactive({\n        reviews &lt;- input$reviews\n        oscars &lt;- input$oscars\n        minyear &lt;- input$year[1]\n        maxyear &lt;- input$year[2]\n        minboxoffice &lt;- input$boxoffice[1] * 1e6\n        maxboxoffice &lt;- input$boxoffice[2] * 1e6\n        \n        m &lt;- all_movies |&gt;\n          dplyr::filter(\n            Reviews &gt;= reviews,\n            Oscars &gt;= oscars,\n            Year &gt;= minyear,\n            Year &lt;= maxyear,\n            BoxOffice &gt;= minboxoffice,\n            BoxOffice &lt;= maxboxoffice\n          ) |&gt;\n          dplyr::arrange(Oscars)\n        \n        if (input$genre != \"All\") {\n          genre &lt;- paste0(\"%\", input$genre, \"%\")\n          m &lt;- m |&gt;\n            dplyr::filter(Genre %like% genre)\n        }\n        \n        if (!is.null(input$director) && input$director != \"\") {\n          director &lt;- paste0(\"%\", input$director, \"%\")\n          m &lt;- m |&gt;\n            dplyr::filter(Director %like% director)\n        }\n        \n        if (!is.null(input$cast) && input$cast != \"\") {\n          cast &lt;- paste0(\"%\", input$cast, \"%\")\n          m &lt;- m |&gt;\n            dplyr::filter(Cast %like% cast)\n        }\n        \n        m &lt;- as.data.frame(m)\n        m$has_oscar &lt;- character(nrow(m))\n        m$has_oscar[m$Oscars == 0] &lt;- \"No\"\n        m$has_oscar[m$Oscars &gt;= 1] &lt;- \"Yes\"\n        m\n      })\n      \n      # Return a reactive list giving the xvar, yvar, and filtered data\n      shiny::reactive({\n        list(\n          xvar = input$xvar,\n          yvar = input$yvar,\n          data = movies()\n        )\n      })\n    }\n  )\n}\n\n\n\n\nshow/hide mod_graph_output.R\n# mod_graph_output.R\nmod_graph_output_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    plotly::plotlyOutput(outputId = ns(\"plot1\")),\n    shiny::wellPanel(\n      shiny::span(\n        \"Number of movies selected:\",\n        shiny::textOutput(ns(\"n_movies\"))\n      )\n    )\n  )\n}\n\nmod_graph_output_server &lt;- function(id, inputs_list) {\n  shiny::moduleServer(\n    id,\n    function(input, output, session) {\n      \n      # Render a plotly chart\n      output$plot1 &lt;- plotly::renderPlotly({\n        xvar &lt;- inputs_list()$xvar\n        yvar &lt;- inputs_list()$yvar\n        movie_data &lt;- inputs_list()$data\n        \n        # Axis label from named vector\n        xvar_label &lt;- names(axis_vars)[axis_vars == xvar]\n        yvar_label &lt;- names(axis_vars)[axis_vars == yvar]\n        \n        if (is.null(movie_data) || nrow(movie_data) == 0) {\n          return(NULL)\n        }\n        \n        # Construct the tooltip\n        tooltip_text &lt;- paste0(\n          \"&lt;b&gt;\", movie_data$Title, \"&lt;/b&gt;&lt;br&gt;\",\n          movie_data$Year, \"&lt;br&gt;$\",\n          format(movie_data$BoxOffice, big.mark = \",\", scientific = FALSE)\n        )\n        \n        plotly::plot_ly(\n          data = movie_data,\n          x = ~.data[[xvar]],\n          y = ~.data[[yvar]],\n          text = tooltip_text,\n          hoverinfo = \"text\",\n          color = ~factor(has_oscar, levels = c(\"Yes\", \"No\")),\n          colors = c(\"orange\", \"#aaa\"),\n          type = \"scatter\",\n          mode = \"markers\"\n        ) |&gt;\n          plotly::layout(\n            xaxis = list(title = xvar_label),\n            yaxis = list(title = yvar_label),\n            showlegend = TRUE\n          )\n      })\n      \n      output$n_movies &lt;- shiny::renderText({\n        nrow(inputs_list()$data)\n      })\n    }\n  )\n}\n\n\n\n\nshow/hide db_app_ui.R\n# db_app_ui.R\ndb_app_ui &lt;- function() {\n  shiny::fluidPage(\n    shiny::titlePanel(\"Movie explorer\"),\n    shiny::fluidRow(\n      shiny::column(\n        width = 3,\n        mod_graph_inputs_ui(\"graph_inputs\")\n      ),\n      shiny::column(\n        width = 9,\n        mod_graph_output_ui(\"graph_outputs\")\n      )\n    )\n  )\n}\n\n\n\n\nshow/hide db_app_server.R\n# db_app_server.R\ndb_app_server &lt;- function(input, output, session) {\n  \n  # Set up handles to database tables on app start\n  db &lt;- dplyr::src_sqlite(\"movies.db\")\n  omdb &lt;- dplyr::tbl(db, \"omdb\")\n  tomatoes &lt;- dplyr::tbl(db, \"tomatoes\")\n  \n  # Join tables, filter out those with &lt;10 reviews, and select\n  all_movies &lt;- dplyr::inner_join(omdb, tomatoes, by = \"ID\") |&gt;\n    dplyr::filter(Reviews &gt;= 10) |&gt;\n    dplyr::select(\n      ID, imdbID, Title, Year, Rating_m = Rating.x, Runtime, Genre,\n      Released, Director, Writer, imdbRating, imdbVotes, Language,\n      Country, Oscars, Rating = Rating.y, Meter, Reviews, Fresh, Rotten,\n      userMeter, userRating, userReviews, BoxOffice, Production, Cast\n    )\n  \n  # Call module for inputs\n  inputs_reactive &lt;- mod_graph_inputs_server(\n    id = \"graph_inputs\",\n    all_movies = all_movies\n  )\n  \n  # Call module for outputs\n  mod_graph_output_server(\n    id = \"graph_outputs\",\n    inputs_list = inputs_reactive\n  )\n}\n\n\n\n\nshow/hide global.R\n# A named vector of possible axis variables\naxis_vars &lt;- c(\n  \"Meter\" = \"Meter\",\n  \"Reviews\" = \"Reviews\",\n  \"Box office\" = \"BoxOffice\",\n  \"IMDB rating\" = \"imdbRating\",\n  \"IMDB votes\" = \"imdbVotes\",\n  \"User meter\" = \"userMeter\",\n  \"User rating\" = \"userRating\"\n)\n\n\n\n\nshow/hide launch_db_app.R\n# Standalone app (im app.R)\nlaunch_db_app &lt;- function() {\n  shiny::shinyApp(\n    ui = db_app_ui(),\n    server = db_app_server\n  )\n}\n\n\nExplanation of major changes:\n• The ggvis plot and bindings have been replaced with a plotly plot.\n• The UI for the plot is now plotlyOutput rather than ggvisOutput.\n• The “movie_tooltip” logic is approximated through Plotly’s text and hoverinfo =  'text'.\n• Modules (mod_graph_inputs_) handle filtering inputs, and modules (mod_graph_output_) handle the plotly plot output plus the count of displayed movies.\n• db_app_ui() and db_app_server() assemble everything, and launch_db_app() calls shiny::shinyApp() with those functions.\n\n\n\n\nWe’ll create an app folder in inst/db_app, then structure the files like a ‘mini’ R package:\ninst/db_app/\n├── R\n│   ├── db_app_server.R\n│   ├── db_app_ui.R\n│   ├── global.R\n│   ├── mod_graph_inputs.R\n│   └── mod_graph_output.R\n├── app.R\n└── movies.db\n\n2 directories, 7 files\nAfter organizing the files into the structure above, we can run the application using the launch_db_app() function (stored in app.R).\n\n\n\n\n\n\n\nInitial application from ellmer\n\n\nThe application launches and we can see the plotly scatter plot renders successfully. The inputs in the sidebar are somewhat cramped and out of view, but we can adjust this with future prompts (or by manually editing the UI components).\n\n\n\n27.2.3 Prompt 2: refactor\nPrompt 2: The second prompt will focus on creating utility functions for the database connection and joining/wrangling the data. I’ve stored the instructions in inst/prompts/prompt-02-utility-functions.md (we’ll use the same system_prompt).\nThe goal with this prompt is to create testable utility functions and address the dplyr::src_sqlite() warning we’re getting from our database connection:\nWarning: `src_sqlite()` was deprecated in dplyr 1.0.0.\nℹ Please use `tbl()` directly with a database connection\n\n\n\n\n\n\nPrompt text 2\n\n\n\n\n\n\n\n\nshow/hide prompt 2\nchat$chat(\"\nConvert the following code into two utility functions for 1) establishing a \nconnection to the `movies.db` database, and 2) joining the omdb and tomatoes\ntables, filtering to `Reviews &gt;= 10`, and selecting the necessary columns.\n\n\\`\\`\\`r\ndb_con.R \n# Set up handles to database tables on app start\ndb &lt;- dplyr::src_sqlite(path = 'movies.db')\nomdb &lt;- dplyr::tbl(db, 'omdb')\ntomatoes &lt;- dplyr::tbl(db, 'tomatoes')\n\\`\\`\\`\n\n\n\\`\\`\\`r\n# Join tables, filter out those with &lt;10 reviews, and select\nall_movies &lt;- dplyr::inner_join(omdb, tomatoes, by = 'ID') |&gt;\ndplyr::filter(Reviews &gt;= 10) |&gt;\ndplyr::select(\n    ID, imdbID, Title, Year, Rating_m = Rating.x, Runtime, Genre,\n    Released, Director, Writer, imdbRating, imdbVotes, Language,\n    Country, Oscars, Rating = Rating.y, Meter, Reviews, Fresh, Rotten,\n    userMeter, userRating, userReviews, BoxOffice, Production, Cast\n)\n\\`\\`\\`\n\n\")\n\n\n\n\n\n\n\n27.2.3.1 Response 2: refactor\nThe response includes two new functions: connect_database() and get_all_movies()\n\n\n\n\n\n\nResponse text 2\n\n\n\n\n\n\n\n\nshow/hide connect_database.R\n# connect_database.R\nconnect_database &lt;- function(db_path = \"movies.db\") {\n  # Create a handle to the movies database\n  db &lt;- dplyr::src_sqlite(path = db_path)\n  db\n}\n\n\n\n\nshow/hide get_all_movies.R\n# get_all_movies.R\nget_all_movies &lt;- function(db) {\n  # Join tables, filter out those with &lt;10 reviews, and select columns\n  omdb &lt;- dplyr::tbl(db, \"omdb\")\n  tomatoes &lt;- dplyr::tbl(db, \"tomatoes\")\n  \n  all_movies &lt;- dplyr::inner_join(\n    x = omdb,\n    y = tomatoes,\n    by = \"ID\"\n  ) |&gt;\n    dplyr::filter(Reviews &gt;= 10) |&gt;\n    dplyr::select(\n      ID, imdbID, Title, Year, Rating_m = Rating.x, Runtime, Genre,\n      Released, Director, Writer, imdbRating, imdbVotes, Language,\n      Country, Oscars, Rating = Rating.y, Meter, Reviews,\n      Fresh, Rotten, userMeter, userRating, userReviews, BoxOffice,\n      Production, Cast\n    )\n  \n  all_movies\n}\n\n\nExplanation\n• connect_database() is a simple function that uses dplyr::src_sqlite() to connect to the movies.db SQLite database, returning the database connection object.\n• get_all_movies() pulls the omdb and tomatoes tables, joins them, filters for Reviews ≥ 10, and selects the required columns.\n\n\n\n\nconnect_database() still uses dplyr::src_sqlite(), so we’ll rewrite this function to address the warning, move the movies.db file into the inst/extdata6 folder, and access the file with system.file():\n\nconnect_database &lt;- function(pkg, db) {\n  # Create connection to movies database\n  con &lt;- DBI::dbConnect(RSQLite::SQLite(),\n              system.file(\"extdata\", db, package = pkg))\n  con\n}\n\nWe’ll also need to update the db_app_server() function to use the new utility functions:\n\ndb_app_server &lt;- function(input, output, session) {\n  \n  # Set up connection to database tables on app start\n1  db &lt;- connect_database(pkg = \"sap\", db = \"movies.db\")\n  \n  # Join tables, filter out those with &lt;10 reviews, and select\n2  all_movies &lt;- get_all_movies(db = db)\n  \n  # Call module for inputs\n  inputs_reactive &lt;- mod_graph_inputs_server(\n    id = \"graph_inputs\",\n    all_movies = all_movies\n  )\n  \n  # Call module for outputs\n  mod_graph_output_server(\n    id = \"graph_outputs\",\n    inputs_list = inputs_reactive\n  )\n}\n\n\n1\n\nReplaces the dplyr::src_sqlite() and dplyr::tbl() calls.\n\n\n2\n\nReplaces the dplyr::inner_join(), dplyr::filter(), and dplyr::select() functions.\n\n\n\n\nTo implement these changes, we’ll need to add the new function files to the inst/db_app/R folder:\ninst/db_app/\n├── R\n│   ├── connect_database.R\n│   ├── db_app_server.R\n│   ├── db_app_ui.R\n│   ├── get_all_movies.R\n│   ├── global.R\n│   ├── mod_graph_inputs.R\n│   └── mod_graph_output.R\n└── app.R\n\n2 directories, 8 files\nThis results in the following application:\n\n\n\n\n\n\n\nUpdated inst/db_app app\n\n\nWe can see the dplyr::src_sqlite() warning is gone and the data is correctly loaded in the application.\n\n\n\n27.2.4 Prompt 3: overhaul\nPrompt 3: We’ll get even more detailed in the third prompt (stored in inst/prompts/prompt-03-app-ast-design.md). In these instructions, we’ll include an abstract syntax tree (courtesy of lobstr::ast()) with proposed function names and descriptions:\n█─launch_app \n├─█─db_app_ui \n│ ├─█─mod_select_input_ui \n│ ├─█─mod_slider_input_ui \n│ ├─█─mod_text_input_ui \n│ ├─█─mod_points_plotly_ui \n│ └─█─mod_table_ui \n└─█─db_app_server \n  ├─█─db_con \n  │ └─█─join_movies_tbls \n  ├─█─mod_slider_input_server \n  ├─█─mod_select_input_server \n  ├─█─mod_text_input_server \n  ├─█─mod_table_server \n  └─█─mod_points_plotly_server \n    └─█─scatter_plotly \nI’ve found this practice is helpful when writing prompts that request nested functions (like modules). We’ll also instruct the model to return the functions with roxygen2 documentation.\n\n\n\n\n\n\nPrompt text 3\n\n\n\n\n\nExpand the code chunk below to view the entire prompt.\n\n\n\nshow/hide prompt 3\nchat$chat(\"\nRestructure the application to use the following modules and functions: \n\n* `db_app_ui()`: main app UI function\n\n* `db_app_server()`: main server function \n\n* `mod_select_input_ui()`/`mod_slider_input_server()`: select inputs shiny \n  module \n\n* `mod_slider_input_ui()`/`mod_slider_input_server()`: slider inputs shiny \n  module \n\n* `mod_text_input_ui()`/`mod_text_input_server()`: text input shiny module \n\n* `mod_points_plotly_ui()`/`mod_points_plotly_server()`: scatter-plot \n  (plotly) shiny module (UI)\n\n* `mod_table_ui()`/`mod_table_server()`: reactable table shiny module (UI) \n  that displays the data in the scatter-plot.\n\n* `db_con()`: database connection to `movies.db` (using `DBI::dbConnect()`,\n  `RSQLite::SQLite()` and `system.file()`)\n\n* `join_movies_tbls()`: joins the `omdb` and `tomatoes` tables from an SQLite\n  database connection, filters out movies with fewer than 5 reviews, and \n  selects relevant columns.\n\n* `scatter_plotly()`: generates an interactive Plotly scatter plot using a \nreactive dataset. The user specifies the x-axis, y-axis, and a categorical \nvariable for coloring the points.\n\nAn abstract syntax tree for the functions is below for reference:\n\n\\`\\`\\`\n█─launch_db_app \n├─█─db_app_ui \n│ ├─█─mod_select_input_ui \n│ ├─█─mod_slider_input_ui \n│ ├─█─mod_text_input_ui \n│ ├─█─mod_points_plotly_ui \n│ └─█─mod_table_ui \n└─█─db_app_server \n  ├─█─db_con \n  │ └─█─join_movies_tbls \n  ├─█─mod_slider_input_server \n  ├─█─mod_select_input_server \n  ├─█─mod_text_input_server \n  ├─█─mod_table_server \n  └─█─mod_points_plotly_server \n    └─█─scatter_plotly \n\\`\\`\\`\n\nInclude roxygen2 documentation for each function.\n\")\n\n\n\n\n\n\n\n27.2.4.1 Response 3: overhaul\nView the results in the callout box below (or in the Response section on GitHub).\n\n\n\n\n\n\nResponse text 3\n\n\n\n\n\nExpand the code chunks below to view the entire response.\n\nBelow is an example folder structure and skeleton code that follows your specifications. Each function has roxygen2 documentation, and the code follows the tidyverse style guide conventions (80-character line limit, snake_case naming, clear function naming, etc.). Adjust the code to meet your specific data and logic requirements.\n\n\nshow/hide R/launch_db_app.R\n#' Launch DB app\n#'\n#' This function launches the Shiny application for exploring the\n#' \"movies.db\" dataset.\n#'\n#' @return A Shiny app object.\n#' @export\nlaunch_db_app &lt;- function() {\n  shiny::shinyApp(\n    ui    = db_app_ui(),\n    server = db_app_server()\n  )\n}\n\n\n\n\nshow/hide R/db_app_ui.R\n#' Define the User Interface for the Shiny Application\n#'\n#' This function constructs the UI layout of the Shiny application, including\n#' input filters, slider controls, and movie selection elements.\n#'\n#' @return A `shiny.tag.list` object representing the application UI.\n#'\n#' @export\n#'\ndb_app_ui &lt;- function() {\n  tagList(\n    bslib::page_navbar(\n      title = \"Movies Explorer\",\n      id = \"nav\",\n      sidebar = bslib::sidebar(\n        conditionalPanel(\n          \"input.nav === 'Filters'\",\n          h4(\"Filters\"),\n          mod_select_input_ui(\"selects\"),\n          mod_slider_input_ui(\"sliders\")\n        ),\n        conditionalPanel(\n          \"input.nav === 'Director and Cast'\",\n          h4(\"Director and Cast\"),\n          mod_text_input_ui(\"text\")\n        )\n      ),\n      bslib::nav_panel(\"Filters\",\n        bslib::card(\n          mod_points_plotly_ui('plotly'),\n          bslib::card_footer(\n              em(\n                paste0(\n                  \"Note: The Tomato Meter is the proportion of positive reviews\",\n                  \" (as judged by the Rotten Tomatoes staff), and the Numeric rating is\",\n                  \" a normalized 1-10 score of those reviews which have star ratings\",\n                  \" (for example, 3 out of 4 stars).\"\n                )\n              )\n          )\n        )\n      ),\n      bslib::nav_panel(\"Director and Cast\",\n        bslib::card(\n          mod_table_display_ui(\"filters\"),\n          bslib::card_header(\"Movies selected:\"),\n          verbatimTextOutput(\"vals\")\n        )\n      )\n    )\n  )\n}\n\n\n\n\nshow/hide R/db_app_server.R\n#' Define the Server Logic for the Shiny Application\n#'\n#' This function sets up server-side logic, including reactive movie data,\n#' input modules, and filtering operations. It initializes reactive expressions\n#' for user input and manages interactions between different UI components.\n#'\n#' @param input,output,session Standard Shiny server function arguments.\n#'\n#' @return A `shiny.server` function handling user inputs and outputs.\n#' \n#' @export\n#'\ndb_app_server &lt;- function(input, output, session, .dev = FALSE) {\n\n  all_movies &lt;- reactive({\n    con &lt;- db_con(\"sap\", \"movies.db\")\n    all_movies &lt;- join_movies_tbls(con = con)\n    return(all_movies)\n    DBI::dbDisconnect(con) # close connection\n  })\n\n    nums &lt;- mod_slider_input_server(\"sliders\")\n\n    vars &lt;- mod_select_input_server('selects')\n\n    txts &lt;- mod_text_input_server('text')\n\n    filtered_movies &lt;- mod_table_display_server(\n      id = \"filters\",\n      movies = all_movies,\n      var = vars,\n      num = nums,\n      txt = txts)\n\n    mod_points_plotly_server(\n      id = 'plotly',\n      data = filtered_movies,\n      vars = vars)\n\n    if (.dev) {\n      output$vals &lt;- renderPrint({\n        vals &lt;- reactiveValuesToList(x = input, all.names = TRUE)\n        print(str(vals))\n      })\n    }\n\n\n}\n\n\n\n\nshow/hide R/mod_select_input.R\n#' select inputs shiny module (UI)\n#'\n#' @param id shiny module id\n#'\n#' @export\n#' \nmod_select_input_ui &lt;- function(id) {\n\n    # Variables that can be put on the x and y axes\n    axis_vars &lt;- c(\n      \"Tomato Meter\" = \"meter\",\n      \"Numeric Rating (OMDB)\" = \"omdb_ratings\",\n      \"Numeric Rating (RT)\" = \"rt_ratings\",\n      \"Number of reviews\" = \"reviews\",\n      \"Dollars at box office\" = \"box_office\",\n      \"Year\" = \"year\",\n      \"Length (minutes)\" = \"runtime\"\n    )\n    ns &lt;- shiny::NS(id)\n        shiny::tagList(\n        selectInput(\n          inputId = ns(\"genre\"),\n          label = strong(\"Genre*\"),\n          c(\"All\",\n            \"Action\",\n            \"Adventure\",\n            \"Animation\",\n            \"Biography\",\n            \"Comedy\",\n            \"Crime\",\n            \"Documentary\",\n            \"Drama\",\n            \"Family\",\n            \"Fantasy\",\n            \"History\",\n            \"Horror\",\n            \"Music\",\n            \"Musical\",\n            \"Mystery\",\n            \"Romance\",\n            \"Sci-Fi\",\n            \"Short\",\n            \"Sport\",\n            \"Thriller\",\n            \"War\",\n            \"Western\")),\n        tags$small(em(\"*a movie can have multiple genres\")),\n        selectInput(inputId = ns(\"xvar\"),\n          label = strong(\"X-axis variable\"),\n          axis_vars,\n          selected = \"meter\"),\n        selectInput(inputId = ns(\"yvar\"),\n          label = strong(\"Y-axis variable\"),\n          choices = axis_vars,\n          selected = \"runtime\")\n        )\n    }\n#' select inputs shiny module (server)\n#'\n#' @param id shiny module id\n#'\n#' @export\n#' \nmod_select_input_server &lt;- function(id) {\n    shiny::moduleServer(id, function(input, output, session) {\n        ns &lt;- session$ns\n      return(\n        reactive(\n          list(\n          'yvar' = input$yvar,\n          'xvar' = input$xvar,\n          'genre' = input$genre\n          )\n        )\n      )\n\n    })\n}\n\n\n\n\nshow/hide R/mod_slider_input.R\n#' slider inputs shiny module (UI)\n#'\n#' @param id shiny module id\n#'\n#' @export\n#' \nmod_slider_input_ui &lt;- function(id) {\n    ns &lt;- shiny::NS(id)\n        shiny::tagList(\n        sliderInput(\n          inputId = ns(\"reviews\"),\n          label = strong(\"Number of Rotten Tomatoes reviews\"),\n          min = 20,\n          max = 300,\n          value = 100,\n          step = 20\n        ),\n        sliderInput(\n          inputId = ns(\"year\"),\n          label = strong(\"Release year\"),\n          min = 1940,\n          max = 2014,\n          value = c(1970, 2014),\n          sep = \"\"\n        ),\n        sliderInput(\n          inputId = ns(\"oscars\"),\n          label = strong(\"Number of Oscar wins\"),\n          min = 0,\n          max = 4,\n          value = 0,\n          step = 1\n        ),\n        sliderInput(\n          inputId = ns(\"boxoffice\"),\n          label = strong(\"Dollars at Box Office*\"),\n          min = 0,\n          max = 800,\n          value = c(0, 500),\n          step = 1\n        ),\n        tags$small(\n          em('*In millions')\n          )\n      )\n    }\n#' slider inputs shiny module (server)\n#'\n#' @param id shiny module id\n#'\n#' @export\n#' \nmod_slider_input_server &lt;- function(id) {\n    shiny::moduleServer(id, function(input, output, session) {\n        ns &lt;- session$ns\n\n      # Due to dplyr issue #318, we need temp variables for input values\n      return(\n        reactive(\n          list(\n          'reviews' = input$reviews,\n          'oscars' = input$oscars,\n          'minyear' = input$year[1],\n          'maxyear' = input$year[2],\n          'minboxoffice' = input$boxoffice[1] * 1e6,\n          'maxboxoffice' = input$boxoffice[2] * 1e6\n          )\n        )\n      )\n\n    })\n}\n\n\n\n\nshow/hide R/mod_text_input.R\n#' text input shiny module (UI)\n#'\n#' @param id shiny module id\n#'\n#' @export\n#' \nmod_text_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    textInput(\n      inputId = ns(\"director\"),\n      label = \"Director name contains (e.g., Miyazaki)\"),\n    textInput(\n      inputId = ns(\"cast\"),\n      label = \"Cast names contains (e.g. Tom Hanks)\")\n    )\n}\n#' text input shiny module (server)\n#'\n#' @param id shiny module id\n#'\n#' @export\n#' \nmod_text_input_server &lt;- function(id) {\n  shiny::moduleServer(id, function(input, output, session) {\n    ns &lt;- session$ns\n      return(\n        reactive(\n          list(\n          'director' = input$director,\n          'cast' = input$cast\n          )\n        )\n      )\n  })\n}\n\n\n\n\nshow/hide R/mod_points_plotly.R\n#' Scatter-plot (plotly) shiny module (UI)\n#'\n#' @param id shiny module id\n#'\n#' @export\n#' \nmod_points_plotly_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n    shiny::tagList(\n      plotly::plotlyOutput(ns(\"graph\"))\n    )\n  }\n#' Scatter-plot (plotly) shiny module (server)\n#'\n#' @param id shiny module id\n#' \n#' @export\n#' \nmod_points_plotly_server &lt;- function(id, data, vars) {\n  shiny::moduleServer(id, function(input, output, session) {\n    ns &lt;- session$ns\n\n      output$graph &lt;- plotly::renderPlotly({\n         xvar &lt;- vars()[['xvar']]\n         yvar &lt;- vars()[['yvar']]\n         df &lt;- data()[[1]]\n        scatter_plotly(\n          data = df,\n          xvar = xvar,\n          yvar = yvar,\n          colvar =  'has_oscar')\n      })\n\n  })\n}\n\n\n\n\nshow/hide R/mod_table.R\n#' Reactable table shiny module (UI)\n#'\n#' @param id shiny module id\n#'\n#' @export\n#' \nmod_table_display_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    reactable::reactableOutput(ns(\"tbl\"))\n  )\n}\n#' Reactable table shiny module (server)\n#'\n#' @param id shiny module id\n#' @param movies movies connection\n#' @param num slider inputs\n#' @param var variable inputs\n#' @param txt text inputs\n#'\n#' @export\n#' \nmod_table_display_server &lt;- function(id, movies, num, var, txt) {\n  shiny::moduleServer(id, function(input, output, session) {\n    ns &lt;- session$ns\n\n    # observe({\n    #   browser()\n\n    filtered_nums &lt;- reactive({\n      dplyr::filter(local(movies()),\n        reviews &gt;= !!num()[[\"reviews\"]],\n        oscars &gt;= !!num()[[\"oscars\"]],\n        year &gt;= !!num()[[\"minyear\"]],\n        year &lt;= !!num()[[\"maxyear\"]],\n        box_office &gt;= !!num()[[\"minboxoffice\"]],\n        box_office &lt;= !!num()[[\"maxboxoffice\"]]\n      ) |&gt;\n        dplyr::arrange(oscars) |&gt;\n        dplyr::collect()\n    }) |&gt;\n      # update when slider inputs change\n      bindEvent(movies(), num())\n\n    filtered_vars &lt;- reactive({\n      # Optional: filters\n      if (!!var()[[\"genre\"]] != \"All\") {\n        filter_regex &lt;- paste0(var()[[\"genre\"]], \"|\", var()[[\"genre\"]], \",\")\n        filtered &lt;- dplyr::filter(filtered_nums(),\n                          stringr::str_detect(string = genre, filter_regex))\n      } else {\n        filtered &lt;- filtered_nums()\n      }\n      return(filtered)\n    }) |&gt;\n      # update when slider or select inputs change\n      bindEvent(movies(), num(), var())\n\n    filtered_txts &lt;- reactive({\n      # first condition on both text inputs being filled\n      if (!is.null(txt()[[\"cast\"]]) && !!txt()[[\"cast\"]] != \"\" & !is.null(txt()[[\"director\"]]) && !!txt()[[\"director\"]] != \"\") {\n        dir_regex &lt;- txt()[[\"director\"]]\n        cast_regex &lt;- txt()[[\"cast\"]]\n        filtered &lt;- dplyr::filter(filtered_vars(),\n                  stringr::str_detect(string = cast, cast_regex),\n                  stringr::str_detect(string = director, dir_regex))\n      # now only director\n      } else if (!is.null(txt()[[\"director\"]]) && !!txt()[[\"director\"]] != \"\") {\n        filter_regex &lt;- txt()[[\"director\"]]\n        filtered &lt;- dplyr::filter(filtered_vars(),\n                          stringr::str_detect(string = director, filter_regex))\n        # only cast\n      } else if (!is.null(txt()[[\"cast\"]]) && !!txt()[[\"cast\"]] != \"\") {\n        filter_regex &lt;- txt()[[\"cast\"]]\n        filtered &lt;- dplyr::filter(filtered_vars(),\n                          stringr::str_detect(string = cast, filter_regex))\n        # neither\n      } else {\n        filtered &lt;- filtered_vars()\n      }\n        # Add column which says whether the movie won any Oscars\n        # Be a little careful in case we have a zero-row data frame\n        filtered$has_oscar &lt;- character(nrow(filtered))\n        filtered$has_oscar[filtered$oscars == 0] &lt;- \"No\"\n        filtered$has_oscar[filtered$oscars &gt;= 1] &lt;- \"Yes\"\n        return(filtered)\n    }) |&gt;\n      # update when slider, select, or text inputs change\n      bindEvent(movies(), num(), var(), txt())\n\n    observe({\n      output$tbl &lt;- reactable::renderReactable({\n\n        reactable::reactable(\n          dplyr::select(\n            filtered_txts(),\n            title, genre, reviews, oscars, has_oscar,\n            year, box_office, director, cast,\n            # include text values for x and y\n            dplyr::all_of(c(var()[[\"yvar\"]], var()[[\"xvar\"]]))\n            )\n          )\n      })\n    }) |&gt;\n      bindEvent(movies(), num(), var(), txt())\n\n    return(\n      reactive(\n        list(\n          # return with text values for x and y\n          dplyr::select(\n            filtered_txts(),\n            title, genre, reviews, oscars, has_oscar,\n            year, box_office, director, cast,\n            dplyr::all_of(c(var()[[\"yvar\"]], var()[[\"xvar\"]]))\n          )\n        )\n      )\n    )\n\n  })\n}\n\n\n\n\nshow/hide R/db_con.R\n#' Establish a Database Connection\n#'\n#' This function connects to an SQLite database within an R package's\n#'  `extdata` directory.\n#'\n#' @param pkg A character string specifying the name of the R package where\n#' the database file is located.\n#' @param db A character string specifying the name of the SQLite database\n#' file (e.g., `\"movies.db\"`).\n#'\n#' @return A `DBIConnection` object representing the connection to the database.\n#'\n#' @export\n#'\ndb_con &lt;- function(pkg, db) {\n  # Set up handles to database tables on app start\n  con &lt;- DBI::dbConnect(RSQLite::SQLite(),\n                      system.file(\"extdata\", db, package = pkg))\n}\n\n\n\n\nshow/hide R/join_movies_tbls.R\n#' Join and Filter Movie Tables\n#'\n#' This function joins the `omdb` and `tomatoes` tables from an SQLite database\n#' connection, filters out movies with fewer than 5 reviews, and selects\n#' relevant columns.\n#'\n#' @param con A `DBIConnection` object representing the connection to the SQLite\n#' database.\n#' @param collect A logical value indicating whether to retrieve the results\n#' into a local `data.frame`. If `FALSE` (default), returns a lazy `tbl` for\n#' efficient database queries.\n#'\n#' @return A `tbl` object if `collect = FALSE`, or a `data.frame`\n#' if `collect = TRUE`.\n#'\n#' @export\n#' \njoin_movies_tbls &lt;- function(con, collect = FALSE) {\n\n  # create connection to both data tables\n  omdb &lt;- dplyr::tbl(con, \"omdb\")\n  tomatoes &lt;- dplyr::tbl(con, \"tomatoes\")\n\n  # join tables, filtering out those with &lt;5 reviews, and select specified columns\n  all_movies &lt;- dplyr::inner_join(x = omdb, y = tomatoes,\n                                  by = \"ID\") |&gt;\n  dplyr::filter(Reviews &gt;= 5) |&gt;\n  dplyr::select(id = ID,\n    imdb_id = imdbID,\n    title = Title,\n    year = Year,\n    omdb_ratings = Rating.x,\n    rt_ratings = Rating.y,\n    omdb_last_updated = lastUpdated.x,\n    rt_last_updated = lastUpdated.y,\n    runtime = Runtime,\n    genre = Genre,\n    released = Released,\n    director = Director,\n    writer = Writer,\n    imdb_rating = imdbRating,\n    imdb_votes = imdbVotes,\n    language = Language,\n    country = Country,\n    oscars = Oscars,\n    meter = Meter,\n    reviews = Reviews,\n    fresh = Fresh,\n    rotten = Rotten,\n    user_meter = userMeter,\n    user_rating = userRating,\n    user_reviews = userReviews,\n    box_office = BoxOffice,\n    production = Production,\n    cast = Cast\n  )\n  if (collect) {\n    return(\n      dplyr::collect(all_movies)\n    )\n  } else {\n    return(\n      all_movies\n    )\n  }\n\n}\n\n\n\n\nshow/hide R/scatter_plotly.R\n#' Create a Plotly Scatter Plot\n#'\n#' The `scatter_plotly()` function generates an interactive Plotly\n#' scatter plot using a reactive dataset.\n#' The user specifies the x-axis, y-axis, and a categorical variable for\n#' coloring the points.\n#'\n#' @param data A reactive expression that returns a `tibble` or `data.frame`\n#' containing the data.\n#' @param xvar A reactive expression specifying the column name for the x-axis\n#' variable.\n#' @param yvar A reactive expression specifying the column name for the y-axis\n#' variable.\n#' @param colvar A character string specifying the column name for the\n#' categorical variable used for coloring points.\n#'\n#' @return A `plotly` object representing the scatter plot.\n#'\n#' @export\n#'\nscatter_plotly &lt;- function(data, xvar, yvar, colvar) {\n\n  # check column names exist\n  if (!all(c(xvar, yvar, colvar) %in% names(data))) {\n    stop(\"One or more specified columns do not exist in the dataset.\")\n  }\n\n  # convert to factor (for consistent coloring)\n  data[[colvar]] &lt;- as.factor(data[[colvar]])\n\n  plotly::plot_ly(\n    data = data,\n    x = ~ .data[[xvar]],\n    y = ~ .data[[yvar]],\n    color = ~ .data[[colvar]],\n    type = 'scatter',\n    mode = 'markers',\n    marker = list(size = 8, opacity = 0.6)\n  ) |&gt;\n    plotly::layout(\n      title = tools::toTitleCase(paste(\"Scatter Plot of\", xvar, \"vs\", yvar)),\n      xaxis = list(title = tools::toTitleCase(xvar)),\n      yaxis = list(title = tools::toTitleCase(yvar)),\n      legend = list(title = list(text = colvar))\n    )\n}\n\n\nUsage\n\nCreate an R package (or place these files in your Shiny app directory under R/).\nAdjust db_path in db_con() to point to your movies.db file.\nRun the following to launch the app:\n\nlibrary(mypackage)    \nlaunch_db_app()  \nYour Shiny application will start, displaying the UI with the select inputs, slider, text input, plotly scatter plot, and reactable table.\n\n\n\n\nWe’ll create these files in the R/ folder and add a shinydb folder to the inst/ directory. After making some minor adjustments to the module names, we can include this application to our launch_app() function.\n\n\nshow/hide updated launch_app()\nlaunch_app &lt;- function(app = NULL, options = list(), run = \"p\", ...) {\n  if (interactive()) {\n    display_type(run = run)\n  }\n\n  if (is.null(app)) {\n    app &lt;- \"movies\"\n  }\n\n  logr_msg(glue::glue(\"Launching app: {app}\"),\n    level = \"INFO\"\n  )\n\n  tryCatch(\n    {\n      if (app == \"bslib\") {\n        shinyApp(\n          ui = movies_ui(bslib = TRUE),\n          server = movies_server,\n          options = options\n        )\n      } else if (app == \"ggp2\") {\n        shinyAppDir(\n          appDir = system.file(\"tidy-movies\", package = \"sap\"),\n          options = options\n        )\n      } else if (app == \"quarto\") {\n        quarto::quarto_preview(\n          system.file(\"quarto\", \"index.qmd\", package = \"sap\"),\n          render = \"all\"\n        )\n      } else if (app == \"assist\") {\n        shinyAppDir(\n          appDir = system.file(\"shiny-assist/movies\", package = \"sap\"),\n          options = options\n        )\n      } else if (app == \"db\") {\n        shinyAppDir(\n          appDir = system.file(\"shinydb\", package = \"sap\"),\n          options = options\n        )\n      } else {\n        shinyApp(\n          ui = movies_ui(...),\n          server = movies_server,\n          options = options\n        )\n      }\n    },\n    error = function(e) {\n      logr_msg(glue::glue(\"FATAL: Application failed to launch. Reason: {e$message}\"),\n        level = \"FATAL\"\n      )\n\n      stop(\"Application launch failed. Check logs for details.\")\n    }\n  )\n}\n\n\nOur updated shinydb application is below:\n\nlaunch_app(app = 'db')\n\n\n\n\n\n\n\n\nshinydb app\n\n\nAs we can see, the sidebar is less crowded, and with the information we provided, the chat was able to figure out where each utility function should be placed.",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>ellmer</span>"
    ]
  },
  {
    "objectID": "ellmer.html#sec-ellmer-finishing-touches",
    "href": "ellmer.html#sec-ellmer-finishing-touches",
    "title": "27  ellmer",
    "section": "27.3 Finishing touches",
    "text": "27.3 Finishing touches\nFrom here, we can continue using ellmer or ensure (see Section 16.1) to write unit tests for these new functions. We should also make sure any new dependencies are properly managed (i.e., using attachment::att_amend_desc())\n\nattachment::att_amend_desc()\n\nUpdating sap documentation\nWriting NAMESPACE\nℹ Loading sap\n[+] 5 package(s) added: DBI, dplyr, plotly, reactable, RSQLite.",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>ellmer</span>"
    ]
  },
  {
    "objectID": "ellmer.html#recap",
    "href": "ellmer.html#recap",
    "title": "27  ellmer",
    "section": "Recap",
    "text": "Recap\nThe ellmer package simplifies using LLMs, making it easier to include them as a tool in regular app/package development. Storing prompts ensures your project is well documented (especially when converting back to previous versions).",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>ellmer</span>"
    ]
  },
  {
    "objectID": "ellmer.html#footnotes",
    "href": "ellmer.html#footnotes",
    "title": "27  ellmer",
    "section": "",
    "text": "Edit this file using the usethis::edit_r_environ() function.↩︎\nThe chat_openai() documentation recommends “explicitly choosing a model for all but the most casual use.”↩︎\n“If you have multiple prompts, give them informative names like prompt-extract-metadata.md or prompt-summarize-text.md. If you’re writing a package, put your prompt(s) in inst/prompts” - ellmer documentation↩︎\nUse system_prompts to ‘provide additional instructions to the model, shaping its responses to your needs’ - What is a prompt? ellmer documentation↩︎\nMarkdown is “quite readable to LLMs (and humans), and it allows you to do things like use headers to divide up a prompt into sections and itemised lists to enumerate multiple options.” Best Practices, ellmer documentation↩︎\nThe inst/extdata folder is covered in R Packages, 2nd ed.↩︎",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>ellmer</span>"
    ]
  },
  {
    "objectID": "chores.html",
    "href": "chores.html",
    "title": "28  chores",
    "section": "",
    "text": "28.1 Setting up chores\nThe chores package was developed by Simon Couch (who is also the author of the ensure and gander packages) to “help you complete repetitive, hard-to-automate tasks quickly”. We previously covered the ellmer package (see Chapter 27), which is required to configure your LLM of choice.\nusethis::edit_r_profile()\noptions(.chores_chat = ellmer::chat_openai(model = \"gpt-4o\"))",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>chores</span>"
    ]
  },
  {
    "objectID": "chores.html#sec-shiny-chores-setup",
    "href": "chores.html#sec-shiny-chores-setup",
    "title": "28  chores",
    "section": "",
    "text": "28.1.1 Using the add-in",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>chores</span>"
    ]
  },
  {
    "objectID": "gander.html",
    "href": "gander.html",
    "title": "29  gander",
    "section": "",
    "text": "We’re going to be using the Shiny application from the 2023 Shiny in production posit::conf() workshop.1 The application demonstrated in this workshop–brickapp–is an app-package with various versions in the Git branches (similar to the sap package). We’re going to be using a slightly modified version of the application stored in the profiledemo branch.2 brickapp was built using the golem framework (we’ll cover golem in Chapter 23), and a folder tree of it’s structure is below:\nI’ve chosen this example to illustrate the gander package because",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>gander</span>"
    ]
  },
  {
    "objectID": "gander.html#footnotes",
    "href": "gander.html#footnotes",
    "title": "29  gander",
    "section": "",
    "text": "The accompanying GitHub repo for the application.↩︎\nThe prediction modules/functionality has been removed from the version we’re using. If you’d like to see the full app, check the Github Repo.↩︎",
    "crumbs": [
      "Shiny Tools",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>gander</span>"
    ]
  },
  {
    "objectID": "special_topics.html",
    "href": "special_topics.html",
    "title": "Special topics",
    "section": "",
    "text": "App data\nThis section holds a collection of topics you might find useful when developing your app-package.\nIn App data, 32.1 reactiveValues() demonstrates how we can use reactiveValues() to store and retrieve reactive values from a ‘persistent’ object in our app. 32.1.5 Testing reactiveValues() also has examples of testing modules with values from a reactiveValues() object.\n32.2 session$userData gives an example of how to store persistent, non-reactive objects in your application (see also 9.2.1 A tidy-movies app).",
    "crumbs": [
      "Special topics"
    ]
  },
  {
    "objectID": "special_topics.html#stack-traces",
    "href": "special_topics.html#stack-traces",
    "title": "Special topics",
    "section": "Stack traces",
    "text": "Stack traces\nThe Stack traces chapter…",
    "crumbs": [
      "Special topics"
    ]
  },
  {
    "objectID": "special_topics.html#dependency-hell",
    "href": "special_topics.html#dependency-hell",
    "title": "Special topics",
    "section": "Dependency hell",
    "text": "Dependency hell\nThe 33  Dependency hell chapter…\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Special topics"
    ]
  },
  {
    "objectID": "shiny_ui_edit.html",
    "href": "shiny_ui_edit.html",
    "title": "30  Shiny UI Editor",
    "section": "",
    "text": "WARNING\n\n\n\n\n\n\nThis chapter is being developed. Thank you for your patience.",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Shiny UI Editor</span>"
    ]
  },
  {
    "objectID": "code.html",
    "href": "code.html",
    "title": "31  Code style",
    "section": "",
    "text": "31.1 Code style and formatting\nDuring development, it can be challenging to keep the code in your app-package clean and perfectly formatted. Fortunately, the R ecosystem has some excellent tools for making your code functional and easy to read.\nThe lintr and styler packages in R serve related but distinct purposes and have different focuses in their functionality. The primary difference between lintr and styler is that styler can automatically fix any stylistic issues it identifies in your code (rather than just reporting them).",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Code style</span>"
    ]
  },
  {
    "objectID": "code.html#code-style-and-formatting",
    "href": "code.html#code-style-and-formatting",
    "title": "31  Code style",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('31_style')\n\n\n31.1.1 lintr\nlintr is a static code analysis tool used to identify syntax errors, semantic issues, and violations of stylistic guidelines in your code. The package contains a list of ‘linters’ for various potential problems and can be customized according to your needs. lintr is designed to help improve your code’s quality and readability by generating reports in the ‘markers’ pane. Running lintr won’t automatically correct the identified issues (you’ll need to fix the linting issues it reports manually).\n\n\n31.1.2 styler\nOn the other hand, the purpose of styler is to ensure consistency in the code formatting, which is crucial if you’re working in a team or contributing to open-source projects (like tidyverse packages). The styler package will change your code’s format according to specified style guidelines. These changes include indentation, spaces, and line breaks that adhere to your style guidelines.\nWhile there is some overlap (both packages can help enforce coding style guidelines), lintr is a more general tool for code quality, spotting potential issues and bugs. At the same time, styler focuses on code formatting and can automatically apply fixes. Many developers find combining both can help catch potential issues and ensure a consistent, readable coding style.",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Code style</span>"
    ]
  },
  {
    "objectID": "code.html#checking-your-code",
    "href": "code.html#checking-your-code",
    "title": "31  Code style",
    "section": "31.2 Checking your code",
    "text": "31.2 Checking your code\nI’ve previously mentioned running devtools::check() can be overkill for your app-package (especially if it’s not destined for CRAN). A nice alternative to check() is the goodpractice package..\ngoodpractice::gp() inspects your package and prints any areas that might need ‘good practice’ advice:\n\nlibrary(goodpractice)\npkg_checks &lt;- gp(path = \".\")\npkg_checks\n\nPreparing: description\nPreparing: lintr\n  |====================================================================| 100%\nPreparing: namespace\nPreparing: rcmdcheck\n── GP sap ───────────────────────────────────────────────────────\n\nIt is good practice to\n\n  ✖ add a \"URL\" field to DESCRIPTION. It helps users find information about your\n    package online. If your package does not have a homepage, add an URL to \n    GitHub, or the CRAN package package page.\n  ✖ add a \"BugReports\" field to DESCRIPTION, and point it to a bug tracker. \n    Many online code hosting services provide bug trackers for free, \n    https://github.com, https://gitlab.com, etc.\n  ✖ avoid long code lines, it is bad for readability. Also, many people prefer \n    editor windows that are about 80 characters wide. Try make your lines \n    shorter than 80 characters\n\n    data-raw/tidy_movies.R:49:81\n    R/data.R:4:81\n    R/data.R:7:81\n    R/data.R:17:81\n    R/data.R:21:81\n    ... and 13 more lines\n\n  ✖ not import packages as a whole, as this can cause name clashes between the \n    imported packages. Instead, import only the specific functions you need.\n  ✖ fix this R CMD check NOTE: display_type: no visible binding for global \n    variable\n    ‘.rs.invokeShinyPaneViewer’ display_type: no visible binding for global \n    variable\n    ‘.rs.invokeShinyWindowExternal’ display_type: no visible binding for global\n    variable\n    ‘.rs.invokeShinyWindowViewer’ mod_scatter_display_server : &lt;anonymous&gt;: no \n    visible binding for global\n    variable ‘movies’ Undefined global functions or variables: \n    .rs.invokeShinyPaneViewer \n    .rs.invokeShinyWindowExternal \n    .rs.invokeShinyWindowViewer \n    movies\nWe can also check specific components of our package by looking up the available checks in all_checks():\n\ngrep(\"import\", x = all_checks(), value = TRUE)\n\n\n[1] \"no_import_package_as_a_whole\"                 \n[2] \"rcmdcheck_undeclared_imports\"                 \n[3] \"rcmdcheck_imports_not_imported_from\"          \n[4] \"rcmdcheck_depends_not_imported_from\"          \n[5] \"rcmdcheck_triple_colon_imported_objects_exist\"\n[6] \"rcmdcheck_unexported_base_objects_imported\"   \n[7] \"rcmdcheck_unexported_objects_imported\"        \n[8] \"rcmdcheck_empty_importfrom_in_namespace\"  \n\nAll of the checks with the rcmdcheck_ prefix are part of the R CMD check diagnostic, but goodpractice comes with other checks that are good practices (even if you’re not submitting your package to CRAN).\nFor example, no_import_package_as_a_whole checks the practice we covered in managing imports. If we pass the no_import_package_as_a_whole check as a character vector to the checks argument:\n\ngp(path = \".\", checks = 'no_import_package_as_a_whole')\n\nOnly this check is performed:\n\n── GP sap ───────────────────────────────────────────────────\n\nIt is good practice to\n\n  ✖ not import packages as a whole, as this can cause name clashes between\n    the imported packages. Instead, import only the specific functions you need.\n\n───────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Code style</span>"
    ]
  },
  {
    "objectID": "code.html#recap",
    "href": "code.html#recap",
    "title": "31  Code style",
    "section": "31.3 Recap",
    "text": "31.3 Recap\nThis chapter covered an introduction to some tools and practices for improving and maintaining the quality of the code in your app-package. Maintaining code style and standards (lintr and styler) and performing thorough checks to adhere to best practices (goodpractice) will ensure efficient and reliable development and deployment for your app.\n\n\n\n\n\n\nCode style recap\n\n\n\n\n\n\nThis chapter covered:\nCode Linting and Styling:\n\nlintr is used for checking the code for potential errors and style issues\n\nCan help in identifying syntactical and stylistic problems that might lead to code inefficiency or errors\nLinters are instrumental in enforcing coding standards and ensuring consistency across the codebase\n\nstyler is used to automatically style the R code in your app-package\n\nstyler will format R code according to specified style guidelines, ensuring that the code is not only consistent in its look but also adheres to best practices\nAutomating styling can save time and reduces manual effort in code formatting\n\n\nManaging Dependencies:\n\nThe attachment package helps in managing these dependencies by automatically listing and updating the packages used in your app-package\n\natt_amend_desc scans the code and identifies all package dependencies\nmanaging dependencies ensures reproducibility and ease of package installation\n\ndesc assists in handling the DESCRIPTION file in your app-package\n\nprovides tools for reading, writing, and modifying the DESCRIPTION files\n\n\nCode Checks:\n\ngoodpractice is designed to help ensure best practices in R coding and package development are adhered to in your app-package\n\ngoodpractice::gp() performs a comprehensive analysis of the code (beyond devtools::check()) and checks for various potential issues like code complexity, redundancy, adherence to coding standards, etc\nOffers suggestions for improvements, making it a helpful tool for quality assurance in package development",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Code style</span>"
    ]
  },
  {
    "objectID": "app_data.html",
    "href": "app_data.html",
    "title": "32  App data",
    "section": "",
    "text": "32.1 reactiveValues()\nThis chapter covers using session$userData vs. reactiveValues() in an application to store values and objects. Whether to use session$userData or reactiveValues() will depend on the purpose you want them to serve (and what you want to store/access) in your application.\nCalling reactiveValues() creates “an object for storing reactive values.” We’ve been storing the reactive values returned from the var_input module in the selected_vars object, then passing these values into the scatter_display module. 1\nmovies_server &lt;- function(input, output, session) {\n\n1      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n2      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\n1\n\nreactive values returned from var_input module\n\n\n2\n\nreactive values passed to scatter_display module\nIn the steps below we’ll walk through an example of using reactiveValues() to capture the selected_vars values returned from the var_input module and passed to the scatter_display module.\nYou should note a series of changes made to movies_server() in this branch:\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n1    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n2    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = FALSE)\n    \n    # view output in the UI\n3    output$vals &lt;- renderPrint({\n\n    })\n\n    # pass reactive values to display\n4    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nNew reactiveValues() object\n\n\n2\n\nReturned values from mod_var_input_server() assigned to rVals$inputs\n\n\n3\n\nrenderPrint() for displaying reactive values in UI\n\n\n4\n\nrVals object passed to mod_scatter_display_server()\nIn the steps below, we’ll view the structure and function of rVals and the reactive values in the application using methods covered in the Debug section.",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "app_data.html#sec-reactiveValues",
    "href": "app_data.html#sec-reactiveValues",
    "title": "32  App data",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('26.1.0_reactive-values')\n\n\n\n\n\n\nreactiveValues() is used to create rVals\nInstead of creating the selected_vars, the output from mod_var_input_server() is assigned to rVals as inputs\nrVals is then passed as an input argument to mod_scatter_display_server()\n.dev arguments have been added to both module server functions (and have been set to FALSE)\n\n\n\n\n32.1.1 Step 1\nIn movies_server(), the .dev in mod_var_input_server() is set to TRUE (the updated movies_server() function is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.1.1_step_01')\n\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n\n    # pass reactive values to display\n    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\n.dev has been set to TRUE\n\n\n\n\nWhen we load the package and run the application, we see the following:2\n\n\n\n\n\n\n\n\n\n\n(a) .dev = TRUE in mod_var_input_server()\n\n\n\n\n\nFigure 32.1: reactive values from mod_var_input_server()\n\n\n\n\nThe output in the sidebar are the reactive values from the variable input module (mod_var_input_server()). The server function has been simplified to return the output from reactiveValuesToList(), and the output is being rendered in the sidebar when .dev is set to TRUE:\n\nmod_var_input_server &lt;- function(id, .dev = TRUE) {\n\n  moduleServer(id, function(input, output, session) {\n    \n    if (.dev) {\n      # view output in the UI\n      output$vals &lt;- renderPrint({\n        x &lt;- reactiveValuesToList(input, all.names = TRUE)\n        str(x)\n      })\n    }\n    \n    # return reactives\n    return(\n      reactive({\n        reactiveValuesToList(input, all.names = TRUE)\n      })\n    )\n\n  })\n}\n\n\n\n32.1.2 Step 2\nThe renderPrint() in movies_server() displays the structure of rVals in the mainPanel() (the updated movies_server() function is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.1.2_step_02')\n\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n2    output$vals &lt;- renderPrint({\n      str(rVals)\n    })\n\n    # pass reactive values to display\n    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n2\n\nDisplay output from str(rVals)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) str(rVals)from movies_server()\n\n\n\n\n\nFigure 32.2: rVals$inputs() from movies_server()\n\n\n\n\n\n32.1.2.1 What is reactiveValues()?\n\n“When you read a value from it, the calling reactive expression takes a reactive dependency on that value, and when you write to it, it notifies any reactive functions that depend on that value. Note that values taken from the reactiveValues() object are reactive, but the reactiveValues() object itself is not.” Shiny Documentation\n\nI’ve added emphasis to the quote above because it’s important to remember that any object assign to reactiveValue() should be treated like any reactive object (i.e., and inputId or object returned from reactive() or observe()).3\nFor example, if we try to access the input values as a list outside movies_server() or the module server function, we see the following error:4\n\nx &lt;- reactiveValues(\n  inputs = list(x = \"imdb_rating\",\n                y = \"audience_score\",\n                z = \"mpaa_rating\",\n                alpha = 0.5,\n                size = 2,\n                plot_title = \"Enter Plot Title\")\n  )\nx$inputs()\n\n\n## Error in `x$inputs`:\n## ! Can't access reactive value 'inputs' outside of reactive consumer.\n## ℹ Do you need to wrap inside reactive() or observe()?\n\n\n\n\n32.1.3 Step 3\nIn this branch, the renderPrint() displays the structure of rVals$inputs() (the updated movies_server() function is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.1.3_step_03')\n\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n2    output$vals &lt;- renderPrint({\n      str(rVals$inputs())\n    })\n\n    # pass reactive values to display\n    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n2\n\nDisplay str(rVals$inputs())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) str(rVals)from movies_server()\n\n\n\n\n\nFigure 32.3: rVals$inputs() from movies_server()\n\n\n\n\nThe rVals$inputs() being rendered in movies_server() are the returned values from the variable input module (and they’re identical to the values in the sidebar).\nWhen rVals is passed to mod_scatter_display_server(), the reactive inputs() object (passed inside the function) is built as rVals$inputs():\n\ninputs &lt;- reactive({\n  plot_title &lt;- tools::toTitleCase(rVals$inputs()[['plot_title']])\n    list(\n      x = rVals$inputs()[['x']],\n      y = rVals$inputs()[['y']],\n      z = rVals$inputs()[['z']],\n      alpha = rVals$inputs()[['alpha']],\n      size = rVals$inputs()[['size']],\n      plot_title = plot_title\n    )\n})\n\nThe mod_scatter_display_server() function will display the structure of rVals$inputs() if the .dev argument is set to TRUE:\n\n    if (.dev) {\n      # view output in the UI\n      output$display_vals &lt;- renderPrint({\n        str(\n          rVals$inputs()\n          )\n      })\n    }\n\n\n\n32.1.4 Step 4\nIn this final step, the .dev argument has been set to TRUE in the mod_scatter_display_server() (the updates movies_server() function is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.1.4_step_04')\n\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n2    output$vals &lt;- renderPrint({\n      rVals$inputs()\n    })\n\n    # pass reactive values to display\n3    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = TRUE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n\n2\n\nDisplay rVals$inputs()\n\n\n3\n\nSet .dev to TRUE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) .dev set to TRUE and reactive values from movies_server()\n\n\n\n\n\nFigure 32.4: Both module .dev arguments set to TRUE and rVals$inputs() from movies_server()\n\n\n\n\nThe display we’re seeing directly below the graph (i.e., under inputs() from display module) is the structure of rVals$inputs() from mod_scatter_display_server():\n\nif (.dev) {\n  # view output in the UI\n  output$display_vals &lt;- renderPrint({\n    str(\n      rVals$inputs()\n      )\n  })\n}\n\nAn important thing to note is that we can only reference rVals$inputs() in a reactive consumer (i.e., using reactive(), observe(), etc.). That’s why when we change any of the UI inputs, the values change in rVals$inputs() and in the inputs() object inside the display module.\nYou can also view these outputs using launch_app(run = 'b', bslib = TRUE).\n\n\n32.1.5 Testing reactiveValues()\nIf you decide to use reactiveValues() or session$userData, you’ll need to confirm these objects in your tests. The module tests for test-mod_scatter_display.R have been redesigned to handle the reactiveValues() input.5\nI’ll briefly summarize the changes below:\n\nargs = list() in testServer() now takes the output from helper functions (stored in tests/testthat/helper.R and R/testthat.R). 6\n\nmake_initial_rVals_inputs &lt;- function() {\n  rVals &lt;- reactiveValues(\n    inputs =\n      reactive(list(\n        x = \"imdb_rating\",\n        y = \"audience_score\",\n        z = \"mpaa_rating\",\n        alpha = 0.5,\n        size = 2,\n        plot_title = \"Enter Plot Title\"\n      ))\n  )\n  return(rVals)\n}\n\nThis creates a reaciveValues() list that can be used in the test:\n\nrVals &lt;- make_initial_rVals_inputs()\nrVals\n## &lt;ReactiveValues&gt; \n##   Values:    inputs \n##   Readonly:  FALSE\n\nWe can view it’s contents by wrapping it in isolate().\n\nisolate(rVals$inputs())\n## $x\n## [1] \"imdb_rating\"\n## \n## $y\n## [1] \"audience_score\"\n## \n## $z\n## [1] \"mpaa_rating\"\n## \n## $alpha\n## [1] 0.5\n## \n## $size\n## [1] 2\n## \n## $plot_title\n## [1] \"Enter Plot Title\"\n\nPassing make_initial_rVals_inputs() to the args in testServer() requires creating rVals (which can be referenced in the test as rVals$inputs():\n\n    shiny::testServer(app = mod_scatter_display_server,\n      args = list(rVals = make_initial_rVals_inputs()), expr = {\n        testthat::expect_equal(\n          object = rVals$inputs(),\n          expected = list(\n                x = \"imdb_rating\",\n                y = \"audience_score\",\n                z = \"mpaa_rating\",\n                alpha = 0.5,\n                size = 2,\n                plot_title = \"Enter Plot Title\"\n            )\n        )\n      })",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "app_data.html#sec-session-user-data",
    "href": "app_data.html#sec-session-user-data",
    "title": "32  App data",
    "section": "32.2 session$userData",
    "text": "32.2 session$userData\nObjects stored in session$userData are not inherently reactive, which makes it ideal for storing persistent values or data that don’t require (or trigger) reactivity. Below is a demonstration of using session$userData to store a non-reactive function to be used in the inst/tidy-data/ application.\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.2.0_user-data')\n\n\n32.2.0.1 Non-reactive objects\nObjects we want to pass inside the server (and modules) but don’t need to update or change are perfect for session$userData. The example we’ll use below is a function (make_dev_ggp2_movies()) that prepares the ggplot2movies::movies for the application:\n\n\nView make_dev_ggp2_movies() function\nmake_dev_ggp2_movies &lt;- function(con) {\n  movies_data &lt;- read.csv(file = con)\n  # specify genre columns\n  genre_cols &lt;- c(\n    \"Action\", \"Animation\",\n    \"Comedy\", \"Drama\",\n    \"Documentary\", \"Romance\",\n    \"Short\"\n  )\n  # calculate row sum for genres\n  movies_data$genre_count &lt;- rowSums(movies_data[, genre_cols])\n  # create aggregate 'genres' for multiple categories\n  movies_data$genres &lt;- apply(\n    X = movies_data[, genre_cols],\n    MARGIN = 1,\n    FUN = function(row) {\n      genres &lt;- names(row[row == 1])\n      if (length(genres) &gt; 0) {\n        return(paste(genres, collapse = \", \"))\n      } else {\n        return(NA)\n      }\n    }\n  )\n  # format variables\n  movies_data$genre_count &lt;- as.integer(movies_data$genre_count)\n  movies_data$genre &lt;- ifelse(test = movies_data$genre_count &gt; 1,\n    yes = \"Multiple genres\",\n    no = movies_data$genres\n  )\n  movies_data$genre &lt;- as.factor(movies_data$genre)\n  movies_data$mpaa &lt;- factor(movies_data$mpaa,\n    levels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"),\n    labels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\")\n  )\n\n  # reduce columns to only those in graph\n  movies_data[, c(\n    \"title\", \"year\", \"length\", \"budget\",\n    \"rating\", \"votes\", \"mpaa\", \"genre_count\",\n    \"genres\", \"genre\"\n  )]\n}\n\n\nmake_dev_ggp2_movies() is designed to take a path or URL (i.e., a connection) as an input and returns a dataset that can be used in the inst/tidy-data/ application.\nIn the inst/tidy-data/app.R file, the following changes have been made to devServer():\n\nsession$userData stores the contents of make_dev_ggp2_movies()\nreactiveValues() is used to create rVals 7\nThe values returned from mod_var_input_server() is assigned to rVals as inputs\ndev_mod_scatter_server() as been updated to include arguments for rVals, userData, con, and .dev\n\n\ndevServer &lt;- function(input, output, session) {\n  \n1  session$userData$make_dev_ggp2_movies &lt;- make_dev_ggp2_movies\n  \n2  rVals &lt;- reactiveValues()\n  \n3  rVals$inputs &lt;- sap::mod_var_input_server(\"vars\",\n                                                  .dev = TRUE)\n\n4  dev_mod_scatter_server(\"plot\",\n    rVals = rVals,\n    data_fun = session$userData$make_dev_ggp2_movies, \n    con = \"https://bit.ly/3FQYR8j\",\n    .dev = FALSE\n  )\n\n}\n\n\n1\n\nCreate userData$make_dev_ggp2_movies that holds make_dev_ggp2_movies()\n\n2\n\nCreate rVals\n\n3\n\nAssign output from mod_var_input_server() to rVals$inputs\n\n4\n\nUpdated dev_mod_scatter_server() function\n\n\n\n\nTo view what’s happening with session$userData, we’ll run the application using the Run App button at the top of app.R\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Initial app in dev/inst/app.R\n\n\n\n\n\nFigure 32.5: The reactive values from mod_var_input_server() in the sidebar\n\n\n\n\nWe’re using the same version of mod_var_input_server() from above that includes a .dev argument, so we know it’s displaying the contents from reactiveValuesToList() in the sidebar.\n\n\n32.2.1 Step 1\nIn devServer(), a renderPrint() call has been added to display the structure of session in the UI:\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.2.1_step_01')\n\n\ndevServer &lt;- function(input, output, session) {\n  \n  # add function to userData\n1  session$userData$make_dev_ggp2_movies &lt;- make_dev_ggp2_movies\n  \n  # create reactive values\n2  rVals &lt;- reactiveValues()\n  \n  # assign inputs to rVals\n3  rVals$inputs &lt;- sap::mod_var_input_server(\"vars\",\n                                                  .dev = TRUE)\n  \n  # view output in the UI\n4  output$vals &lt;- renderPrint({\n    str(session)\n  })\n\n5  dev_mod_scatter_server(\"plot\",\n    rVals = rVals,\n    data_fun = session$userData$make_dev_ggp2_movies, \n    con = \"https://bit.ly/3FQYR8j\",\n    .dev = FALSE\n  )\n  \n}\n\n\n1\n\nCreate userData$make_dev_ggp2_movies that holds make_dev_ggp2_movies()\n\n2\n\nCreate rVals\n\n3\n\nAssign output from mod_var_input_server() to rVals$inputs\n\n4\n\nPrint the structure of session to UI\n\n\n5\n\nUpdated dev_mod_scatter_server() function\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) str(session) dev/inst/app.R\n\n\n\n\n\nFigure 32.6: The str(session) from devServer()\n\n\n\n\n\n32.2.1.1 What is session?\nEach time the app launches, the session list is created and tied to that particular ’session.\n\n“An environment for app authors and module/package authors to store whatever session-specific data they want.” Shiny Documentation\n\nsession$userData can store objects that should persist across different reactive contexts, but don’t need reactive updating (and won’t trigger reactivity). On the other hand, reactiveValues() creates objects stored in a reactive ‘state’, which will trigger reactive updates in the UI.’8\ndev_mod_scatter_server() includes both reactiveValues() and session$userData. The arguments for rVals, data_fun, con, and .dev are described below:\n\nrVals is the reactiveValues() object with our input values\ndata_fun is session$userData$make_dev_ggp2_movies\ncon is the path or URL to the data_fun in session$userData 9\n\n\ndev_mod_scatter_server(\"plot\",\n  \n1  rVals = rVals,\n  \n2  data_fun = session$userData$make_dev_ggp2_movies,\n  \n3  con = \"https://bit.ly/3FQYR8j\",\n  \n4  .dev = FALSE)\n\n\n1\n\npass reactive values from reactiveValues()\n\n2\n\npass session$userData with make_dev_ggp2_movies()\n\n3\n\npass connection to non-reactive object\n\n\n4\n\nview userData value in module\n\n\n\n\nInside the display module (dev_mod_scatter_server()), the data_fun() function creates all_data with con:\n\n# use data_fun() function on con\nall_data &lt;- data_fun(con)\n\n\nThe inputs() list passed to the plotting function is very similar to the methods used in mod_scatter_display_server():\n\ninputs &lt;- reactive({\n  plot_title &lt;- tools::toTitleCase(rVals$inputs()[[\"plot_title\"]])\n  list(\n    x = rVals$inputs()[[\"x\"]],\n    y = rVals$inputs()[[\"y\"]],\n    z = rVals$inputs()[[\"z\"]],\n    alpha = rVals$inputs()[[\"alpha\"]],\n    size = rVals$inputs()[[\"size\"]],\n    plot_title = plot_title\n  )\n})\n\nThe structure of data_fun is be printed to the UI when the .dev argument is set to TRUE\n\n# view output in the UI\nif (.dev) {\n  # view output in the UI\n  output$data &lt;- renderPrint({\n    data_fun\n  })\n}\n\n\n\n\n\n32.2.2 Step 2\nChange .dev argument in dev_mod_scatter_server() to TRUE:\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.2.2_step_02')\n\n\n  dev_mod_scatter_server(\"plot\",\n    rVals = rVals,\n    data_fun = session$userData$make_dev_ggp2_movies, \n    con = \"https://bit.ly/3FQYR8j\",\n1    .dev = TRUE\n  )\n\n\n1\n\nChange to TRUE\n\n\n\n\nLoad (with load_all()) and the app by clicking on the Run App icon:\n\n\n\n\n\n\n\n\n\n\n(a) data_fun dev_mod_scatter_server()\n\n\n\n\n\nFigure 32.7: The data_fun argument from dev_mod_scatter_server() is not reactive\n\n\n\n\nWe can see data_fun() is passed to dev_mod_scatter_server() from devServer() and is not a reactive (it’s a standard function we can apply to app_data).\nTests are more difficult for modules using session$userData, because these values are created when a Shiny app object is created (and exist inside the reactive context). This point is covered in more detail in this blog post.\n\n“reusing objects passed through session violates module independence – there is code inside the module that uses external objects without stating them explicitly as server arguments.”",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "app_data.html#recap",
    "href": "app_data.html#recap",
    "title": "32  App data",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: reactiveValues() & session$userData\n\n\n\n\n\n\nsession$userData\n\nsession$userData is best used with values or objects that persist across actions or navigation inside the app (i.e., maintaining values or data across pages of a multi-page app). session$userData can react to changes, but we’d need to explicitly create these reactive expressions or observers.\n\nreactiveValues()\n\nAn object created with reactiveValues() is designed to be reactive, so changing values will trigger reactivity in any observers and/or reactives that depend on those values. Remember that ‘values taken from the reactiveValues() object are reactive, but the reactiveValues() object itself is not.’\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "app_data.html#footnotes",
    "href": "app_data.html#footnotes",
    "title": "32  App data",
    "section": "",
    "text": "Mastering Shiny also has a great section on reactiveVal() and reactiveValues()↩︎\nThe methods used in this chapter can be found in the section on Debug↩︎\nRead more in the Shiny documentation.↩︎\nWe can access the values by wrapping the assigned object in isolate(). Read more in the documentation on reactiveValues().↩︎\nYou can view the full test-mod_scatter_display.R test file in the 24.1.4_step_04 branch.↩︎\nI resorted to both locations because the tests/testthat/helper.R file wasn’t loading with devtools::load_all()↩︎\nWe’ll cover how reactiveValues() works in Section 32.1 below.↩︎\nNotice session has :Classes 'ShinySession', 'R6'↩︎\nIn this case, con is a URL for a .csv version of ggplot2movies::movies)↩︎",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "entanglement.html",
    "href": "entanglement.html",
    "title": "33  Dependency hell",
    "section": "",
    "text": "33.1 Exploring dependencies\nMastering dependency management\nThis chapter covers a few packages and tools to help explore, understand and keep track of your app-package dependencies.1 It’s not likely you’ll build an application that only relies on shiny, so it’s important to 1) know the packages and versions required for your application to function, and 2) ensure these packages are included in the correct DESCRIPTION field (or NAMESPACE).\nThe first package we’ll cover is pak, which is, “A Fresh Approach to R Package Installation.” pak includes two tools I’ve found to be incredibly helpful for understanding the dependencies in a given package (or a package I’m building): dependency trees and the dependency explainer.",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Dependency hell</span>"
    ]
  },
  {
    "objectID": "entanglement.html#exploring-dependencies",
    "href": "entanglement.html#exploring-dependencies",
    "title": "33  Dependency hell",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('28_dependency-hell')\n\n\n33.1.1 Trees\npak::pkg_deps_tree() shows us the dependencies for a particular package. To demonstrate how this function works, we’ll explore the dependencies in three packages:\n\nrlang: “Functions for Base Types and Core R and ‘Tidyverse’ Features”\nlifecycle: “Manage the Life Cycle of your Package Functions”, and\nvctrs: “Vector Helpers”\n\nLet’s start with the rlang package:\n\npak::pkg_deps_tree(\"rlang\")\n\nrlang 1.1.1 ✨\n\nKey:  ✨ new\nrlang is “a collection of frameworks and APIs for programming with R” and it’s built with only base R packages (that’s why it’s DESCRIPTION file only Imports the utils package):\nImports:\n    utils\nNow lets look at lifecycle:\n\npak::pkg_deps_tree(pkg = \"lifecycle\")\n\nlifecycle 1.0.3 ✨ ⬇ (123.60 kB)               \n├─cli 3.6.1 ✨\n├─glue 1.6.2 ✨\n└─rlang 1.1.1 ✨\nlifecycle depends on cli, glue, and rlang.\n\ncli: “Helpers for Developing Command Line Interfaces”\nglue: “Interpreted String Literals”\n\nIf we look at the DESCRIPTION file for lifecycle, it also imports cli, glue, and rlang (and specifies versions for cli and rlang)\nImports:\n    cli (&gt;= 3.4.0),\n    glue,\n    rlang (&gt;= 1.1.0)\nFinally, lets look at the dependencies in the vctrs package. The DESCRIPTION file for vctrs imports cli, glue, lifecycle, and rlang\nImports:\n    cli (&gt;= 3.4.0),\n    glue,\n    lifecycle (&gt;= 1.0.3),\n    rlang (&gt;= 1.1.0)\nIf we check the dependency tree, we see the cli, glue, and rlang are listed twice (once for vctrs, and again for lifecycle):\n\npak::pkg_deps_tree(pkg = \"vctrs\")\n\nvctrs 0.6.4 ✨                               \n├─cli 3.6.1 ✨\n├─glue 1.6.2 ✨\n├─lifecycle 1.0.3 ✨ ⬇ (123.60 kB)\n│ ├─cli\n│ ├─glue\n│ └─rlang 1.1.1 ✨\n└─rlang\n\nKey:  ✨ new |  ⬇ download\nvctrs depends on cli, glue, rlang, and lifecycle (which also depends on cli, glue, and rlang)\n\n\n33.1.2 Explain\nWe can show dependency relationships with pak::pkg_deps_explain(). For example,\nHow does lifecycle depend on rlang?\n\npak::pkg_deps_explain(\"lifecycle\", \"rlang\")\n\nlifecycle -&gt; rlang \nHow does vctrs depend on rlang?\n\npak::pkg_deps_explain(\"vctrs\", \"rlang\")\n\nvctrs -&gt; lifecycle -&gt; rlang                                    \nvctrs -&gt; rlang\nvctrs directly depends on rlang and lifecycle (which also depends on rlang).\n\n\n33.1.3 Depends\nSo far we’ve been including add-on functions to the Imports field in the DESCRIPTION, which ensures the package is installed with our app-package, but not attached to the search list. However, if we include a package in the Depends field, it’s installed and attached.\nThis is rarely needed, but a great example is the relationship between devtools usethis:\n\npak::pkg_deps_explain(\"devtools\", \"usethis\")\n\ndevtools -&gt; usethis\nIn the DECRIPTION file for devtools, usethis is listed with a version number under Depends:\nDepends: \n    usethis (&gt;= 2.1.6)\n\n\n33.1.4 Case study: devtools\nThe conscious uncoupling of devtools split package development across multiple packages. Let’s see how this works, starting with the commonly used devtools function load_all()\n\n33.1.4.1 pkgload\nload_all() is handled by the pkgload package, which “Simulate[s] Package Installation and Attach”.\nHow does devtools depend on pkgload?\n\npak::pkg_deps_explain(\"devtools\", \"pkgload\")\n\ndevtools -&gt; pkgload                                            \ndevtools -&gt; roxygen2 -&gt; pkgload\ndevtools -&gt; testthat -&gt; pkgload\nThis relationship shows the three actions that call load_all() during package development:\n\ndevtools::load_all() actually calls pkgload::load_all()\ndevtools::document() and devtools::test() also call pkgload::load_all()\n\n\npak::pkg_deps_explain(\"devtools\", \"roxygen2\")\n\ndevtools -&gt; roxygen2\n\npak::pkg_deps_explain(\"devtools\", \"testthat\")\n\ndevtools -&gt; testthat",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Dependency hell</span>"
    ]
  },
  {
    "objectID": "entanglement.html#tracking-dependencies",
    "href": "entanglement.html#tracking-dependencies",
    "title": "33  Dependency hell",
    "section": "33.2 Tracking dependencies",
    "text": "33.2 Tracking dependencies\nThe following packages will help keep your app-package dependencies managed in the DESCRIPTION file and the code below R/:\n\n33.2.1 attachment\nattachment was introduced in the golem chapter, but you don’t have to use the golem framework to take advantage of it’s functions. att_amend_desc() will update the package dependencies in the DESCRIPTION file.\nattachment::att_amend_desc()\nSaving attachment parameters to yaml config file\nUpdating sap documentation\nℹ Loading sap\nWriting NAMESPACE\nWriting NAMESPACE\nℹ Loading sap\n[+] 6 package(s) added: cli, tools, fst, ggplot2movies, glue, waldo.\nattachment::att_amend_desc() will automatically create a dev/ folder with a YAML configuration file:\ndev\n└── config_attachment.yaml\n\n1 directory, 1 file\nconfig_attachment.yaml contents:\npath.n: NAMESPACE\npath.d: DESCRIPTION\ndir.r: R\ndir.v: vignettes\ndir.t: tests\nextra.suggests: ~\npkg_ignore: ~\ndocument: yes\nnormalize: yes\ninside_rmd: no\nmust.exist: yes\ncheck_if_suggests_is_installed: yes\nThis can be deleted, but if you’re going to continue using attachment it’s worth customizing some of the options for your app-package.\n\n\n33.2.2 sinew\nThe sinew package also warrants mentioning because it can help ensure you’re namespacing functions from add-on packages, although it’s not automated like attachment::att_amend_desc(). The primary function in sinew is pretty_namespace().\nsinew::pretty_namespace(con = \"app.R\")\n\nAll Shiny app-packages will inherently depend on shiny, so including more dependencies can make developers justifiably uneasy. In this appendix, we’ll explore the package dependencies using the dependency lookup features from the pak package\n\n\n33.2.3 desc\nThe desc package provides functions for creating, reading, writing, and manipulating DESCRIPTION files. You can include additional dependencies to your DESCRIPTION using the desc_set_dep() function.\nlibrary(desc)\ndesc_set_dep(\"glue\", \"Imports\")\ndesc_get(\"Imports\")\nImports:\n    bslib,\n    cli,\n    glue,\n    ggplot2,\n    logger,\n    rlang,\n    sass,\n    shiny,\n    shinythemes,\n    stringr,\n    tools",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Dependency hell</span>"
    ]
  },
  {
    "objectID": "entanglement.html#footnotes",
    "href": "entanglement.html#footnotes",
    "title": "33  Dependency hell",
    "section": "",
    "text": "Try to avoid dependency hell.↩︎",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Dependency hell</span>"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Appendix A — Glossary of terms",
    "section": "",
    "text": "App-package: An app-package is a package containing a shiny application. App-packages have all of the functionality of a standard R package, but also contain the files and folders required to successfully develop, run, and deploy a Shiny application. See the Shiny and Packages chapters for more information.1\nExternal resource/file: In Shiny app-packages, external files or resources are files used in the application that aren’t part of a standard R package. These can include images (.jpg, .png, etc.), JavaScript files (.js), and CSS or Sass styling (.css, .sass). See the Resources chapter for more information.2\nModule: Shiny modules3 are a pair of UI and server functions (linked by a shared id) to create a shared by isolated namespace. Using modules in a shiny application makes it possible to isolate individual components of an application during development. Additionally, since modules are functions, they can be reused throughout the application (and tested using Shiny’s testServer() function). See the Shiny chapter for more information.4\nPackage: A directory of functions, documentation, and/or data that can be installed and loaded into an R session. R packages include the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION). In Shiny App-packages, I extend this definition to include having access to the package development tools provided by devtools in the Posit Workbench IDE. See the Packages chapter for more information.5\nR Project: Any directory of R executable files with an RStudio/Posit workbench project file (.Rproj). See the Packages chapter for more information.6\nStandalone app function: A standalone app function encapsulates the UI and server components of a Shiny app into a single function. App function typically end with a call to shinyApp(ui, server, ...) and are used to launch or deploy the the app after installing or loading the app-package.7\nUtility/helper function: A utility or helper function is a non-Shiny function that is used for the business logic (i.e., data processing, manipulation, or other common operations) that supports the main functionalities of the application. See the Shiny and Packages chapters for more information.8",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Glossary of terms</span>"
    ]
  },
  {
    "objectID": "glossary.html#footnotes",
    "href": "glossary.html#footnotes",
    "title": "Appendix A — Glossary of terms",
    "section": "",
    "text": "App-packages are covered in Mastering Shiny and Engineering Production-Grade Shiny Apps↩︎\nExternal resources/files are covered in the Shiny documentation and in Engineering Production-Grade Shiny Apps↩︎\nModules are also part of the box package from the rhino framework, but these are different from Shiny modules.↩︎\nShiny modules are covered in the Shiny documentation, Mastering Shiny, and in Engineering Production-Grade Shiny Apps↩︎\nPackages are covered in Writing R Extensions and R Packages, 2ed↩︎\nRead more about R projects on the Posit website↩︎\nStandalone app functions are also covered in Mastering Shiny.↩︎\nUtility/helper function are covered in Mastering Shiny and Engineering Production-Grade Shiny Apps↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Glossary of terms</span>"
    ]
  },
  {
    "objectID": "create.html",
    "href": "create.html",
    "title": "Appendix B — Packages FAQ",
    "section": "",
    "text": "B.1 Can an .Rproj file convert an R project into an R package?\nThe technical answer is no, because the .Rproj only activates the Build pane in the IDE. The tools in the Build pane are directly connected to the devtools package (hence the PackageUseDevtools: Yes in the .Rproj file).\nThe seven mandatory fields are required in the DESCRIPTION to have a functioning R package.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Packages FAQ</span>"
    ]
  },
  {
    "objectID": "create.html#i-have-a-description-file-with-the-required-fields-but-where-is-the-build-pane",
    "href": "create.html#i-have-a-description-file-with-the-required-fields-but-where-is-the-build-pane",
    "title": "Appendix B — Packages FAQ",
    "section": "B.2 I have a DESCRIPTION file with the required fields, but where is the Build pane?",
    "text": "B.2 I have a DESCRIPTION file with the required fields, but where is the Build pane?\nIf the mandatory fields are added to the DESCRIPTION, but the .Rproj file doesn’t have any of the package configuration fields, then the Build pane will not be displayed (see example below):\n\n\n\n\n\n\n\n\n\n(a) Build pane tools\n\n\n\n\n\nFigure B.1: Mandatory DESCRIPTION fields with package configuration in .Rproj file",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Packages FAQ</span>"
    ]
  },
  {
    "objectID": "create.html#what-if-my-.rproj-file-is-configured-to-work-with-a-package-but-my-description-file-is-missing-one-or-more-of-the-required-fields",
    "href": "create.html#what-if-my-.rproj-file-is-configured-to-work-with-a-package-but-my-description-file-is-missing-one-or-more-of-the-required-fields",
    "title": "Appendix B — Packages FAQ",
    "section": "B.3 What if my .Rproj file is configured to work with a package, but my DESCRIPTION file is missing one (or more) of the required fields?",
    "text": "B.3 What if my .Rproj file is configured to work with a package, but my DESCRIPTION file is missing one (or more) of the required fields?\nSetting the Project build tools in your Project Options is insufficient to convert a project into a package. If the .Rproj file has the package development fields (i.e., Project build tools to Package) but the mandatory fields are missing from the DESCRIPTION file, the Build pane will be triggered:\n\n\n\n\n\n\n\n\n\n(a) DESCRIPTION\n\n\n\n\n\nFigure B.2: Unchanged DESCRIPTION file after changing .Rproj\n\n\n\nBut trying to load the code in the R/ folder with Build &gt; Load All (or devtools::load_all()) we return the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n\n\n\n\n(a) Build pane tools\n\n\n\n\n\nFigure B.3: Attempt to load_all() code in R/ folder\n\n\n\nThe directory must include a DESCRIPTION file containing the mandatory fields and an .Rproj file with the package configuration fields listed above to be a functional R package.\nRead more about DESCRIPTION file fields in R Packages, 2ed\n\n\n\n\n\n\nRStudio project files\n\n\n\n\n\n\nYou can read more about the benefits of using RStudio projects to configuring project-level options here.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Packages FAQ</span>"
    ]
  },
  {
    "objectID": "create.html#i-have-the-mandatory-fields-in-my-.rproj-file-and-description-but-still-no-build-pane",
    "href": "create.html#i-have-the-mandatory-fields-in-my-.rproj-file-and-description-but-still-no-build-pane",
    "title": "Appendix B — Packages FAQ",
    "section": "B.4 I have the mandatory fields in my .Rproj file and DESCRIPTION, but still no Build pane?",
    "text": "B.4 I have the mandatory fields in my .Rproj file and DESCRIPTION, but still no Build pane?\nTo get the IDE to re-read the .Rproj file, you might have to terminate the session (Session &gt; Terminate R… &gt; Yes)\n\n\n\n\n\n\n\n\n\n\n\n(a) Session &gt; Terminate\n\n\n\n\n\n\n\n\n\n\n\n(b) Click Yes\n\n\n\n\n\n\n\nFigure B.4: Terminate your R session\n\n\n\nThis prompts the IDE to re-read the .Rproj file and trigger the Build pane.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Packages FAQ</span>"
    ]
  },
  {
    "objectID": "github.html",
    "href": "github.html",
    "title": "Appendix C — GitHub",
    "section": "",
    "text": "C.1 Example Shiny project\nIf you’re new to GitHub, the steps below will walk you through setting up Git and GitHub from RStudio using the Git pane. The initial files in the project are below:\nLet’s assume we’ve just created projApp, a new Shiny application without the package structure (it was initially created using the New Project Wizard with a Git repo initialized).\nThe files in projApp are below:\nAfter creating the project, we’ll head over to GitHub and create am empty repo with the same name. We’ll see the following options:\nWe’re interested in the second option, “…push an existing repository from the command line”. One option is to copy the Git commands and enter them into the Terminal pane in Posit workbench, but we’re going to use Posit Workbench’s Git pane.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#example-shiny-project",
    "href": "github.html#example-shiny-project",
    "title": "Appendix C — GitHub",
    "section": "",
    "text": "projApp/\n  ├── app.R\n  └── projApp.Rproj\n\n1 directory, 2 files\n\n\n\n\n\n\n\n\n\n\n\n(a) New repository on GitHub\n\n\n\n\n\nFigure C.1: Empty GitHub repository options",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#committing-changes",
    "href": "github.html#committing-changes",
    "title": "Appendix C — GitHub",
    "section": "C.2 Committing changes",
    "text": "C.2 Committing changes\nWe’ll commit these initial files to the repo using the Commit icon in the Git pane (each file initially has a yellow question mark icon):\n\n\n\n\n\n\n\n\n\n(a) Commit changes\n\n\n\nAfter selecting each file, the icon turns to a blue ‘A’ (which means the file or change has been ‘added’ to the repo)\n\n\n\n\n\n\n(b) First commit\n\n\n\n\n\nFigure C.2: Click on Commit to open the Git window. Stage all the files, add a commit message, and click Commit\n\n\n\nWe’ll add a brief commit message and click Commit. This is the equivalent of entering the following commands in the Terminal:\n\ngit add .\ngit commit -m 'first commit'\n\n\n\n\n\n\n\nCommitting changes to a repository with a message\n\n\n\n\n\n\ngit commit -m 'first commit'\nWhen you run git commit -m 'first commit', you are committing your staged changes (i.e., changes you’ve previously added to the staging area using git add) with the message ‘first commit’.\nThis message is then stored in the Git history, allowing anyone who looks at the commit logs to see a brief description of what was done in that particular commit.\n\ngit commit: This command captures a snapshot of the changes in your project’s tracked files and directories. By committing, you’re saving the current state of those files in the Git repository.\n-m: This flag indicates that a commit message will be provided directly from the command line.\n'first commit': This is the commit message associated with this commit. Commit messages are useful for documenting the changes you’ve made, making it easier for others (and your future self) to understand the evolution and purpose of changes in the project.\n\n\n\n\n\nReview the output from the commit.\n\n\n\n\n\n\n\n\n\n(a) First commit output\n\n\n\n\n\nFigure C.3: The .gitignore, app.R, and sap.Rproj files have been committed to main\n\n\n\nThe output tells us the contents of projApp are part of our local main branch. Now we need to make sure the local branch has a remote on GitHub at the following URL: https://github.com/&lt;username&gt;/sap.git.\n\n\n\n\n\n\nAdd a new remote to your Git repository\n\n\n\n\n\n\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n\ngit remote: used to manage and set remotes (‘remote repositories’) for your project\nadd: specifies that you want to add a new remote.\norigin: a convention widely used in the Git community is to name the primary remote repository origin.\nhttps://github.com/&lt;username&gt;/&lt;repo&gt;.git: This is the URL to the Git repository (hosted on GitHub). Replace &lt;username&gt; with the GitHub username of the repository owner and &lt;repo&gt; with the name of the repository.\n\nSo, when you run this command, you’re telling Git: ‘I want to add a new remote called origin, and the URL for this remote is https://github.com/&lt;username&gt;/&lt;repo&gt;.git'.’\nAfter executing this command, you can then push to and pull from the repository using this remote by referring to its name (origin). For instance, git push origin master would push your local main branch to the main branch on the origin remote.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#new-branch-add-remote",
    "href": "github.html#new-branch-add-remote",
    "title": "Appendix C — GitHub",
    "section": "C.3 New branch, add remote",
    "text": "C.3 New branch, add remote\nClick the New Branch icon in the Git pane and create a new main branch. Then click on Add Remote… and name the remote origin.\n\n\n\n\n\n\n\n\n\n(a) Add branch and remote name\n\n\n\nThe Remote URL is the link from the Quick Setup above.\n\n\n\n\n\n\n(b) Add remote URL\n\n\n\n\n\nFigure C.4: Create new main branch to track origin\n\n\n\nAfter clicking Add and Create, you’ll be asked to checkout or overwrite the existing main branch. In this case, we can select Overwrite (because we’re already on the main branch).\n\n\n\n\n\n\n\n\n\n(a) Overwrite main\n\n\n\n\n\nFigure C.5",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#push-a-local-branch-to-remote-and-set-branch-to-track-remote-branch",
    "href": "github.html#push-a-local-branch-to-remote-and-set-branch-to-track-remote-branch",
    "title": "Appendix C — GitHub",
    "section": "C.4 Push a local branch to remote (and set branch to track remote branch)",
    "text": "C.4 Push a local branch to remote (and set branch to track remote branch)\nThe git push -u origin main commands tell Git to “push the main branch to the origin remote, and also set the local main branch to track the main branch on origin.”\n\ngit push: used to push commits from your local repository to a remote repository.\norigin: name of the remote repository you want to push to. When you clone a repo or add a remote using git remote add, it’s common to name the main remote origin (though it could technically be any name).\nmain: name of the branch you’re pushing to the remote repository.\n-u or --set-upstream: When this option is used, it sets a tracking relationship between the local and upstream remote branches. This means that in the future, using git pull or git push doesn’t require specifying the remote or branch (Git will know you’re referring to the origin/main branch).\n\n\n\n\n\n\n\n\n\n\n(a) branch main set up to track origin/main\n\n\n\n\n\nFigure C.6: main will now track the remote (origin)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#renaming-branches",
    "href": "github.html#renaming-branches",
    "title": "Appendix C — GitHub",
    "section": "C.5 Renaming branches",
    "text": "C.5 Renaming branches\nThe Git UI above called the git branch -B main commands, so we’ll break these down below:\n\ngit branch without any arguments would list all the local branches in the current repository. But, with certain options (like -M), you can perform other branch-related operations.\n-M: This option stands for ‘move/rename’ and forcibly renames the branch. If a branch named main already exists, it will be overwritten because of the forceful nature of the -M option. If you want to avoid accidentally overwriting an existing branch, you could use -m (lowercase) instead. The lowercase -m will rename only if the target name doesn’t already exist.\nmain: This is the new name for the currently checked-out branch.\n\n\n\n\n\n\n\nDo I have to call the default branch main?\n\n\n\n\n\n\nMost Git users started transitioning from master to main as the default branch name for new repositories, but it’s not required. You can call the default branch anythign (for example, in sap, the default is the first chapter (01_whole-app-game))\n\n\n\n\nThe complete workflow for setting up Git from the command line is below:\n# make and add changes \ngit add .\n# commit changes\ngit commit 'first commit'\n# set remote on GitHub\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n# rename the current branch to main\ngit branch -M main\n# push and set upstream to origin (remote)\ngit push -u origin main",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "bdd.html",
    "href": "bdd.html",
    "title": "Appendix D — BDD (code snippet)",
    "section": "",
    "text": "This appendix provides more information on behavior-driven development (BDD). If you decide to adopt the BDD functions in your test suite, I highly recommend creating code snippets to reduce the typing/copying and pasting.1\nYou can edit keyboard shortcuts by selecting Tools &gt; Edit Code Snippets…\nSnippets also work well with tab completion in the Posit Workbench IDE:\nBDD uses a specific format for translating application behavior into into features. These ‘user stories’ are typically written in the Gherkin language and include the following sections:\nThe testthat BDD functions can be adapted to use this format, because the description argument a text string and these functions can be nested.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>BDD (code snippet)</span>"
    ]
  },
  {
    "objectID": "bdd.html#footnotes",
    "href": "bdd.html#footnotes",
    "title": "Appendix D — BDD (code snippet)",
    "section": "",
    "text": "Read more about creating code snippets on the Posit website.↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>BDD (code snippet)</span>"
    ]
  },
  {
    "objectID": "graph_tests.html",
    "href": "graph_tests.html",
    "title": "Appendix E — Tests (graph outputs)",
    "section": "",
    "text": "E.0.1 Graph outputs and BDD\nIf we want to create a graph snapshot test, the vdiffr package allows us to perform a ‘visual unit test’ by capturing the expected output as an .svg file that we can compare with future versions.\nThe expect_doppelganger() function from vdiffr is designed specifically to work with ‘graphical plots’.\nAnother option for using snapshots for testing is the expect_snapshot_file() function 1 but expect_doppelganger() is probably the better option for comparing graph outputs.\nThe Feature for the initial graph output from scatter_plot() might look like:\ntestthat::describe(\n  \"Feature: Scatter Plot Configuration in Movie Review Application\n    As a user who accesses the movie review application,\n    I want the initial scatter plot pre-configured with variables and aesthetics,\n    So that I can immediately see a meaningful visualization.\", code = {\n    \n})\nCombining scenarios in the same test file is helpful if we’re trying to keep a 1:1 between the test/testthat/ file names and file names in R/.2\n1testthat::it(\n  \"Scenario: Create scatter plot\n      Given I have launched the movie review exploration app,\n      When the scatter plot renders,\n      Then the points on the x axis should represent 'Ratings'\n      And the points on the y axis should represent 'Length'\n      And the points should be colored by 'MPAA' rating\n      And the opacity of the points should be set to '0.5'\n      And the size of the points should be set to '2'\n      And the plot title should be set to 'Enter plot title'\",\n  code = {\n    \n2    test_logger(\n      start = \"snap scatter_plot()\", \n      msg = \"initial x,y,z,size,alpha\")\n\n3    scatter_inputs &lt;- list(\n      x = \"imdb_rating\",\n      y = \"audience_score\",\n      z = \"mpaa_rating\",\n      alpha = 0.5,\n      size = 2,\n      plot_title = \"Enter plot title\"\n    )\n\n4    vdiffr::expect_doppelganger(\n      title = \"Initial x y z axes\",\n      fig = scatter_plot(movies,\n        x_var = scatter_inputs$x,\n        y_var = scatter_inputs$y,\n        col_var = scatter_inputs$z,\n        alpha_var = scatter_inputs$alpha,\n        size_var = scatter_inputs$size\n      ) +\n        ggplot2::labs(\n          title = scatter_inputs$plot_title,\n          x = stringr::str_replace_all(\n            tools::toTitleCase(\n              scatter_inputs$x\n            ), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            tools::toTitleCase(\n              scatter_inputs$y\n            ), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    )\n\n5    test_logger(\n      end = \"snap scatter_plot()\", \n      msg = \"initial x,y,z,size,alpha\")\n    \n  }\n)\n\n\n1\n\nTest scope\n\n\n2\n\nLog start\n\n\n3\n\nInitial movies variable inputs for x, y, and z from UI\n\n\n4\n\nSnapshot with initial values\n\n\n5\n\nLog end\nTest results also return the output from test_logger() with the context I’ve added on what’s being tested.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Tests (graph outputs)</span>"
    ]
  },
  {
    "objectID": "graph_tests.html#footnotes",
    "href": "graph_tests.html#footnotes",
    "title": "Appendix E — Tests (graph outputs)",
    "section": "",
    "text": "Follow the expect_snapshot_file() example from the testthat documentation↩︎\nmatching files names between R/ and tests/testthat/ keeps our code organized and ensures the devtools::test_coverage_active_file() function works.↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Tests (graph outputs)</span>"
    ]
  },
  {
    "objectID": "test_mocks.html",
    "href": "test_mocks.html",
    "title": "Appendix F — Tests (mocking)",
    "section": "",
    "text": "F.0.1 Example: mocking add-on functions\nTest code may rely on external systems, behavior, functions, or objects. To ensure that our unit tests remain fast and focused solely on the functional requirement being tested, it’s important to minimize these external dependencies.\nThe mocking functions can be used to substitute functions by emulating their behavior within the test scope (in BDD terms, mocks are creating the Given conditions).1\nWe’ll work through a unit test mocking example from the package development masterclass workshop at posit::conf(2023). Instead of real-time computations, mocks return predefined responses to given inputs. Consider the check_installed() function below:\ncheck_installed &lt;- function(package) {\n  if (is_installed(package)) {\n    return(invisible())\n  } else {\n    stop(\"Please install '{package}' before continuing\")\n  }\n}\nWe’ll use local_mocked_bindings() from testthat to mock the behavior of rlang::is_installed(). Below is a feature description for check_installed() and two scenarios for each expected behavior:\nThe check_installed() shouldn’t be confused with rlang::check_installed(), which checks if a package is installed, and if it isn’t, prompts the user install the package using pak::pkg_install().\nLets review how is_installed() behaves with installed and missing packages:\nrlang::is_installed('foo')\n## [1] FALSE\nrlang::is_installed('base')\n## [1] TRUE\nThe version of check_installed() in sap will check if a package is installed and return invisible() if it is (which, when assigned to an object, evaluates to NULL):\ncheck_installed('base')\nx &lt;- check_installed('base')\nx\n## NULL\nIf the package is not installed, check_installed() prints an error message:\ncheck_installed('foo')\n## Error in check_installed(\"foo\"): Please install '{package}' before continuing\nTo use mocking with is_installed(), we’ll use the following syntax:\nIn this case, {local function} is is_installed() from rlang, and we want to test the two possible {value}s (TRUE/FALSE).\nIn the first test, we’ll use expect_error() to confirm that the error message is returned for an uninstalled package by using local_mocked_bindings() and setting the is_installed() value to FALSE:\ndescribe(\"Feature: Checking if an R package is installed\", {\n  \n  test_that(\n    \"Scenario: Checking an uninstalled package\n        Given the R package 'foo' is not installed\n        When I call the `check_installed()` function with 'foo'\n        Then the function should raise an error with the message\n        `Please install 'nonexistent_package' before continuing`\", {\n          \n1    test_logger(start = \"mock is_installed\", msg = \"FALSE\")\n2    local_mocked_bindings(is_installed = function(package) FALSE)\n3    expect_error(object = check_installed(\"foo\"))\n    test_logger(end = \"mock is_installed\", msg = \"FALSE\")\n    \n  })\n  \n})\n\n\n1\n\nLog test start and end\n\n2\n\nSet {value} to FALSE\n\n\n3\n\nPass a package we know is not installed\nTo test installed packages, we’ll confirm check_installed('foo') with expect_invisible():\ndescribe(\"Feature: Checking if an R package is installed\", {\n  \n  test_that(\n    \"Scenario: Checking an installed package\n        Given the R package 'base' is installed\n        When I call the `check_installed()` function with 'base'\n        Then the function should return without any error\", {\n          \n1    test_logger(start = \"mock is_installed\", msg = \"TRUE\")\n2    local_mocked_bindings(is_installed = function(package) TRUE)\n3    expect_invisible(check_installed(\"base\"))\n    test_logger(end = \"mock is_installed\", msg = \"TRUE\")\n    \n  })\n})\n\n\n1\n\nLog test start and end\n\n2\n\nSet {value} to TRUE\n\n\n3\n\nPass a package we know is installed\nThe output from the tests above is provided below:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Tests (mocking)</span>"
    ]
  },
  {
    "objectID": "test_mocks.html#footnotes",
    "href": "test_mocks.html#footnotes",
    "title": "Appendix F — Tests (mocking)",
    "section": "",
    "text": "Test mocking functions are a relatively new addition to testthat. Read more in the recent updates to testthat↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Tests (mocking)</span>"
    ]
  },
  {
    "objectID": "rhino_append.html",
    "href": "rhino_append.html",
    "title": "Appendix G — rhino (CI/CD)",
    "section": "",
    "text": "G.1 Rhino CI/CD\nThe rhino framework includes the following GitHub Actions workflow file with new apps:\nThe sections are described below:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>rhino (CI/CD)</span>"
    ]
  },
  {
    "objectID": "rhino_append.html#rhino-cicd",
    "href": "rhino_append.html#rhino-cicd",
    "title": "Appendix G — rhino (CI/CD)",
    "section": "",
    "text": ".github/workflows/rhino-test.yml\n\nname: Rhino branch test, 20_rhino\nname: Rhino Test\non: push\npermissions:\n  contents: read\n  \njobs:\n  main:\n    name: Run linters and tests\n    runs-on: ubuntu-20.04\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v2\n\n      - name: Extract R version from lockfile\n        run: printf 'R_VERSION=%s\\n' \"$(jq --raw-output .R.Version renv.lock)\" &gt;&gt; $GITHUB_ENV\n\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v2\n        with:\n          r-version: ${{ env.R_VERSION }}\n\n      - name: Setup system dependencies\n        run: &gt;\n          sudo apt-get update && sudo apt-get install --yes\n          libcurl4-openssl-dev\n\n      - name: Restore renv from cache\n        uses: actions/cache@v2\n        env:\n          CACHE_KEY: renv-${{ runner.arch }}-${{ runner.os }}-${{ env.R_VERSION }}\n        with:\n          path: renv/library\n          key: ${{ env.CACHE_KEY }}-${{ hashFiles('renv.lock') }}\n          restore-keys: ${{ env.CACHE_KEY }}-\n\n      - name: Sync renv with lockfile\n        shell: Rscript {0}\n        run: |\n          options(renv.config.cache.symlinks = FALSE)\n          renv::restore(clean = TRUE)\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: 16\n\n      - name: Lint R\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_r()\n\n      - name: Lint JavaScript\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_js()\n\n      - name: Lint Sass\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_sass()\n\n      - name: Build JavaScript\n        if: always()\n        shell: Rscript {0}\n        run: rhino::build_js()\n\n      - name: Build Sass\n        if: always()\n        shell: Rscript {0}\n        run: rhino::build_sass()\n\n      - name: Run R unit tests\n        if: always()\n        shell: Rscript {0}\n        run: rhino::test_r()\n\n      - name: Run Cypress end-to-end tests\n        if: always()\n        uses: cypress-io/github-action@v5\n        with:\n          working-directory: .rhino # Created by earlier commands which use Node.js\n          start: npm run run-app\n          project: ../tests\n          wait-on: 'http://localhost:3333/'\n          wait-on-timeout: 60\n\n\n\nG.1.1 Trigger\nThe .github/workflows/rhino-test.yml file runs on pushes to the repo containing a rhino app.\nname: Rhino Test\non: push\n\n\nG.1.2 Permissions\nThe workflow only has read permission for the repository. Read more about setting permissions here.\npermissions:\n  contents: read\n\n\nG.1.3 Jobs\nrhino-test.yml contains a single job named main with the following steps:\njobs:\n  main:\n    name: Run linters and tests\n    runs-on: ubuntu-20.04\n    env:\n      R_VERSION: '4.1.0'\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n\nG.1.3.1 Step: Checkout Code, R version, Dependencies\nChecks out the code using actions/checkout@v2, extracts the R version from a lockfile (renv.lock) and sets it as an environment variable (env.R_VERSION), and uses apt-get to install system dependencie (libcurl4-openssl-dev)\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v2\n\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v1\n        with:\n          r-version: ${{ env.R_VERSION }}\n\n      - name: Setup system dependencies\n        run: &gt;\n          sudo apt-get update && sudo apt-get install --yes\n          libcurl4-openssl-dev\n\n\nG.1.3.2 Step: Restore and sync renv\nThe R dependencies in renv.lock are restored from cache with actions/cache@v2, then the R environment is synchronized with the lockfile (ensuring all necessary R packages are installed).\n\n      - name: Restore renv from cache\n        uses: actions/cache@v2\n        env:\n          CACHE_KEY: renv-${{ runner.arch }}-${{ runner.os }}-${{ env.R_VERSION }}\n        with:\n          path: renv/library\n          key: ${{ env.CACHE_KEY }}-${{ hashFiles('renv.lock') }}\n          restore-keys: ${{ env.CACHE_KEY }}-\n          \n      - name: Sync renv with lockfile\n        shell: Rscript {0}\n        run: |\n          options(renv.config.cache.symlinks = FALSE)\n          renv::restore(clean = TRUE)\n\n\nG.1.3.3 Step: Node.js\nThe Node.js environment is set up with version 16.\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: 16\n\n\nG.1.3.4 Step: Linters\nLints R (rhino::lint_r()), JavaScript (rhino::lint_js()), and Sass (rhino::lint_sass()) code for quality and style consistency.\n      - name: Lint R\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_r()\n\n      - name: Lint JavaScript\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_js()\n\n      - name: Lint Sass\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_sass()\n\n\nG.1.3.5 Step: Unit Tests\nExecutes testthat unit tests written in R (rhino::test_r())\n      - name: Run R unit tests\n        if: always()\n        shell: Rscript {0}\n        run: rhino::test_r()\n\n\nG.1.3.6 Step: Cypress End-to-End Tests\nSpecifies the working directory .rhino/, starting command for the application (npm run run-app), project directory for tests (../tests), URL to wait for ('http://localhost:3333/'), and a timeout for waiting (60) for Cypress to run end-to-end tests.\n      - name: Run Cypress end-to-end tests\n        if: always()\n        uses: cypress-io/github-action@v5\n        with:\n          working-directory: .rhino # Created by earlier commands which use Node.js\n          start: npm run run-app\n          project: ../tests\n          wait-on: 'http://localhost:3333/'\n          wait-on-timeout: 60",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>rhino (CI/CD)</span>"
    ]
  },
  {
    "objectID": "stack_traces.html",
    "href": "stack_traces.html",
    "title": "Appendix H — Stack traces",
    "section": "",
    "text": "Alert\n\n\n\n\n\n\nThe contents for section are being revised. Thank you for your patience.\n\n\n\n\nIn this chapter covers how to read stack traces (or call stacks), which is the printout that follows programming errors.\n\n\nLaunch app with the shinypak package:\n\nlaunch('27_stack-traces')\n\n\n\n\n\n\n\nAccessing applications\n\n\n\n\n\n\nI’ve created the shinypak R package In an effort to make each section accessible and easy to follow:\nInstall shinypak using pak (or remotes):\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\n\nReview the chapters in each section:\n\nlibrary(shinypak)\nlist_apps(regex = '^27')\n## # A tibble: 1 × 2\n##   branch        last_updated       \n##   &lt;chr&gt;         &lt;dttm&gt;             \n## 1 27_llm-ellmer 2025-03-12 13:08:13\n\nLaunch the app:\n\nlaunch(app = \"27_stack-traces\")\n\nDownload the app:\n\nget_app(app = \"27_stack-traces\")\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Stack traces</span>"
    ]
  },
  {
    "objectID": "comparisons.html",
    "href": "comparisons.html",
    "title": "Appendix I — Comparisons",
    "section": "",
    "text": "I.0.1 waldo::compare()\nComparisons are the backbone of testing. Exploring the mechanics of how tests perform these comparisons (i.e., the underlying package(s)) can save you from surprising results.\nFor example, expect_equal() compares whatever is passed to the observed and expected arguments with the waldo package, with some help from diffobj.\nIf you’d like a preview of a comparison before writing a formal test, you can pass the your observed and expected objects to compare()1\nFor example, suppose we have two objects:\nThe outputs below are example outputs from waldo::compare():\ncompare(\n1  x = old,\n  y = old)\n## ✔ No differences\n\n\n1\n\nComparing identical objects\ncompare(\n1  x = old,\n  y = new)\n## `class(old)`: \"tbl_df\" \"tbl\" \"data.frame\"\n## `class(new)`:                \"data.frame\"\n## \n## `names(old)`: \"chr\" \"num\" \"fct\"\n## `names(new)`: \"CHR\" \"num\" \"fct\"\n## \n## `old$chr` is a character vector ('B', 'C', 'D')\n## `new$chr` is absent\n## \n## `old$num` is a double vector (1, 2, 3)\n## `new$num` is an integer vector (1, 2, 3)\n## \n## `class(old$fct)`: \"ordered\" \"factor\"\n## `class(new$fct)`:           \"factor\"\n## \n## `levels(old$fct)`: \"L\"   \"M\"   \"H\"   \n## `levels(new$fct)`: \"low\" \"med\" \"high\"\n## \n## `old$CHR` is absent\n## `new$CHR` is a character vector ('B', 'C', 'D')\n\n\n1\n\nComparing different objects\ncompare() displays the differences in classes, names, and any individual value differences.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Comparisons</span>"
    ]
  },
  {
    "objectID": "comparisons.html#footnotes",
    "href": "comparisons.html#footnotes",
    "title": "Appendix I — Comparisons",
    "section": "",
    "text": "Be mindful of the difference in arguments between expectation functions (i.e., expect_equal()) and compare()↩︎\nThe results from testthat don’t include the differences between old$num and new$num. This is due to the tolerance argument, which can be adjusted in both functions.↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Comparisons</span>"
    ]
  }
]