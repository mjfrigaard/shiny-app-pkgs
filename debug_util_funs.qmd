# Utility functions {#sec-debug-funs}

```{r}
#| label: _common
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(lobstr)
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "r", 
  header = "Warning",
  contents = "The contents for section are under development. Thank you for your patience."
)
```

When building Shiny app-packages, debugging plays a crucial role in ensuring that our app works as expected *and* integrates seamlessly into the package structure. Posit Workbench's debugging tools are covered elsewhere, so this chapter will focus on debugging Shiny code and functions inside an R package.[^debug-other-resources]

One of the most effective tools for debugging in R is the `browser()` function.

[^debug-other-resources]: For an introduction to the IDE's debugging tools, see this [Posit article](https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE). Debugging is also covered in [Advanced R, 2ed](https://adv-r.hadley.nz/debugging.html) and [Mastering Shiny.](https://mastering-shiny.org/action-workflow.html#debugging)


:::: {.callout-tip collapse='true' appearance='default'}

## [Accessing applications]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 0.95em; color: #282b2d;'}

I've created the [`shinypak` R package](https://mjfrigaard.github.io/shinypak/) In an effort to make each section accessible and easy to follow:
  
Install `shinypak` using `pak` (or `remotes`):

```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| eval: false
# install.packages('pak')
pak::pak('mjfrigaard/shinypak')
```

Review the chapters in each section:
  
```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| collapse: true
library(shinypak)
list_apps(regex = 'debug')
```

Launch the app: 

```{r}
#| code-fold: false 
#| eval: false
launch(app = "15_debug-util-funs")
```

Download the app: 

```{r}
#| code-fold: false 
#| eval: false
get_app(app = "15_debug-util-funs")
```

::: 

::::

```{r}
#| label: hot_key_intro
#| echo: false
#| results: asis
#| eval: true
hot_key(fun = "L")
```

Let's start by debugging the scatter plot in `launch_app()`. After loading, documenting and installing `sap`, launch the application:

```{r}
#| eval: false 
#| code-fold: false
launch_app(test = FALSE)
```

:::{#fig-debug_movies_app_01}

![Error in `launch_app()`](images/debug_movies_app_01.png){#fig-debug_movies_app_01 width='100%' align='center'}

The Error messages in the UI is not always informative
:::

The error printed in the UI is not very descriptive, but fortunately the following output is also printed to the **Console**: 

:::{.column-margin}

`ggplot2` has excellent error messages ðŸ‘Œ

:::

```{verbatim}
#| eval: false 
#| code-fold: false
Warning: Error in ggplot2::geom_point: Problem while computing aesthetics.
â„¹ Error occurred in the 1st layer.
Caused by error in `.data[[NULL]]`:
! Must subset the data pronoun with a string, not `NULL`.
```

We can see the error is coming from `ggplot2::geom_point()`, specifically from one of the calls to `.data`. We can safely assume the source of this bug is the `scatter_plot()` utility function. However, we'll proceed as if the message wasn't very helpful or informative.

## Debugging strategies {.unnumbered}

The two most common tools I use for debugging are:

1. Wrapping `browser()` in a call to `observe()`  
2. Capturing reactive values with `reactiveValuesToList()` and sending output to the UI

These two methods cover 90% of my Shiny app debugging needs. In the following sections, I'll provide examples of how--and when--I use each method.

### [`browser()`]{style="font-size: 1.05em; font-weight: bold;"} 

`browser()` pauses code execution and activates the interactive debugger mode in the IDE, allowing us to view objects, execute code, and â€˜step throughâ€™ each function line.



### [`observe()`]{style="font-size: 1.05em; font-weight: bold;"} 

Shinyâ€™s reactive model can make debugging challenging because the issues arenâ€™t limited to the internal logic or calculations. Bugs can also be caused by the timing, sequence, or creation of reactive values. `observe()` creates a reactive observer that 'listens' for changes to reactive expressions (and executes code in response).

```{r}
#| label: co_box_dbug_modules
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "r", 
  size = '1.05', 
  header = "Debugging Reactivity in Shiny App-Packages", 
  hsize = '1.15', 
  fold = FALSE, 
  look = 'simple',
  contents = "
  
***Don't forget to load any debugging calls with `devtools::load_all()` _before_ re-launching the app*** 
  
\`\`\`r
devtools::load_all('.')
`\`\`\

***Or***
  
<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>

  "
)
```

Wrapping `browser()` with `observe()` will trigger the debugger when the observer is invalidated, allowing us to interactively examine variables and reactive expressions (within the scope of the `observe()` function):

```{r}
#| eval: false 
#| code-fold: false
server <- function(input, output, session) { # <1> 

    observe({ # <2>
        browser() # <3> 
    

    returned_values <- mod_something("bla")

    mod_something_else("blabla", input_values = returned_values)
    
    }) # <2>
} # <1>
```
1. Shiny server function
2. `observe()` function scope  
3. Call to `browser()` (called at the top of the `observe()` scope) 

```{r}
#| label: git_box_25.3_debug-scatter_plot
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "launch",
  fig_pw = '65%', 
  branch = "25.3_debug-scatter_plot", 
  repo = 'sap')
```

If we want to debug the scatter plot output, we need to move our `observe(browser())` functions inside the call to `renderPlot()`:

```{r}
#| eval: false 
#| code-fold: false
output$scatterplot <- renderPlot({
  observe({ # <1>
    browser() # <2>

    
  }) # <1>
})
```
1. Observe scope   
2. Call to `browser()`   

Load the package and run the application again:

```{r}
#| label: hot_key_render_plot
#| echo: false
#| results: asis
#| eval: true
hot_key(fun = "L")
```

```{verbatim}
#| eval: false 
#| code-fold: false
â„¹ Loading sap
```

```{r}
#| eval: false 
#| code-fold: false
launch_app(options = list(test.mode = FALSE), run = 'p')
```

Inside `renderPlot()`, we can progress to the creation of the `plot` object:

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[1]> n
```

``` sh
debug at sap/R/mod_scatter_display.R#68: 
  plot <- scatter_plot(
    df = movies, 
    x_var = inputs()$x, 
    y_var = inputs()$y, 
    col_var = inputs()$col, 
    alpha_var = inputs()$alpha, 
    size_var = inputs()$size)
```

:::

From here we can step inside the `scatter_plot()` utility function to identify the source of the error:

```{r}
#| eval: false 
#| code-fold: false 
Browse[2]> s
```

:::{#fig-debug_scatter_plot_03}

![Step into `scatter_plot()`](images/debug_scatter_plot_03.png){#fig-debug_scatter_plot_03 width='100%' align='center'}

Use `s` in the debugger console to 'step into' `scatter_plot()`
:::

Note the changes in the debugger console when we 'step into' `scatter_plot()`:

```{bash}
#| eval: false 
#| code-fold: false
debugging in: 
  scatter_plot(df = movies, 
    x_var = inputs()$x, 
    y_var = inputs()$y, 
    col_var = inputs()$col, 
    alpha_var = inputs()$alpha, 
    size_var = inputs()$size)
debug at /sap/R/scatter_plot.R#30: # <1> 
{   
    ggplot2::ggplot(data = df, 
      ggplot2::aes(x = .data[[x_var]], 
                   y = .data[[y_var]], 
                   color = .data[[col_var]])) + 
      ggplot2::geom_point(alpha = alpha_var, 
                          size = size_var)
}
```
1. Location of debugger in utility function  

After some examination, we can identify the source of the error.

```{r}
#| eval: false 
#| code-fold: true
#| code-summary: 'show/hide source of scatter_plot() bug'
inputs <- reactive({
  plot_title <- tools::toTitleCase(var_inputs()$plot_title)
  list(
    x = var_inputs()$x,
    y = var_inputs()$y,
    col = var_inputs()$z, # <1>
    alpha = var_inputs()$alpha,
    size = var_inputs()$size,
    plot_title = plot_title
  )
})
plot <- scatter_plot(
  df = movies,
  x_var = inputs()$x,
  y_var = inputs()$y,
  col_var = inputs()$z, # <2>
  alpha_var = inputs()$alpha,
  size_var = inputs()$size
)
```
1. Color is assigned as **`col`** in `inputs`   
2. Color is passed to `scatter_plot()` as **`col_var`**

