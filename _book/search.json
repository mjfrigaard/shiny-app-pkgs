[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "Welcome!",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#whats-in-the-book",
    "href": "index.html#whats-in-the-book",
    "title": "Shiny App-Packages",
    "section": "What’s in the book",
    "text": "What’s in the book\n\n\n\n\n\n\nURLs\n\n\n\n\n\n\n\nShort URL: https://bit.ly/ShinyAppPkgs\n\nFull link: https://mjfrigaard.github.io/shiny-app-pkgs/\n\nGitHub repo: https://github.com/mjfrigaard/shiny-app-pkgs/\n\n\n\n\n\n\n\nThis book is a resource to help ‘connect the dots’ between building scalable Shiny applications and writing R packages. Adopting R package development practices in the early stages of your Shiny app will improve the reusability, maintainability, and shareability of all your hard work.\nThe code and data originate from the excellent Building Web Applications with Shiny (BWAS) course. If you’re new to Shiny development this course is a great place to start. The four learning modules will provide a solid understanding for many of the topics covered in this book.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#whats-not-in-the-book",
    "href": "index.html#whats-not-in-the-book",
    "title": "Shiny App-Packages",
    "section": "What’s not in the book",
    "text": "What’s not in the book\nThis book isn’t a replacement for Mastering Shiny or R Packages, 2ed (or Writing R Extensions). I highly suggest bookmarking these resources to return and read when you’d like to learn more about R package and Shiny development.\n\n\n\n\n\nI also won’t be recommending a particular Shiny framework or package, but I’ll cover a few popular choices, show what they’re doing ‘under the hood,’ and let you decide if you’d like to adopt their practices.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#what-i-assume-about-you",
    "href": "index.html#what-i-assume-about-you",
    "title": "Shiny App-Packages",
    "section": "What I assume about you",
    "text": "What I assume about you\nIf you’re reading this, I assume you’re comfortable with R, Posit Workbench, Shiny, and the tidyverse. Maybe you haven’t built a ton of applications, but you understand reactivity, and you’re comfortable with the core Shiny concepts (i.e., the UI, server, *_Input(), *_Output(), and render_* functions, etc.).",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#code-examples",
    "href": "index.html#code-examples",
    "title": "Shiny App-Packages",
    "section": "Code examples",
    "text": "Code examples\nThe code files for each chapter are stored in GitHub repository. Major code changes are stored in branches. Whenever a new branch is used, you’ll see the Git Branch icon with a link to the repo/branch in the margin.\n\n\n\n\n\n\n\n\n\n\nSee the &lt;branch&gt; branch of sap.\n\nIn an effort to make the code and examples more accessible and easy to use, I’ve also created the shinypak package:\nExample:\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\nshinypak::launch('09.2_inst-bslib')",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "Why this book?\nShiny App-Packages attempts to combine and distill Shiny and R package development practices from multiple resources.\nR Packages, 2ed is the premier resource for learning the best practices when creating functions, writing documentation, managing package namespaces, and many other fundamental aspects of package development. However, R Packages, 2ed primarily focuses on creating conventional R packages, so it doesn’t cover Shiny programming (designing user interfaces, server-side computations, modules, etc.). Moreover, testing and debugging a Shiny application differs from the traditional methods used in R packages.\nMastering Shiny is an excellent introduction to the world of Shiny and provides a foundation of best practices for developing applications. R packages are introduced near the end of Mastering Shiny, and this chapter is a great place to start.1 However, to fully understand and appreciate the benefits of developing your Shiny app as an R package, it’s helpful to have an example app-package that includes the full suite of the package development tools (loading, documenting, testing, installing, etc.).2",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#why-this-book",
    "href": "preface.html#why-this-book",
    "title": "Preface",
    "section": "",
    "text": "Did you read R Packages, 2ed and find it difficult to apply package development practices to your Shiny application?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDid you read Mastering Shiny and want to learn more about package development?\n\n\n\n\n\nOther Shiny Resources\nThroughout the course of writing this book, the Shiny community has grown and other resources have been published for developing and customizing Shiny applications. Two popular resources are Engineering Production-Grade Shiny Apps and Outstanding User Interfaces with Shiny.\n\n\n\n\n\n\nEngineering Production-Grade Shiny Apps introduces the golem package, which is an ‘opinionated framework for building production-grade Shiny applications’. golem offers a robust and standardized way to build, maintain, and deploy production-grade Shiny apps. Whether due to the learning curve, number of features, dependencies, or a particular set of deployment constraints, golem might not be the right fit for your application.3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOutstanding User Interfaces with Shiny ‘addresses a specific gap between the beginner and advanced level’ focusing on customizing your Shiny application with HTML, CSS and JavaScript. It introduces charpente, which streamlines the creation of Shiny development by quickly creating an R package, importing external web dependencies for JavaScript and CSS, initializing input/output bindings, and providing custom handler boilerplates. charpente also offers a high-level interface to htmltools (the workhorse that converts R code to web-friendly HTML).\n\n\n\nWe’ll cover both of these texts more in the frameworks section.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#sec-pkgs-ides",
    "href": "preface.html#sec-pkgs-ides",
    "title": "Preface",
    "section": "Development Environments",
    "text": "Development Environments\nThe two integrated development environments (IDEs) I will be demonstrating are RStudio and Positron.\n\n\n\n\n\n\nRStudio is a popular integrated development environment (IDE) that streamlines many R package development tasks. I’d previously connected this IDE to the definitions above for R package and Shiny app-packages. Specifically, the package development tools provided in the Build pane and the devtools package.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPositron is Posit’s new integrated development environment (IDE) designed to improve productivity and performance across multiple programming languages. Building on RStudio’s success, Positron offers a sleek, user-friendly interface while keeping powerful tools for debugging, profiling, and interactive visualizations.\n\n\n\nMost of the book will focus on developing Shiny app-packages in RStudio, because Positron is under active development. When I’m including information specific to particular IDE, I will use icons to differentiate Positron from RStudio ( vs. ).\n\nOther tools\nDeveloping R packages in RStudio or Positron is not required. There are alternative IDEs and tools, and many developers employ these setups (VS Code, PyCharm, Jupyter Lab, Colab, etc). Package development outside RStudio would look almost identical to development in the IDE:\n\nCreate the package structure (R/ folder for .R scripts, man/ folder for documentation, data/ folder for datasets, etc.)\nCreate DESCRIPTION and NAMESPACE files, etc.\nEnsure the package can be installed and loaded into an R session.\n\nThe development workflow functions we’ll cover work just about anywhere you can execute R code (i.e., roxygen2::roxygenize(), devtools::load_all(), devtools::install(), etc.).",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#how-to-read-this-book",
    "href": "preface.html#how-to-read-this-book",
    "title": "Preface",
    "section": "How to read this book",
    "text": "How to read this book\nTransitioning from programming in R to building Shiny applications and writing R packages presents a steep learning curve. The chapters in this book are aimed flattening the package development portion of that curve. As with any new skill, app-package development involves new mental models, concepts, terminology, habits, and details. If you find yourself getting frustrated, I recommend the 15 minute rule:\n\n“By forcing yourself to try for 15 minutes, you gain a deeper understanding of what you’re troubleshooting so that, even if you don’t fix it in 15, next time you’re in a better position to troubleshoot than you were the last time.\nAnd by forcing yourself to ask for help after 15, you not only limit the amount of banging-your-head time, but you also get to see how the other person solves the problem while all the details are still fresh in your mind, so that you’ll more likely have a deeper understanding of why what you were doing to fix it wasn’t working, and why the ultimate solution actually worked.” - Hacker News, 2013\n\nThe chapters in this book (roughly) represent the steps of R package development, but through the lens of an existing Shiny application.4 Each topic can be applied to creating a new app-package, but–in my experience–many Shiny developers have existing applications they’d like to convert into an R package.\nIntroduction covers the development of a Shiny app project and it’s gradual progression of complexity to warrant an R package:\n\n1  Whole app game is a ‘whole game’ for the development of a toy app-package. This chapter gives a high-level overview of the app-package development workflow.5\nIn 2  Shiny we’ll dive into shiny development, focusing on the files and folders found in most Shiny applications.\nR packages are introduced in 3  Packages, and it covers the differences between Shiny app projects, R packages, and Shiny app-packages.\n4  Development introduces devtools and the app-package development workflow.\n\nThe app-packages applies the key components of R package development to a Shiny app. These sections aren’t likely to change anytime soon.\n\n5  Documentation covers documenting the application’s utility functions, modules, UI, server, and standalone app function using roxygen2.\nManaging dependencies (both imports and exports) using the NAMESPACE file is introduced in 6  Dependencies\n7  Data discusses the storage, format, and documentation of data files your app-package.\nThere are multiple ways to launch an application from an app-package. 8  Launch covers options to include in the app.R file and your standalone app function.\n9  Resources covers the many uses of the inst/ folder in R packages. This chapter also covers how to add external files and resources to your application.\n\nWhile developing your application, you’ll want to ensure it’s features are documented and tested. The Tests section covers testing:\n\nBefore running any tests we need to set up the test suite in our app-package. 14  Test suite briefly covers setting up the testing infrastructure with testthat.\nKnowing what features to implement and what tests to develop reduces the chances of writing code that doesn’t address a user needs. 15  Specifications discusses how to identify user specifications, features, and functional requirements. It also briefly introduces behavior-driven development.\n16  Test tools covers how to include testing tools (fixtures and helpers) in your test suite to ensure isolated yet controllable test conditions.\nReactivity makes testing modules tricky. In 17  Testing modules, I’ll cover some strategies and approaches for verifying that your modules are communicating correctly with Shiny’s testServer() function.\n18  System tests introduces performing system (or end-to-end) tests in you app-package with the shinytest2 package.\n\nAfter you’ve developed your Shiny App-Package, you’ll likely want to deploy it (or put it ‘into production’). A selection of popular methods are covered in Deploy:\n\n20  Docker explains how build Docker images and containers using Docker desktop. These topics are also covered in 23  golem.\n21  GitHub Actions covers continuous integration (CI) / continuous deployment (CD) for Shiny app-packages using GitHub Actions.\n22  pkgdown websites are an excellent way to enhance it’s visibility and usability of your app-package (and it’s made seamless with usethis and GitHub actions (see 22.4 Deploying your site)).\n\nIf you’re Googling ‘what is the best way to build a Shiny application?’ you’ll eventually encounter a Shiny framework. This section contains the development workflow and methods for three popular Shiny application frameworks (golem, leprechaun, charpente and rhino).\n\n23  golem covers developing an application using the golem framework (which is introduced in Engineering Production-Grade Shiny Apps).\nFor developers looking for a ‘lightweight’ version of the golem package, 24  leprechaun introduces the leprechaun package and development workflow\n25  charpente is the Shiny framework introduced in Outstanding User Interfaces with Shiny.\n26  rhino covers how to build a rhino application (which is not technically a package, but is still worth including based on it’s popularity and features).\n\nThe special topics section includes a handful of topics on development, storing and retrieving data, reading error outputs, and keeping track of dependencies.\n\n29  App data explores the differences between and use of shiny::reactiveValues() and session$userData.\n30  Stack traces (this chapter is under construction)\n31  Dependency hell (this chapter is under construction)",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#acknowledgments",
    "href": "preface.html#acknowledgments",
    "title": "Preface",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThis book is the result of multiple discussions with 1) Shiny developers who were new to writing R packages, 2) R package authors who were learning Shiny development and testing, and 3) new R users who wanted to build a robust and scalable application. Shiny App-Packages wouldn’t have been possible without the contributors below (and I am deeply grateful for all of their help!).\n\nHenry Bernreuter & Elizabeth Marshallsay for the initial discussions that created the outline for this book\n\nAndrew Bates for being an exemplary developer and professional, quietly building outstanding UIs, applications, and packages\nEric Simms for asking so many great questions, reviewing chapters, and giving phenomenal feedback\n\nEric Nantz6 for his R podcast, Shiny developer series, workshops, and everything else he does for the Shiny community\n\nPhilip Bowsher for everything he does for the R/Pharma conference and community\n\nTed Laderas for his excellent gRadual intRoduction to Shiny course and insightful blog posts\n\nJennifer Bryan and Hadley Wickham for their posit::conf(23) package development masterclass workshop.\nMaya Gans for having multiple conversations and Shiny modules and package dependencies\nLeon Samson for his feedback on the testing chapters",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#footnotes",
    "href": "preface.html#footnotes",
    "title": "Preface",
    "section": "",
    "text": "Testing Shiny apps requires additional packages and tools to ensure an application’s reliability and performance.↩︎\nThe ‘Converting an existing app’ chapter provides an example of converting a Shiny app into an R Package. However, many of the helpful package development tools aren’t available (i.e., roxygen2 tags, NAMESPACE imports/exports, tests, vignettes, etc.).↩︎\ngolem apps are built as packages. Still, EPGSA assumes the reader is ‘comfortable with building an R package.’ (if you’re familiar with package development, EPGSA is an excellent resource).↩︎\nThe original code and data for the application in this book comes from the Building Web Applications with Shiny (BWAS) course.↩︎\nR Packages, 2ed, has a similar chapter that covers developing standard R packages.↩︎\nEric’s LinkedIn↩︎",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Packages help you\nUsing R package development practices will boost your productivity when building applications and make it easier for your collaborators. First, you will have a clear structure for your files. Second, others can easily share and use your work.\nA guiding principle in this book comes from the Benjamin Franklin quote,\nDo future you a favor.\nStandardizing your projects helps anyone reading your code, especially future you. By structuring every Shiny app like an R package, you save time on setup (or re-orienting yourself to each project’s structure). Clear code is essential for Shiny applications in production, and using an R package is a common way to organize your code.1\nIf you’re using RStudio or Positron, the package structure lets you access user-friendly tools for developing Shiny applications. These tools help you develop and test functions, run unit tests, store data, manage dependencies, and create documentation.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#packages-help-you",
    "href": "intro.html#packages-help-you",
    "title": "Introduction",
    "section": "",
    "text": "“a package [is] the fundamental unit of shareable, reusable, and reproducible R code.” - R Packages, 2ed",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#packages-help-them",
    "href": "intro.html#packages-help-them",
    "title": "Introduction",
    "section": "Packages help them",
    "text": "Packages help them\nAssume someone else will read your code.\nR packages provide a standardized way to enhance R’s capabilities, allowing others to install and use them in their R environment. When developing Shiny apps for production deployment, it’s important to remember that the code will likely be accessed and used by others.\nTo quote Marie Kondo, the de-cluttering expert,\n\n“Ensuring that each one of your belongings has its own spot is the only way to maintain a tidy and clutter-free home. Clutter has nothing to do with what or how much you own – it’s the failure to put things back where they belong.”\n\nR packages simplify sharing your work with colleagues by eliminating the need for them to determine where everything is located, how everything connects, and how it works.\n\n\n\n\n\n\nWhat does it mean to ‘put something into production?’\n\n\n\n\n\n\n‘Production’ usually means passing the code from your personal development environment into your company’s cloud-based server environment, which typically involves bundling your app in a structure that can be shared, installed, tested, and launched.\n\n‘I think the easiest way to think about it for me is that we develop a model in one computational environment–think of this as maybe your laptop or maybe you work in a server environment–still, it’s in one place, and it turns out the software that you need to have installed there is about tuning, training, etc. Putting something into production is getting it out of that computational environment and successfully carrying it over to a new computational environment. For many people, this might be like a cloud computing environment. It might be some kind of server your organization has, and we need to take it, lift it, and then successfully have it working.’ - Julia Silge, What is ‘production’ anyway? MLOps for the curious (SatRdays London 2023))\n\nI’ve added emphasis and edited this for clarity.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#packages-are-scalable",
    "href": "intro.html#packages-are-scalable",
    "title": "Introduction",
    "section": "Packages are scalable",
    "text": "Packages are scalable\nGreat R packages solve common problems.\nIf you’ve developed R functions for tasks such as analysis, data visualization, or report generation, consider creating a package instead of using source() to load them. This approach will help you expand your understanding from specific use cases (e.g., “this code performs a specific task”) to a broader perspective (e.g., “this package can perform various tasks”).\nThe advantage of having a mental model for R packages is that you will often observe similarities in common problems. Developing packages that address and solve frequent issues in your workflow can lead to some of the most valuable and popular contributions, as seen with packages like datapasta and reprex`.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#packages-to-know",
    "href": "intro.html#packages-to-know",
    "title": "Introduction",
    "section": "Packages to know",
    "text": "Packages to know\nI highly recommend reading and bookmarking the Shiny articles and the sites for the core package development tools:\n\ndevtools\n\npkgbuild\npkgload\nrcmdcheck\nrevdepcheck\nroxygen2\n\nremotes\nsessioninfo\nusethis",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introduction",
    "section": "",
    "text": "David Neuzerling has a great post on the benefits of structuring your project as a package↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "whole_game.html",
    "href": "whole_game.html",
    "title": "1  Whole app game",
    "section": "",
    "text": "1.1 A toy app-package\nThis chapter is modeled on the Whole Game chapter in R Packages, 2ed.1 We’ll go through the development of the monthAppPkg Shiny app-package (adapted from Mastering Shiny).2\nWe will briefly discuss creating an R package with a Shiny application. Each topic will be explained in detail in the next chapters. In the end, you will have a Shiny application with all the features and functions of an R package.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-description",
    "href": "whole_game.html#sec-use-description",
    "title": "1  Whole app game",
    "section": "1.2 Package metadata",
    "text": "1.2 Package metadata\nEvery R package requires a DESCRIPTION file. You can quickly create one using usethis::use_description().3\n\nusethis::use_description(\n  fields = list(\n    Package = 'monthAppPkg',\n    Title = 'An example app-pkg',\n    Version = '0.0.0.9000',\n    Description = 'A shiny application built inside an R package.',\n    \"Authors@R\" = NULL,\n    Author = utils::person(\n      given = \"Jane\",\n      family = \"Doe\",\n      role = c(\"aut\", \"cre\")\n    ),\n    Maintainer = utils::person(\n      given = \"Jane\",\n      family = \"Doe\",\n      email = \"Jane.Doeh@email.io\"\n    ),\n    License = \"GPL-3\"\n  )\n)\n\nThe values above in the fields list avoids the boilerplate content from use_description().4\nThe essential seven fields are shown below:5\nPackage: monthAppPkg\nTitle: An example app-pkg\nVersion: 0.0.0.9000\nAuthor: Jane Doe [aut, cre]\nMaintainer: Jane Doe &lt;Jane.Doeh@email.io&gt;\nDescription: A shiny application built inside an R package.\nLicense: GPL-3\nYou will get specific fields automatically for function documentation and dependency management.6\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-data",
    "href": "whole_game.html#sec-use-data",
    "title": "1  Whole app game",
    "section": "1.3 Data",
    "text": "1.3 Data\nTo include the birthstones.csv data in monthAppPkg, we’ll create a data-raw/ folder with usethis::use_data_raw(\"stones\"). Next, we’ll move the birthstones.csv file into data-raw/, load it into the Global Environment, and an R package data object witho usethis::use_data():\n\nusethis::use_data_raw(\"stones\")\n\n✔ Setting active project to '/path/to/monthAppPkg'\n✔ Creating 'data-raw/'\n✔ Adding '^data-raw$' to '.Rbuildignore'\n✔ Writing 'data-raw/stones.R'\n• Modify 'data-raw/stones.R'\n• Finish the data preparation script in 'data-raw/stones.R'\n• Use `usethis::use_data()` to add prepared data to package\nMove birthstones.csv to data-raw/birthstones.csv:\n\nfs::file_move(path = \"birthstones.csv\", new_path = \"data-raw/birthstones.csv\")\n\nContents of data-raw/stones.R:\n\n## code to prepare `stones` dataset goes here\nlibrary(vroom)\nstones &lt;- vroom::vroom(\"data-raw/birthstones.csv\")\nusethis::use_data(stones, overwrite = TRUE)\n\nRows: 12 Columns: 2                                                                                                                                \n── Column specification ──────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): month, stone\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nusethis::use_data(stones)\n\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Setting LazyData to 'true' in 'DESCRIPTION'\n✔ Saving 'stones' to 'data/stones.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nData should be documented using roxygen2 which we’ll cover in the data chapter.7",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-dependencies",
    "href": "whole_game.html#sec-use-dependencies",
    "title": "1  Whole app game",
    "section": "1.4 Dependencies",
    "text": "1.4 Dependencies\nEvery Shiny app-package depends on the shiny package. usethis::use_package()8 adds it under the Imports field the DESCRIPTION file.\n\nusethis::use_package(\"shiny\")\n\n✔ Adding 'shiny' to Imports field in DESCRIPTION\n• Refer to functions with `shiny::fun()`\nWe’re advised to use explicit namespacing (i.e., pkg::fun()), but we can avoid this by importing all Shiny’s functions into our package namespace using the @import tag from roxygen2.9",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-r-code",
    "href": "whole_game.html#sec-use-r-code",
    "title": "1  Whole app game",
    "section": "1.5 Package code",
    "text": "1.5 Package code\nCreate new .R files under R/ using use_r():\n\nusethis::use_r(\"monthFeedback\")\n\n✔ Setting active project to '/projects/apps/monthAppPkg'\n• Modify 'R/monthFeedback.R'\nBoth UI and server module functions are stored in R/monthFeedback.R and R/birthstone.R. Tests should also be created for each function.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-load-all",
    "href": "whole_game.html#sec-use-load-all",
    "title": "1  Whole app game",
    "section": "1.6 Loading",
    "text": "1.6 Loading\nShiny app development typically involves something like the following workflow:\n\nWrite UI/server code\n\nClick Run App\n\nRinse, repeat\n\nWhen making the switch from app development to app-package development, calling load_all() is somewhat analogous to clicking on the Run App icon–you’ll do it often (more than any other devtools or usethis function).\n\ndevtools::load_all()\n\nThe output we’re looking for from load_all() is straightforward:\nℹ Loading monthAppPkg\nload_all() is similar to calling library, but it’s specifically designed to be used during package development. Imagine sourcing all the functions in the R/ folder, but more sophisticated.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-package-tests",
    "href": "whole_game.html#sec-use-package-tests",
    "title": "1  Whole app game",
    "section": "1.7 Package tests",
    "text": "1.7 Package tests\nCreate tests for the code in the R/ folder using use_test()\n\nusethis::use_test(\"monthFeedbackServer\")\n\nThis will add test- files in tests/testthat/:\n\ntests/\n├── testthat/\n│   └── test-monthFeedbackServer.R\n└── testthat.R\n\n2 directories, 2 files\n\nThe first time you run use_test(), it will detect if your package has the testthat infrastructure (and create the necessary files if you don’t).10 use_test() will also adds the testthat package to the Suggests field in the DESCRIPTION and includes the edition (currently 3).\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Adding '3' to Config/testthat/edition\nTests are covered in Mastering Shiny,11 on the Shiny website,12 and in various testing packages (like shinytest13 and shinytest214).",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-app-dot-r",
    "href": "whole_game.html#sec-use-app-dot-r",
    "title": "1  Whole app game",
    "section": "1.8 app.R",
    "text": "1.8 app.R\nThe contents of app.R have been changed to include a call to pkgload::load_all() the standalone app function (monthApp()), which is stored in the R/ folder.\n\npkgload::load_all(\".\")\nmonthApp()\n\npkgload needs to be listed under Imports in the DESCRIPTION file (just like we did with shiny above).\n\nusethis::use_package(\"pkgload\")\n\n✔ Adding 'pkgload' to Imports field in DESCRIPTION\n• Refer to functions with `pkgload::fun()`\nBecause we’re only going to use load_all() from pkgload, we’ll use explicit namespacing (i.e., pkg::fun()).15\n\n1.8.1 use_package_doc()\nThe use_package_doc() creates the R/[[name]-package].R file, which can be used as a single location for declaring dependencies in monthAppPkg:\n\nusethis::use_package_doc()\n\n✔ Setting active project to 'projects/apps/monthAppPkg'\n✔ Writing 'R/monthAppPkg-package.R'\n• Modify 'R/monthAppPkg-package.R'\nWe’ll use @importFrom to add only the load_all() function to the NAMESPACE.\n\n#' @keywords internal\n\"_PACKAGE\"\n\n## usethis namespace: start\n#' @importFrom pkgload load_all\n## usethis namespace: end\nNULL\n\n\n\n1.8.2 use_build_ignore()\nR packages don’t typically have an app.R file in their root folder, so we’ll let devtools know this file should be ignored by creating a .Rbuildignore and include a pattern that excludes app.R whenever the package is built.\n\nusethis::use_build_ignore(\"app.R\")\n\n✔ Adding '^app\\\\.R$' to '.Rbuildignore'\nIt’s best to let use_build_ignore() handle excluding any files or folders from your package builds because it automatically writes the correct regular expression pattern.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-license-file",
    "href": "whole_game.html#sec-use-license-file",
    "title": "1  Whole app game",
    "section": "1.9 LICENSE",
    "text": "1.9 LICENSE\nUse one of the usethis license functions to add a LICENSE file.\n\nusethis::use_mit_license()\n\nThe license file should match the License field in the DESCRIPTION file (in this case, it’s MIT).16\n✔ Adding 'MIT + file LICENSE' to License\n✔ Writing 'LICENSE'\n✔ Writing 'LICENSE.md'\n✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-roxygen2",
    "href": "whole_game.html#sec-use-roxygen2",
    "title": "1  Whole app game",
    "section": "1.10 Document",
    "text": "1.10 Document\nAfter writing roxygen2 documentation for the data, modules, and standalone app function, calling devtools::document()() generates the .Rd files and NAMESPACE.17\n\ndevtools::document()\n\nThe output from document() tells us what files have been created (and if there were any errors in them).18\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nWriting NAMESPACE\nWriting NAMESPACE\nWriting birthstoneUI.Rd\nWriting birthstoneServer.Rd\nWriting monthApp.Rd\nWriting monthFeedbackUI.Rd\nWriting monthFeedbackServer.Rd\n\n1.10.1 Namespace\nThe NAMESPACE file contains the imported and exported functions from monthAppPkg:19\n# Generated by roxygen2: do not edit by hand\n\nexport(birthstoneServer)\nexport(birthstoneUI)\nexport(monthApp)\nexport(monthFeedbackServer)\nexport(monthFeedbackUI)\nimport(shiny)\nimportFrom(pkgload,load_all)",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-rstudio-project-options",
    "href": "whole_game.html#sec-use-rstudio-project-options",
    "title": "1  Whole app game",
    "section": "1.11 RStudio project options ",
    "text": "1.11 RStudio project options \nIf you’re developing in RStudio, we need to update our .Rproj file to enable the Build pane and keyboard shortcuts:\n\nfile.edit(\"monthAppPkg.Rproj\")\n\nIf your app-package was initially built as an RStudio project (i.e., not as a package), the following fields should be included at the bottom of monthAppPkg.Rproj:\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\nThese options are also available under Tools &gt; Project Options … &gt; Build Tools",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-git",
    "href": "whole_game.html#sec-use-git",
    "title": "1  Whole app game",
    "section": "1.12 Git",
    "text": "1.12 Git\nThe use_git() step is performed much earlier in R Packages, 2ed, but I’ve saved it for this step because using Git will prompt the IDE to re-initialize and display the Git pane (and it will also read our new settings in the .Rproj file).\n✔ Setting active project to '/projects/apps/monthAppPkg'\n✔ Initialising Git repo\n✔ Adding '.Rproj.user', '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\nThere are 12 uncommitted files:\n* '.gitignore'\n* '.Rbuildignore'\n* 'app.R'\n* 'data/'\n* 'DESCRIPTION'\n* 'LICENSE'\n* 'LICENSE.md'\n* 'man/'\n* 'monthAppPkg.Rproj'\n* 'NAMESPACE'\n* ...\nIs it ok to commit them?\n\n1: Absolutely not\n2: Not now\n3: Absolutely\nAgree to commit these files:\nSelection: 3\n✔ Adding files\n✔ Making a commit with message 'Initial commit'\n• A restart of RStudio is required to activate the Git pane\nRestart now?\n\n1: Not now\n2: Negative\n3: Absolutely\nRestarting RStudio will activate the Git and Build panes:\n\n\n\n\n\n\n\nGit Pane\n\n\n\n\n\n\n\n\n\nBuild Pane\n\n\nThis will also activate the devtools keyboard shortcuts:",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-keyboard-shortcuts",
    "href": "whole_game.html#sec-use-keyboard-shortcuts",
    "title": "1  Whole app game",
    "section": "1.13 Keyboard shortcuts",
    "text": "1.13 Keyboard shortcuts\nThe devtools keyboard shortcuts are available in RStudio and Positron.\n\n\n\n\n\n\nload_all()\nShift + Ctrl/Cmd + L\n\n\ndocument()\nShift + Ctrl/Cmd + D\n\n\n\n\ninstall()\nShift + Ctrl/Cmd + B\n\n\ntest()\nShift + Ctrl/Cmd + T",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-pkg-install",
    "href": "whole_game.html#sec-use-pkg-install",
    "title": "1  Whole app game",
    "section": "1.14 Install",
    "text": "1.14 Install\nInstalling monthAppPkg with devtools::install() produces see the following output in the Build pane:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nDocumentation completed\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source monthAppPkg\n\n* installing to library ‘/path/to/Library/R/x86_64/4.2/library’\n* installing *source* package ‘monthAppPkg’ ...\n** using staged installation\n** R\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (monthAppPkg)\nBack in the Console, RStudio will restart and call library(monthAppPkg):\nRestarting R session...\n\n&gt; library(monthAppPkg)\nWe can now launch the app using monthApp()\n\nmonthApp()\n\n\n\n\nOur monthApp() application\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('01_whole-app-game')",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#sec-use-additional-files",
    "href": "whole_game.html#sec-use-additional-files",
    "title": "1  Whole app game",
    "section": "1.15 Additional files",
    "text": "1.15 Additional files\nThe following sections cover additional files you should include in your ap-package (but are not required).\n\n1.15.1 README\nA README.md file is the initial point of contact for users and/or contributors looking for information about your app-package. use_readme_rmd() will create a README.Rmd (i.e., the file you’ll edit), which serves as the source document for your README.md.\n\nusethis::use_readme_rmd()\n\nThe README.Rmd pattern is automatically added to the .Rbuildignore, and includes a Git ‘pre-commit’ hook:20\n✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n✔ Writing '.git/hooks/pre-commit'\n\n\n1.15.2 NEWS.md\nA NEWS.md is helpful for logging updates to your app-package and tracking release information.\n\nusethis::use_news_md()\n\nuse_news_md() will also prompt me to add and commit this file to the Git repository:\nThere is 1 uncommitted file:\n* 'NEWS.md'\nIs it ok to commit it?\n\n1: Negative\n2: Yeah\n3: Absolutely not\n\nSelection: 2\n✔ Adding files\n✔ Making a commit with message 'Add NEWS.md'\nThe contents of the NEWS.md are below:21\n# monthAppPkg (development version)\n\n* Initial CRAN submission.\n\n\n1.15.3 Vignettes\nVignettes can be used to store detailed tutorials, explanations of core concepts, use-cases, FAQs and troubleshooting, integration with other packages, etc.\n\nuse_vignette(\"monthAppPkg\")\n\nThe first time we call use_vignette() will prompt usethis to add the following fields in the DESCRIPTION:\n✔ Adding 'knitr' to Suggests field in DESCRIPTION\n✔ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✔ Adding 'knitr' to VignetteBuilder\nThe following files are also included in the .gitignore:\n✔ Adding 'inst/doc' to '.gitignore'\n✔ Creating 'vignettes/'\n✔ Adding '*.html', '*.R' to 'vignettes/.gitignore'",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#recap",
    "href": "whole_game.html#recap",
    "title": "1  Whole app game",
    "section": "1.16 Recap",
    "text": "1.16 Recap\nIn this chapter we’ve covered the steps used to create a package containing a Shiny application.\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "whole_game.html#footnotes",
    "href": "whole_game.html#footnotes",
    "title": "1  Whole app game",
    "section": "",
    "text": "The example app comes from the Packages chapter of Mastering Shiny↩︎\nI’ve stored the code for this application in the 01_whole-app-game branch of the sap repository (to avoid confusing it with the actual application repo for this chapter).↩︎\nThe Whole Game chapter of R Packages, 2ed begins with the usethis::create_package() function, which calls usethis::use_description() internally.↩︎\nAt the time this was written, there are over 4,000 hits with the boilerplate value for Description (i.e., \"What the package does\"), which is a sign of how much usethis has been adopted (and how often people forget to come back and edit their DESCRIPTION file).↩︎\nIf you frequently develop R packages or Shiny apps, consider adding these fields to your .Rprofile.↩︎\nAlways leave an empty final line in the DESCRIPTION.↩︎\nView the documented stones dataset here on GitHub.↩︎\nWhenever you use a function from another package, start by running usethis::use_package() to ensure it’s in the DESCRIPTION file.↩︎\nI’ve included @import shiny above the definition of our standalone app function (R/launch_app.R), which means I don’t need to add shiny:: when using Shiny functions belowR/.↩︎\nYou can also set up the testthat infrastructure by calling usethis::use_testthat()↩︎\nThe Testing chapter in Mastering Shiny covers unit tests with testthat, shiny::testServer(), and the shinytest package.↩︎\nSee the ‘Server Function Testing’ article on the Shiny website for more information on testServer()↩︎\nCheck the shinytest package website and video tutorial for more information on testing your app.↩︎\nshinytest2 is an updated verison of shinytest with excellent documentation and videos.↩︎\nWe typically call devtools::load_all(), but using pkgload reduces the number of dependencies included with devtools. Read more about pkgload in the ‘Conscious uncoupling’ of devtools.↩︎\nuse_mit_license() will automatically include the LICENSE.md file in the root folder (and includes the necessary pattern in the .Rbuildignore to exclude it from the package builds).↩︎\nYou can include an Roxygen skeleton in the IDE by clicking on Code &gt; Insert Roxygen Skeleton, or using the keyboard shortcut: Option/⌥ + Shift⇧ + Ctrl/Cmd + R↩︎\nThe files created by document() rely on the roxygen2 package (and should not be edited manually).↩︎\nWe’re importing the everything from shiny and only load_all from pkgload):↩︎\nThis Git behavior is designed to prevent us from making changes to the README.Rmd and forgetting to re-render the README.md. If you find this behavior confusing or would like to disable it, run the following commands in the Terminal: rm .git/hooks/pre-commit↩︎\nThe Initial CRAN submission bullet doesn’t apply to monthAppPkg, so I’ll remove it and re-commit/push the NEWS.md file.↩︎",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Whole app game</span>"
    ]
  },
  {
    "objectID": "shiny.html",
    "href": "shiny.html",
    "title": "2  Shiny",
    "section": "",
    "text": "Shiny basics\nReactivity is the process that lets Shiny apps respond to user actions automatically. When developing Shiny apps, we need to connect inputs, reactivity, and outputs to manage how the app behaves and predict its actions.\nShiny programming is different from regular R programming in a few important ways:\nLearning reactivity can be challenging when you start, but fortunately, there are excellent tutorials and articles to help you along the way!",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#shiny-basics",
    "href": "shiny.html#shiny-basics",
    "title": "2  Shiny",
    "section": "",
    "text": "An Event-driven UI: Shiny apps require developers to create a user interface (UI) that helps users navigate the app. The UI registers user actions, such as button clicks or input changes, which trigger updates in the application.1\n\nRegular R programming often involves executing predefined steps or functions without direct interaction or responses to user events.\n\nA Reactive Server: In Shiny, the app reacts based on how inputs, values, and outputs are connected, which means that when a user makes a change, those changes are automatically shared throughout the app.\n\nIn standard R programming, we write functions to process data and generate outputs like graphs, tables, and model results. This method does not account for reactivity or downstream changes.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-shiny-projects",
    "href": "shiny.html#sec-shiny-projects",
    "title": "2  Shiny",
    "section": "2.1 Shiny projects ",
    "text": "2.1 Shiny projects \n\n\nLaunch app with the shinypak package:\n\nlaunch('02.1_shiny-app')\n\nRStudio’s New Project Wizard  can be used to create a new Shiny application project:\n\n\n\n\n\n\n\nNew Shiny app project\n\n\nNew app projects need a name and location:\n\n\n\n\n\n\n\nWe can also decide whether we want to use Git or renv\n\n\n\n2.1.1 Boilerplate app.R\nNote that the only items in the new Shiny app project are app.R and the sap.Rproj file.\n\nsap/\n    ├── app.R\n    └── sap.Rproj\n\n1 directory, 2 files\n\nIf you’ve created a new app project in RStudio , the app.R initially contains a boilerplate application, which we can launch by clicking on the Run App button:\n\n\n\n\n\n\n\n\n\nClick on Run App\n\n\n\n\n\n\n\n\n\n\n\n(a) Old Faithful geyser app\n\n\n\n\n\nFigure 2.1: Boilerplate Old Faithful geyser app in new Shiny projects\n\n\n\nThe boilerplate ‘Old Faith Geyser Data’ app is a perfect example of what Shiny can do with a single app.R file, but we’ll want to exchange this code for a more realistic application.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-introduce-movie-review-app",
    "href": "shiny.html#sec-introduce-movie-review-app",
    "title": "2  Shiny",
    "section": "2.2 Movies app",
    "text": "2.2 Movies app\n\n\nLaunch app with the shinypak package:\n\nlaunch('02.2_movies-app')\n\nThe next few sections will cover some intermediate/advanced Shiny app features using the Shiny app from the ‘Building Web Applications with Shiny’ course. This app is a great example for the following reasons:\n\nIt has multiple input types that are collected in the UI\nThe graph output can be converted to a utility function\nThe app loads an external data file when it’s launched\nThe code is accessible (and comes from a trusted source)\n\nAs Shiny applications become more complex, they often grow beyond just one app.R file. Knowing how to store utility functions, data, documentation, and metadata is important to manage this complexity. This preparation helps us successfully organize our Shiny apps into R packages.\n\n2.2.1 app.R\nThe code below replaces our boilerplate ‘Old Faith Geyser Data’ app in app.R:\n\n\nshow/hide movie review Shiny app\nui &lt;- shiny::fluidPage(\n  theme = shinythemes::shinytheme(\"spacelab\"),\n  shiny::sidebarLayout(\n    shiny::sidebarPanel(\n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.4\n      ),\n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 3\n      ),\n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n      shiny::actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n    shiny::mainPanel(\n      shiny::br(),\n      shiny::p(\n        \"These data were obtained from\",\n        shiny::a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n        shiny::a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \".\"\n      ),\n      shiny::p(\n        \"The data represent\",\n        nrow(movies),\n        \"randomly sampled movies released between 1972 to 2014 in the United States.\"\n      ),\n      shiny::plotOutput(outputId = \"scatterplot\"),\n      shiny::hr(),\n      shiny::p(shiny::em(\n        \"The code for this Shiny application comes from\",\n        shiny::a(\"Building Web Applications with shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"\n        )\n      ))\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- shiny::reactive({\n    tools::toTitleCase(input$plot_title)\n  }) |&gt;\n    shiny::bindEvent(input$update_plot_title,\n      ignoreNULL = FALSE,\n      ignoreInit = FALSE\n    )\n\n\n  output$scatterplot &lt;- shiny::renderPlot({\n    scatter_plot(\n      df = movies,\n      x_var = input$x,\n      y_var = input$y,\n      col_var = input$z,\n      alpha_var = input$alpha,\n      size_var = input$size\n    ) +\n      ggplot2::labs(title = new_plot_title()) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\n2.2.2 Utility functions\nI’ve converted ggplot2 server code into a scatter_plot() utility function:\n\n\nshow/hide scatter_plot()\nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\nThis function is stored in a new utils.R file:\n\n\n2.2.3 Data\nThe movies.RData dataset contains reviews from IMDB and Rotten Tomatoes. You can download these data here. The sap project now contains the following files:\n\nsap/\n  ├── app.R\n  ├── movies.RData\n  ├── sap.Rproj\n  └── utils.R\n\n2 directories, 4 files\n\nTo run the movies app, we need to load the data and source the utils.R file by adding the code below to the top of the app.R file:\n\n# install ------------------------------------\n# install pkgs, then comment or remove below\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# data -----------------------------------------\nload(\"movies.RData\")\n\n# utils ----------------------------------------\nsource(\"utils.R\")\n\n\n1\n\nInstall pkgs, then comment or remove below\n\n\n\n\nClicking on Run App displays the movie review app:\n\n\n\n\n\n\n\nMovie review app",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-shiny-folders",
    "href": "shiny.html#sec-shiny-folders",
    "title": "2  Shiny",
    "section": "2.3 Folders",
    "text": "2.3 Folders\nNow that we have a slightly more complex application in app.R, I’ll add a few project folders we can include in our project that have unique built-in behaviors. These folders will help organize your files and make additional resources available to your app.\n\n\nLaunch app with the shinypak package:\n\nlaunch('02.3_proj-app')\n\n\n2.3.1 R/\nIf your Shiny app relies on utility or helper functions outside the app.R file, place this code in an R/ folder. Any .R files in the R/ folder will be automatically sourced when the application is run.\n\n\n\n\n\n\nPlace utils.R in R/ folder\n\n\n\n\n\nI’ve moved the utils.R file into the R/ folder in sap:\n\nsap/\n     └── R/\n         └── utils.R\n\n1 directory, 1 file\n\n\n\n\nShiny’s loadSupport() function makes this process possible. We’ll return to this function in a later chapter, because the R/ folder has a similar behavior in R packages.2\n\n\n2.3.2 www/\nWhen you run a Shiny application, any static files (i.e., resources) under a www/ directory will automatically be made available within the application. This folder stores images, CSS or JavaScript files, and other static resources.\n\n\n\n\n\n\nCreate www/ folder and download image\n\n\n\n\n\nI’ve downloaded the Shiny logo (shiny.png) and stored it in the www/ folder.\n\nsap/\n     └── www/\n           └── shiny.png\n\n1 directory, 1 file\n\nIn the section below, we’ll reference shiny.png directly in the UI.\n\n\n\nFollowing the conventional folder structure will also help set you up for success when/if you decide to convert it into an app-package.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-shiny-files",
    "href": "shiny.html#sec-shiny-files",
    "title": "2  Shiny",
    "section": "2.4 Files",
    "text": "2.4 Files\nThe sections below cover additional files to include in your Shiny app. None of these files are required, but including them will make the transition to package development smoother.\n\n2.4.1 README\nIncluding a README.md file in your root folder is a good practice for any project. Using the standard markdown format (.md) guarantees it can be read from GitHub, too. README.md files should contain relevant documentation for running the application.\n\n\n\n\n\n\nCreate README.md\n\n\n\n\n\nI’ve included the content below in the README.md file\n# movies app\n\nThe original code and data for this Shiny app comes from the [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) course. It's been converted to use [shiny modules](https://shiny.posit.co/r/articles/improve/modules/). \n\nView the code for this application in the [`sap` branches](https://github.com/mjfrigaard/sap/branches/all).\n\n\n\n\n\n2.4.2 DESCRIPTION\nDESCRIPTION files play an essential role in R packages, but they are also helpful in Shiny projects if I want to deploy the app in showcase mode.\n\n\n\n\n\n\nCreate DESCRIPTION\n\n\n\n\n\nI’ve included the content below in DESCRIPTION:\n\nType: shiny\nTitle: movies app\nAuthor: John Smith\nDisplayMode: Showcase                                                 \n                                                                      \n\n\n\n\n\n\n\nIt’s always a good idea to leave at least one &lt;empty final line&gt; in your DESCRIPTION file.\n\nAfter adding README.md and a DESCRIPTION file (listing DisplayMode: Showcase), the movies app will display the code and documentation when the app launches.3",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-app-code",
    "href": "shiny.html#sec-app-code",
    "title": "2  Shiny",
    "section": "2.5 Code",
    "text": "2.5 Code\nThe following two items are considered best practices because they make your app more scalable by converting app.R into functions.\n\n2.5.1 Modules\nShiny modules are a ‘pair of UI and server functions’ designed to compartmentalize input and output IDs into distinct namespaces,\n\n‘…a namespace is to an ID as a directory is to a file…’ - shiny::NS() help file\n\nModule UI functions usually combine the layout, input, and output functions using tagList(). Module server functions handle the ‘backend’ logic within a Shiny server function. UI and server module functions are connected through an id argument. The UI function creates this id with NS() (namespace), and the server function uses moduleServer() to call it.\n\n2.5.1.1 Inputs\nThe mod_var_input_ui() function creates a list of inputs (column names and graph aesthetics) in the UI:\n\n\nshow/hide mod_var_input_ui()\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n1      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n2      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n3      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n4      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n5      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n6      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace',\"fontSize\":\"16px\"}}}%%\nflowchart TD\n    User([\"User\"])\n    subgraph mod_var_input_server[\"&lt;strong&gt;mod_var_input_server()&lt;/strong&gt;\"]\n        XServer[\\\"input$x\"\\]\n        YServer[\\\"input$y\"\\]\n        ZServer[\\\"input$z\"\\]\n        AlphaServer[\\\"input$alpha\"\\]\n        SizeServer[\\\"input$size\"\\]\n        TitleServer[\\\"input$plot_title\"\\]\n    end\n    subgraph mod_var_input_ui[\"&lt;strong&gt;mod_var_input_ui()&lt;/strong&gt;\"]\n        XUI[/\"X-axis\"/]\n        YUI[/\"Y-axis\"/]\n        ZUI[/\"Color by\"/]\n        AlphaUI[/\"Alpha\"/]\n        SizeUI[/\"Size\"/]\n        TitleUI[/\"Plot title\"/]\n    end\n    User --&gt; |\"&lt;em&gt;Selects...&lt;/em&gt;\"|mod_var_input_ui\n    mod_var_input_ui --&gt;|\"&lt;em&gt;Collects...&lt;/em&gt;\"| mod_var_input_server\n    mod_var_input_server --&gt; |\"&lt;em&gt;Returns...&lt;/em&gt;\"|Return([\"Reactive&lt;br&gt;list\"])\n    \n\n\n Variable input module \n\n\n\nmod_var_input_server() returns these values in a reactive list:\n\n\nshow/hide mod_var_input_server()\nmod_var_input_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n        reactive({\n          list(\n1            \"y\" = input$y,\n2            \"x\" = input$x,\n3            \"z\" = input$z,\n4            \"alpha\" = input$alpha,\n5            \"size\" = input$size,\n6            \"plot_title\" = input$plot_title\n          )\n        })\n    )\n  })\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\n\n\n2.5.1.2 Display\nmod_scatter_display_ui() creates a dedicated namespace for the plot output (along with some help text):\n\n\nshow/hide mod_scatter_display_ui()\nmod_scatter_display_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\"The data for this application comes from the \",\n        shiny::tags$a(\"Building web applications with Shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"),\n                      \"tutorial\"))\n      ),\n1    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\n\n1\n\nNamespaced module id for plot in UI\n\n\n\n\nmod_scatter_display_server() loads the movies data and collects the returned reactive list from variable input module as var_inputs.\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    User([\"User\"])\n    mod_var_input_ui[\"&lt;strong&gt;mod_var_input_ui()&lt;/strong&gt;\"]\n    mod_scatter_display_ui[\"&lt;strong&gt;mod_scatter_display_ui&lt;/strong&gt;\"] \n    \n    subgraph mod_scatter_display_server[\"&lt;strong&gt;mod_scatter_display_server()&lt;/strong&gt;\"]\n        var_inputs[\\\"var_inputs()\"\\]\n        inputs[\\\"inputs()\"\\]\n        scatter_plot(\"scatter_plot()\")\n    end\n    \n    subgraph mod_var_input_server[\"&lt;strong&gt;mod_var_input_server()&lt;/strong&gt;\"]\n        Reactives[/\"input$x&lt;br&gt;input$y&lt;br&gt;input$z&lt;br&gt;input$alpha&lt;br&gt;input$size\"/]\n        Title[/\"input$plot_title\"\\]\n    end\n    \n    User --&gt; |\"&lt;em&gt;Selects inputs...&lt;/em&gt;\"|mod_var_input_ui\n    mod_var_input_ui --&gt; |\"&lt;em&gt;Collects inputs..&lt;/em&gt;\"|mod_var_input_server\n    Reactives --&gt;|\"&lt;em&gt;Returns inputs...&lt;/em&gt;\"|selected_vars\n    Title -.-&gt; |\"&lt;em&gt;Optional input...&lt;/em&gt;\"|selected_vars\n    selected_vars[/\"selected inputs\"/] --&gt;|\"&lt;em&gt;Input argument for...&lt;/em&gt;\"|mod_scatter_display_server\n    var_inputs --&gt; inputs --&gt; scatter_plot\n    scatter_plot --&gt;|\"&lt;em&gt;Renders plot...&lt;/em&gt;\"|mod_scatter_display_ui\n    mod_scatter_display_ui --&gt;|\"&lt;em&gt;Displays output...&lt;/em&gt;\"|Display([\"Graph\"])\n    \n    style mod_scatter_display_ui stroke-width:2px,rx:3,ry:3\n    style mod_scatter_display_server stroke-width:2px,rx:3,ry:3\n    style mod_var_input_ui stroke-width:2px,rx:3,ry:3\n    style mod_var_input_server stroke-width:2px,rx:3,ry:3\n    style scatter_plot stroke-width:2px,rx:10,ry:10\n    style Reactives font-size:15px,stroke-width:1px,rx:5,ry:5\n    style Title font-size:15px,stroke-width:1px,rx:5,ry:5\n\n\n Display module \n\n\n\nvar_inputs() is used to build the inputs() reactive, which is passed to the scatter_plot() utility function. scatter_plot() creates the graph, adds the plot_title() (if necessary) and theme:\n\n\nshow/hide mod_scatter_display_server()\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    \n1    load(\"movies.RData\")\n\n2    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n3    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n4      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(\n                  tools::toTitleCase(\n                      inputs()$x),\n                  \"_\", \" \"),\n          y = stringr::str_replace_all(\n                  tools::toTitleCase(\n                    inputs()$y),\n                \"_\", \" \")\n        ) + \n5        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n1\n\nloading the movies data\n\n2\n\nassembling the returned values from mod_var_input_server(), and creating the input() reactive\n\n3\n\nscatter_plot() utility function creates the plot object\n\n4\n\nadds the plot_title()\n\n5\n\nadd theme to layers\n\n\n\n\nBoth UI and server module functions are combined into a single .R file, and all modules are placed in the R/ folder so they are sourced when the application is run.\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n └── utils.R\n\n\n\n\n2.5.2 Standalone app function\nInstead of using shiny::shinyApp() (or the Run App icon), we’ll want a custom standalone app function to launch our application. This give us more flexibility and control with our modules (and makes debugging easier).\n\n\nshow/hide launch_app()\nlaunch_app &lt;- function() { \n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n1          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n2          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      \n3      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n4      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\n\n\n\n1\n\nVariable input UI module\n\n2\n\nGraph display UI module\n\n3\n\nVariable input server module\n\n4\n\nGraph display server module\n\n\n\n\nThe id arguments (\"vars\" and \"plot\") connect the UI functions to their server counterparts, and the output from mod_var_input_server() is the var_inputs argument in mod_scatter_display_server().\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart LR\n    subgraph Launch[\"&lt;code&gt;launch_app()&lt;/code&gt;\"]\n        subgraph VarNS[\"Variable (&lt;code&gt;vars&lt;/code&gt;) Namespace\"]\n            VarInpuUI[\"UI Module:&lt;br&gt;&lt;code&gt;mod_var_input_ui()&lt;/code&gt;\"]\n            VarInpuServer[\"Server Module:&lt;br&gt;&lt;code&gt;mod_var_input_server()&lt;/code&gt;\"]\n            VarInpuUI &lt;--&gt; VarInpuServer\n        end\n        subgraph GraphNS[\"Graph (&lt;code&gt;plot&lt;/code&gt;) Namespace\"]\n        DisplayUI[\"UI Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_ui()&lt;/code&gt;\"]\n        DisplayServer[\"Server Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_server()&lt;/code&gt;\"]\n        PlotUtil[\"Utility Function:&lt;br&gt;&lt;code&gt;scatter_plot()&lt;/code&gt;\"]\n        VarInpuServer &lt;--&gt;|\"selected_vars\"|DisplayServer\n        DisplayServer &lt;-.-&gt; PlotUtil &lt;--&gt; DisplayUI\n        end\n    end\n\n    VarNS &lt;==&gt;|\"Communicates&lt;br&gt;across namespaces\"| GraphNS\n\n\n\n Standalone app function \n\n\n\nTo launch our app, we place the call to shinyApp() in a launch_app() function in app.R. Both module functions are combined in the ui and server arguments of shinyApp().\n\n\nshow/hide launch_app() in app.R\n# install ------------------------------------\n# after installing, comment this out\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\n2library(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\nlaunch_app &lt;- function() { \n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n3          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n4          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      \n5      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n6      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\nlaunch_app()\n\n\n\n1\n\nHeader (comment this out after the packages are installed)\n\n2\n\nLoad packages\n\n\n3\n\nVariable input UI module\n\n4\n\nGraph display UI module\n\n5\n\nVariable input server module\n\n6\n\nGraph display server module\n\n\n\n\nNow, I can run the app with launch_app().\n\n\n\n\n\n\n\nView a deployed version here\n\n\nThe deployed files of sap are below:\n\nsap/ # 02.3_proj-app branch\n├── DESCRIPTION\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── sap.Rproj\n├── rsconnect/\n│   └── shinyapps.io/\n│       └── user/\n│           └── sap.dcf\n└── www/\n    └── shiny.png\n\n6 directories, 10 files\n\n\n\nThe rsconnect/ folder has been removed from the 02.3_proj-app branch.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#sec-adv-shiny-projects",
    "href": "shiny.html#sec-adv-shiny-projects",
    "title": "2  Shiny",
    "section": "2.6 Additional features",
    "text": "2.6 Additional features\nBelow are two additional ‘optional’ features that can be included with your Shiny application. I consider these ‘optional’ because they’re use depends on the specific needs and environment for each application.\n\n2.6.1 Globals\nPlacing a global.R file in your root folder (or in the R/ directory) causes this file to be sourced only once when the Shiny app launches, rather than each time a new user connects to the app. global.R is commonly used for initializing variables, loading libraries, loading large data sets and/or performing initial calculations.\n\n\n\n\n\n\nUsing global.R\n\n\n\n\n\nI could place the header from app.R in global.R to ensure these packages are loaded before the application launches:\n\n\nshow/hide contents of R/global.R\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n\nglobal.R can be placed in the R/ folder\n\nR/\n├── global.R\n├── mod_scatter_display.R\n├── mod_var_input.R\n└── utils.R\n\n1 directory, 4 files\n\nOr in the project root folder\n\n├── DESCRIPTION\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── global.R\n├── man\n├── movies.RData\n├── sap.Rproj\n└── www\n    └── shiny.png\n\n4 directories, 10 files\n\nIn both locations, it will be sourced before launching the application.\n\n\n\nglobal.R can be used to maintain efficiency and consistency across application sessions.\n\n\n2.6.2 Project dependencies (renv)\nIf you use renv, keep track of your dependencies by regularly running renv::status() and renv::snapshot().\n\n\n\n\n\n\nUsing renv\n\n\n\n\n\nStart by initiating renv with renv::init(), then run renv::status() to check which packages have been added to the lockfile:\n\nrenv::status()\n\nThe following package(s) are in an inconsistent state:\n\n package      installed recorded used\n colorspace   y         n        y   \n fansi        y         n        y   \n farver       y         n        y   \n ggplot2      y         n        y   \n gtable       y         n        y   \n isoband      y         n        y   \n labeling     y         n        y   \n lattice      y         n        y   \n MASS         y         n        y   \n Matrix       y         n        y   \n mgcv         y         n        y   \n munsell      y         n        y   \n nlme         y         n        y   \n pillar       y         n        y   \n pkgconfig    y         n        y   \n RColorBrewer y         n        y   \n scales       y         n        y   \n shinythemes  y         n        y   \n tibble       y         n        y   \n utf8         y         n        y   \n vctrs        y         n        y   \n viridisLite  y         n        y   \nTake a ‘snapshot’ to capture the current package dependencies:\n\nrenv::snapshot()\n\nThe following package(s) will be updated in the lockfile:\n\n# CRAN --------------------------------------------------\n- lattice        [* -&gt; 0.21-8]\n- MASS           [* -&gt; 7.3-60]\n- Matrix         [* -&gt; 1.5-3]\n- mgcv           [* -&gt; 1.8-42]\n- nlme           [* -&gt; 3.1-162]\n- vctrs          [* -&gt; 0.6.3]\n\n# RSPM --------------------------------------------------\n- colorspace     [* -&gt; 2.1-0]\n- fansi          [* -&gt; 1.0.4]\n- farver         [* -&gt; 2.1.1]\n- ggplot2        [* -&gt; 3.4.2]\n- gtable         [* -&gt; 0.3.3]\n- isoband        [* -&gt; 0.2.7]\n- labeling       [* -&gt; 0.4.2]\n- munsell        [* -&gt; 0.5.0]\n- pillar         [* -&gt; 1.9.0]\n- pkgconfig      [* -&gt; 2.0.3]\n- RColorBrewer   [* -&gt; 1.1-3]\n- scales         [* -&gt; 1.2.1]\n- shinythemes    [* -&gt; 1.2.0]\n- tibble         [* -&gt; 3.2.1]\n- utf8           [* -&gt; 1.2.3]\n- viridisLite    [* -&gt; 0.4.2]\n\nDo you want to proceed? [Y/n]: y\n\n- Lockfile written to '~/path/to/sap/renv.lock'.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#recap",
    "href": "shiny.html#recap",
    "title": "2  Shiny",
    "section": "2.7 Recap",
    "text": "2.7 Recap\nThis chapter has covered some differences between developing Shiny apps and regular R programming, creating new Shiny projects in Posit Workbench, and some practices to adopt that can make the transition to app-packages a little easier. The code used in this chapter is stored in the sap repository.\n\n\n\n\n\n\nRecap\n\n\n\n\n\n\n\nPlacing utility or helper files in an R/ folder removes the need to call source() in app.R.\nImages, CSS, JavaScript, and other static resources can be stored in www/ and Shiny will serve these files when the application is run.\nREADME.md files can document the application’s description, purpose, requirements, etc.\nDESCRIPTION files provide metadata and include fields that affect application deployment (i.e., DisplayMode: Showcase)\nConverting the application code into functions (modules and standalone app functions) creates a ‘division of labor’ for each component, which makes it easier to think about and work on them independently.\nFinally, if you’re using renv, run renv::status() and renv::snapshot() to manage dependencies\n\n\n\n\n\nIn the next chapter, I’ll cover what makes a package a package, and some do’s and don’ts when converting a developed Shiny application into an R package.\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "shiny.html#footnotes",
    "href": "shiny.html#footnotes",
    "title": "2  Shiny",
    "section": "",
    "text": "Shiny apps require developers to design and develop a user interface (UI). User experience (UX) design is an entirely separate field, but as Shiny developers, we need to know enough to allow users to interact with and navigate our apps.↩︎\nShiny introduced these features in version 1.3.2.9001, and you can read more about them in the section titled, ‘The R/ directory’ in App formats and launching apps↩︎\nRead more about showcase mode here↩︎",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Shiny</span>"
    ]
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "3  Packages",
    "section": "",
    "text": "3.1 R packages\nBefore we start, we should establish some operational definitions of what is meant by the terms ‘project,’ ‘package,’ and ‘app-package.’\nThere are multiple reasons for deciding to develop a Shiny app-package, but if you’re reading this book, you’ve likely found yourself in one of two circumstances:\nThe previous chapters covered a few practices to adopt during development that improve the extensibility of your app and will make it easier to convert into a Shiny app-package.3\nR packages can be easily shared, reused, and reproduced because they all have a similar structure, and each folder and file plays an essential role in extending R’s capabilities. Below is a folder tree with some of the typical files and folders found in R packages:4\n&lt;R package&gt;/\n1    ├── DESCRIPTION\n2    ├── &lt;R package&gt;.Rproj\n3    ├── LICENSE\n    ├── LICENSE.md\n4    ├── NAMESPACE\n5    ├── NEWS.md\n6    ├── README.Rmd\n    ├── README.md\n7    ├── renv.lock\n8    ├── R/\n9    ├── man/\n10    ├── tests/\n11    ├── data/\n12    ├── data-raw/\n13    ├── vignettes/\n14    ├── inst/\n15    └── renv/\n  \n\n\n1\n\nMetadata file with the package’s purpose, dependencies, authors, and other essential information.\n\n\n2\n\nRStudio project file for managing and organizing the package’s development environment.\n\n3\n\nSpecifies the terms under which the package can be used, modified, and distributed.\n\n4\n\nDefines the functions and datasets exported by the package and the imports from other packages.\n\n\n5\n\nContains a changelog detailing updates and changes made across package versions.\n\n6\n\nProvides an overview of the package, usage examples, and installation instructions (typically for display on GitHub).\n\n\n7\n\nContains he exact package versions and dependencies for a reproducible development environment.\n\n8\n\nAll the R scripts with the package’s functions and main code.\n\n9\n\nDocumentation files for functions and datasets in .Rd format, generated using tools like roxygen2.\n\n\n10\n\nStores unit tests to validate the functionality of the package, often using frameworks like testthat.\n\n11\n\nIncludes preprocessed datasets provided with the package, saved in .RData or .rda format.\n\n12\n\nRaw data and scripts for processing it into the format stored in the data/ folder.\n\n13\n\nLong-form documentation and tutorials, written in RMarkdown, explaining package usage in depth.\n\n\n14\n\ndirectory for additional files installed with the package, such as documentation, examples, or datasets.\n\n\n15\n\nManages the package’s dependencies in an isolated environment, ensuring reproducibility.\nThe sections below cover the minimum requirements for an R package, so you can handle both creating new Shiny app-packages and converting existing Shiny projects into Shiny app-packages.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#sec-packages-r-pkgs",
    "href": "packages.html#sec-packages-r-pkgs",
    "title": "3  Packages",
    "section": "",
    "text": "3.1.1 Essential ingredients\nIf you’ve done some research on R packages, you’ve probably encountered one (or both) of the following statements,\n\n‘RStudio and devtools consider any directory containing DESCRIPTION to be a package’ - R Packages, 2ed (Chapter 9, DESCRIPTION)\n‘all a project needs to be a package is a directory of R/ files and a DESCRIPTION file.’ - Mastering Shiny (Chapter 20, Packages)\n\nBelow is the current sap app folder:\n\nsap/\n1├── DESCRIPTION\n├── sap.Rproj \n2├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n└── www/\n    └── shiny.png\n\n4 directories, 9 files\n\n\n1\n\nDESCRIPTION file\n\n\n2\n\nR/ folder with .R files\n\n\n\n\nWe can see sap has:\n\na DESCRIPTION file\nan R/ directory\n\nSo, is sap a functioning R package?\n\n3.1.1.1 Can we load it with devtools?\nPackage development kicks off with the load_all() function from devtools, which is similar to calling library() (we’ll cover this function extensively in the Development chapter).\nHowever, when we attempt to load the code in the R/ folder with load_all(), we see the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n\n\ndevtools is looking for the Package field in our DESCRIPTION file\n\n\n\n\n3.1.1.2 Does it have a DESCRIPTION?\n\n\nLaunch app with the shinypak package:\n\nlaunch('03.1_description')\n\nThe official R documentation5 lists the following required fields for the DESCRIPTION in R packages:\n\nThe ‘Package’, ‘Version’, ‘License’, ‘Description’, ‘Title’, ‘Author’, and ‘Maintainer’ fields are mandatory.\n\nBelow is an example DESCRIPTION file for our new sap package with the mandatory fields:6\n\nPackage: sap\nTitle: Shiny App-Packages\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: An R package with a collection of Shiny applications.\nLicense: GPL-3\n\n\n\n\n\n\n\nAuthor and Maintainer fields\n\n\n\n\n\nNote that the Author and Maintainer fields require additional information beyond first and last name (i.e., John Smith). These can be created with the utils::person() function:\n\n# Author\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  role = c(\"aut\", \"cre\"))\n## [1] \"John Smith [aut, cre]\"\n# Maintainer\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  email = \"John.Smith@email.io\")\n## [1] \"John Smith &lt;John.Smith@email.io&gt;\"\n\n\n\n\n\n\n\n3.1.2 RStudio’s Build pane \nIf you’re using RStudio, then functioning R packages also have access to the Build pane, which allows us to quickly load, install, and test code. When we open sap, the Build pane is not displayed in the IDE:\n\n\n\n\n\n\n\nThe Build pane is normally between Connections and Git\n\n\nAfter adding the seven mandatory fields to the DESCRIPTION file, devtools::load_all() runs without the previous error, but the IDE still doesn’t display the Build pane:\n\n\n\n\n\n\n\nWhere is the Build pane?\n\n\n\n3.1.2.1 RStudio projects \n.Rproj files are plain text files with various configurations for the RStudio IDE. We were able to run devtools::load_all() above without the presence of the Build pane because RStudio displays the Build pane after reading the fields in the .Rproj file.\nThe quickest way to access the fields in the .Rproj file is under Tools &gt; Project Options….\n\n\n3.1.2.2 Project options\nSelecting Tools &gt; Project Options… will provide us access to the project-level options. For example, fields 2 - 4 are available under General, 5 - 8 affect the Code options, and the final two fields deal with Sweave.\n\n\n\n\n\n\n\nField settings from sap.Rproj file\n\n\nThe default settings were created when we selected the Shiny app project from the New Project Wizard in the last chapter.\n\n\n3.1.2.3 Build tools\nI’ve placed the .Rproj file from sap with the example .Rproj file from R Packages, (2ed) side-by-side so you can compare them below:7\n\n\n\n\n\n\n\n\n\n(a) .Rproj files\n\n\n\n\n\nFigure 3.1: Comparison of sap.Rproj file and .Rproj file in R Packages, 2ed\n\n\n\nI’ve circled the fields in the .Rproj file that illustrate it’s configured to work with an R package. Note that in sap, the Project build tools are initially set to (None) under Build Tools:\n\n\n\n\n\n\n\n\n\n(a) sap.Rproj build tools\n\n\n\n\n\nFigure 3.2: Build tool settings in sap.Rproj file\n\n\n\nChanging the Project build tools option to Package will set the default Build Tools options:8\n\n\n\n\n\n\n\n\n\n(a) Default package build tools\n\n\n\n\n\nFigure 3.3: Default build tool settings\n\n\n\nThe links between the Build Tools options and fields in sap.Rproj are in the figure below:\n\n\n\n\n\n\n\n\n\n(a) sap.Rproj build tool fields\n\n\n\n\n\nFigure 3.4: Default build tool settings in sap.Rproj file\n\n\n\n\nBuildType: Package tells the IDE sap is an R package and triggers the Build pane.\nPackageUseDevtools: Yes links the options in the Build pane to the devtools package.\nThe PackageInstallArgs are complicated, but I’ve included some information about them in the callout block below (and you can read more in the official R documentation)\nThe fourth option (PackageRoxygenize) is available under Generate documentation with Roxygen &gt; Use roxygen to generate:\n\nThese options affect the documentation in an R package. To match the example from R Packages, 2ed above, make sure Rd files, Collate field, and NAMESPACE file are selected and click OK.\n\n\n\n\n\n\n\n\n\n\n\n(a) PackageRoxygenize in .Rproj file\n\n\n\n\n\nFigure 3.5: roxygen2 build settings\n\n\n\nAfter clicking OK, the IDE will automatically reboot, and the additional fields will be added to the bottom of the sap.Rproj:\n\n\nLaunch app with the shinypak package:\n\nlaunch('03.2_rproj')\n\n\nVersion: 1.0\n1ProjectId: 1b90afca-cb2f-ae46-4bc8-fc983de5f832\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\n                                            \n\n\n1\n\nProjectId is a relatively new field, and it helps keep each project configured with the RStudio IDE.\n\n\n\n\n\n\n\n\n\n\nWhat is --no-multiarch --with-keep.source?\n\n\n\n\n\n\n\n--no-multiarch: refers to the option for the package installer to only compile the package for the architecture of the current R session. By default, R tries to compile packages for 32-bit and 64-bit architectures if running in a 64-bit R session on Windows. This flag can help avoid problems if a package can only be compiled on one architecture. Read more here.\n--with-keep.source: In R, when a function is created, its body can be stored in two ways: 1) as a parsed but unevaluated expression and 2) as a character string containing the function’s source code. By default, only the parsed expression is kept. If –with-keep.source is specified, R will also keep the source code as a character string, which can be helpful for debugging and tools that analyze or modify source code. Read more here.\n\n\n\n\n\nWhen the new session starts, the new project-level options activate the Build pane in the IDE, and I can check the R package functionality by loading the code with Build &gt; Load All\n\n\n\n\n\n\n\nIdentical to running devtools::load_all()\n\n\n\n\n\n3.1.3 Positron’s workspaces \nPositron doesn’t recognize RStudio’s project files (.Rproj) or their build tools configuration. Instead, Positron organizes files and paths around workspaces.9\nA workspace is any folder that contains your project’s files. You can open an existing folder or create a new one from Positron’s welcome pane:\n\n\n\n\n\n\n3.1.3.1 Positron projects\nThe Welcome pane also offers an option for creating a New Project, but this shouldn’t be confused with creating an RStudio project.\nIf we follow the steps for a new project by specifying the type, name, and location:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe see this opens a folder in the IDE without an .Rproj file:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf you’re building your Shiny app from scratch, this is still a great way to get started because it makes it easy to adopt best practices (i.e., using Git and renv).\n\n\n3.1.3.2 Build tools\nIn Positron, all of the package development tools from devtools are available, but they are executed and handled a little differently by the IDE. We’ll cover these differences more in the Development, Degbug, and Tests chapters.\n\n\n\n3.1.4 R packages recap\nIn summary, to turn a Shiny Project  into a ‘functioning’ R package that can be installed and loaded into an R session we need:\n\nA DESCRIPTION file containing the seven mandatory fields (Package, Version, License, Description, Title, Author, and Maintainer), making running the necessary devtools functions possible.10\n\n\nIf we’re using RStudio, the .Rproj file must contain the three package configuration fields11, which makes the Build pane accessible and functional.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#sec-packages-app-pkgs",
    "href": "packages.html#sec-packages-app-pkgs",
    "title": "3  Packages",
    "section": "3.2 App-packages ",
    "text": "3.2 App-packages \nShiny app-packages  have all of the functionality of a standard R Package  but also contain the files and folders required to successfully develop, run, and deploy a Shiny app . The Posit documentation lists the following way(s) to create R packages:12\n\n\nCall usethis::create_package().\nIn Posit Workbench, do File &gt; New Project &gt; New Directory &gt; R Package. This ultimately calls usethis::create_package(), so really there’s just one way.\n\n\n\n\n\n\n\n\n\n\n\n\nSee the 03.3_create-package branch of sap.\n\ncreate_package() is a great option if you’re looking for a way to quickly create or convert your Shiny project into a Shiny app-package. In the following sections I’ll cover some suggestions for using create_package().13\n\n3.2.1 New app-packages\nIf you haven’t written any code and want to create a new Shiny app-package, create_package() is the quickest way to get started.\nFirst, install devtools:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\ndevtools automatically loads usethis\nLoading required package: usethis\nAssuming your current working directory is where you want your new Shiny app-package, call usethis::create_package() with the path argument set to getwd()\n\nusethis::create_package(path = getwd())\n\nThis call launches a series of actions:\n\nFirst, the active project is set to whatever was given to the path argument.\n✔ Setting active project to 'path/to/newApp'\nThe R/ folder and DESCRIPTION/ file are created:\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\nThe NAMESPACE and .Rproj files are created:\n✔ Writing 'NAMESPACE'\n✔ Writing 'newApp.Rproj'\nThe .Rproj is added to the .Rbuildignore file, the .Rproj.user folder is added to the .gitignore and .Rbuildignore files.\n✔ Adding '^newApp\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\nA new session is opened from the new .Rproj file:\n✔ Opening 'path/to/newApp/' in new RStudio session\n\nWhen the new session opens, newApp has the following contents:\n\nnewApp/\n  ├── .Rbuildignore\n  ├── .Rproj.user/\n  ├── .gitignore\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── newApp.Rproj\n\nYou’re now free to develop newApp. Store and document any .R files in the R/ folder, edit the DESCRIPTION file with details about the application, read through R Packages and Mastering Shiny, and add the Shiny code to complete your Shiny app-package.\n\n\n3.2.2 Converting a Shiny project\nIf you already have a Shiny app project that needs to be converted into a Shiny app-package, you can also use create_package(path = getwd()) in your root folder, but I recommend using the following arguments:\n\n3.2.2.1 DESCRIPTION arguments\n\nfields: these are arguments passed to usethis::use_description(). If the fields argument is empty, a boilerplate DESCRIPTION file is created (similar to this one).\n\nThese boilerplate fields in the DESCRIPTION work, but I’ve found some of the fields are unnecessary (i.e., I’ve never needed Authors@R: or ORCID) and inevitably require revision, so I’d prefer to handle this during the creation process (and remove the risk of forgetting to change it later).\nAll fields should be passed in a list() as field = 'value' pairs.\n\n\nusethis::use_description(\n    list(Package = 'sap',\n         Version = '0.3.3',\n         Title = 'Shiny App-Packages',\n         Description = 'An R package with a collection of Shiny applications.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"))\n\n\nA few fields require specially formatted values (see the utils::person() examples below).\n\nutils::person(\"John\", \"Smith\", \n              email = \"John.Smith@email.io\", \n              role = c(\"aut\", \"cre\"))\n\n[1] \"John Smith &lt;John.Smith@email.io&gt; [aut, cre]\"\n\n\n\nTwo additional arguments from use_description() are passed to create_package():\n\ncheck_name: verifies your Shiny app-package name is valid for CRAN, so we can set this to FALSE (unless you’re planning on submitting to CRAN)\nroxygen2: is TRUE by default and adds the fields required to use roxygen2 (which I won’t cover here because we’ll cover documentation in-depth in a future chapter).\n\n\n\n\n\n\n\n\nDon’t use \".\" with create_package()\n\n\n\n\n\n\nWhen converting your existing Shiny app project into a Shiny app-package with usethis::create_package(), don’t use '.' in the path argument:\nusethis::create_package('.')\nThis will return the following warning about creating nested projects, and ask if you want to proceed anyway:\nNew project 'sap' is nested inside an existing project\n'./', which is rarely a good idea. If this is unexpected, \nthe here package has a function,\n`here::dr_here()` that reveals why './' is regarded as a\nproject.\n  \nDo you want to create anyway?\n\n1: Yes\n2: No way\n3: Not now\nWe can avoid this warning altogether by passing getwd() to the path argument, so I recommend cancelling the project creation:\nSelection: 2\nError: Cancelling project creation.\n\n\n\n\n\n\n3.2.2.2 IDE arguments\n\nrstudio: adds the necessary Build Tools fields in the .Rproj file (leave as TRUE)\nopen: can be set to FALSE because we don’t need RStudio/Posit Workbench to open in a new session\n\n\nusethis::create_package(\n  path = getwd(),\n  fields = list(Package = 'sap',\n         Version = '0.3.3',\n         Title = 'Shiny App-Packages',\n         Description = 'An R package with a collection of Shiny applications.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            email = \"John.Smith@email.io\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"),\n  roxygen = TRUE,\n  check_name = FALSE, \n  rstudio = TRUE,\n  open = FALSE)\n\nAfter running usethis::create_package() with the arguments above, the IDE will present us with a few prompts to confirm:\nOverwrite pre-existing file 'DESCRIPTION'?\nOverwrite pre-existing file 'sap.Rproj'?\nThe Shiny app-package structure is below:\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── sap.Rproj\n└── www\n    └── Shiny.png\n\n3 directories, 10 files\nThe DESCRIPTION file (shown below) has a few additional fields (Encoding, Roxygen, and RoxygenNote) we didn’t include when we converted sap above, but we will cover these in the upcoming chapters.\nPackage: sap\nTitle: Shiny App-Packages\nVersion: 0.3.3\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: An R package with a collection of Shiny applications.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.2\n\n\nLaunch app with the shinypak package:\n\nlaunch('03.3_create-package')",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#recap",
    "href": "packages.html#recap",
    "title": "3  Packages",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered the mandatory fields in the DESCRIPTION file and the R package configuration fields in .Rproj. We also covered creating and converting Shiny app projects using the usethis::create_package() function.\n\n\n\n\n\n\nRecap: Packages!\n\n\n\n\n\n\n\nThe DESCRIPTION file ultimately controls whether you have a functional Shiny app-package.\n\nThe mandatory fields are Package, Version, License, Description, Title, Author, and Maintainer.\n\nusethis::create_package() can be used to create a new R package and to convert an existing Shiny project into a Shiny app-package.\nThe RStudio IDE reads project (.Rproj) files and determines R session settings at the project-level (i.e., working directory, workspace, history, code formatting, etc.)\n\nPackage development settings can be accessed via Project Options &gt; Build Tools.\n\n\n\n\n\n\nIn the next chapter, I’ll cover how you can quickly Load, Document, and Install your package!\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#footnotes",
    "href": "packages.html#footnotes",
    "title": "3  Packages",
    "section": "",
    "text": "If you’re developing in RStudio , your Shiny project might also include a Posit workbench project file (.Rproj).↩︎\nIf you’re working in RStudio , your R package will also likely include a project file (.Rproj).↩︎\nShiny app project features are covered in Section 2.3 and Section 2.4 of the previous chapter.↩︎\nFortunately, Shiny app-packages don’t require all the files and folders displayed in the folder tree to gain the functionality and benefits of an R package.↩︎\nThe mandatory fields are covered in Writing R Extensions, ‘The DESCRIPTION file’↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎\n.Rproj files are covered in the What makes an RStudio Project? section of R Packages (2 ed)↩︎\nThe initial Build Tools settings (i.e., (None)) should help explain the absence of any R package development fields in the sap.Rproj when we compared it to the version in R Packages, 2ed (i.e., BuildType, PackageUseDevtools, PackageInstallArgs, and PackageRoxygenize).↩︎\nLearn more about this in Jenny Bryan’s discussion in the Introducing Positron, a new data science IDE presentation at posit::conf(2024).↩︎\nRead more about the mandatory fields DESCRIPTION fields.↩︎\nThe .Rproj package configuration fields are BuildType: Package, PackageUseDevtools: Yes, and PackageInstallArgs: --no-multiarch --with-keep.source.↩︎\nThis information comes from the Writing R Packages documentation for Posit Workbench.↩︎\nusethis::create_package() is covered in the ‘Fundamental development workflows’ chapter of R Packages, 2ed↩︎",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "development.html",
    "href": "development.html",
    "title": "4  Development",
    "section": "",
    "text": "4.1 Getting started\nIf you’d like a refresher on the Shiny and R package chapters, I’ve provided a refresher of these topics below:\nIf you’re new to package development, having a little background on the devtools package is helpful. Earlier versions of devtools contained most of the functions used for package development. In version 2.0, devtools went under a conscious uncoupling, which means there was a “division of labor” for its core functionality:\nYou don’t have to install all of these packages (they will be loaded with devtools), but the information is essential because it affects the dependencies in your app-package:\nWe will cover this topic more in the dependencies chapter..\nBefore we can start developing, we need to install devtools:\ninstall.packages(\"devtools\")\nlibrary(devtools)\nusethis is automatically loaded/attached with devtools.\nLet’s assume we’re continuing with a Shiny project from the previous branch of sap. Our Shiny project has a DESCRIPTION file and the code has been placed in the R/ folder, so we’re ready to start developing our app-package with devtools (the files and folders are below).\nsap/ \n1  ├── DESCRIPTION\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n2  ├── sap.Rproj\n  └── www\n      └── shiny.png\n\n4 directories, 9 files\n\n\n1\n\nThe DESCRIPTION file contains the required fields: Package, Version, License, Description, Title, Author, and Maintainer.\n\n\n2\n\nThe .Rproj file is still configured to work with a Shiny project (not an R package).",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#getting-started",
    "href": "development.html#getting-started",
    "title": "4  Development",
    "section": "",
    "text": "Loading required package: usethis\n\n\n\n\n\n\n\n\n\n\n\nSee the 03.1_description branch of sap.\n\n\n\n4.1.1 Keyboard shortcuts\nI strongly recommend using the keyboard shortcuts for each devtools function. Shortcuts reduce typing and bundle all those keystrokes into a single action. They also create a kind of ‘muscle memory’ for each step.\nIn RStudio , new keyboard shortcuts can be created using the shrtcts package or by clicking on Tools &gt; Modify Keyboard Shortcuts.\nIn Positron , the devtools functions covered below are already mapped to the keyboard shortcuts. Follow the instructions found in Positron’s Wiki to add new shortcuts.\n\n\n4.1.2 Habits\nThe differences between developing an R package and a Shiny app can be boiled down to a handful of habits, each of which calls a devtools function:\n\n\nI’ll use this font style to indicate each habit and accompanying function.\n\nLoad all the functions and data in your app-package with load_all()\nDocument the app-package functions and data with document()\nInstall the app-package with install()\n\nIn the sections below, I’ll cover each devtools function and my habits around their use when my Shiny app transitions to an app-package.1",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#sec-dev-load",
    "href": "development.html#sec-dev-load",
    "title": "4  Development",
    "section": "4.2 Load",
    "text": "4.2 Load\nload_all() is the most common devtools function used during development. Load the package when anything changes in the R/ folder.\n\n‘load_all() removes friction from the development workflow and eliminates the temptation to use workarounds that often lead to mistakes around namespace and dependency management’ - Benefits of load_all(), R Packages, 2ed\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n=\n\n\ndevtools::load_all()\n\n\n\n\nUsing load_all() is similar to calling library(sap) because it loads the code in R/ along with any data files. load_all() is also designed for iteration (unlike using source()), and when it’s successful, the output is a single informative message:\nℹ Loading sap",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#sec-dev-document",
    "href": "development.html#sec-dev-document",
    "title": "4  Development",
    "section": "4.3 Document",
    "text": "4.3 Document\nThe document() function from devtools serves two purposes:\n\nWriting the package NAMESPACE file\nCreates the help files in the man/ folder\n\nDocument a package whenever changes are made to the roxygen2 syntax or DESCRIPTION.\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n=\n\n\ndevtools::document()\n\n\n\n\ndevtools is smart enough to recognize the first time document() is called, so when I initially run it in the Console, it prompts me that the roxygen2 version needs to be set in the DESCRIPTION file:2\nℹ Updating sap documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.3.2\"\nYou may have noticed calling document() also calls load_all(), which scans the loaded package contents for special documentation syntax before writing the NAMESPACE file (we’ll cover the NAMESPACE in the Dependencies chapter).\nℹ Loading sap\nWriting NAMESPACE\nIf we open the NAMESPACE file, we see it’s empty (and that we shouldn’t edit this file by hand).\n\n\n\n\n\n\nFigure 4.1: Initial NAMESPACE file\n\n\n\nThe last few output lines warn us to include the Encoding field in the DESCRIPTION.\nWarning message:\nroxygen2 requires Encoding: \"UTF-8\"\nℹ Current encoding is NA \ndevtools won’t automatically add Encoding (like it did with RoxygenNote above), so we’ll need to add it to the DESCRIPTION file manually:\n\nPackage: sap\nVersion: 0.0.0.9000\nType: Package\nTitle: Shiny App-Packages\nDescription: An R package with a collection of Shiny applications.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\n1Encoding: UTF-8\n                                                      \n\n\n1\n\nThe Encoding value shouldn’t include quotes like the warning message above (i.e., UTF-8)\n\n\n\n\nAfter adding the required fields to the DESCRIPTION file,3 we’ll document() the package again and we should see the following:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating sap documentation\nℹ Loading sap\nDocumentation completed",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#sec-dev-install",
    "href": "development.html#sec-dev-install",
    "title": "4  Development",
    "section": "4.4 Install",
    "text": "4.4 Install\nThe final development habit checking if our app-package can be installed locally with devtools::install() or pak::local_install(upgrade = FALSE) (depending on the IDE you’re using).\nInstall a package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n=\n\n\ndevtools::install()\n\n\n\n\n4.4.1 In RStudio \n\ninstall() will prompt the following output in the Build pane:\n1==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source sap\n\n2* installing to library ‘/path/to/local/install/sap-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n3* installing *source* package ‘sap’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n4No man pages found in package  ‘sap’\n5** help\n*** installing help indices\n** building package indices\n6** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n7** testing if installed package keeps a record of temporary installation path\n8* DONE (sap)\n\n1\n\nWe saw both of these R CMD INSTALL settings in the sap.Rproj file from the previous chapter\n\n\n2\n\nFull file path for installation\n\n3\n\ninstall() attempts to install the package from the *source* files and a ‘bundle’ or source tarball file (i.e., .tar.gz)\n\n4\n\nNo man pages found in package 'sap' tells us none of the code in R/ has adequately been documented (which we’ll cover in the roxygen2 chapter)\n\n\n5\n\nBuilding the ?help files\n\n\n6\n\nChecks to see if package can be loaded from multiple locations and stores\n\n7\n\nChecks to see if package stores the install location\n\n8\n\nDONE (sap) means sap was successfully installed!\n\n\n\n\n4.4.2 In Positron \n\nIn Positron, Ctrl/Cmd + Shift + B will call pak::local_install(upgrade = FALSE). This command will be run in a new Terminal window:\n1 *  Executing task: /Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/bin/R -e 'pak::local_install(upgrade = FALSE)'\n\n\n2R version 4.4.0 (2024-04-24) -- \"Puppy Cup\"\nCopyright (C) 2024 The R Foundation for Statistical Computing\nPlatform: x86_64-apple-darwin20\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n3&gt; pak::local_install(upgrade = FALSE)\n4✔ Updated metadata database: 7.50 MB in 12 files.\n✔ Updating metadata database ... done\n \n5→ Will update 1 package.\n→ The package (0 B) is cached.\n+ sap 0.0.0.9000 → 0.0.0.9000 👷🏾‍♂️\nℹ No downloads are needed, 1 pkg is cached\n✔ Got sap 0.0.0.9000 (source) (96 B)\n6ℹ Packaging sap 0.0.0.9000\n✔ Packaged sap 0.0.0.9000 (18.2s)\n7ℹ Building sap 0.0.0.9000\n✔ Built sap 0.0.0.9000 (3.1s)\n8✔ Installed sap 0.0.0.9000 (local) (63ms)\n9✔ 1 pkg + 54 deps: kept 54, upd 1, dld 1 (NA B) [53.2s]\n&gt; \n&gt; \n10 *  Terminal will be reused by tasks, press any key to close it.\n\n1\n\nName of task and terminal\n\n\n2\n\nStarts new R session\n\n3\n\nCalls pak::local_install(upgrade = FALSE)\n\n\n4\n\npak will check the package database for updates\n\n5\n\nthe upgrade = FALSE means pak is going to do “the minimum amount of work to give you the latest version(s) of pkg”\n\n6\n\nPackaging sap\n\n7\n\nBuilding sap\n\n\n8\n\nInstalling sap\n\n\n9\n\nSummary (‘kept 54 dependencies, updated 1, downloaded 1 package’)\n\n10\n\nClose Terminal message\n\n\n\n\nWhat’s the difference?\ndevtools::install() focuses on helping package developers by managing all necessary steps for installation, including rebuilding documentation and running tests. install() also automatically updates outdated dependencies during installation unless dependencies is set to FALSE.\npak::local_install() is designed to use parallel downloads and more efficient dependency resolution, making it faster and more reliable than devtools::install() in many cases.4 The upgrade = FALSE installs a package without upgrading its dependencies, keeping the current package versions intact.\n\n\nLaunch app with the shinypak package:\n\nlaunch('04_devtools')",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#sec-dev-check",
    "href": "development.html#sec-dev-check",
    "title": "4  Development",
    "section": "4.5 Check?",
    "text": "4.5 Check?\ndevtools::check() performs a series of checks to ensure a package meets the standards set by CRAN. You can consider check() as a ‘quality control’ function for documentation, NAMESPACE dependencies, unnecessary or non-standard folders and files, etc. R Packages recommends using check() often, but I agree with the advice in Mastering Shiny on using check() with app-packages,\n\n‘I don’t recommend that you [call devtools::check()] the first time, the second time, or even the third time you try out the package structure. Instead, I recommend that you get familiar with the basic structure and workflow before you take the next step to make a fully compliant package.’\n\nHowever, I’ve included an example of running check() on sap in the callout box below to demonstrate how it works.\n\n\n\n\n\n\nRunning devtools::check()\n\n\n\n\n\n\ndevtools::check()\n\nThe output from check() can be rather lengthy (it’s pretty comprehensive!), and it provides feedback on each item in the form of a note (N), warning (W), or error (E).\n==&gt; devtools::check()\n\nDuration: 15.3s\n\nN  checking top-level files\n   Non-standard files/directories found at top level:\n     ‘app.R’ ‘movies.RData’\n\nW  checking dependencies in R code ...\n   '::' or ':::' imports not declared from:\n     ‘ggplot2’ ‘shiny’ ‘stringr’\n\nN  checking R code for possible problems (3.1s)\n   mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n     variable ‘movies’\n   scatter_plot: no visible binding for global variable ‘.data’\n   Undefined global functions or variables:\n     .data movies\n\nW  checking for missing documentation entries ...\n   Undocumented code objects:\n     ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n     ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n   All user-level objects in a package should have documentation entries.\n   See chapter ‘Writing R documentation files’ in the ‘Writing R\n   Extensions’ manual.\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nA summary of each item is below:\n\nchecking top-level files: This note refers to the two non-standard (i.e., not typically found in an R package) files, app.R and movies.RData.\nchecking dependencies in R code: This warning tells I need to namespace functions from add-on packages (in this case, ggplot2, shiny, and stringr)\nchecking R code for possible problems: This item refers to the call to load the movies data in the module server function (mod_scatter_display_server).\nchecking for missing documentation entries: This is warning me that the module functions aren’t properly documented and refers me to the official R documentation.\n\nEach of these items is also printed under the ── R CMD check results heading:\n\n\nshow/hide R CMD check results\nDuration: 15.3s\n\n❯ checking dependencies in R code ... WARNING\n  '::' or ':::' imports not declared from:\n    ‘ggplot2’ ‘shiny’ ‘stringr’\n\n❯ checking for missing documentation entries ... WARNING\n  Undocumented code objects:\n    ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n    ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n  All user-level objects in a package should have documentation entries.\n  See chapter ‘Writing R documentation files’ in the ‘Writing R\n  Extensions’ manual.\n\n❯ checking top-level files ... NOTE\n  Non-standard files/directories found at top level:\n    ‘app.R’ ‘movies.RData’\n\n❯ checking R code for possible problems ... NOTE\n  mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n    variable ‘movies’\n  scatter_plot: no visible binding for global variable ‘.data’\n  Undefined global functions or variables:\n    .data movies\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\n\n\nIf you’re submitting your app-package to CRAN (or want to use check() for other reasons), follow the suggested workflow for check():\n\nThe workflow for checking a package is simple, but tedious:\n\nRun devtools::check() or press Shift + Ctrl/Cmd + E\nFix the first problem.\nRepeat until there are no more problems.’\n\n\nI’ve found a good habit for when to check() to be:\nAfter adding a bug fix or feature, check a package and keep any notes, warnings, or errors from accumulating.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#package-versions",
    "href": "development.html#package-versions",
    "title": "4  Development",
    "section": "4.6 Package versions",
    "text": "4.6 Package versions\nThe DESCRIPTION file contains a boilerplate version number (0.0.0.9000) to signify it’s a development package.5 Generally speaking, R package development versions follow the Semantic versioning methods:\n\nGiven a version number MAJOR.MINOR.PATCH, increment the:\n1. MAJOR version when you make incompatible API changes\n2. MINOR version when you add functionality in a backward compatible manner\n3. PATCH version when you make backward compatible bug fixes\nAdditional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\n\nIn this book, the package versions all begin with 0.0.0.9000, because they should all be considered ‘development’ packages. However, I’ve included the chapter/section to align with the package version. So this chapter’s version is:\n\nPackage: sap\nVersion: 0.0.0.9400\nType: Package\nTitle: Shiny App-Packages\nDescription: An R package with a collection of Shiny applications.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#hidden-files",
    "href": "development.html#hidden-files",
    "title": "4  Development",
    "section": "4.7 Hidden files",
    "text": "4.7 Hidden files\nYou might notice additional ‘hidden’ files in your new app-package:6 .gitignore, .Rbuildignore, and .Rprofile:\n\n4.7.1 .gitignore\n.gitignore will ignore some of the standard hidden files created by R or RStudio. The initial contents will include something like the following:\n\n.Rproj.user\n.Rhistory\n.RData\n.Ruserdata\n.DS_Store # for mac users \n\n\n\n4.7.2 .Rbuildignore\n.Rbuildignore includes files that we need to have in our app-package, but don’t conform to the standard R package structure (and shouldn’t be included when building our app-package from the source files).\n\n^.*\\.Rproj$\n^\\.Rproj\\.user$\n\nNote the syntax for detecting file patterns.\n\n\n4.7.3 .Rprofile\nThe .Rprofile is specific to the user (you) and might include options for loading packages or tests:\n\nif (interactive()) {\n  require(usethis, quietly = TRUE)\n}\noptions(shiny.testmode = TRUE)\n\n.Rprofile is also included in your directory if you’re using renv to manage packages/versions.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#recap",
    "href": "development.html#recap",
    "title": "4  Development",
    "section": "Recap",
    "text": "Recap\nCreating an app-package involves adopting some new devtools habits, and the initial contents of sap hopefully helped demonstrate the purpose of each function.\n\n\n\n\n\n\nRecap: Package development habits\n\n\n\n\n\n\nAfter installing and loading devtools:\n\nLoad the package whenever changes occur in the R/ folder.\n\nCtrl/Cmd + Shift + L load all the code in the package.\n\nDocument the package whenever changes are made to any roxygen2 syntax or the DESCRIPTION file..\n\nCtrl/Cmd + Shift + D record the documentation and dependencies.\n\nInstall the package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\nCtrl/Cmd + Shift + B confirms the package can be installed.\npak::local_install() benefits from optimized dependency resolution and download methods\ndevtools::install() handles a broader range of tasks during installation (including rebuilding documentation and running tests)\n\n\nHabits require repetition to develop, but things like keyboard shortcuts can help minimize the friction we all experience with change.\n\n\n\n\nThe following section will cover documenting functions with roxygen2\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "development.html#footnotes",
    "href": "development.html#footnotes",
    "title": "4  Development",
    "section": "",
    "text": "The topics covered in this section shouldn’t be considered a replacement for the ‘Whole Game’ chapter in R packages (2 ed) or the ‘Workflow’ section of Mastering Shiny (and I highly recommend reading both).↩︎\ndevtools relies on roxygen2 for package documentation, so the RoxygenNote field is required in the DESCRIPTION.↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎\nIt stands to reason that installing a package with pak::local_install() in Positron would be faster than installing a package using devtools::install() in RStudio, but this has not been my experience.↩︎\nRead more about package development version in R Packages, 2nd Ed.↩︎\nBy convention, files that begin with . (dot files) are considered hidden.↩︎",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Development</span>"
    ]
  },
  {
    "objectID": "app_packages.html",
    "href": "app_packages.html",
    "title": "App-packages",
    "section": "",
    "text": "App-packages\nExpand the callout boxes below to review what we’ve covered in the last four chapters:\nIn the following chapters, we will continue developing our Shiny application within the R package structure. Below is a preview of each topic covered in the upcoming chapters.",
    "crumbs": [
      "App-packages"
    ]
  },
  {
    "objectID": "app_packages.html#app-packages",
    "href": "app_packages.html#app-packages",
    "title": "App-packages",
    "section": "",
    "text": "Documentation (Chapter 5)\n5  Documentation covers documenting the code in your app-package with roxygen2:\n\nRequired tags:\n\n5.1.2 Markdown support\n5.1.3 Title & description\n5.1.4 Parameters & return objects and\n5.1.6 Examples\n\nApp-package tags for modules and standalone app functions:\n\n5.2.1 See also\n\n5.2.2 Family\n\n5.3.1 Usage, and\n\n5.2.3 Section\n\n\n\n\nDependencies (Chapter 6)\n6  Dependencies dives into the external (i.e. add-on) functions and packages you’ve used to build your app-package. We’ll also cover how to export functions and objects from your app-packages for others to use.\n\n6.1 Package exports\n\n6.2 Package imports\n\n\n\nData (Chapter 7)\n7  Data covers how to include datasets in your app-package namespace, and the various kinds of data in R packages.\n\nStoring and Documenting data:\n\n7.1 The data/ folder\n7.3 Documenting data\n\n\nRaw data files:\n\n7.2 data-raw/\n\n\nOther locations for data:\n\n7.4 External data\n\n\n\n\nLaunch (Chapter 8)\nThe 8  Launch chapter covers how to 1) run your application during development, 2) how to run your app using a standalone app function, and 3) how to deploy your application to shinyapps.io.\n\nApp run functions:\n\n8.2.1 shinyApp()\n8.2.2 shinyAppDir()\n8.2.3 runApp()\n\nLaunching app files:\n\n8.4 The app.R file\n\n\n\n\nResources (Chapter 9)\n9  Resources covers how to include external resources (i.e. the images, CSS, html, or other files that are typically included in the www/ folder and served when you run your Shiny app). This chapter also covers other uses for the isnt/ folder in app-packages.\n\nStatic files:\n\n9.1 Image files\n\n9.1.2 addResourcePath()\n\n\nData files:\n\n9.2.1 A tidy-movies app\n\n\nQuarto apps:\n\n9.3 Quarto apps\n\n\nProduction:\n\n9.4 Production\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages"
    ]
  },
  {
    "objectID": "document.html",
    "href": "document.html",
    "title": "5  Documentation",
    "section": "",
    "text": "5.1 roxygen2 basics\nThis chapter covers documenting Shiny app functions with roxygen2. I’ll start by introducing the fundamentals of the roxygen2 syntax, but also touch on a few helpful tips specific to Shiny modules and standalone app functions.\nThe current structure of our sap package is displayed in the folder tree below:1\n(the rsconnect/ folder from deploying sap has been removed)\nWhen we use devtools::install(), the following message regarding documentation is returned:\nDocumenting the functions in the R/ folder will address this message, and I strongly encourage checking out the roxygen2 vignettes and the chapter in R Packages, 2ed for more information on documenting your app-package.\nroxygen2 connects the package code (i.e., the .R files in the R/ folder) to its documentation files (i.e., the .Rd files in the man/ folder). Two pieces of roxygen2 syntax to know are comment blocks and tags:\nThe roxygen2 tags and comment blocks are placed above functions and used with devtools::document() to create help documentation:\n#' \n#' @tag\n#' \nmy_fun &lt;- function() {\n  \n}\nIn the following sections, we’ll cover some roxygen2 basics using the scatter_plot() function in the R/utils.R file.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#sec-intro-roxygen2",
    "href": "document.html#sec-intro-roxygen2",
    "title": "5  Documentation",
    "section": "",
    "text": "See the 04_devtools branch of sap.\n\n\n\nComment blocks are any lines beginning with #'\n\n#' \n#' \n#' \n\nTags begin with @\n\n#' \n#' @tag\n#' \n\n\n\n\n\n\n5.1.1 File name alignment\nShiny apps (and most R projects) often contain utility functions in helper.R or utils.R files. Placing non-Shiny code in these files isn’t a bad practice–it’s is even encouraged in Mastering Shiny:\n\n“You might want to collect smaller, simpler, functions into one place. I often use R/utils.R for this…”\n\nHowever, because we’ll want to develop tests for scatter_plot(), we should follow the advice in R Packages,2 and rename R/utils.R to R/scatter_plot.R as we transition to an app-package.3\n\n\n\n\n\n\nR/utils.R\n\n\n\n\n\n\nFrom now on, I’ve renamed R/utils.R to R/scatter_plot.R, so it aligns with the naming conventions in other R packages.\nFor a deep dive on R/utils.R files in R packages, I recommend reading Dissecting R Package “Utility Belts”\n\n\n\n\n\n\n5.1.2 Markdown support\nWhen we created our app-package with create_package(), support for markdown formatting in our package help files was automatically included by adding Roxygen: list(markdown = TRUE) to the DESCRIPTION file:\n\nPackage: sap\n1Version: 0.0.0.9500\nType: Package\nTitle: Shiny App-Packages\nDescription: An R package with a collection of Shiny applications.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.3.2\nEncoding: UTF-8\n2Roxygen: list(markdown = TRUE)\n                                                    \n\n\n1\n\nUpdated package version\n\n\n2\n\nMarkdown support\n\n\n\n\nIf this field is not in your DESCRIPTION file, follow the instructions in the roxygen2 documentation for enabling markdown.\n\n\n5.1.3 Title & description\n\n\n\n\n\n\nInserting roxygen2 skeletons\n\n\n\n\n\n\nIn RStudio , you can insert an roxygen2 skeleton into your function using Code &gt; Insert Roxygen Skeleton\n\n\n\n\n\n\n\nStandard roxygen2 skeleton\n\n\n\n\n\n\nThe first two sections of roxygen2 documentation are the title and description. These sections don’t require tags–roxygen2 will detect each section as long as there is at least one #' line separating them (and their contents don’t extend past the length indicated in parentheses below):\n\n#' function title (one line)\n#'\n#' A short description... (one paragraph)\n#' \n\nThe @title and @description for the scatter_plot() function stored in R/utils.R might look like this:\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `sap`.\n#' \n\n\n\n\n\n\n\nFunction @description and @details\n\n\n\n\n\n\nIf the contents in the @description for a function requires more complicated formatting than a single paragraph (i.e., multiple paragraphs, lists, etc.), you can use the @details tag:\n#' Create scatter plot  \n#' \n#' @description\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `sap`.\n#' \n#' @details\n#' `scatter_plot()` is a custom `ggplot2` function written to handle string arguments from reactive inputs (i.e., `input$x` or `input$y`)\n\n\n\n\n\n\n5.1.4 Parameters & return objects\nDocument function arguments and outputs with @param and @return:\n\n@param should include the name and description of each function input (i.e., their type and what they do)4\n\n#' @param name description of its action\n\n\n\n@return describes the type (or class) and structure of the function output5\n\n#' @return type/structure of the output\n\n\nBelow are examples for @param and @return in the scatter_plot() function stored in R/utils.R:\n\n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n\nTo view how the roxygen2 syntax will appear in the .Rd file, we’ll need to document sap:\n\n\nTo reduce the amount of repetitive code, I’ll just be showing the keyboard shortcuts for each devtools function from this point forward\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nI can see the scatter_plot.Rd file is written to the man/ folder:\nℹ Updating sap documentation\nℹ Loading sap\nWriting scatter_plot.Rd\nDocumentation completed\nAn overview of what devtools::document() does is illustrated below:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TB\n  subgraph Code[\"R/ Folder\"]\n   Roxy2(\"&lt;code&gt;roxygen2&lt;/code&gt; comments (&lt;code&gt;#'&lt;/code&gt;)&lt;br&gt; & tags (&lt;code&gt;@&lt;/code&gt;)\")\n   end\n  Roxy2 --&gt; Doc[[\"&lt;strong&gt;Run &lt;code&gt;devtools::document()&lt;/code&gt;&lt;/strong&gt;\"]]\n  Doc --&gt; Parse(\"Parses &lt;code&gt;roxygen2&lt;/code&gt; comments and tags\")\n   \n   subgraph Man[\"man/ Folder\"]\n    Rd(\".Rd Files\")\n   end\n   \n   subgraph Root[\"Package Root Folder\"]\n    NS(\"NAMESPACE\")\n   end\n\n   Parse --&gt; Man \n   Parse --&gt; Root\n  \n  %% style Code fill:#8dd38d,stroke:none,rx:10,ry:10,font-size:13px\n  %% style Roxy2 fill:#8dd38d,stroke:none,rx:10,ry:10,font-size:13px\n  %% style Doc fill:#89D6FB,stroke:none,rx:10,ry:10,font-size:13px\n  %% style Parse fill:#89D6FB,stroke:none,rx:10,ry:10,font-size:13px\n  %% style Man fill:#8dd38d,stroke:none,rx:10,ry:10,font-size:13px\n  %% style NS fill:#8dd38d,stroke:none,rx:10,ry:10,font-size:13px\n\n\n roxygen2 creates the NAMESPACE and help files in the man/ folder \n\n\n\n\n\n5.1.5 .Rd files\nWhen we open man/scatter_plot.Rd, we see it contains the following:\n\n\n\n\n\n\n\nThe scatter_plot.Rd documentation file\n\n\nR documentation (.Rd) files have a formatting style similar to (La)TeX, but roxygen2 saves us from having to learn this syntax by automatically generating the .Rd files.\nTo view the help file, I can enter ?scatter_plot in the console:\n\n?scatter_plot\n\n\n\n\n\n\n\n\nHelp file\n\n\nPreviewing the development versions of our documentation is a great way to verify the content in each .Rd file meets our expectations.\n\n\n5.1.6 Examples\n@examples are unique because they include executable code that demonstrates how a particular function works. In the Posit Workbench IDE, @examples are especially helpful because they come with a clickable hyperlink (the @examples from ggplot2::aes() are below):\n\n\n\n\n\n\n\n\n\n\n\n(a) Run examples hyperlink\n\n\n\n\n\n\n\n\n\n\n\n(b) Executed @examples code\n\n\n\n\n\n\n\nFigure 5.1: Run examples in help files\n\n\n\nBelow is an example demonstrating how the scatter_plot() utility function works:\n\n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n\n\n\n\n\n\n\nTab-completion for @tags\n\n\n\n\n\n\nIf you’re documenting your package functions in Positron, tab-completion is your friend! The help text displayed with each tag ensures you’re including the correct version (see @example vs. @examples below).\n\n\n\nTab completion for @example\n\n\nRead more here.\n\n\n\n\nTo preview the @examples in the help file, I’ll document() and open the development .Rd file:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n?scatter_plot\n\n\n\n\n\n\n\n\nPreview of examples\n\n\nThe Run examples hyperlink won’t be active in the .Rd file preview, but reviewing the code in @examples allows me to correct any errors or typos early.\nThe scatter_plot() function now has a Title, Description, Usage, Arguments, Value, and Examples documented. Consider these tags as the minimum level of documentation for the functions in your app-package.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#sec-document-app-functions",
    "href": "document.html#sec-document-app-functions",
    "title": "5  Documentation",
    "section": "5.2 Documenting app functions",
    "text": "5.2 Documenting app functions\nUsing Markdown in roxygen2 can improve the clarity of our documentation, especially in Shiny app-packages, where modules and functions often need detailed explanations.\n\n5.2.1 See also\nWhen documenting Shiny modules, I tend to think of the audience as anyone looking to understand the execution path through an application. For example, in our sap application, the inputs are collected in the UI and returned from the mod_var_input_server() function:\nExample for mod_var_input_ui:\n\n#' @seealso\n#' - [`mod_var_input_server()`]  for server-side logic.\n#' - [`shiny::tagList()`](https://shiny.rstudio.com/reference/shiny/latest/tagList.html) \n#'   for containing UI elements.\n#' - [`shiny::NS()`](https://shiny.rstudio.com/reference/shiny/latest/NS.html) \n#'   for namespacing.\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart LR\n        mod_var_input_ui(\"UI Module:&lt;br&gt;&lt;code&gt;mod_var_input_ui()&lt;/code&gt;\")\n        mod_var_input_server(\"Server Module:&lt;br&gt;&lt;code&gt;mod_var_input_server()&lt;/code&gt;\")\n        mod_scatter_display_server(\"Server Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_server()&lt;/code&gt;\")\n        tag(\"Documentation:&lt;br&gt;&lt;code&gt;shiny::tagList()&lt;/code&gt;\")\n        ns(\"Documentation:&lt;br&gt;&lt;code&gt;shiny::NS()&lt;/code&gt;\")\n\n    mod_var_input_ui &lt;--&gt;|\"@seealso\"|mod_var_input_server\n    mod_var_input_ui &lt;--&gt;|\"@seealso\"|tag\n    mod_var_input_ui &lt;--&gt;|\"@seealso\"|ns\n    mod_var_input_server &lt;--&gt;|\"@seealso\"|mod_scatter_display_server\n    \n    style mod_scatter_display_server font-size:13px\n\n\n The @seealso tag \n\n\n\nExample for mod_var_input_server:\n\n#' @seealso\n#' - [`mod_var_input_ui()`] for the UI counterpart of this module.\n#' - [`mod_scatter_display_server()`] for displaying the scatter plot.\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart LR\n    mod_var_input_ui(\"UI Module:&lt;br&gt;&lt;code&gt;mod_var_input_ui()&lt;/code&gt;\")\n    mod_var_input_server(\"Server Module:&lt;br&gt;&lt;code&gt;mod_var_input_server()&lt;/code&gt;\")\n    mod_scatter_display_server(\"Server Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_server()&lt;/code&gt;\")\n\n    mod_var_input_server &lt;--&gt;|\"@seealso\"|mod_var_input_ui\n    mod_var_input_server &lt;--&gt;|\"@seealso\"|mod_scatter_display_server\n    \n    style mod_scatter_display_server font-size:13px\n\n\n The @seealso tag \n\n\n\nWith Markdown, you can use backticks for inline code, bulleted lists, and links for external references. To make references more readable and user-friendly, we can use @seealso to connect modules, utility functions, and links to external documentation.\n\n\n5.2.2 Family\nThe @family tag works the same way, but can be used to group functions by type. Markdown gives us the ability to use bold or italic text for emphasis.\nFor the variable input module:\n\n#' @family **Variable Input Module**\n\nFor utility functions:\n\n#' @family *Utility Functions*\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TD\n    subgraph AppCom[\"&lt;strong&gt;Application Components&lt;/strong&gt;\"]\n        launch_app(\"Standalone Function:&lt;br&gt;launch_app()\")\n    end\n    subgraph Vars[\"&lt;strong&gt;Variable Input Module&lt;/strong&gt;\"]\n        mod_var_input_ui(\"UI Module:&lt;br&gt;mod_var_input_ui()\")\n        mod_var_input_server(\"Server Module:&lt;br&gt;mod_var_input_server()\")\n    end\n    subgraph Graph[\"&lt;strong&gt;Plot Display Module&lt;/strong&gt;\"]\n        mod_scatter_display_ui(\"UI Module:&lt;br&gt;mod_scatter_display_ui()\")\n        mod_scatter_display_server(\"Server Module:&lt;br&gt;mod_scatter_display_server()\")\n    end\n    subgraph Utils[\"&lt;strong&gt;Utility Functions&lt;/strong&gt;\"]\n        scatter_plot(\"Utility Function:&lt;br&gt;scatter_plot()\")\n    end\n\n    launch_app --&gt; mod_var_input_ui --&gt; mod_var_input_server\n    launch_app --&gt; mod_scatter_display_ui --&gt; mod_scatter_display_server --&gt; scatter_plot\n\n\n The @family tag \n\n\n\nMarkdown doesn’t drastically change @family, but it improves the consistency of formatting across related functions.\n\n\n5.2.3 Section\nMarkdown shines in sections, where you can use headings (###), bold text, or lists to structure detailed explanations.\nExample for mod_var_input_server:\n\n#' @section Inputs:\n#' This function expects inputs provided via the `shiny` session namespace:\n#'\n#' - `y`: Variable for the y-axis.\n#' - `x`: Variable for the x-axis.\n#' - `z`: Variable for the color aesthetic.\n#' - `alpha`: Transparency level of points (0-1).\n#' - `size`: Size of the points.\n#' - `plot_title`: Title for the plot.\n#'\n#' @section Outputs:\n#' - A **reactive expression** that returns a list of selected inputs.\n\nFor scatter_plot:\n\n#' @section Usage:\n#' Use this function to create a scatter plot as part of a Shiny app or in a\n#' standalone script. This is particularly useful when integrated with reactive\n#' inputs from Shiny modules.\n\n\n5.2.3.1 Variable input\nBelow are full example of variable input module documented with Markdown. Note the use of @family and interactive() in the @examples:\nmod_var_input_ui():\n\n\nshow/hide mod_var_input_ui documentation\n#' Variable Input Module - UI\n#'\n#' Creates a UI for selecting variables and attributes for a scatter plot.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#'\n#' @return A `shiny::tagList()` containing UI elements for variable \n#' selection.\n#'\n#' @section Details: \n#' `mod_var_input_ui()` provides UI controls for customizing scatter plots. \n#'  It includes:  \n#' - **Dropdowns**: \n#'   - X-axis variable\n#'   - Y-axis variable\n#'   - Color aesthetic variable\n#' - **Sliders**:\n#'   - Transparency (`alpha`) ranging from 0 to 1.\n#'   - Point size ranging from 0 to 5.\n#' - **Text Input**:\n#'   - Plot title.\n#'\n#' The function uses `shiny::NS()` to namespace all input IDs.\n#'\n#' @seealso\n#' - [`mod_var_input_server()`]  for server-side logic.\n#' - [`shiny::tagList()`](https://shiny.rstudio.com/reference/shiny/latest/tagList.html) \n#'   for containing UI elements.\n#' - [`shiny::NS()`](https://shiny.rstudio.com/reference/shiny/latest/NS.html) \n#'   for namespacing.\n#'\n#' @family **Variable Input Module**\n#'\n#' @examples\n#'\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(mod_var_input_ui(\"vars\")),\n#'     server = function(input, output, session) {\n#'       selected_vars &lt;- mod_var_input_server(\"vars\")\n#'       shiny::observe(\n#'           print(selected_vars())\n#'        )\n#'     }\n#'   )\n#' }\n#' \n\n\nmod_var_input_server():\n\n\nshow/hide mod_var_input_server documentation\n#' Variable Input Module - Server\n#'\n#' Handles the server-side logic for the variable input module.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#'\n#' @return A **reactive expression** that returns a list of selected input\n#'   values:  \n#' - `y`: Variable for the y-axis.\n#' - `x`: Variable for the x-axis.\n#' - `z`: Variable for the color aesthetic.\n#' - `alpha`: Transparency level of points (0-1).\n#' - `size`: Size of the points.\n#' - `plot_title`: Title for the scatter plot.\n#'\n#' @section Details: \n#' `mod_var_input_server()` reads user input from the corresponding UI \n#'  function created with \n#' `mod_var_input_ui()`. It processes and returns a reactive object \n#'  containing the selected variables and plot attributes.\n#'\n#' @seealso\n#' - [`mod_var_input_ui()`] for the UI counterpart of this module.\n#' - [`mod_scatter_display_server()`] for displaying the scatter plot.\n#'\n#' @family **Variable Input Module**\n#'\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(mod_var_input_ui(\"vars\")),\n#'     server = function(input, output, session) {\n#'       selected_vars &lt;- mod_var_input_server(\"vars\")\n#'       shiny::observe(print(selected_vars()))\n#'     }\n#'   )\n#' }\n#'\n\n\n\n\n5.2.3.2 Graph display\nmod_scatter_display_ui:\n\n\nshow/hide mod_scatter_display_ui documentation\n#' Scatter Plot Display Module - UI\n#'\n#' Creates a UI for displaying a scatter plot with user-selected options.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#'\n#' @return A `shiny::tagList` containing the plot output and metadata.\n#'\n#' @section Details: \n#' `mod_scatter_display_ui()` includes:\n#' - A **scatter plot** created dynamically based on user input.\n#' - Metadata about the app, including the data source.\n#'\n#' @seealso\n#' - [`mod_scatter_display_server()`]  for the server-side logic of this \n#'   module.\n#' - [`scatter_plot()`]  for the utility function generating the plot.\n#'\n#' @family **Plot Display Module**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(mod_scatter_display_ui(\"plot\")),\n#'     server = function(input, output, session) {\n#'       # Example usage - server logic is minimal for standalone testing.\n#'     }\n#'   )\n#' }\n#'\n\n\nmod_scatter_display_server:\n\n\nshow/hide mod_scatter_display_server documentation\n#' Scatter Plot Display Module - Server\n#'\n#' Handles the server-side logic for rendering a scatter plot.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#' @param var_inputs *(reactive)* A reactive expression containing \n#'  user-selected variables and attributes.\n#'\n#' @return No direct return value. This function generates a plot output.\n#'\n#' @section Details: \n#' `mod_scatter_display_server()`:\n#' - Uses `var_inputs` to dynamically generate a scatter plot with \n#'   user-selected variables.\n#' - Reads from the `movies` dataset, which must be loaded in the app \n#'   environment.\n#' - Processes plot titles and axis labels to improve readability.\n#'\n#' @section Reactive Inputs:\n#' - `var_inputs()$x`: X-axis variable.\n#' - `var_inputs()$y`: Y-axis variable.\n#' - `var_inputs()$z`: Color aesthetic variable.\n#' - `var_inputs()$alpha`: Transparency level.\n#' - `var_inputs()$size`: Size of points.\n#' - `var_inputs()$plot_title`: Title of the plot.\n#'\n#' @seealso\n#' - [`mod_var_input_server()`] for variable selection.\n#' - [`scatter_plot()`] for generating the scatter plot.\n#'\n#' @family **Plot Display Module**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(\n#'       mod_var_input_ui(\"vars\"),\n#'       mod_scatter_display_ui(\"plot\")\n#'     ),\n#'     server = function(input, output, session) {\n#'       selected_vars &lt;- mod_var_input_server(\"vars\")\n#'       mod_scatter_display_server(\"plot\", selected_vars)\n#'     }\n#'   )\n#' }\n#'\n\n\n\n\n5.2.3.3 Utility function\nscatter_plot():\n\n\nshow/hide scatter_plot() documentation\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building \n#' scatter plots in `sap`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' Generate a Scatter Plot\n#'\n#' Creates a scatter plot using `ggplot2` with the specified data and \n#' aesthetics.\n#'\n#' @param df *(data.frame)* The dataset containing the variables to plot.\n#' @param x_var *(character)* Name of the variable for the x-axis.\n#' @param y_var *(character)* Name of the variable for the y-axis.\n#' @param col_var *(character)* Name of the variable for the color aesthetic.\n#' @param alpha_var *(numeric)* Transparency level of points (0 to 1).\n#' @param size_var *(numeric)* Size of points.\n#'\n#' @return A `ggplot` object representing the scatter plot.\n#'\n#' @section Details:\n#' `scatter_plot()` is designed for use in Shiny applications but can also be \n#'  used independently.\n#' It supports customization of transparency, size, and color aesthetics.\n#'\n#' @seealso\n#' - [`mod_scatter_display_server()`] for integrating this function into the\n#'   scatter plot module.\n#' - [`ggplot2::ggplot()`](https://ggplot2.tidyverse.org/) for details on \n#'   `ggplot2` usage.\n#'\n#' @family **Utility Functions**\n#'\n#' @examples\n#' scatter_plot(\n#'   df = mtcars,\n#'   x_var = \"mpg\",\n#'   y_var = \"hp\",\n#'   col_var = \"cyl\",\n#'   alpha_var = 0.7,\n#'   size_var = 3\n#' )\n#'",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#sec-roxygen2-ui-server",
    "href": "document.html#sec-roxygen2-ui-server",
    "title": "5  Documentation",
    "section": "5.3 UI & Server functions",
    "text": "5.3 UI & Server functions\nSplitting the standalone app function in app.R into separate UI and server functions has multiple benefits:\n\nDocumenting each function will be easier if they are stored in the R/ folder.\nHaving dedicated UI, server, and app function means we can develop and test them independently.\nA standalone app function can have multiple applications in the same app-package.\n\nI’ve split the UI and server from launch_app() into separate movies_ui() and movies_server() below.\nThe movies_ui() doesn’t have any arguments–it contains the theme, image, and application title:\n\n\nshow/hide movies_ui documentation\n#' User Interface for the Movies Review Application\n#'\n#' Creates the user interface (UI) for the Movies Review application, which \n#' allows users to create customizable scatter plots based on movie data.\n#'\n#' @return A Shiny `tagList` object containing the UI elements.\n#'\n#' @section Details:\n#' The interface is built using:\n#' - **Theme**: `shinythemes::shinytheme(\"spacelab\")`.\n#' - **Title Panel**: Displays the app title and a logo.\n#' - **Sidebar Panel**: Includes the variable selection module \n#'   ([`mod_var_input_ui`]).\n#' - **Main Panel**: Displays the scatter plot module \n#'   ([`mod_scatter_display_ui`]).\n#'\n#' @seealso\n#' - [`movies_server()`] for the server logic of the app.\n#' - [`mod_var_input_ui()`] and [`mod_scatter_display_ui()`] for the modules \n#'   included in the UI.\n#'\n#' @family **Application Components**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(ui = movies_ui(), server = movies_server)\n#' }\n#'\nmovies_ui &lt;- function() {\n  tagList(\n    fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      titlePanel(\n        div(\n          img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movie Reviews\"\n        )\n      ),\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\n\nmovies_server() is written to be passed to the server argument in shinyApp():\n\n\nshow/hide movies_server documentation\n#' Server Logic for the Movies Review Application\n#'\n#' Handles the server-side logic for the Movies Review application.\n#'\n#' @param input The Shiny `input` object.\n#' @param output The Shiny `output` object.\n#' @param session The Shiny `session` object.\n#'\n#' @return No direct return value. Defines server logic for reactive outputs \n#' and module integration.\n#'\n#' @section Details:\n#' The server integrates the following modules:\n#' - **Variable Input Module**: Processes user input for scatter plot \n#'   customization using  [`mod_var_input_server()`].\n#' - **Plot Display Module**: Generates and displays a scatter plot \n#'   based on user inputs using [`mod_scatter_display_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the corresponding user interface.\n#' - [`launch_app()`] for the entry point of the application.\n#'\n#' @family **Application Components**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(ui = movies_ui(), server = movies_server)\n#' }\n#'\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\nThis will change the grouping in our @family tags to the following:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"14px\"}}}%%\nflowchart TD\n    subgraph AppCom[\"&lt;strong&gt;Application Components&lt;/strong&gt;\"]\n        launch_app[\"Standalone Function:&lt;br&gt;&lt;code&gt;launch_app()&lt;/code&gt;\"]\n        UI[\"UI:&lt;br&gt;&lt;code&gt;movies_ui()&lt;/code&gt;\"]\n        Server[\"Server:&lt;br&gt;&lt;code&gt;movies_server()&lt;/code&gt;\"]\n    end\n    subgraph Vars[\"&lt;strong&gt;Variable Input Module&lt;/strong&gt;\"]\n        mod_var_input_ui[\"UI Module:&lt;br&gt;&lt;code&gt;mod_var_input_ui()&lt;/code&gt;\"]\n        mod_var_input_server[\"Server Module:&lt;br&gt;&lt;code&gt;mod_var_input_server()&lt;/code&gt;\"]\n    end\n    subgraph Graph[\"&lt;strong&gt;Plot Display Module&lt;/strong&gt;\"]\n        mod_scatter_display_ui[\"UI Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_ui()&lt;/code&gt;\"]\n        mod_scatter_display_server[\"Server Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_server()&lt;/code&gt;\"]\n    end\n    subgraph Utils[\"&lt;strong&gt;Utility Functions&lt;/strong&gt;\"]\n        scatter_plot[\"Utility Function:&lt;br&gt;&lt;code&gt;scatter_plot(&lt;/code&gt;\"]\n    end\n\n    launch_app --&gt; UI\n    launch_app --&gt; Server\n    UI --&gt; mod_var_input_ui\n    UI --&gt; mod_scatter_display_ui\n    Server --&gt; mod_var_input_server\n    Server --&gt; mod_scatter_display_server --&gt; scatter_plot\n\n\n The updated @family tag \n\n\n\n\n5.3.1 Usage\nWe’ll explicitly describe the use of movies_ui() and set @usage to NULL (note the use of a code block). We’ll also use @section to describe each module UI function (and link to the server functions with @seealso).\n\n\nshow/hide movies_server documentation\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#'\n#' @usage NULL\n#' \n#' @details\n#' The [launch_app()] function is as a wrapper for `shiny::shinyApp()`: \n#'  \n#' ```\n#' shinyApp(ui = movies_ui, server = movies_server)\n#' ```\n#' \n#' In [launch_app()]:\n#'  * UI is stored in `movies_ui()`    \n#'  * server is stored in [movies_server()]\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_ui()] is used to collect the following inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'  \n#' @seealso [mod_var_input_server()]\n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_ui()] displays the graph output using [scatter_plot()]\n#' \n#' @seealso [mod_scatter_display_server()]\n#'\n#' @return `ui` argument in `shiny::shinyApp()` \n#' \nlaunch_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#recap",
    "href": "document.html#recap",
    "title": "5  Documentation",
    "section": "Recap",
    "text": "Recap\nGood documentation aims to make it as easy as possible for others (and future you) to understand what your function does and how to use it.\n\n\nLaunch app with the shinypak package:\n\nlaunch('05_roxygen2')\n\nBelow is a recap of the topics covered in this chapter.\n\n\n\n\n\n\n   Documentation Recap\n\n\n\n\n\n\nThis chapter covered:\n\nFunction @title and @description: The @title should be a short one-line description of the function, followed by a more detailed paragraph @description. These tags should give users an idea of what the function does (you can also use @details)\nArguments (@param) and outputs (@return): List all function arguments with @param. Include the argument type (e.g., integer, character, etc.) and a brief description of what the argument does. Be sure to mention any default or optional arguments. Function outputs should be listed with @return and describe the type or class of the object, whether or not it’s reactive, and mention any related functions.\nExamples: @examples provide executable R code that captures how the function is used in your app-package. These are incredibly valuable for new users trying to understand how a function (and your app-package) works.\n\nApp-package specific considerations:\n\nConnect functions with@seealso and @family: Use @seealso to provide links to related functions (i.e., modules) so users can click through a ‘guided tour’ of your application’s code–group similar functions using @family {description}.\nGive more info with @sections: Use @section to give in-depth explanations and specific details about how a function works, including any information about the @usage or its @params.\n@usage: This field will be automatically generated by roxygen2, but in some circumstances, it makes sense to set it to NULL and describe a function’s use explicitly.\n\n\n\n\n\nIn the next section, we’ll use roxygen2 to manage our app-package dependencies.\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "document.html#footnotes",
    "href": "document.html#footnotes",
    "title": "5  Documentation",
    "section": "",
    "text": "View the 04_devtools branch and review the previous chapter for more information.↩︎\n‘More often, a single .R file will contain multiple function definitions: such as a main function and its supporting helpers, a family of related functions, or some combination of the two.’ - Organise functions into files, R Packages, 2ed↩︎\nMaking .R file/function names brief but descriptive will also make writing and running tests easier.↩︎\nRead more about @param in the arguments chapter of R Packages, 2ed.↩︎\nRead more about @return in the return value chapter of R Packages, 2ed.↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Documentation</span>"
    ]
  },
  {
    "objectID": "dependencies.html",
    "href": "dependencies.html",
    "title": "6  Dependencies",
    "section": "",
    "text": "Identifying dependencies\nDependencies are the must-have components for your app-package, and they can be divided into imports and exports. - Imports are the functions we’re borrowing from add-on/third party packages (i.e., any packages not automatically loaded in a new R session).\n- Exports are the functions, data, and other R objects our app-package offers to users.\nIn this chapter we’ll cover how to manage dependencies in your new app-package.\nDependencies are handled with in the NAMESPACE directives (generated via roxygen2 tags) and three fields in the DESCRIPTION file (Suggests, Imports, or Depends). Together, these files determine which functions and packages our app-package depends on, and which functions and object we make available to users of our app-package. This chapter will pick up where we left off with the 05_roxygen2 branch of sap.\nBelow is a folder tree of it’s contents:\nWhen in doubt…load, document, and install\nDuring development, you might lose track of the last devtools function you called (I know I do). If this happens, I’ve found loading, documenting, and installing helps to re-orient me to the current state of the package.\nIt’s also satisfying to see all three functions execute without any errors!\nThe first step in managing dependencies is identifying which add-on packages sap relies on.1 The diagram below outlines the basic process for importing functions from add-on packages to use in our locally developed package, and then exporting those functions for people to use when they install/load our package.\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TD\n    subgraph RPkg[\"R Package:&lt;code&gt;pkg&lt;/code&gt;\"]\n        fun(\"Has &lt;code&gt;fun()&lt;/code&gt; function\")\n    end\n    subgraph SapPkg[\"&lt;code&gt;sap&lt;/code&gt; Package\"]\n    sap(\"Uses &lt;code&gt;pkg::fun()&lt;/code&gt; in local&lt;br&gt;&lt;code&gt;foo()&lt;/code&gt; function\")\n    end\n    Users(\"Users install/load &lt;code&gt;sap&lt;/code&gt; to use &lt;code&gt;foo()&lt;/code&gt;\")\n    RPkg --&gt;|\"import &lt;code&gt;fun()&lt;/code&gt; from &lt;code&gt;pkg&lt;/code&gt;\"| SapPkg\n    SapPkg --&gt;|\"export &lt;code&gt;foo()&lt;/code&gt; from &lt;code&gt;sap&lt;/code&gt;\"| Users\n\n\n\n Handling package dependencies\nOur goal is to limit the dependencies to only those critical to the functioning of our app, because each additional dependency is a potential point of failure (should this package become unavailable or significantly change).\nA great place to start is our app.R file:\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# launch_app ------------------------------------\nlaunch_app()\nIdeally, we’ll want to replace these calls to libary(), but first we have to make sure the functions we’re using in these packages will be available in sap.\nWhen we run the contents of app.R, we see the following:\nWhy can’t R find the \"launch_app\" function in app.R?\nLet’s recap what we’ve done so far:\nThe error above is telling us that despite having documentation for launch_app() in the R/ folder and generating the corresponding .Rd file in man/, launch_app() isn’t being exported from sap.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#identifying-dependencies",
    "href": "dependencies.html#identifying-dependencies",
    "title": "6  Dependencies",
    "section": "",
    "text": "&gt; launch_app()\nError in launch_app() : could not find function \"launch_app\"\n\n\n\n\n\n\n\n\napp.R\n\nThe app.R file loads the necessary packages and calls launch_app():\n\n\n\n\nsap/\n    └── app.R\n\n\n\n\n\n\n\n\n\nR/\n\nThe R/launch_app.R file contains the code and roxygen2 documentation for launch_app() function:\n\n\n\n\nsap/\n    └── R/\n        └── launch_app.R\n\n\n\n\n\n\n\n\n\nman/\n\nroxygen2 generates the man/launch_app.Rd documentation file:\n\n\n\n\nsap/\n    └── man/\n          └── launch_app.Rd",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#sec-depends-exports",
    "href": "dependencies.html#sec-depends-exports",
    "title": "6  Dependencies",
    "section": "6.1 Package exports",
    "text": "6.1 Package exports\nThe exact cause of the error above becomes more apparent when we try to explicitly namespace launch_app() from sap:2\n\nsap::launch_app()\n\nError: 'launch_app' is not an exported object from 'namespace:sap'\n\n\nLaunch app with the shinypak package:\n\nlaunch('06.1_pkg-exports')\n\nTo make the launch_app() function available to users of our package, we need to export it by including the @export tag in the roxygen2 comment block:\n\n@export: make function available to users of sap.\n\n1#' @export my_func\n#' my_func &lt;- function() {\n#' \n#' }\n\n\n1\n\nPlaced above the function we want to export (function name is not required)\n\n\n\n\n\n\nExport launch_app()\nWe’ll export launch_app() from sap by placing the @export tag above the function in R/launch_app.R:\n\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#'\n#' @return A **Shiny application** object.\n#'\n#' @section Details:\n#' The application uses:\n#' - **UI**: Defined in [`movies_ui()`].\n#' - **Server Logic**: Defined in [`movies_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the user interface.\n#' - [`movies_server()`] for the server logic.\n#'\n#' @family **Standalone Application**\n#'\n#' @examples\n#' if (interactive()) {\n#'   launch_app()\n#' }\n#'\n#' @export\nlaunch_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nIn app.R, we’ll replace the calls to library() with a single call to library(sap)\n\n# packages ------------------------------------\nlibrary(sap)\n\n# launch_app ------------------------------------\nlaunch_app()\n\nWe’ll document the package to generate the NAMESPACE changes:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nNow, when we run the code app.R, we see the following:\n\n\n\nlaunch_app()\n\n\n\n\nWe’ve lost the Shiny icon (www/shiny.png) in the UI, but we’ll address this in Chapter 9.\nlaunch_app() launches our application!\n\n\nThe NAMESPACE file now contains a single export (launch_app), and when we enter sap:: in the Console, we see the launch_app() function help file in the tab completion.\n\n\n\n\n\n\n\n\n\n\n\n(a) updated NAMESPACE\n\n\n\n\n\n\n\n\n\n\n\n(b) launch_app() from the sap namespace\n\n\n\n\n\n\n\nFigure 6.1: The launch_app() is now part of the sap namespace\n\n\n\n\n\nWhat @export does\nWe’ll pause here to notice a few things about what @export does. When we documented our package, the code was automatically loaded before the NAMESPACE was updated with export(launch_app).\n\n&gt; devtools::document()\nℹ Updating sap documentation\n1ℹ Loading sap\nWriting NAMESPACE\n\n\n1\n\nCall to devtools::load_all()\n\n\n\n\ndocument() will call load_all() to make sure all the changes in the R/ folder are included in the updated documentation.\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart\n    subgraph R[\"&lt;strong&gt;R/ folder&lt;/strong&gt;\"]\n        Tag(\"Add &lt;code&gt;@export&lt;/code&gt;&lt;br&gt;to function&lt;br&gt;documentation\")\n    end\n  subgraph NS[\"&lt;strong&gt;NAMESPACE&lt;/strong&gt;\"]\n        Exported([\"&lt;code&gt;export(launch_app)&lt;/code&gt;\"])\n  end\n  subgraph Man[\"&lt;strong&gt;man/ folder&lt;/strong&gt;\"]\n        RdFile([\"&lt;code&gt;.Rd&lt;/code&gt; files created\"])\n  end\n  Document[[\"Run &lt;code&gt;document()&lt;/code&gt;\"]]\n  Load(\"Calls &lt;code&gt;load_all()&lt;/code&gt;\")\n  \n\n  Tag --&gt; Document\n  Document -.-&gt; Load --&gt; NS & Man\n\n\n\n What @export does \n\n\n\nWe can confirm launch_app() has been exported with ls(), which returns “the names of the objects in the specified environment.\n\nls(name = \"package:sap\")\n\n[1] \"launch_app\"\n\nThe search() list\nlibrary(sap) attaches sap to the search list. We can view all the attached packages in the string returned from search():\n\"package:sap\" %in% search()\n[1] TRUE\nWhat about the add-on/third-party package functions launch_app() relies on, like ggplot2? Let’s check to see if ggplot2 is also attached to the search() list:\n\nc(\"package:ggplot2\") %in% search()\n\n[1] FALSE\nWhy does this matter? Because if these packages aren’t attached to the search() list, we can’t call their functions directly (the way we would if we’d loaded the package with library()). For example, if we try to use ggplot2 to build a plot (similar to the one we have in the app), we see the following:\nggplot(data = mtcars, \n  aes(x = disp, y = mpg)) + \n  geom_point()\n# Error in ggplot(data = mtcars, aes(x = disp, y = mpg)) : \n#  could not find function \"ggplot\"\nWe can use the add-on/third-party package functions sap relies on, but we need to explicitly namespace these functions from their original package namespaces (i.e., using pkg::fun()):\n\n\n\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\n\nWe can use ggplot2 if we explicitly namespace it’s functions\n\n\n\n\n\n\nAccessing add-on package functions\n\n\n\n\n\n\nWhat happens to add-on/third party functions that are exported from sap?\nWhen a user loads sap with library(sap), any add-on/third-party package functions used in exports are available to users if they use pkg::fun() (or if they load the package themselves with library()).\n\n\n\n\nAccess to add-on/third-party package functions has implications for the other functions in sap–for example, the scatter_plot() function uses ggplot2 functions. But we’re not exporting scatter_plot(), so when we attempt to run the examples, we see the following error:\n\n\n\n\n\n\n\n\n\n(a) Error in scatter_plot() examples\n\n\n\n\n\nFigure 6.2: Examples in scatter_plot() function without exporting\n\n\n\nExamples for ‘sap::scatter_plot’\nThe message at the top of the Help pane is informative because it tells us that despite scatter_plot() being functional when we run launch_app(), it’s not part of the package namespace (and thus, not accessible to users in the help file).\n\n\n\nExport scatter_plot()\nLet’s add the @export tag to R/scatter_plot.R so it’s exported from sap.\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building \n#' scatter plots in `sap`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' Generate a Scatter Plot\n#'\n#' Creates a scatter plot using `ggplot2` with the specified data and \n#' aesthetics.\n#'\n#' @param df *(data.frame)* The dataset containing the variables to plot.\n#' @param x_var *(character)* Name of the variable for the x-axis.\n#' @param y_var *(character)* Name of the variable for the y-axis.\n#' @param col_var *(character)* Name of the variable for the color aesthetic.\n#' @param alpha_var *(numeric)* Transparency level of points (0 to 1).\n#' @param size_var *(numeric)* Size of points.\n#'\n#' @return A `ggplot` object representing the scatter plot.\n#'\n#' @section Details:\n#' `scatter_plot()` is designed for use in Shiny applications but can also be \n#'  used independently.\n#' It supports customization of transparency, size, and color aesthetics.\n#'\n#' @seealso\n#' - [`mod_scatter_display_server()`] for integrating this function into the\n#'   scatter plot module.\n#' - [`ggplot2::ggplot()`](https://ggplot2.tidyverse.org/) for details on \n#'   `ggplot2` usage.\n#'\n#' @family **Utility Functions**\n#'\n#' @examples\n#' scatter_plot(\n#'   df = mtcars,\n#'   x_var = \"mpg\",\n#'   y_var = \"hp\",\n#'   col_var = \"cyl\",\n#'   alpha_var = 0.7,\n#'   size_var = 3\n#' )\n#'\n#' @export\n\nAfter documenting sap, the NAMESPACE is updated with the export() directive:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nThe contents of the updated NAMESPACE file and typing sap:: in the Console now displays the scatter_plot() help file in the tab completion:\n\n\n\n\n\n\n\n\n\n\n\n\n(a) @export the scatter_plot function\n\n\n\n\n\n\n\n\n\n\n\n(b) scatter_plot()\n\n\n\n\n\n\n\nFigure 6.3: scatter_plot() is now part of the sap namespace\n\n\n\n\nBelow, we confirm users can access the help file for scatter_plot() and run the examples:\n\n\n\n\n\n\n\nRunning examples in ?scatter_plot\n\n\n\nloadedNamespaces()\nWe’ve already confirmed that ggplot2 isn’t attached with sap (and hence, it is not included in the search() list)\n\nc(\"package:ggplot2\") %in% search()\n\n[1]  FALSE\nHowever, we can access the functions we used the pkg::fun() syntax with because those functions are included in the loaded namespaces (which we can view with loadedNamespaces())\n\nc(\"ggplot2\") %in% loadedNamespaces()\n\n[1] TRUE\n\n\n\n\n\n\nAccessing non-exported functions\n\n\n\n\n\n\nWhat about functions that aren’t exported from sap?\nFunctions that are not exported (i.e., do not include the @export tag) are still accessible after installing and loading a package using the pkg:::fun()\n\n\n\n\n\n\n\nWhat to @export\n\n‘Always err on the side of caution, and simplicity. It’s easier to give people more functionality than it is to take away stuff they’re used to’ - What to export, R Packages, 2ed\n\nWhen determining which functions to export, consider the question: “When a user installs and loads sap, what functions do I want to be available?”\nIn app-packages, I’ll take the following general approach:\n\nStart by exporting the standalone app function (launch_app())\nThen selectively export modules and/or functions that perform distinct tasks with potentially reusable functionality (i.e., generate specific UI components, perform data processing tasks, etc.).\n\nIt’s rare that I don’t export functions from app-packages, but I like to make sure users have the ability to get ‘under to hood’ and see how each part of an application works.\nIf you’d like to the Low-key @exports with @keywords internal box below for exporting functions without including them in your package index.\n\n\n\n\n\n\nLow-key exports with @keywords internal\n\n\n\n\n\n\nIf you’d like a function to be exported, but not listed in your app-package index, you can use @export in combination with @keywords internal:\n#' @export\n#' \n#' @keywords internal\nFor example, adding @export and @keywords internal to R/scatter_plot.R will make the function accessible to users and generate a help file:\n\n\n\n\n\nBut if a user were to click on the Index for sap (at the bottom of the help file) scatter_plot would not be listed:",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#sec-depends-imports",
    "href": "dependencies.html#sec-depends-imports",
    "title": "6  Dependencies",
    "section": "6.2 Package imports",
    "text": "6.2 Package imports\n\n\nLaunch app with the shinypak package:\n\nlaunch('06.2_imports')\n\nImporting dependencies is slightly more involved than exports because imports are managed by both the DESCRIPTION and the NAMESPACE:\n\nThe DESCRIPTION file handles package-level dependencies, specifying which add-on packages our app-package uses.\nThe NAMESPACE manages function-level access, importing functions from add-on packages to be used in our app-package, and–as we’ve seen above–exporting functions from our app-package for others to use.\n\n\nPackage-level depencencies\nThe DESCRIPTION file manages dependencies with three fields: Depends, Imports, and Suggests. Most add-on packages belong under the Imports field (i.e., functions from these packages are used in the code below R/).3\n\nDepends\nPackages listed under Depends are essential for our app-package to work. These packages will be attached before our package when library(sap) is called.\n\n\nImports\nPackages listed under Imports are necessary for our app-package to work. These packages are loaded (but not attached) when our app-package is installed.\n\n\nSuggests\nThe Suggests field should include any packages that enhance our app-package, but aren’t necessary for the basic functionality. This might include packages used in examples, vignettes, tests, etc.\n\n\n\n\n\n\nAvoiding dependency hell\n\n\n\n\n\n\nGenerally speaking, you want to keep your app-package lightweight (i.e., limit the number of add-on/third-party dependencies, other than base-R packages and shiny). Doing this ensures you’ll be able to safely use this app-packages as a dependencies in the next app-packages. We’ll cover tracking and exploring dependencies in Chapter 31.\n\n\n\n\n\n\n\nFunction-level access\nFunction-level access is managed using namespace-qualified references (or ‘explicit namespacing’) in the code below R/. The NAMESPACE can also be used to include add-on packages or functions with the @import and @importFrom tags.4\n\nNamespace-qualified referencing: Refer to add-on package functions using pkg::fun() syntax in the code below R/.\nSpecial imports: @importFrom should be used when 1) “You can’t call an operator from another package via ::” 2) “importing a function makes your code much more readable” (not easier to write)\nImporting everything: @import should be used if “you make such heavy use of so many functions from another package that you want to import its entire namespace”\n\n\n\nHandling imports\nThe workflow I use to manage add-on dependencies comes from the advice in the roxygen2 documentation:\n\n“if you are using just a few functions from another package, we recommending adding the package to the Imports: field of the DESCRIPTION file and calling the functions explicitly using ::, e.g., pkg::fun()…”\n…“If the repetition of the package name becomes annoying you can @importFrom and drop the pkg::fun()”. - Importing functions\n\n\nInclude the add-on package to the Imports field with usethis::use_package().\nRefer to add-on functions using explicit namespacing (i.e., pkg::fun()) in the code beneath R/.\n\nWe have some special considerations for the imported add-on functions in our app-package:\n\nUsing @import\nA substantial portion of the code in sap comes from shiny, so we’ll remove the explicit namespacing and place the @import tag in R/launch_app.R5\n\n\nshow/hide R/launch_app.R\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#'\n#' @return A **Shiny application** object.\n#'\n#' @section Details:\n#' The application uses:\n#' - **UI**: Defined in [`movies_ui()`].\n#' - **Server Logic**: Defined in [`movies_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the user interface.\n#' - [`movies_server()`] for the server logic.\n#'\n#' @family **Standalone Application**\n#'\n#' @examples\n#' if (interactive()) {\n#'   launch_app()\n#' }\n#'\n1#' @import shiny\n#' \n\n\n\n1\n\nImport entire shiny package namespace\n\n\n\n\n\n\nUsing @importFrom\n.data can’t be exported using ::, so we’ll include @importFrom in R/scatter_plot.R. On the other hand, ggplot2 has over 400 functions, so we’ll add the package to the Imports field and use the namespace-qualified references.6\n\n\nshow/hide R/scatter_plot.R\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building \n#' scatter plots in `sap`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' Generate a Scatter Plot\n#'\n#' Creates a scatter plot using `ggplot2` with the specified data and \n#' aesthetics.\n#'\n#' @param df *(data.frame)* The dataset containing the variables to plot.\n#' @param x_var *(character)* Name of the variable for the x-axis.\n#' @param y_var *(character)* Name of the variable for the y-axis.\n#' @param col_var *(character)* Name of the variable for the color aesthetic.\n#' @param alpha_var *(numeric)* Transparency level of points (0 to 1).\n#' @param size_var *(numeric)* Size of points.\n#'\n#' @return A `ggplot` object representing the scatter plot.\n#'\n#' @section Details:\n#' `scatter_plot()` is designed for use in Shiny applications but can also be \n#'  used independently.\n#' It supports customization of transparency, size, and color aesthetics.\n#'\n#' @seealso\n#' - [`mod_scatter_display_server()`] for integrating this function into the\n#'   scatter plot module.\n#' - [`ggplot2::ggplot()`](https://ggplot2.tidyverse.org/) for details on \n#'   `ggplot2` usage.\n#'\n#' @family **Utility Functions**\n#'\n#' @examples\n#' scatter_plot(\n#'   df = mtcars,\n#'   x_var = \"mpg\",\n#'   y_var = \"hp\",\n#'   col_var = \"cyl\",\n#'   alpha_var = 0.7,\n#'   size_var = 3\n#' )\n#'\n#' @export\n#' \n1#' @importFrom rlang .data\n#' \n\n\n\n1\n\nImport a the .data operator from rlang\n\n\n\n\n\n\nuse_package('pkg')\nAs an example, we’ll add the bslib package and update our app UI layout:\n\nusethis::use_package('bslib')\n\n✔ Setting active project to '/Users/mjfrigaard/projects/apps/sap'\n✔ Adding 'bslib' to Imports field in DESCRIPTION\n• Refer to functions with `bslib::fun()`\nIn movies_ui(), we’ll change the fluidPage() to the bslib::page_fillable() and adjust move the data source information to the bslib::card_footer():\n\n\nupdated movies_ui() bslib function\n#' User Interface for the Movies Review Application\n#'\n#' Creates the user interface (UI) for the Movies Review application, which \n#' allows users to create customizable scatter plots based on movie data.\n#'\n#' @return A Shiny `tagList` object containing the UI elements.\n#'\n#' @section Details:\n#' The interface is built using [`bslib`](https://rstudio.github.io/bslib/)\n#' - **Page (fillable)**: [`bslib::page_fillable()`](https://rstudio.github.io/bslib/reference/page_fillable.html) \n#'   displays the app title. \n#' - **Sidebar**: [`bslib::layout_sidebar()`](https://rstudio.github.io/bslib/reference/sidebar.html) \n#'   includes a logo and the variable \n#'   selection module.\n#'   ([`mod_var_input_ui`]).\n#' - **Card**: [`bslib::card()`](https://rstudio.github.io/bslib/reference/card.html) \n#'   displays the scatter plot module \n#'   ([`mod_scatter_display_ui`]).\n#'\n#' @seealso\n#' - [`movies_server()`] for the server logic of the app.\n#' - [`mod_var_input_ui()`] and [`mod_scatter_display_ui()`] for the modules \n#'   included in the UI.\n#'\n#' @family **Application Components**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(ui = movies_ui(), server = movies_server)\n#' }\n#'\nmovies_ui &lt;- function() {\n  tagList(\n    bslib::page_fillable(\n      h1(\"Movie Reviews\"),\n      bslib::layout_sidebar(\n        sidebar =\n          bslib::sidebar(\n            title = tags$h4(\"Sidebar inputs\"),\n            img(\n              src = \"shiny.png\",\n              height = 60,\n              width = 55,\n              style = \"margin:10px 10px\"\n            ),\n            mod_var_input_ui(\"vars\")\n          ),\n        bslib::card(\n          full_screen = TRUE,\n          bslib::card_header(\n            tags$h4(\"Scatter Plot\")\n          ),\n          mod_scatter_display_ui(\"plot\"),\n          bslib::card_footer(\n            tags$blockquote(\n              tags$em(\n                tags$p(\n                  \"The data for this application comes from the \",\n                  tags$a(\"Building web applications with Shiny\",\n                    href = \"https://rstudio-education.github.io/shiny-course/\"\n                  ),\n                  \"tutorial\"\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n}\n\n\nAfter adding the add-on packages to the DESCRIPTION with usethis::use_package(), then deciding if/where to use @importFrom and @import, we’ll load, document, and install sap:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nWhen we review the updated NAMESPACE and DESCRIPTION files, we should see the following:\n\n\n\n\n\n\nUpdated NAMESPACE with @import and @importFrom:\n\n\n\n\n\nNAMESPACE\n\n\n\n\n\n\n\n\n\n\n\nUpdated DESCRIPTION with all Imports:\n\n\n\n\n\nDESCRIPTION\n\n\n\n\n\nroxygen2 will update the NAMESPACE, but usethis::use_package() is needed to update the DESCRIPTION.\n\nWhen we run launch_app(), we see the application launches and we can still run the scatter_plot() examples:\n\n\n\n\n\n\n\n\n\n\n\n(a) launch_app() works\n\n\n\n\n\n\n\n\n\n\n\n(b) Examples in ?scatter_plot\n\n\n\n\n\n\n\nFigure 6.4: Confirming we still have full functionality in sap\n\n\n\n\n\n\nWhat @import does\nThe figure below attempts to capture some of confusion between the dependencies listed in the NAMESPACE and the Imports field in the DESCRIPTION file.7\n\n\n\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TD\n    subgraph DESCRIPTION[\"&lt;strong&gt;DESCRIPTION&lt;/strong&gt;\"]\n        UsePkg[\"&lt;code&gt;use_package('pkg')&lt;/code&gt;\"]\n        Imports(\"&lt;code&gt;Imports&lt;/code&gt;&lt;br&gt; in DESCRIPTION\")\n    end\n    subgraph R[\"&lt;strong&gt;R/ Folder&lt;/strong&gt;\"]\n        Tag{{\"Use &lt;code&gt;pkg::fun()&lt;/code&gt;&lt;br&gt;\"}}\n        Import(\"Use &lt;code&gt;@import&lt;/code&gt;\")\n        ImportFrom(\"Use &lt;code&gt;@importFrom&lt;/code&gt;\")\n    end\n    subgraph NAMESPACE[\"&lt;strong&gt;NAMESPACE&lt;/strong&gt;\"]\n        NSImport(\"&lt;code&gt;import(pkg)&lt;/code&gt;\")\n        NSImportFrom(\"&lt;code&gt;importFrom(fun,pkg)&lt;/code&gt;\")\n    end\n    Document([\"&lt;code&gt;devtools::document()&lt;/code&gt;&lt;/strong&gt;\"])\n\n  UsePkg --&gt;|\"Adds &lt;code&gt;pkg&lt;/code&gt; to\"|Imports\n  DESCRIPTION ==&gt;|\"Use &lt;code&gt;fun()&lt;/code&gt; from &lt;code&gt;pkg&lt;/code&gt;\"|Tag\n  DESCRIPTION -.-&gt; |\"Everything from &lt;code&gt;pkg&lt;/code&gt;\"|Import \n  DESCRIPTION -.-&gt; |\"Special cases from &lt;code&gt;pkg&lt;/code&gt;\"|ImportFrom\n  Tag ==&gt; Document\n  Import -.-&gt; Document -.-&gt; |\"Adds &lt;code&gt;pkg&lt;/code&gt; to\"|NSImport\n  ImportFrom -.-&gt; Document -.-&gt; |\"Adds &lt;code&gt;fun, pkg&lt;/code&gt; to\"|NSImportFrom\n\n\n\n devtools::document does not change the DESCRIPTION file \n\n\n\n\n\nFigure 6.5: devtools::document() (or Ctrl/Cmd + Shift + D) updates the NAMESPACE with any @import, @importFrom or @export tags. However, no changes are made to the DESCRIPTION file.\n\n\n\nLet’s confirm we’re still only exporting launch_app() and scatter_plot() from sap:\n\nls(name = \"package:sap\")\n\n[1] \"launch_app\"   \"scatter_plot\"\nGreat. Now we’ve listed six packages in the Imports field of the DESCRIPTION file:\nImports: \n    bslib,\n    ggplot2,\n    rlang,\n    shiny,\n    stringr,\n    tools\n\nThe search() list\nAre these packages on the search list?\n\npkgs &lt;- c(\"package:bslib\", \"package:ggplot2\", \n          \"package:rlang\", \"package:shiny\", \n          \"package:stringr\", \"package:tools\")\npkgs %in% search()\n\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\nThis demonstrates that none of these packages are attached with sap.\n\n\nloadedNamespaces()\nHowever, the rlang and shiny packages are included in the loadedNamespaces() (because we included them with @import/@importFrom).\n\npkgs &lt;- c(\"bslib\", \"ggplot2\", \"rlang\", \n          \"shiny\", \"stringr\", \"tools\")\npkgs %in% loadedNamespaces()\n\n[1] FALSE FALSE  TRUE  TRUE FALSE  TRUE\nWe can still access the add-on package functions in sap using the pkg::fun() syntax:\n\n\n\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(\n      x = disp, \n      y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\nggplot2 functions are still available if we explicitly namespace\n\n\n\n\n\n\n\n\nImports FAQ\nBelow are handful of questions and answers I’ve encountered regarding package imports:\nQuestion 1: How can I include an add-on package to my DESCRIPTION file?\nAnswer 1: usethis::use_package() automatically adds a package in the Imports section, and has options for specifying the minimum version.\nQuestion 2: Will users of my app-package have access to the packages listed in the Imports field of my DESCRIPTION file?\nAnswer 3: library(pkg) loads the namespace of imported packages, but they are not attached to the search() path.8\nQuestion 4: How can I tell the difference between functions written by a package author and imported functions in the code below R/?\nAnswer 4: using pkg::fun() makes calls to add-on packages explicit and easy to differentiate from the native functions developed in sap.9\nQuestion 5: What does the NAMESPACE do when my package is installed by a user?\nAnswer 5: managing the NAMESPACE ensures your app-package works when it’s installed and loaded on another machine, because R will read your package namespace to find what it imports and exports.10\nQuestion 6: Where should I place the @importFrom tag in the code below R/?\nAnswer 6: place the @importFrom pkg fun tag directly above the code using the add-on function. You can also consolidate all @import and @importFrom tags into a single package doc file (i.e., R/[sap]-package.R) by calling usethis::use_package_doc().\nQuestion 7: Should I be using @importFrom or @import from?\nAnswer 7: prefer @importFrom over @import, but try to avoid using either.11 12\nQuestion 8: Where can I find more information about package namespaces and imports?\nAnswer 8a: Imports are described briefly in R Packages, 2ed13 and covered in-depth in Advanced R, 2ed.14\nAnswer 8b: “Each namespace has an imports environment that can contain bindings to functions used by the package that are defined in another package.”\nAnswer 8c: “The imports environment is controlled by the package developer with the NAMESPACE file. Specifically, directives such as importFrom() and imports() populate this environment.”\nIn order for app-package to work, users needs to have access to any add-on packages that are called in the code below R/. Knowing when, why, how and what happens to imports helps you decide how to fit these habits into your package development workflow.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#checking-dependencies",
    "href": "dependencies.html#checking-dependencies",
    "title": "6  Dependencies",
    "section": "Checking dependencies",
    "text": "Checking dependencies\nWith all the moving parts in dependency management, it can be easy to forget if you’ve documented everything correctly. So far we haven’t covered using devtools::check() as part of your app-package habits (which is fine), but this is one area it’s particularly helpful.\nFor example, if I had listed shiny as an import using the @import tag (resulting in the import(shiny) directive in the NAMESPACE), devtools::check() would produce the following error:\n── R CMD check results ────────────────────────── sap 0.0.0.9620 ────\nDuration: 7.4s\n\n❯ checking package dependencies ... ERROR\n  Namespace dependency missing from DESCRIPTION Imports/Depends entries: ‘shiny’\n  \n  See section ‘The DESCRIPTION file’ in the ‘Writing R Extensions’\n  manual.\n\n1 error ✖ | 0 warnings ✔ | 0 notes ✔\nError: R CMD check found ERRORs\nExecution halted\n\nExited with status 1.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#recap",
    "href": "dependencies.html#recap",
    "title": "6  Dependencies",
    "section": "Recap",
    "text": "Recap\nBelow are the main takeaways from managing the imports and exports from your app-package:\n\n\n\n\n\n\nDependencies recap\n\n\n\n\n\n\nThis chapter covered:\n\nExports: Aim for a balance between simplicity and utility when deciding which functions to export (i.e., what functions should be available to users who install your package). Export objects from using @export\nImports: Use pkg::fun() syntax when you use add-on package functions and include them in the Imports field of the DESCRIPTION file. App-packages use so many shiny functions it makes sense to include @import shiny to 1) ensure all of these functions are available, and 2) you won’t need to use pkg::fun().\n\nDESCRIPTION Imports This field lists the packages your app-package uses. All add-on packages used in the R/ folder must be listed in the Imports field. These functions can be called using the pkg::fun() syntax (or with @importFrom()). Functions from these packages will be available for your package, but not for the user unless they use the :: operator or load the package themselves with library().\nNAMESPACE imports: The @import/@importFrom tags make the functions from add-on packages available to your package. Favor using @importFrom over @import for add-on package functions (the only exception being shiny, which you’d want to use @import).\n\n\nThe Imports field in the DESCRIPTION handles package-level dependencies (and it is managed manually or with usethis::use_package()), while the NAMESPACE handles function-level access (with @export and @import/@importFrom). Multiple packages can help you manage the dependencies in your app-package, and these are covered in the Dependency hell chapter.\n\n\n\n\nIf you’d like to read more about package dependencies, I recommend Writing R Extensions (specifically the sections on dependencies 15 and namespaces 16).\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub\n\n\n\n\nIn the next section, we’ll cover how to ensure the movies.RData can be stored and loaded in our app-package!",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "dependencies.html#footnotes",
    "href": "dependencies.html#footnotes",
    "title": "6  Dependencies",
    "section": "",
    "text": "I’ve made this process somewhat easier by explicitly namespacing all of the add-on package functions in sap (i.e., with pkg::fun()).↩︎\nRead more in the Exports section of R Packages, 2nd Ed↩︎\nAdditional fields exists (i.e., Remotes), but these are special circumstances.↩︎\nRead more about this in the section titled, ‘In code below R/’ in R Packages, 2ed↩︎\nUsing @import is not generally considered best practice, but it makes sense for app-packages: …for Shiny apps, I recommend using @import shiny to make all the functions in the Shiny package easily available. Mastering Shiny, R CMD check”↩︎\nRead more about using ggplot2 in packages in the section titled, ‘Referring to ggplot2 functions’↩︎\nSee the section titled, ‘Confusion about Imports’ in R Packages, 2ed, “Listing a package in Imports in DESCRIPTION does not ‘import’ that package.”↩︎\nUsers can access functions from add-on packages with the pkg::fun syntax.↩︎\n“Our recommended default is to call external functions using the package::function() syntax.” - R Packages, 2ed↩︎\nThe namespace controls the search strategy for variables used by functions in the package. If not found locally, R searches the package namespace first, then the imports, then the base namespace and then the normal search path (so the base namespace precedes the normal search rather than being at the end of it). - Writing R Extensions↩︎\n“Using importFrom selectively rather than Imports is good practice and recommended notably when importing from packages with more than a dozen exports and especially from those written by others (so what they export can change in future).” - Specifying imports and exports.↩︎\n“Specifically, we recommend that you default to not importing anything from [add-on packages] into your namespace. This makes it very easy to identify which functions live outside of your package, which is especially useful when you read your code in the future. This also eliminates any concerns about name conflicts between [add-on packages] and your package.” - R Packages, 2ed↩︎\nSee the Function lookup inside a package section of R Packages, 2ed↩︎\nSee the Package environments and the search path of Advanced R, 2ed↩︎\nSee section 1.1.3 Package Dependencies in Writing R Extensions↩︎\nSee section 1.5, Package namespaces in Writing R Extensions↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dependencies</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "7  Data",
    "section": "",
    "text": "7.1 The data/ folder\nThe previous chapters in this section covered how documenting functions and managing dependencies. In this chapter, we’ll discuss how data files (like movies.RData) become part of an app-package so they can be loaded into our application. We’ll also cover the various locations and purposes for app-package data files.\nData in R packages are typically stored in one of three folders: data/, data-raw/, and inst/extdata/.1 The folder you use will depend on the format, accessibility, and intended purpose of the data file.2\nThe primary location for data is the data/ folder. Objects in data/ folder are available in your package namespace when it’s installed and loaded, and can be accessed with the :: syntax. See the example below of the storms data from dplyr:\nlibrary(dplyr)\nhead(dplyr::storms)\n## # A tibble: 6 × 13\n##   name   year month   day  hour   lat  long status\n##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; \n## 1 Amy    1975     6    27     0  27.5 -79   tropi…\n## 2 Amy    1975     6    27     6  28.5 -79   tropi…\n## 3 Amy    1975     6    27    12  29.5 -79   tropi…\n## 4 Amy    1975     6    27    18  30.5 -79   tropi…\n## 5 Amy    1975     6    28     0  31.5 -78.8 tropi…\n## 6 Amy    1975     6    28     6  32.4 -78.7 tropi…\n## # ℹ 5 more variables: category &lt;dbl&gt;, wind &lt;int&gt;,\n## #   pressure &lt;int&gt;,\n## #   tropicalstorm_force_diameter &lt;int&gt;,\n## #   hurricane_force_diameter &lt;int&gt;",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-data",
    "href": "data.html#sec-data-data",
    "title": "7  Data",
    "section": "",
    "text": "7.1.1 LazyData\nData files become part of a package when they’re added to the data/ folder and LazyData: true is added to the DESCRIPTION file. Enabling LazyData means the data are only loaded into memory if they are explicitly accessed by the user or a function in the package. Until then, only the dataset name is loaded. This user-friendly practice is the default for most R packages.\nOmitting LazyData (or setting it to false) means we would have to access the data file from the package by explicitly loading it with the data() function.\n\n\n7.1.2 use_data()\nThe usethis::use_data() function simplifies adding data to packages. To use usethis::use_data(), we can load the data into the global environment with load(\"movies.RData\"), then run usethis::use_data(movies):\n\nusethis::use_data(movies)\n\n✔ Adding R to Depends field in DESCRIPTION.\n✔ Creating data/.\n✔ Setting LazyData to \"true\" in DESCRIPTION.\n✔ Saving \"movies\" to \"data/movies.rda\".\n☐ Document your data (see &lt;https://r-pkgs.org/data.html&gt;).\nWe can see use_data() added two fields in the DESCRIPTION and stored movies.rda in the data/ folder. After loading and installing sap, we can see movies is now part the package NAMESPACE.\nIf we run devtools::load_all(), any data in the data/ folder are not lazy-loaded at this stage. However, the data are directly available in our environment for testing during development.\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nIf we want data to be part of the lazyload DB, we need to install the package.\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nWhen the package is installed, we’ll see the following outputs related to data processing:\n\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\n\nmovies is now part of sap’s namespace:\n\n\n\n\n\n\n\nsap::movies\n\n\n\n\n7.1.3 Installed package files\nThe lazyload DB is located in the installed version of the sap package. Installation begins by reading and parsing the DESCRIPTION file to extract metadata such as the package name, version, and dependencies (e.g., Depends, Imports, Suggests). After checking the dependencies (and downloading and installing any that are missing), our source package is extracted, and the files are organized into specific folders:\n\nMeta/: information about datasets, help files, and general package metadata.\nR/: byte-compiled R code stored as .rdb and .rdx files\ndata/: datasets serialized into a lazyload database (stored as .rdb and .rdx files in the R/ directory)\nhelp/: binary help files\nhtml/: html and css files for help files\n\nThe installed folders and files can be viewed using the file path accessor function, system.file().3\n\nsystem.file(..., package = \"\", mustWork = FALSE)\n\nPassing \".\" to the ... argument of system.file() will return the installed location of the root folder of package.\nTo view the path to the R/ folder in our installed package, we can use:\n\nsystem.file(\"R\", package = \"sap\")\n\npath/to/installed/pkg/library/R-4.4/sap/R\nIf we combine this with fs::dir_tree(), we can see the files contained in the R/ folder:\n\nfs::dir_tree(system.file(\"R\", package = \"sap\"))\n\npath/to/installed/pkg/library/R-4.4/sap/R\n├── sap\n├── sap.rdb\n└── sap.rdx\nDuring installation, data in the data/ folder are converted to .rdb and .rdx file formats and moved to the binary database stored in the R/ folder.\n\nfs::dir_tree(system.file(\"data\", package = \"sap\"))\n\npath/to/installed/pkg/library/R-4.4/sap/data\n├── Rdata.rdb\n├── Rdata.rds\n└── Rdata.rdx\nThe lazyload database stores data objects in serialized form for fast retrieval (i.e., data are loaded only when explicitly requested, optimizing memory usage). The diagram below illustrates the development workflow for adding data to an app-package:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TD\n    subgraph DESC[\"&lt;strong&gt;DESCRIPTION&lt;/strong&gt;\"]\n        LazyData(\"Add &lt;code&gt;LazyData: true&lt;/code&gt;\")\n    end\n    subgraph Data[\"&lt;strong&gt;data/ folder&lt;/strong&gt;\"]\n        app_data[(\"&lt;br&gt;&lt;code&gt;app_data.rda&lt;/code&gt;\")]\n    end\n    subgraph Global[\"&lt;strong&gt;Global Environment&lt;/strong&gt;\"]\n        load_data[(\"&lt;br&gt;&lt;code&gt;app_data&lt;/code&gt;\")]\n    end\n    subgraph Lazy[\"&lt;strong&gt;lazyload DB&lt;/strong&gt;\"]\n        app_data_lazy[(\"&lt;br&gt;Serialized&lt;br&gt; (&lt;code&gt;.rdb&lt;/code&gt;/&lt;code&gt;.rds&lt;/code&gt;/&lt;code&gt;.rdx&lt;/code&gt;)\")]\n    end\n    load(\"&lt;code&gt;devtools::load_all()&lt;/code&gt;\")\n    inst(\"&lt;code&gt;devtools::install()&lt;/code&gt;\")\n    \n    DESC --&gt;|\"&lt;code&gt;usethis::use_data(app_data)&lt;/code&gt;\"|Data\n    Data --&gt; load & inst\n    load --&gt; |\"Direct access for testing\"|Global\n    inst --&gt; |\"Loaded only when&lt;br&gt;explicitly requested\"|Lazy\n  \n\n\n LazyData field in the DESCRIPTION file",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-data-raw",
    "href": "data.html#sec-data-data-raw",
    "title": "7  Data",
    "section": "7.2 data-raw/",
    "text": "7.2 data-raw/\nThe data-raw folder is not an official directory in the standard R package structure, but it’s a common location for any data processing or cleaning scripts, and the raw data file for datasets stored in data/.4\nWe’ll move the movies.RData file into data-raw/.\n\n├── data\n│   └── movies.rda\n└── data-raw\n    └── movies.RData\n\nWe can create a script to document sap::movies using usethis::use_data_raw(\"movies\"):\n\n✔ Adding \"^data-raw$\" to .Rbuildignore.\n✔ Writing data-raw/movies.R.\n☐ Modify data-raw/movies.R.\n☐ Finish writing the data preparation script in data-raw/movies.R.\n☐ Use `usethis::use_data()` to add prepared data to package.\n\nIn the data-raw/movies.R file, we find the following:\n\n## code to prepare `movies` dataset goes here\n\nusethis::use_data(movies, overwrite = TRUE)\n\nWe’ll adapt the script for the movies.RData file.\n\n## code to prepare `movies` dataset goes here\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\n\n\n\n\n\n\n\nScripts for creating movies data\n\n\n\n\n\n\nThe code used to produce the movies dataset in the data/ directory might* come from this GitHub repo. If so, the data-raw folder is where the data processing and preparation scritps would be stored (along with a copy of the data in .csv format) before saving a copy in the data/ folder.\n*I say ‘might’ because it’s not clear if the movies.RData is the output from these .R files (although many of the column names match).\n\n\n\n\n\n7.2.1 A data-raw/ example\nIf we look at the data in the dplyr package, we can see the data-raw/ folder contains a combination of .R and .csv files:\ndata-raw/\n├── band_members.R\n├── starwars.R\n├── starwars.csv\n└── storms.R\n\n1 directory, 4 files\nIn this example, the starwars.R script downloads & prepares starwars, then saves a .csv copy of the data in data-raw.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#sec-document-data",
    "href": "data.html#sec-document-data",
    "title": "7  Data",
    "section": "7.3 Documenting data",
    "text": "7.3 Documenting data\nDocumenting data can be tedious, but it’s worth the effort if you’ll be sharing your package with collaborators. There are multiple ways to store dataset documentation, but we’ll cover using a R/data.R file.5\nIn R/data.R, provide a title, description, a @details tag for more information:\n\n#' IMDB movies data \n#'\n#' Movie review data from the Building Web Applications with Shiny \n#' [course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the 'Web Scraping and programming' \n#' section of [Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#' \n\nBelow @details, include a @format tag with a one-sentence description of the data (and it’s dimensions).\n\n#' IMDB movies data \n#'\n#' Movie review data from the Building Web Applications with Shiny \n#' [course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the 'Web Scraping and programming' \n#' section of [Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming)  \n#' \n#' @format A data frame with [] rows and [] variables:\n\nEach variable (column) in the data is documented with a combination of \\describe and \\item (pay close attention to the curly brackets):\n\n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n\nAfter closing the curly brackets in \\describe, place the name of the data in quotes (\"movies\") on the following line. Below is the documentation for the first five columns in the movies dataset:\n\n#' IMDB movies data \n#'\n#' Movie review data from the Building Web Applications with Shiny \n#' [course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the 'Web Scraping and programming' \n#' section of [Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming)  \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#' }\n#'\n\"movies\"\n\nIf we load and document sap, we can see a preview of the help file:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nWe can view the documentation using the following in the Console:\n\n?movies\n\n\n\n\n\n\n\n\nDocumentation for the movies dataset\n\n\nI’ve provided documentation for the full movies dataset below.\n\n\nshow/hide full movies data documenation\n#' IMDB movies data \n#'\n#' Movie review data from the Building Web Applications with Shiny \n#' [course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the 'Web Scraping and programming' \n#' section of [Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#'  \\item{studio}{name of studio, chr}\n#'  \\item{thtr_rel_date}{Theatre release date, POSIXct, min = 1970-05-19 21:00:00, max = 2014-12-24 21:00:00}\n#'  \\item{thtr_rel_year}{Theatre release year, num, min = 1970, max = 2014}\n#'  \\item{thtr_rel_month}{Theatre release month, num, min = 1, max =12}\n#'  \\item{thtr_rel_day}{Theatre release day, num, min = 1, max =31}\n#'  \\item{dvd_rel_date}{DVD release date, POSIXct, min = 1991-03-27 21:00:00, max = 2015-03-02 21:00:00}\n#'  \\item{dvd_rel_year}{DVD release year, num, min = 1991, max = 2015}\n#'  \\item{dvd_rel_month}{DVD release month, num, min = 1, max = 12}\n#'  \\item{dvd_rel_day}{DVD release day, num, min = 1, max = 31}\n#'  \\item{imdb_rating}{Internet movie database rating, avg = 6.49, sd = 1.08}\n#'  \\item{imdb_num_votes}{Internet movie database votes, avg = 57533, sd = 112124}\n#'  \\item{critics_rating}{Rotten tomatoes rating, fct (Certified Fresh, Fresh, Rotten)}\n#'  \\item{critics_score}{Rotten tomatoes score, avg = 57.7, sd = 28.4}\n#'  \\item{audience_rating}{Audience rating, fct (Spilled, Upright)}\n#'  \\item{audience_score}{Audience score, avg = 62.4, sd = 20.2}\n#'  \\item{best_pic_nom}{Best picture nomination, fct (no, yes)}\n#'  \\item{best_pic_win}{Best picture win, fct (no, yes)}\n#'  \\item{best_actor_win}{Best actor win, fct (no, yes)}\n#'  \\item{best_actress_win}{Best actress win, fct (no, yes)}\n#'  \\item{best_dir_win}{Best director win, fct (no, yes)}\n#'  \\item{top200_box}{Top 20 box-office, fct (no, yes)}\n#'  \\item{director}{Name of director, chr}\n#'  \\item{actor1}{Name of leading actor, chr}\n#'  \\item{actor2}{Name of supporting actor, chr}\n#'  \\item{actor3}{Name of #3 actor, chr}\n#'  \\item{actor4}{Name of #4 actor, chr}\n#'  \\item{actor5}{Name of #5 actor, chr}\n#'  \\item{imdb_url}{IMDB URL}\n#'  \\item{rt_url}{Rotten tomatoes URL}\n#' }\n#'\n\"movies\"\n\n\n\n\n\n\n\n\nDocumenting data\n\n\n\n\n\n\nDocumenting data requires the following roxygen2 structure:\n#' \n#' @title single-sentence describing [data]\n#' \n#' @description\n#' Single-paragraph describing [data]\n#' \n#' @format [data] number of rows and columns:\n#' \\describe{\n#'  \\item{variable}{description}\n#'  \\item{variable}{description}\n#' }\n#'\n\"[data]\"\nReplace [data] with the name of your dataset.\n\n\n\n\n\n7.3.1 Documentation example\nTo illustrate other options for data documentation, we’ll use the dplyr package again. As we can see from the folder tree below, dplyr stores its data in the data/ folder:\ndata/\n├── band_instruments.rda\n├── band_instruments2.rda\n├── band_members.rda\n├── starwars.rda\n└── storms.rda\nThe documentation for the datasets in dplyr are stored in R/ using a data- prefix:\nR/\n├── data-bands.R\n├── data-starwars.R\n└── data-storms.R\nThe three band_ datasets have documented in a single file, data-bands.R:\n\n\nshow/hide documentation for dplyr::band_ datasets\n# from the dplyr github repo: \n# https://github.com/tidyverse/dplyr/blob/main/R/data-bands.R\n# \n#' Band membership\n#'\n#' These data sets describe band members of the Beatles and Rolling Stones. They\n#' are toy data sets that can be displayed in their entirety on a slide (e.g. to\n#' demonstrate a join).\n#'\n#' `band_instruments` and `band_instruments2` contain the same data but use\n#' different column names for the first column of the data set.\n#' `band_instruments` uses `name`, which matches the name of the key column of\n#' `band_members`; `band_instruments2` uses `artist`, which does not.\n#'\n#' @format Each is a tibble with two variables and three observations\n#' @examples\n#' band_members\n#' band_instruments\n#' band_instruments2\n\"band_members\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments2\"\n\n\nIn the example above, note that two of the datasets (band_instruments and band_instruments2) have the @format set to NULL, and define the help search name with @rdname. The @examples tag can be used to view the dataset when users click ‘Run Examples.’\nEither method works–what’s important is that each dataset in your package has documentation.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-inst-extdata",
    "href": "data.html#sec-data-inst-extdata",
    "title": "7  Data",
    "section": "7.4 External data",
    "text": "7.4 External data\nThe inst/extdata folder is used for external datasets in other file formats (.csv, .tsv, .txt, .xlsx, etc).6 These data files aren’t directly loadable using the package::data syntax or data() like with the data/ directory, but we can access them using system.file().\n\n7.4.1 inst/extdata/\nWe’ll create the inst/extdata/ folder and save a copy of movies in the .fst file format:\n\nlibrary(fs)\nlibrary(tibble)\nlibrary(fst)\n\nfst package v0.9.8\n\nfs::dir_create(\"inst/extdata/\")\nfst::write_fst(\n  x = movies, \n  path = \"inst/extdata/movies.fst\", \n  compress = 75)\n\nfstcore package v0.9.14\n(OpenMP was not detected, using single threaded mode)\nThen load, document, and install sap:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nWe can import movies.fst using system.file() to create a path to the file:\n\ntibble::as_tibble(\n  fst::read_fst(path = \n      system.file(\"extdata/\", \"movies.fst\", package = \"sap\")\n    )\n  )\n\nfstcore package v0.9.18\n(OpenMP was not detected, using single threaded mode)\n# A tibble: 651 × 34\n   title                  title_type genre runtime mpaa_rating studio\n   &lt;chr&gt;                  &lt;fct&gt;      &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;       &lt;fct&gt;\n 1 Filly Brown            Feature F… Drama      80 R           Indom…\n 2 The Dish               Feature F… Drama     101 PG-13       Warne…\n 3 Waiting for Guffman    Feature F… Come…      84 R           Sony …\n 4 The Age of Innocence   Feature F… Drama     139 PG          Colum…\n 5 Malevolence            Feature F… Horr…      90 R           Ancho…\n 6 Old Partner            Documenta… Docu…      78 Unrated     Shcal…\n 7 Lady Jane              Feature F… Drama     142 PG-13       Param…\n 8 Mad Dog Time           Feature F… Drama      93 R           MGM/U…\n 9 Beauty Is Embarrassing Documenta… Docu…      88 Unrated     Indep…\n10 The Snowtown Murders   Feature F… Drama     119 Unrated     IFC F…\n# ℹ 641 more rows\n# ℹ 28 more variables: thtr_rel_date &lt;dttm&gt;, thtr_rel_year &lt;dbl&gt;,\n#   thtr_rel_month &lt;dbl&gt;, thtr_rel_day &lt;dbl&gt;, dvd_rel_date &lt;dttm&gt;,\n#   dvd_rel_year &lt;dbl&gt;, dvd_rel_month &lt;dbl&gt;, dvd_rel_day &lt;dbl&gt;,\n#   imdb_rating &lt;dbl&gt;, imdb_num_votes &lt;int&gt;, critics_rating &lt;fct&gt;,\n#   critics_score &lt;dbl&gt;, audience_rating &lt;fct&gt;,\n#   audience_score &lt;dbl&gt;, best_pic_nom &lt;fct&gt;, best_pic_win &lt;fct&gt;, …\n# ℹ Use `print(n = ...)` to see more rows\nWe’ll cover inst/ and system.file() in more detail in the next chapter.\n\n\n\n\n\n\n\n\n\n\nSee the 07_data branch of sap.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#using-movies",
    "href": "data.html#using-movies",
    "title": "7  Data",
    "section": "7.5 Using movies",
    "text": "7.5 Using movies\nAfter documenting the movies data in R/data.R, we’ll remove the call to load() in the mod_scatter_display_server() function and replace it with a direct call to the dataset:\n\n#' Plot Display Module - Server\n#'\n#' Handles the server-side logic for rendering a scatter plot.\n#'\n#' @param id *(character)* Namespace ID for the module.\n#' @param var_inputs *(reactive)* A reactive expression containing \n#'  user-selected variables and attributes.\n#'\n#' @return No direct return value. This function generates a plot output.\n#'\n#' @section Details: \n#' `mod_scatter_display_server()`:\n#' - Uses `var_inputs` to dynamically generate a scatter plot with \n#'   user-selected variables.\n1#' - Reads from the `sap::movies` dataset\n#' - Processes plot titles and axis labels to improve readability.\n#'\n#' @section Reactive Inputs:\n#' - `var_inputs()$x`: X-axis variable.\n#' - `var_inputs()$y`: Y-axis variable.\n#' - `var_inputs()$z`: Color aesthetic variable.\n#' - `var_inputs()$alpha`: Transparency level.\n#' - `var_inputs()$size`: Size of points.\n#' - `var_inputs()$plot_title`: Title of the plot.\n#'\n#' @seealso\n#' - [`mod_var_input_server()`] for variable selection.\n#' - [`scatter_plot()`] for generating the scatter plot.\n#'\n#' @family **Plot Display Module**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(\n#'     ui = shiny::fluidPage(\n#'       mod_var_input_ui(\"vars\"),\n#'       mod_scatter_display_ui(\"plot\")\n#'     ),\n#'     server = function(input, output, session) {\n#'       selected_vars &lt;- mod_var_input_server(\"vars\")\n#'       mod_scatter_display_server(\"plot\", selected_vars)\n#'     }\n#'   )\n#' }\n#'\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n\n    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n2        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n1\n\nUpdated roxygen2 documentation\n\n\n2\n\nThe movies data from our package namespace\n\n\n\n\nAfter loading, documenting, and installing the package, we see the following application:\n\n\n\n\n\n\n\nlaunch_app() with movies data file",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#recap",
    "href": "data.html#recap",
    "title": "7  Data",
    "section": "Recap",
    "text": "Recap\nIt’s hard to imaging a Shiny app without any data, so knowing how and where to store and access data files in an app-package will make it easier to load and be reproducible in other environments. Here are a few other things to consider when including data in your app-package:\n\n\n\n\n\n\nRecap: Package data files\n\n\n\n\n\n\n\ndata/: All data files stored in data/ will be ‘lazy loaded’ (see below) when the package is installed and loaded.\nLoading: include the LazyData: true field in the DESCRIPTION file so the data is only loaded when it’s used (and it increases package loading speed).\nSize: large data files can inflate the size of your app-package, making it harder for users to download and install. CRAN also has a size limit for packages (if you plan on submitting your app-package).\nFormat: data files in data/ must be either .rda or .RData format.\nDocumentation: document the data files in either a single R/data.R file or individual .R files. Documentation should include the following roxygen2 format:\n#' \n#' @title \n#' \n#' @description\n#' \n#' @format \n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n#'\n'data'\ninst/extdata/: Store external data in the inst/extdata/ directory and access it using system.file(). This can be helpful if your app-package needs access to data files that are not R objects. For faster loading, consider the fst or feather formats.\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#footnotes",
    "href": "data.html#footnotes",
    "title": "7  Data",
    "section": "",
    "text": "Read more about the data folder in the ‘Data in packages’ section of Writing R Extenstions and the ‘Data’ chapter of R Packages, 2ed.↩︎\nFor information on how to store and retrieve inside your application, see the chapter on app Data.↩︎\nThis is similar to find.package(\"sap). Read more about system.file() and find.package().↩︎\nRead more about the data-raw folder in R Packages, 2ed↩︎\nThe ggplot2 package has a great example of documenting datasets in the R/data.R file↩︎\nRead more about the inst/extdata/ folder in R Packages, 2ed↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "launch.html",
    "href": "launch.html",
    "title": "8  Launch",
    "section": "",
    "text": "8.1 Running apps\nThis chapter covers the differences between shinyApp(), runApp(), and shinyAppDir(), what should go in an app.R file, and other options for launching an app (or apps) from within an app-package.\nDuring development, we have a variety of options for launching applications. Both RStudio  and Positron  offer a single-click button to run our application the top of the Source pane/Editor. We can also launch the app by calling the standalone app function in the Console. Below we’ll cover what happens behind the scenes when we click on these icons.\nIn the current branch of sap, the app.R file contains a call to launch_app(), which loads the package and passes the UI and server functions to shinyApp().\nAs we can see in the image below, this places the Run App icon in RStudio’s  Source pane. In Positron , the app.R file displays the Run Shiny App.\nClicking on either Run App/Run Shiny App buttons calls runApp() and launches our application, but with a loadSupport() warning.\nThe section below will cover the loadSupport() warning and why it appears when using the Run App/Run Shiny App buttons in RStudio  and Positron .",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#running-apps",
    "href": "launch.html#running-apps",
    "title": "8  Launch",
    "section": "",
    "text": "‘Launch’ vs. ‘Run’\n\n\n\n\n\n\nI’ll be using the term ‘launch’ to differentiate successfully displaying the application locally (either in the IDE window, viewer pane, or browser) from clicking on the Run App/Run Shiny App button or calling the runApp() function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSee the 06.2_pkg-imports branch of sap.\n\n\n\nRStudio Positron \n\n\n\n\n\n\n\n\n\n\n\n\n8.1.1 loadSupport() warnings\n\n\n\n\n\n\nloadSupport() warning\n\n\n\n\n\n\n\n\nThe warning in the Console is telling us loadSupport() has detected that sap is a package, but it’s still sourcing the R/ subdirectory.1\n\n\n\n\n\nRStudio Positron \n\n\nAs noted above, clicking Run App in RStudio  calls runApp() and launches our application with a loadSupport() warning printed in the Console.\n\n\n\nClicking Run App in RStudio calls runApp() and displays the loadSupport() warning\n\n\n\n\nIn Positron , clicking on the Run Shiny App button launches the application with a slightly different process than RStudio :\n\n\n\nClicking Run Shiny App in Positron calls runApp() and displays the loadSupport() warning\n\n\n\nA new Shiny terminal process is started with the --devmode option\n\nrunApp() is called with the full path to our app.R file and a port argument2\n\nThe loadSupport() warning is displayed in the Terminal\n\n\n\n\n\nIt’s important to note that we also see the loadSupport() warning if we bypass the Run App/Run Shiny App buttons and call shiny::runApp() directly in the Console:\n\nRStudio Positron \n\n\n\n\n\nCalling runApp() directly in RStudio’s Console displays the loadSupport() warning\n\n\n\n\n\n\n\nCalling runApp() directly in Positron’s Console displays the loadSupport() warning\n\n\n\n\n\n\nWhat’s with the warning?\nIn the Shiny chapter we learned loadSupport() is called automatically when an application is run with runApp(). Specifically, loadSupport()\n\n“loads any top-level supporting .R files in the R/ directory adjacent to the app.R/server.R/ui.R files” 3\n\nBehind the scenes, runApp() is called by both Run App/Run Shiny App buttons, which then automatically calls loadSupport(). This is why if we pass our standalone app function to the Console (which uses shinyApp(), not runApp()), the warning disappears:\n\nRStudio Positron \n\n\n\n\n\n\n\n\n\nNo loadSupport() warning in RStudio\n\n\n\n\n\n\n\n\n\n\n\nNo loadSupport() warning in Positron\n\n\n\n\n\n\nThe examples above demonstrate the differences between calling shinyApp() and runApp(), and the tension between calling a standalone app function from an R package vs. sourcing the app.R file in a Shiny project.\n\n\n8.1.2 --devmode\nAs we saw above, clicking Run Shiny App in Positron  will launch the application in devmode,4 which is controlled by the script below:\n\n\nshow/hide Positron’s runShinyApp.R script\nusage &lt;- \"Usage: Rscript runShinyApp.R &lt;path&gt; &lt;port&gt; [--devmode]\"\n\n1args &lt;- commandArgs(trailingOnly = TRUE)\n\nif (length(args) &lt; 2) {\n  stop(usage)\n}\n\npath &lt;- args[1]\nport &lt;- as.integer(args[2])\nstopifnot(is.integer(port))\n2devmode &lt;- \"--devmode\" %in% args\n\nif (devmode) {\n  shiny::devmode()\n} else {\n  options(shiny.autoreload = TRUE)\n}\n\nmessage(\"Running Shiny app\")\nmessage(\"-----------------\")\nmessage(sprintf('shiny::runApp(%s, port = %d)\\n', deparse(path), port))\n\n3shiny::runApp(path, port = port, launch.browser = FALSE)\n\n\n\n1\n\ncommandArgs(trailingOnly = TRUE) retrieves the arguments passed to the script, excluding the default arguments used when R starts.\n\n\n2\n\ndevmode &lt;- \"--devmode\" %in% args checks if the --devmode flag is present among the arguments. If it is, devmode is set to TRUE\n\n\n3\n\nLastly, the script runs the Shiny app using runApp() (with the specified path and port), and launch.browser = FALSE ensures the app is not automatically opened in a web browser.\n\n\n\n\nShiny devmode will display something like the following messages the first time your application is launched using the Run Shiny App button in Positron :\n\n\nshow/hide devmode options\nshiny devmode - Using full shiny javascript file. To use the minified version, call `options(shiny.minified = TRUE)`\nThis message is displayed once every 8 hours.\nshiny devmode - Turning off caching of Sass -&gt; CSS compilation. To turn caching on, call `options(sass.cache = TRUE)`\nThis message is displayed once every 8 hours.\nshiny devmode - Disabling the use of bslib precompiled themes. To be able to use precompiled themes, call `options(bslib.precompiled = TRUE)`\nThis message is displayed once every 8 hours.\nshiny devmode - Enabling warnings about low color contrasts found inside `bslib::bs_theme()`. To suppress these warnings, set `options(bslib.color_contrast_warnings = FALSE)`\nThis message is displayed once every 8 hours.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#shiny-launch-functions",
    "href": "launch.html#shiny-launch-functions",
    "title": "8  Launch",
    "section": "8.2 Shiny launch functions",
    "text": "8.2 Shiny launch functions\n\nIn the following sections, we’ll compare shinyApp(), shinyAppDir(), and runApp() to determine which one to use in R/launch_app.R and the app.R file. As we’ve seen, the Run App/Run Shiny App buttons call runApp(), even when we have a call to shinyApp() in the app.R file. This might make you wonder,\n“Why even include a call to shinyApp() if the app is being launched with runApp()?”\nLet’s review what happens when we call shinyApp().\n\n8.2.1 shinyApp()\nOne of the key features of shinyApp() is the creation of the shiny.appobj (a shiny app object):\n\napp &lt;- shinyApp(ui = movies_ui, \n                server = movies_server)\nstr(app)\n\nIf we look at the structure of the returned object from shinyApp(), we see the shiny.appobj includes the appDir under appOptions:\nList of 5\n $ httpHandler     :function (req)  \n $ serverFuncSource:function ()  \n $ onStart         : NULL\n $ options         : list()\n $ appOptions      :List of 2\n1  ..$ appDir       : chr \"/path/to/sap\"\n  ..$ bookmarkStore: NULL\n2 - attr(*, \"class\")= chr \"shiny.appobj\"\n\n1\n\nappDir is the first argument of runApp()\n\n\n2\n\nA shiny app object\n\n\nThis is why runApp() works with any .R file creating a shiny app object.\n\n\n\n\n\n\nshinyApp()\n\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(): Creates and launches an app defined inline within the call itself (or with UI and server functions passed as arguments).\n\n\nshinyApp(\n  ui = fluidPage(\n    # UI elements\n  ),\n  server = function(input, output) {\n    # Server logic\n  }\n)\n\n\n\n\n\n\n\n\n\n8.2.2 shinyAppDir()\nshinyAppDir() is similar to shinyApp(), but is designed to use a “path to directory that contains a Shiny app.”\nIn practice, we can use shinyAppDir() with a returned object from shinyApp():\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server\n      )\napp$appOptions$appDir\n\n[1] \"path/to/sap\"\nThis path can be passed to the appDir argument (along with any Shiny options).\n\nshinyAppDir(\n  appDir = app$appOptions$appDir,\n  options(test.mode = TRUE)\n)\n\n\n\n\n\n\n\nshinyAppDir()\n\n\n\n\n\n\n\n\n\n\n\n\nshinyAppDir(): Launches an app from a directory (with an app.R or ui.R/server.R files).\n\n\nshinyAppDir(\n  appDir = \"path/to/app/\", \n  options = list())\n\n\n\n\n\n\n\n\n\n8.2.3 runApp()\nThe reason we’re able to call runApp() in the Console to launch both applications above is because it’s very versatile:\n\n\n\n\n\n\nrunApp()\nCan launch apps from ui.R/server.R, app.R or directory:\n\n\n\n# In console\nrunApp()\n\n\n\n\n\n\n\n\n\nWorks with a path to an .R file that creates a shiny.appobj:5\n\n\nrunApp(appDir = \"path/to/sap\")\n\n\n\n\n\n\n\n\n\nCan also use a shiny.appobj directly:\n\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server)\nrunApp(appDir = app)\n\n\n\nThis final method does not produce the loadSupport() warning because a Shiny object (shiny.appobj) has already been created, and runApp() is essentially calling print(app) in the Console.\n\n\n\n\n\n\nrunApp()\n\n\n\n\n\n\n\n\n\n\n\n\nrunApp(): A generalized way to launch your app–it can run apps defined inline, or from a directory.\n\n\nrunApp(\n  appDir = \"path/to/app/\",\n  test.mode = TRUE/FALSE)\n\n\n\n\n\n\n\n\nRecap\n\nshinyApp() is typically used to create apps within an interactive R session\nshinyAppDir() runs a Shiny app stored in a directory (containing an app.R file (or ui.R and server.R files)\nrunApp() also launches apps in a directory, but it’s versatility makes it suitable for running apps in various formats, either defined inline or in separate directories.6",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#standalone-function",
    "href": "launch.html#standalone-function",
    "title": "8  Launch",
    "section": "8.3 Standalone function",
    "text": "8.3 Standalone function\nI tend to name the standalone app function launch_app() and include the options covered below (none of these are required, though).\n\n\nLaunch app with the shinypak package:\n\nlaunch('08_launch')\n\n\n8.3.1 App launching options\nshinyApp() or shinyAppDir() both have an options argument, so we should make this available in launch_app(). For example, one of the Shiny options we could include in our standalone app function is test.mode:\n\n‘Should the application be launched in test mode? This is only used for recording or running automated tests. Defaults to the shiny.testmode option, or FALSE if the option is not set.’\n\nThe test.mode option lets us export values from our application when we’re running tests (which we’ll cover in-depth in the Tests section).\nWe’ll make options an argument that defaults to an empty list() in launch_app():\n\nlaunch_app &lt;- function(options = list()) {\n    shinyApp(\n1      ui = movies_ui(),\n      server = movies_server,\n2      options = options\n      )\n}\n\n\n1\n\nBuild the shiny app object with movies_ui and movies_server\n\n\n2\n\nInclude options list\n\n\n\n\n\n\n8.3.2 Where to launch?\nI’ve written a display_type() helper function to 1) check if the application is being run in RStudio and, if so, 2) control where the Shiny app is launched. The run argument in display_type() takes the following options:\n\n\"p\" = Viewer Pane\n\n\"w\" = IDE Window\n\n\"b\" = External browser\n\nThe option to access configuration is shiny.launch.browser:7\n\n#' Shiny app display mode helper\n#'\n#' @param run where to launch app: \n#'  * `\"p\"` = launch in viewer pane \n#'  * `\"b\"` = launch in external browser  \n#'  * `\"w\"` = launch in window (default)\n#'\n#' @return notification of `shinyViewerType` option\n#' \n#' @export\n#'\ndisplay_type &lt;- function(run = \"w\") {\n  if (interactive()) {\n1    if (Sys.getenv(\"RSTUDIO\") == \"1\") {\n      \n2      switch(\n        run,\n        p = options(shiny.launch.browser = .rs.invokeShinyPaneViewer),\n        b = options(shiny.launch.browser = .rs.invokeShinyWindowExternal),\n        w = options(shiny.launch.browser = .rs.invokeShinyWindowViewer),\n        NULL = options(shiny.launch.browser = NULL)\n      )\n      environment &lt;- \"RStudio\"\n      shinyViewerType &lt;- getOption('shiny.launch.browser') |&gt;\n        attributes() |&gt;\n        unlist() |&gt;\n        unname()\n      \n3      cli::cli_alert_info(\"App running in {environment}\")\n4      cli::cli_alert_info(\"shinyViewerType set to {shinyViewerType}\")\n    } else {\n      environment &lt;- \"RStudio\"\n      cli::cli_alert_info(\"App not running in {environment}\")\n    }\n  } else {\n    cli::cli_alert_info(\"App not running in interactive session\")\n  }\n}\n\n\n1\n\nDetect IDE\n\n2\n\nSet option\n\n\n3\n\nPrint IDE\n\n\n4\n\nPrint option\n\n\n\n\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe cli package is imported as part the devtools/usethis workflow but we want to add it the Imports field of the DESCRIPTION with usethis::use_package('cli').\n\n\n\n\n\n\n8.3.3 An updated launch_app()\nThe display_type() and options list have been added to launch_app():\n\nlaunch_app &lt;- function(options = list(), run = \"p\") {\n1    display_type(run = run)\n    shinyApp( \n      ui = movies_ui(),\n      server = movies_server,\n2      options = options\n3    )\n}\n\n\n1\n\nSet shinyViewerType option with display_type()\n\n\n2\n\nPass options\n\n\n3\n\nLaunch app\n\n\n\n\nAfter loading, documenting, and installing our package, we can see the documentation for our updated launch_app() function in RStudio  and Positron :\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStandalone app function in RStudio\n\n\n\n\n\n\n\nStandalone app function in Positron\n\n\n\n\n\nIn RStudio , we will confirm the app is launching without the loadSupport() warning, the message is printing to the Console from the run argument, and test.mode are implemented correctly.\nWe also want to confirm launch_app() works in Positron :\n\n launch_app() launch_app() args launch_app()\n\n\n\n\n\nlaunch_app() launches the app in the Window\n\n\n\n\n\n\n\nThe updated launch_app() function launches the application in the Viewer\n\n\n\n\n\n\n\nThe updated launch_app() function in Positron\n\n\n\n\n\nWhen we’re confident our standalone app function is working, we’ll write the app.R file.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#sec-launch-app-dot-r",
    "href": "launch.html#sec-launch-app-dot-r",
    "title": "8  Launch",
    "section": "8.4 The app.R file",
    "text": "8.4 The app.R file\nThe app.R file should contain any options or settings that we would use during development. There are multiple ways to launch an application from app.R, so I encourage you to explore the options below to find a method that works for your workflow/environment.\n\n8.4.1 Is this an interactive session?\nThe first condition we’ll check to see if there is a “human operator to interact with” with base::interactive():\n\nif (!interactive()) {\n  \n} else {\n   \n}\n\nYou have probably seen control flow like this in shiny help file examples (like flowLayout() below):\n\n\n\n\n\n\n\n\n\n(a) if (interactive()) in flowLayout() example\n\n\n\n\n\nFigure 8.1: Running examples ‘interactively’ let’s us see the app demo beneath the code\n\n\n\nAdding if and interactive() will allow our app.R file distinguish between 1) launching apps from a RStudio/Positron session (i.e., during development) and 2) deploying apps (i.e., like publishing the application on Posit Connect).\n\n8.4.1.1 Non-interactive sessions\nIf the session is non-interactive, we’ll divert all regular output to the standard error stream. The sink() function “diverts R output to a connection”, so the code below sends the output that would normally print to the console to the where error messages are written.\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n} else {\n   \n}\n\nThis is useful in a non-interactive settings if we want to re-direct the error output for the console text-mode connection.\ntryCatch() is used for ‘catching conditions’ during the execution of an expression (expr =):\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(sap)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   \n}\n\nIn this case, if library(sap) throws an error, the function specified after error = is executed (i.e., pkgload::load_all()).8\nWritten this way, in a non-interactive R session, app.R will re-direct the error output and attempt to load and attach sap, and if this fails, app.R will attempt to load all the files in the R/ folder.\n\n\n8.4.1.2 Interactive sessions\nIf the session is interactive, we want app.R to load all the code in the R/ folder with pkgload::load_all() before launching our app with launch_app() (and a few optional arguments).\n\nif (!interactive()) {\n  sink(stderr(), type = \"output\")\n  tryCatch(\n    expr = {\n      library(sap)\n    },\n    error = function(e) {\n      pkgload::load_all()\n    }\n  )\n} else {\n  pkgload::load_all()\n}\n  sap::launch_app(\n    options = list(test.mode = TRUE), run = 'p')\n\npkgload::load_all() is the function that’s called when we run devtools::load_all() (or use Ctrl/Cmd + Shift + L), and this is somewhat analogous to running library(sap)\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe pkgload package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('pkgload').\n\n\n\n\n\n\n8.4.1.3 Dealing with loadSupport()\nThe withr package is designed to ‘run code with safely and temporarily modified global state’, and it comes in handy when launching shiny apps. For example, I want to turn off the loadSupport() behavior when launching the app from app.R.9\nWe can use withr::with_options() to accomplish this using the following new and code arguments\n\nnew: a named list of the new options and their values\n\ncode: the ’Code to execute in the temporary environment\n\nWe’ll place the withr::with_options() at the top of app.R and pass shiny.autoload.r = FALSE to the new argument (the contents of our app.R are passed into the code argument).\n\n1withr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n2  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        library(sap)\n      },\n      error = function(e) {\n        pkgload::load_all()\n      }\n    )\n3  } else {\n    pkgload::load_all()\n  }\n4    sap::launch_app(\n      options = list(test.mode = TRUE), run = 'p')\n}) \n\n\n1\n\nTurn off loadSupport()\n\n\n2\n\nDefine non-interactive behaviors\n\n\n3\n\nDefine interactive behaviors\n\n\n4\n\nLaunch app (with options)\n\n\n\n\nNow that we’ve updated the app.R to account for the app-package structure, we’ll load, document, and install sap and send it’s contents to the Console:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe withr package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('withr').\n\n\n\n\n\n\n\n8.4.2 Updated app.R\nWhen we send the contents of app.R to the Console, the loadSupport() options are applied before running the app:\n\nRStudio Positron \n\n\n\n\n\nSending app.R to RStudio’s Console\n\n\n\n\n\n\n\nSending app.R to Positron’s Console\n\n\n\n\n\n\n\n\n\n\n\nR/_disable_autoload.R\n\n\n\n\n\n\nIn the documentation for loadSupport(), you’ll find a second option for removing the R/ directory sourcing behavior: placing a _disable_autoload.R file in the R/ directory (this is also one of the behaviors of the golem framework, which we will cover in the following chapters).\nBoth methods work–this chapter demonstrates a way to remove the loadSupport() warning without having to add this file.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#recap-1",
    "href": "launch.html#recap-1",
    "title": "8  Launch",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some options for launching your app within your app-package. We went over what to include in the standalone app function and the app.R file, the differences between shinyApp(), shinyAppDir() and runApp(), but it’s worth exploring these topics further (especially if you plan on having more than one apps in your package).\n\n\n\n\n\n\nRecap: launching your app\n\n\n\n\n\n\nshinyApp():\n\nshinyApp() doesn’t care about file structure, so it’s useful for quick prototyping or if the app is in a single .R script. It’s also more portable because you can share your app with a single .R script.\n\nIt’s possible to bundle shinyApp() in a wrapper function to integrate within an R package (like we’ve done with launch_app()).\nshinyApp() returns a shiny app object, which can be useful if you want to explore the app structure programmatically (i.e., testing).\n\n\nshinyAppDir():\n\nshinyAppDir() launches an app from a directory, and is useful if an app is spread across multiple files and folders.\n\nrunApp()\n\nrunApp() a more generalized way to launch an app. It works with:\n\napps contained in a directory (i.e., runApp('path/to/app')\napps in separate ui.R and server.R files (or a single app.R file)\na shiny app object (passed to the appDir argument).\n\nClicking on Run App will run the application with runApp() if is detects a file (or files) that creates a shiny object.\n\n\n\n\n\nIn the following chapter, we’re going to cover where to put non-standard R package files that are common to Shiny apps (images, .css/.scss file, etc.).\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "launch.html#footnotes",
    "href": "launch.html#footnotes",
    "title": "8  Launch",
    "section": "",
    "text": "If you recall, we covered the loadSupport() function in Chapter 2.↩︎\nI’ve displayed the application in the browser clicking on the  ‘Open the current URL in the default browser’ icon.↩︎\nloadSupport() does this by sourcing the files in alphabetical order.↩︎\ndevmode is an experimental option with multiple settings.↩︎\nShiny’s examples are run using runApp()↩︎\nIt’s worthwhile to read the documentation on shinyApp(), shinyAppDir(), and runApp().↩︎\nThe shiny.launch.browser options are covered in this blog post by Garrick Aden-Buie, and I’ve combined them into a run argument in launch_app()↩︎\npkgload is part of the conscious uncoupling of the devtools package we learned about back in Chapter 6.↩︎\nYou can read more about the shiny.autoload.r option and loadSupport() in this article↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Launch</span>"
    ]
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "9  Resources",
    "section": "",
    "text": "Package files\nIn this chapter, we’ll cover how to include external resources (i.e., the images, CSS styling, JavaScript files, etc. previously served from the www/ folder) in an app-package.\nWhen we launch our app, we see the Shiny logo (shiny.png) in the www/ folder is not being loaded into the UI:\nShiny’s internal functions previously automatically handled serving the contents of www/.1 Now that we’ve converted our application into a package, we’ll need to tell the application where to find these resources explicitly.2\nWhile developing, we get used to accessing and interacting with our package files from the Files pane or Explorer window:\nHowever, as noted in the data chapter, the aren’t the files in our installed package. We can use system.file() and fs::dir_tree() to print a folder tree of our installed package files:\nVery few of the source folders and files we’ve been working with remain in the installed version of our package. An exception is the movies.fst file (stored in inst/extdata/). Hopefully seeing these two folder trees side-by-side demystifies what devtools::install() does.\nWhen we want to add non-R package files to our app (like the shiny.png logo), we store these files in the inst/folder and access them with system.file().3",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#package-files",
    "href": "resources.html#package-files",
    "title": "9  Resources",
    "section": "",
    "text": "RStudio Positron \n\n\n\n\n\n‘Source’ files for sap in Files pane\n\n\n\n\n\n\n\n‘Source’ files for sap in Explorer window\n\n\n\n\n\n\n\n\n\n\n\n\nsap/\n├── DESCRIPTION \n├── NAMESPACE \n├── R \n│   ├── data.R\n│   ├── display_type.R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   ├── launch_app.R\n│   ├── movies_server.R\n│   ├── movies_ui.R\n│   └── scatter_plot.R\n├── README.md\n├── app.R\n├── data \n│   ├── movies.RData\n│   └── movies.rda\n├── inst\n│   └── extdata \n│       └── movies.fst\n├── man\n│   ├── display_type.Rd\n│   ├── mod_scatter_display_server.Rd\n│   ├── mod_scatter_display_ui.Rd\n│   ├── mod_var_input_server.Rd\n│   ├── mod_var_input_ui.Rd\n│   ├── movies.Rd\n│   ├── launch_app.Rd\n│   ├── movies_server.Rd\n│   ├── movies_ui.Rd\n│   └── scatter_plot.Rd\n├── sap.Rproj\n└── www\n    └── shiny.png\n\n\nsap/\n1├── DESCRIPTION\n├── INDEX\n2├── Meta\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n3├── NAMESPACE\n4├── R\n│   ├── sap\n│   ├── sap.rdb\n│   └── sap.rdx\n5├── data\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n6├── extdata\n│   └── movies.fst\n7├── help\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── sap.rdb\n│   ├── sap.rdx\n│   └── paths.rds\n8└── html\n    ├── 00Index.html\n    └── R.css\n\n1\n\nDESCRIPTION is in both source and installed versions, and format remains unchanged.\n\n2\n\nMetadata files, such as data.rds and package.rds, are created in the Meta/ directory\n\n\n3\n\nNAMESPACE is in both source and installed versions, and format remains unchanged.\n\n4\n\nR code in the R/ directory is byte-compiled for improved performance, stored in .rdb and .rdx files.\n\n\n5\n\nDatasets in the data/ directory are serialized into a lazyload database and stored as .rdb and .rdx files in the R/ directory.\n\n\n6\n\nThe extdata/ folder is in both source and installed versions, and the movies.fst file remains unchanged.\n\n\n7\n\n.Rd files are processed into binary help files\n\n\n8\n\nHTML and styling for help index\n\n\n\n\n\n\n\n\n“The contents of the inst/ subdirectory will be copied recursively to the installation directory. Subdirectories of inst/ should not interfere with those used by R (currently, R/, data/, demo/, exec/, libs/, man/, help/, html/ and Meta/, and earlier versions used latex/, R-ex/).” - Writing R extensions, Package subdirectories\n\n\n\n\n\n\n\nOther Uses of the inst/ folder\n\n\n\n\n\n\nI found exploring the structure of the inst/ folder in other packages incredibly helpful in understanding how to use this directory for package development. For example, the inst/examples/ folder in the shiny package holds a variety of Shiny apps:\n/path/to/install/Library/R/x86_64/4.2/library/shiny/examples/\n├── 01_hello\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 02_text\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 03_reactivity\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 04_mpg\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 05_sliders\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 06_tabsets\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 07_widgets\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 09_upload\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n├── 10_download\n│   ├── DESCRIPTION\n│   ├── Readme.md\n│   └── app.R\n└── 11_timer\n    ├── DESCRIPTION\n    ├── Readme.md\n    └── app.R\nThese files are used in shiny::runExample()):\nshiny::runExample(example = '11_timer')",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#sec-resources-image-files",
    "href": "resources.html#sec-resources-image-files",
    "title": "9  Resources",
    "section": "9.1 Image files",
    "text": "9.1 Image files\nTo include the contents of www/ in our app-package, we’ll need to move www/ into inst/, and then access its contents with system.file().4\n\n9.1.1 system.file()\nWe used system.file() in the Data chapter (see Section 7.1.3) to access the movies.fst file in inst/extdata/. system.file() gives us access to the package files on installation (i.e., the files we saw in the folder tree above).\n\n\nsystem.file() is accessing movies.fst from the installed location\nfst::read_fst(\n  path = system.file(\"extdata/\", \"movies.fst\", \n                     package = \"sap\")\n  )\n\n\nIn essence, movies.fst has ‘source’ package and ‘installed’ locations.\n\nSource package files\n\n1inst/\n  └── extdata/\n        └── movies.fst\n\n\n1\n\nWhat we see\n\n\n\n\n\n\nInstalled package files\n\n1└── extdata/\n      └── movies.fst\n\n\n1\n\nWhat R sees\n\n\n\n\n\n\n\n9.1.2 addResourcePath()\nThe addResourcePath() function will add a “directory of static resources to Shiny’s web server.”5 In sap, we want to add the www directory, which includes the shiny.png file.\n\n\n\n\n\n\nCurrent www location\n├── inst\n│   └── extdata\n│       └── movies.fst\n└── www\n    └── shiny.png\n\n\n \n\n\nNew www location\ninst/\n  ├── extdata/\n  │   └── movies.fst\n  └── www/\n      └── shiny.png\n\n\n\nIn R/movies_ui.R, we’ll include the addResourcePath() at the top of the tagList() and reference the image in img() using only the subfolder in the path:\n\n\nshow/hide movies_ui()\nmovies_ui &lt;- function() {\n  addResourcePath(\n1    prefix = \"www\",\n2    directoryPath = system.file(\"www\", package = \"sap\")\n  )\n  tagList(\n    bslib::page_fillable(\n      h1(\"Movie Reviews\"),\n      bslib::layout_sidebar(\n        sidebar =\n          bslib::sidebar(\n            title = tags$h4(\"Sidebar inputs\"),\n            img(\n3              src = \"www/shiny.png\",\n              height = 60,\n              width = 55,\n              style = \"margin:10px 10px\"\n            ),\n            mod_var_input_ui(\"vars\")\n          ),\n        bslib::card(\n          full_screen = TRUE,\n          bslib::card_header(\n            tags$h4(\"Scatter Plot\")\n          ),\n          mod_scatter_display_ui(\"plot\"),\n          bslib::card_footer(\n            tags$blockquote(\n              tags$em(\n                tags$p(\n                  \"The data for this application comes from the \",\n                  tags$a(\"Building web applications with Shiny\",\n                    href = \"https://rstudio-education.github.io/shiny-course/\"\n                  ),\n                  \"tutorial\"\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n}\n\n\n\n1\n\nPrefix (or folder name) of installed location\n\n\n2\n\nPath to installed package files\n\n\n3\n\nReference to installed package image file\n\n\n\n\nThe application includes the image file after loading, documenting, and installing our package:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlibrary(sap)\nlaunch_app(run = 'p')\n\n\n\n\n\n\n\n\ninst/www accessible with addResourcePath()\n\n\nWe can also use inst/ to store alternate image files and configure the UI to display a different layout. This method ensures our app has the exact same functionality, but a different UI layout.6\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nbslib is a dependency of shiny, so we don’t need to import this with usethis::use_package() (see output from pak::pkg_deps_tree('shiny') below)\nshiny 1.9.1 ✨                                                             \n├─httpuv 1.6.15 ✨🔧\n│ ├─later 1.3.2 ✨🔧\n│ │ ├─Rcpp 1.0.13 ✨🔧\n│ │ └─rlang 1.1.4 ✨🔧\n│ ├─promises 1.3.0 ✨🔧\n│ │ ├─fastmap 1.2.0 ✨🔧\n│ │ ├─later\n│ │ ├─magrittr 2.0.3 ✨🔧\n│ │ ├─R6 2.5.1 ✨\n│ │ ├─Rcpp\n│ │ └─rlang\n│ ├─R6\n│ └─Rcpp\n├─mime 0.12 ✨🔧\n├─jsonlite 1.8.8 ✨🔧\n├─xtable 1.8-4 ✨\n├─fontawesome 0.5.2 ✨\n│ ├─rlang\n│ └─htmltools 0.5.8.1 ✨🔧\n│   ├─base64enc 0.1-3 ✨🔧\n│   ├─digest 0.6.36 ✨🔧\n│   ├─fastmap\n│   └─rlang\n├─htmltools\n├─R6\n├─sourcetools 0.1.7-1 ✨🔧\n├─later\n├─promises\n├─crayon 1.5.3 ✨\n├─rlang\n├─fastmap\n├─withr 3.0.1 ✨\n├─commonmark 1.9.1 ✨🔧\n├─glue 1.7.0 ✨🔧\n├─bslib 0.8.0 ✨\n│ ├─base64enc\n│ ├─cachem 1.1.0 ✨🔧\n│ │ ├─rlang\n│ │ └─fastmap\n│ ├─fastmap\n│ ├─htmltools\n│ ├─jquerylib 0.1.4 ✨\n│ │ └─htmltools\n│ ├─jsonlite\n│ ├─lifecycle 1.0.4 ✨\n│ │ ├─cli 3.6.3 ✨🔧\n│ │ ├─glue\n│ │ └─rlang\n│ ├─memoise 2.0.1 ✨\n│ │ ├─rlang\n│ │ └─cachem\n│ ├─mime\n│ ├─rlang\n│ └─sass 0.4.9 ✨🔧\n│   ├─fs 1.6.4 ✨🔧\n│   ├─rlang\n│   ├─htmltools\n│   ├─R6\n│   └─rappdirs 0.3.3 ✨🔧\n├─cachem\n└─lifecycle\n\nKey:  ✨ new | 🔧 compile\n\n\n\n\nThe updated movies_ui() function below has an optional bslib argument that will change the layout an display an alternate image (stored in inst/www/bootstrap.png).\n\n\nshow/hide updated movies_ui()\n#' User Interface for the Movies Review Application\n#'\n#' Creates the user interface (UI) for the Movies Review application, which\n#' allows users to create customizable scatter plots based on movie data.\n#' \n#' @param bslib View bslib logo?\n#'\n#' @return A Shiny `tagList` object containing the UI elements.\n#'\n#' @section Details:\n#' The interface is built using [`bslib`](https://rstudio.github.io/bslib/)\n#' - **Page (fillable)**: [`bslib::page_fillable()`](https://rstudio.github.io/bslib/reference/page_fillable.html)\n#'   displays the app title.\n#' - **Sidebar**: [`bslib::layout_sidebar()`](https://rstudio.github.io/bslib/reference/sidebar.html)\n#'   includes a logo and the variable\n#'   selection module.\n#'   ([`mod_var_input_ui`]).\n#' - **Card**: [`bslib::card()`](https://rstudio.github.io/bslib/reference/card.html)\n#'   displays the scatter plot module\n#'   ([`mod_scatter_display_ui`]).\n#'\n#' @seealso\n#' - [`movies_server()`] for the server logic of the app.\n#' - [`mod_var_input_ui()`] and [`mod_scatter_display_ui()`] for the modules\n#'   included in the UI.\n#'\n#' @family **Application Components**\n#'\n#' @examples\n#' if (interactive()) {\n#'   shiny::shinyApp(ui = movies_ui(), server = movies_server)\n#' }\n#'\n#' @export\nmovies_ui &lt;- function(bslib = FALSE) {\n1  addResourcePath(\n    prefix = 'www', \n    directoryPath = system.file('www', package = 'sap'))\n  if (isFALSE(bslib)) {\n2  tagList(\n    bslib::page_fillable(\n      h1(\"Movie Reviews\"),\n      bslib::layout_sidebar(\n        sidebar =\n          bslib::sidebar(\n            title = tags$h4(\"Sidebar inputs\"),\n            img(\n              src = \"www/shiny.png\",\n              height = 60,\n              width = 55,\n              style = \"margin:10px 10px\"\n            ),\n            mod_var_input_ui(\"vars\")\n          ),\n        bslib::card(\n          full_screen = TRUE,\n          bslib::card_header(\n            tags$h4(\"Scatter Plot\")\n          ),\n          bslib::card_body(fillable = TRUE,\n            mod_scatter_display_ui(\"plot\")\n          ),\n          bslib::card_footer(\n            tags$blockquote(\n              tags$em(\n                tags$p(\n                  \"The data for this application comes from the \",\n                  tags$a(\"Building web applications with Shiny\",\n                    href = \"https://rstudio-education.github.io/shiny-course/\"\n                  ),\n                  \"tutorial\"\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n  } else {\n3    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            open = TRUE,\n            mod_var_input_ui(\"vars\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n                bslib::card_header(\n4                  img(src = \"www/bootstrap.png\",\n                  height = 80,\n                  width = 100,\n                  style = \"margin:10px 10px\")\n              ),\n             bslib::card_body(fillable = TRUE,\n                 mod_scatter_display_ui(\"plot\")\n            )\n          )\n        )\n      )\n    )\n  }\n} \n\n\n\n1\n\nInclude inst/www resources\n\n\n2\n\nOriginal bslib layout\n\n\n3\n\nNew bslib layout\n\n\n4\n\nReference to alternate image (in inst/www/bootstrap.png)\n\n\n\n\nThe new bslib argument in our updated moves_ui() function toggles between the two UI options. We should also add an app argument to launch_app() to handle the two UI options:\n\n\nshow/hide updated launch_app()\n#' Movies app standalone function\n#'\n#' Wrapper function for `shinyApp()`\n#'\n#' @param app which app to run. Options are: \n#'  * `NULL` = the default app (`\"movies\"`)  \n#'  * `\"bslib\"` = Alternative `bslib` layout \n#' @param options arguments to pass to `options()`\n#' @param run where to launch app:\n#'  * `p` = launch in viewer pane\n#'  * `b` = launch in external browser\n#'  * `w` = launch in window\n#' @param ... arguments passed to UI\n#'\n#' @return shiny app\n#'\n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n#'\n#' @export\n#' \n#' @import shiny\n#' \nlaunch_app &lt;- function(app = NULL, options = list(), run = \"p\", ...) {\n  \n  if (interactive()) {\n    display_type(run = run)\n  }\n  \n  if (is.null(app)) {\n    app &lt;- \"movies\"\n  }\n  \n  if (app == \"bslib\") {\n    shinyApp(\n      ui = movies_ui(bslib = TRUE),\n      server = movies_server,\n      options = options\n    )\n  } else {\n    shinyApp(\n      ui = movies_ui(...),\n      server = movies_server,\n      options = options\n    )\n  }\n}\n\n\nNow we can load, document, and build the package and confirm app = \"bslib\" works:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlaunch_app(app = 'bslib')\n\nThis alternate version of launch_app() uses the same modules and utility functions as the previous versions but when app = \"bslib\", the app displays the alternate UI layout:\n\n\n\n\n\n\n\ninst/www/bootstrap.png image from movies_ui()\n\n\nThe inst/ folder is a versatile tool for storing various files needed in our application (logos or images, CSS styling, JavaScript functions, HTML, etc.). The example above was simple, but using inst/ to hold resources for alternate UIs that can be displayed with a single argument is handy for demoing versions for stakeholders.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#sec-resources-data-files",
    "href": "resources.html#sec-resources-data-files",
    "title": "9  Resources",
    "section": "9.2 Data files",
    "text": "9.2 Data files\nIt is not uncommon to develop an application that can handle data from multiple sources. In these situations, we can sometimes store the alternative data files in the inst/ folder.7\n\n9.2.1 A tidy-movies app\nWe’ll create an alternative application in sap that uses a tidy version of the ggplot2movies data, which we create using a function stored in the data-raw/tidy_movies.R file.8\nWe can place the application modules, UI, and server functions in inst/tidy-movies/R:\n\n1inst/tidy-movies/\n            ├── R \n2            │   ├── devServer.R\n            │   ├── devUI.R # \n            │   ├── dev_mod_scatter.R  \n            │   └── dev_mod_vars.R\n3            ├── app.R\n4            ├── imdb.png\n5            └── tidy_movies.fst\n\n2 directories, 7 files\n\n\n1\n\nTidy movies app folder\n\n\n2\n\nApp ui, server, and modules\n\n\n3\n\nLaunch tidy-movies app\n\n4\n\nAlternate image/logo\n\n\n5\n\nAlternate data\n\n\n\n\nAll of the functions from sap are available in the tidy-movies/ app with explicit namespacing (i.e., sap::fun()):\n\ndev_mod_vars_ui() contains choices for the columns in the tidy_movies data, but there’s no need to rewrite the mod_var_input_server() function.9\nThe dev_mode_scatter module functions have been rewritten to add functionality for importing the tidy_movies.fst data file and an option to removing missing values from the graph.\ninst/tidy-data/app.R contains a call to shinyApp() and any other packages we’ll need to launch the application. The data and alternative image file can be placed in the root folder (with the app.R file):\n\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart LR\n    subgraph R[\"&lt;strong&gt;R/ folder&lt;/strong&gt;\"]\n        subgraph launch[\"launch_app('ggp2')\"]\n            display_type[\"display_type()\"]\n        end\n        mod_var_input_server[\"mod_var_input_server()\"]\n        scatter_plot[\"scatter_plot()\"]\n    end\n    \n    subgraph tidy_movies[\"&lt;strong&gt;tidy-movies/ folder&lt;/strong&gt;\"]\n        subgraph app[\"app.R file\"]\n          subgraph SubR[\"&lt;strong&gt;R/ folder&lt;/strong&gt;\"]\n            devServer[\"devServer()\"]\n            dev_mod_scatter_server[\"dev_mod_scatter_server()\"]\n            devServer -.-&gt;|\"&lt;em&gt;Calls&lt;/em&gt;\"|dev_mod_scatter_server\n            devUI[\"devUI()\"]\n            dev_mod_vars_ui[\"dev_mod_vars_ui()\"]\n            dev_mod_scatter_ui[\"dev_mod_scatter_ui()\"]\n            devUI -.-&gt;|\"&lt;em&gt;Calls&lt;/em&gt;\"|dev_mod_vars_ui & dev_mod_scatter_ui\n            end\n        end\n        data[(\"tidy_movies.fst\")]\n        img[/\"imdb.png\"\\]\n    end\n        \n\n    launch ==&gt; |\"&lt;strong&gt;&lt;code&gt;shinyAppDir()&lt;/code&gt;&lt;/strong&gt;\"|app\n    scatter_plot -.-&gt;|\"&lt;em&gt;Called from&lt;/em&gt;\"|dev_mod_scatter_server\n    mod_var_input_server -.-&gt;|\"&lt;em&gt;Called from&lt;/em&gt;\"|devServer\n\n    %% utility functions\n    style scatter_plot fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    style display_type fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    \n    %% tidy-movies/ \n    style tidy_movies fill:#e8f0f5,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% tidy-movies/R\n    style SubR fill:#f7fafb,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% tidy-movies/R/ files\n    style devUI stroke:#333,stroke-width:1px,rx:6,ry:6\n    style devServer stroke:#333,stroke-width:1px,rx:6,ry:6\n    style dev_mod_scatter_server color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style dev_mod_scatter_ui color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style dev_mod_vars_ui color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    %% files \n    style app fill:#f8f6e7,color:#000\n    style data fill:#f8f6e7,color:#000\n    style img fill:#f8f6e7,color:#000\n\n\n\n Architecture of app functions in inst/tidy-movies/ folder \n\n\n\n\n\n9.2.2 Launching tidy-movies\nFinally, we’ll launch the tidy_movies data app with the app argument in our standalone function. This conditional argument is similar to the app = \"bslib\" option, but we use shinyAppDir() to launch the app stored in inst/tidy-movies (which we locate with system.file()).\n\n\nshow/hide R/launch_app.R\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#' \n#' @param app which app to run. Options are:\n#'  * `NULL` = the default app (`\"movies\"`)  \n#'  * `\"bslib\"` = Alternative `bslib` layout \n#'  * `\"ggp2\"` = `ggplot2movies` (tidy) data app.\n#' @param options arguments to pass to `options()`\n#' @param run where to launch app:\n#'  * `p` = launch in viewer pane\n#'  * `b` = launch in external browser\n#'  * `w` = launch in window\n#' @param ... arguments passed to UI \n#'\n#' @return A **Shiny application** object.\n#'\n#' @section Details:\n#' The application uses:\n#' - **UI**: Defined in [`movies_ui()`].\n#' - **Server Logic**: Defined in [`movies_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the user interface.\n#' - [`movies_server()`] for the server logic.\n#'\n#' @family **Standalone Application**\n#' \n#' @details\n#' See the [ggplot2movies](https://github.com/hadley/ggplot2movies) package.\n#' \n#'\n#' @examples\n#' if (interactive()) {\n#'   launch_app()\n#' }\n#'\n#' @export\n#' \n#' @import shiny\n#' \nlaunch_app &lt;- function(app = NULL, options = list(), run = \"p\", ...) {\n  \n  if (interactive()) {\n    display_type(run = run)\n  }\n  \n  if (is.null(app)) {\n    app &lt;- \"movies\"\n  }\n  \n  if (app == \"bslib\") {\n    shinyApp(\n      ui = movies_ui(bslib = TRUE),\n      server = movies_server,\n      options = options\n    )\n  } else if (app == \"ggp2\") {\n      shinyAppDir(\n        appDir = system.file(\"tidy-movies\",\n          package = \"sap\"\n      ),\n      options = options\n      )\n  } else {\n    shinyApp(\n      ui = movies_ui(...),\n      server = movies_server,\n      options = options\n    )\n  }\n}\n\n\n\nAfter loading, documenting, and installing, we’ll run the tidy ggplot2movies::movies data app:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlaunch_app(app = 'ggp2')\n\n\n\n\n\n\n\n\ninst/tidy-movies/ app with dev_movies_ui()\n\n\n\n\n\n\n\n\nUsing colors and themes\n\n\n\n\n\n\nUsing different colors and themes for alternative applications can be a quick and easy way to differentiate the versions of your application.",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#sec-resources-inst-quarto",
    "href": "resources.html#sec-resources-inst-quarto",
    "title": "9  Resources",
    "section": "9.3 Quarto apps",
    "text": "9.3 Quarto apps\nShiny apps can also be built inside Quarto documents, in which case we could also use the inst/ folder to store and load resources (images, CSS, etc.).\nThe inst/quarto/ folder contains a Quarto version of our movies app:\n\ninst/quarto\n├── _quarto.yml\n├── index.qmd\n└── www\n    ├── quarto.png\n    └── styles.scss\n\n1 directory, 4 files\n\nThe _quarto.yml file contains project metadata for the app10, and the www/ folder contains an image file and a CSS file.\ntitle: \"Quarto Movies App\"\n\nformat:\n  html:\n    embed-resources: true\n\n9.3.1 Shiny documents\nIn index.qmd, we can specify server: shiny in the YAML header to let Quarto know we want the document to be interactive:\n\n---\ntitle: Quarto Movies App\nformat:\n  html:\n    page-layout: full\n    embed-resources: true\n    theme:\n      - united\n      - www/styles.scss\n    \nserver: shiny\n---\n\nThe other options we’ve included in our YAML header are page-layout (for customizing the layout of each element), embed-resources (to create a standalone HTML document), and theme (we’re using a Bootstrap 5 theme with custom CSS).\nTo set up our Quarto/Shiny app, we should include a code chunk with context: setup near the top of the document. We can use the image files in inst/quarto/www by adding a call to addResourcePath() in the setup chunk:\n\n```{r}\n1#| context: setup\n2library(sap)\nlibrary(thematic)\nlibrary(ragg)\n3addResourcePath(\n    prefix = 'quarto',\n    directoryPath = system.file('www', package = 'sap'))\n4options(shiny.useragg = TRUE)\n5thematic::thematic_set_theme(\n  theme = thematic::thematic_theme(\n    bg = \"#070d35\", \n    fg = \"#FFFFFF\", \n    sequential = NA, \n    accent = \"#2ee3a4\"))\n```\n\n1\n\nsetup for HTML document\n\n2\n\npackages (including our app-package)\n\n3\n\nresources (including CSS)\n\n4\n\noptions (for images)\n\n5\n\ntheme from thematic\n\n\n\nNote the context: setup chunk includes options and themes (I’m using the thematic package to set a theme for the ggplot2 graph in our app).\nUsing page-layout: full in the YAML header lets us use a variety of panel options for each code chunk. For example, we’ll place the variable input module in a code chunk with the input option,11 the display module with the center option,12 and the data/Quarto attribution in the fill option.13\n\n```{r}\n1#| panel: input\nmod_var_input_ui(\"vars\")\n```\n\n```{r}\n2#| panel: center\nmod_scatter_display_ui(\"plot\")\n```\n\n```{r}\n3#| panel: fill\ntags$br()\ntags$em(\n  \"Built using \",\n  tags$a(\n    img(\n      src = \"www/quarto.png\",\n      height = 25,\n      width = 90,\n      style = \"margin:10px 10px\"\n    ),\n    href = \"https://quarto.org/docs/interactive/shiny/\"\n  ),\n  \"and data from the \",\n  tags$a(\"Building web applications with Shiny\", \n    href = \"https://rstudio-education.github.io/shiny-course/\"),\n  \"tutorial.\"\n)\n```\n\n1\n\nHorizontal input panel\n\n\n2\n\nCenter the graph display\n\n\n3\n\nData/Quarto attribute with hyperlinks across bottom of app\n\n\n\nThe context: setup and panel option code chunks will execute when the document is rendered. However, any code chunk with context: server will execute when the document is served (not when it is rendered).14\n\n```{r}\n#| context: server\n\nselected_vars &lt;- mod_var_input_server(\"vars\")\n\nmod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n\n```\n\nThese chunks are run in separate R sessions, meaning we cannot access variables created in the first chunk within the second and vice versa (similar to to the movies_ui(), and movies_server.R()).\nTo render our Quarto Shiny app, we can use the Run Document/Preview button or running the following commands in the Terminal:\nquarto serve /&lt;path&gt;/&lt;to&gt;/sap/inst/quarto/index.qmd\n\n\n\n\n\n\n\nMovies Quarto Shiny App\n\n\nWe can also launch the quarto app using the following R commands:\n\nquarto::quarto_preview(\n  file = system.file(\"quarto\", \"index.qmd\", \n                     package = \"sap\"),\n  render = \"all\",\n  browse = utils::browseURL,\n  watch = TRUE\n)\n\n\n\n9.3.2 Launching inst/quarto\nTo launch our Quarto application from inst/quarto, we’ll change the app argument again in launch_app():\n\n\nshow/hide launch_app()\n#' Launch the Movies Review Application\n#'\n#' Starts the Movies Review Shiny application, which provides a customizable\n#' scatter plot interface for analyzing movie data.\n#' \n#' @param app which app to run. Options are:\n#'  * `NULL` = the default app (`\"movies\"`)  \n#'  * `\"bslib\"` = Alternative `bslib` layout \n#'  * `\"ggp2\"` = `ggplot2movies` (tidy) data app.\n#'  * `\"quarto\"` = Quarto movies app.\n#' @param options arguments to pass to `options()`\n#' @param run where to launch app:\n#'  * `p` = launch in viewer pane\n#'  * `b` = launch in external browser\n#'  * `w` = launch in window\n#' @param ... arguments passed to UI \n#'\n#' @return A **Shiny application** object.\n#'\n#' @section Details:\n#' The application uses:\n#' - **UI**: Defined in [`movies_ui()`].\n#' - **Server Logic**: Defined in [`movies_server()`].\n#'\n#' @seealso\n#' - [`movies_ui()`] for the user interface.\n#' - [`movies_server()`] for the server logic.\n#'\n#' @family **Standalone Application**\n#' \n#' @details\n#' See the [ggplot2movies](https://github.com/hadley/ggplot2movies) package.\n#' \n#'\n#' @examples\n#' if (interactive()) {\n#'   launch_app()\n#' }\n#' \n#' @export\n#' \n#' @import shiny\n#' \nlaunch_app &lt;- function(app, options = list(), run = \"p\", ...) {\n  \n  if (interactive()) {\n    display_type(run = run)\n  }\n  \n  if (is.null(app)) {\n    app &lt;- \"movies\"\n  }\n  \n  if (app == \"bslib\") {\n    shinyApp(\n      ui = movies_ui(bslib = TRUE),\n      server = movies_server,\n      options = options\n    )\n  } else if (app == \"ggp2\") {\n      shinyAppDir(\n        appDir = system.file(\"tidy-movies\",\n          package = \"sap\"\n      ),\n      options = options\n      )\n  } else if (app == \"quarto\") {\n      quarto::quarto_preview(\n        system.file(\"quarto\", \"index.qmd\",\n            package = \"sap\" ), \n        render = \"all\")\n  } else {\n    shinyApp(\n      ui = movies_ui(...),\n      server = movies_server,\n      options = options\n    )\n  }\n}\n\n\nNow we can load, document, and build the package:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nLaunching the application now just requires a single argument:\n\nlaunch_app(app = \"quarto\")",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#sec-resources-inst-prod",
    "href": "resources.html#sec-resources-inst-prod",
    "title": "9  Resources",
    "section": "9.4 Production",
    "text": "9.4 Production\nFinally, it’s also possible to have a folder dedicated for deploying a production version of our application from our app-package. I recommend naming this folder something like inst/prod/ or inst/deploy, and it can contain a version of your application that’s ‘fit for public consumption.’ In inst/prod/app I’ve created an app.R file:\n\ninst/\n  └── prod/\n      └── app\n          └── app.R\n          \n2 directories, 1 file\n\n\n9.4.1 prod/app/app.R\napp.R includes a call to launch_app() with the app and options arguments:\n\n\nshow/hide prod/app/app.R\nlibrary(sap)\nlaunch_app(app = \"bslib\", options = list(test.mode = FALSE))\n\n\nI’ll use the \"bslib\" version from above to differentiate it from the other applications in sap.\n\n\n9.4.2 Deploying inst/prod/\nBack in the our app.R file, we’ll use shinyAppDir() and system.file() to return the app object from prod/app/app.R:\n\n\nshow/hide app.R\n1withr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        library(sap)\n      },\n      error = function(e) {\n        pkgload::load_all()\n      }\n    )\n2    shinyAppDir(appDir = system.file(\"prod/app\", package = \"sap\"))\n  } else {\n    pkgload::load_all()\n  }\n  launch_app(options = list(test.mode = FALSE), run = 'p')\n})\n\n\n\n1\n\nSet option to turn off loadSupport()\n\n2\n\nCreate shiny object from prod/app\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nTo deploy the app, call rsconnect::deployApp() in the console and supply an appName:\n\nrsconnect::deployApp(appName = 'movie-reviews-prod')\n\nThe deployment log will look something like this:\n── Preparing for deployment ─────────────────────────────────────────────────\n✔ Deploying \"movie-reviews-prod\" using \"server: shinyapps.io / username: &lt;username&gt;\"\nℹ Creating application on server...\n✔ Created application with id 12711883\nℹ Bundling 39 files: .Rbuildignore, app.R, data/movies.rda, data/movies.RData,\ndata-raw/tidy_movies.R, DESCRIPTION, inst/tidy-data/app.R, inst/tidy-data/imdb.png,\ninst/tidy-data/R/dev_mod_scatter.R, inst/tidy-data/R/dev_mod_vars.R, \ninst/tidy-data/R/devServer.R, inst/tidy-data/R/devUI.R, \ninst/tidy-data/tidy_movies.fst, inst/extdata/movies.fst, inst/prod/app/app.R, \ninst/www/bootstrap.png, inst/www/shiny.png, man/display_type.Rd, …, \nR/scatter_plot.R, and README.md\nℹ Capturing R dependencies with renv\n✔ Found 69 dependencies\n✔ Created 1,568,327b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 9101312\n── Deploying to server ────────────────────────────────────────────────────────\nWaiting for task: 1457289827\n  building: Processing bundle: 9101312\n  building: Building image: 11074678\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 11074678\n  deploying: Starting instances\n  success: Stopping old instances\n── Deployment complete ───────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://&lt;username&gt;.shinyapps.io/movie-reviews-prod/&gt;\nYou can see a deployed version of this application here",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#recap",
    "href": "resources.html#recap",
    "title": "9  Resources",
    "section": "Recap",
    "text": "Recap\n\n\nLaunch app with the shinypak package:\n\nlaunch('09_inst')\n\nThis chapter had covered how to include external files and resources (i.e., what was previously stored in the www/ folder of a regular Shiny app project) in your app-package with addResourcePath() and system.file().\nWe’ve also covered how to use the inst/ folder to include alternative files, development and production/deployment versions of your app. You can now launch the following applications from sap:\nStandard application with/without test mode\n\nlibrary(sap)\nlaunch_app(options = list(test.mode = TRUE))\n# or \nlaunch_app(options = list(test.mode = FALSE))\n\ninst/bslib: an application with an alternative layout (with/without test mode)\n\nlibrary(sap)\nlaunch_app(app = \"bslib\", options = list(test.mode = TRUE))\n# or \nlaunch_app(app = \"bslib\", options = list(test.mode = FALSE)) \n\ninst/tidy-data: an application using a ‘development’ dataset (with/without test mode)\n\nlibrary(sap)\nlaunch_app(app = \"ggp2\", options = list(test.mode = TRUE))\n# or \nlaunch_app(app = \"ggp2\", options = list(test.mode = FALSE))\n\ninst/prod: An app.R file for launching a ‘production’ version of our app.\n\nlibrary(sap)\nrsconnect::deployApp(appName = 'movie-reviews-prod')\n\nIn the next section, we’re going to cover testing the code in a shiny app-package.\n\n\n\n\n\n\nRecap: inst & www folders\n\n\n\n\n\n\n\ninst/: the inst/ folder is installed with your app-package and will be accessible to users, so it’s a great location for files you want contained in your app, but don’t fit into the standard R package structure.\n\ninst/ is also a great location for alternative versions of applications (i.e., inst/app/dev or inst/app/prod/).\n\nsystem.file(): constructs a path to files or folders within installed packages and is especially useful when working with external datasets (i.e., inst/extdata/) or other external resources included with your app-package (i.e., inst/www/).\nwww: used for external static resources in shiny apps. shiny will automatically serve files under the www/ directory, but in app-packages we need to explicitly set this location with shiny::addResourcePath()\naddResourcePath(): create a prefix (i.e., path) for a directoryPath of static files to accessible in shiny’s web server:\n# file location\ninst/\n  └── www/\n        └── shiny.png\n# add path to app \naddResourcePath(prefix = 'www', \n                directoryPath = system.file('www', \n                                package = 'sap'))\n# use path without 'inst/' prefix\nshiny::img(src = 'www/shiny.png')\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#footnotes",
    "href": "resources.html#footnotes",
    "title": "9  Resources",
    "section": "",
    "text": "“The www/ folder is a special one for Shiny. Resources your app may link to, such as images—or in this case, scripts—are placed in the www/ folder. Shiny then knows to make these files available for access from the web browser.” - Shiny documentation↩︎\nThis is a common problem developers encounter when converting shiny app into app-packages. See this popular thread on Posit Community.↩︎\nRead more about sub-directories to avoid in inst/ in R Packages, 2ed.↩︎\nThe key takeaway here is that the inst/ subfolders and files are available unchanged in the installed version (with the inst/ folder omitted.).↩︎\nYou can read more about adding external resources in the documentation for addResourcePath().↩︎\nAs the development of your application progresses, you can (and should) keep different versions of your application in separate Git branches. But I’ve also found using the inst/ folder for those early stages of developing is helpful.↩︎\nWe covered external data in Section 7.4.↩︎\nWe covered the data-raw/ folder in the Data chapter, and you can read more about it here in R packages, 2ed↩︎\nThis requires exporting mod_var_input_server() with @export in the R/ folder.↩︎\nRead more about the _quarto.yml configuration file in the Quarto documentation.↩︎\nThis requires exporting mod_var_input_ui() with @export in the R/ folder.↩︎\nThis requires exporting mod_scatter_display_ui() with @export in the R/ folder.↩︎\nRead more about page-layout in the Quarto documentation↩︎\nThis requires exporting mod_var_input_server() and mod_scatter_display_server() with @export in the R/ folder.↩︎",
    "crumbs": [
      "App-packages",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "debug.html",
    "href": "debug.html",
    "title": "Debug",
    "section": "",
    "text": "Shiny bugs\nExpand the callout boxes below to review what we’ve covered in the last section:\nDebugging is the process of identifying, analyzing, and fixing errors in our code.1 In Shiny apps, debugging can be challenging because the reactive model involves dynamic interactions and a non-linear flow of execution between inputs, reactive expressions, and outputs. Consider the diagram below that illustrates the function/module tree for our application:\nThe inputs are collected by the variable input module2 and passed to the graph display module(as var_inputs()),3 where they become inputs() to the graph utility function before finally being rendered.4\nOur application launches with pre-selected values for the x, y and color graph inputs, along with values for the size and opacity (alpha) of the points.\nUsers can add a title or change the graph inputs, but by having pre-selected values, we guarantee the graph renders when the application launches.\nShiny is inherently asynchronous, so bugs can originate from reactive dependencies, execution order, utility functions, hidden states, lazy evaluation, and invalidation (i.e., reactive(), observe(), isolate(), etc.).\nFor example, we could have an incorrectly defined inputIds or outputIds in the UI, which causes our graph utility function to fail. We could also have missing parentheses on reactive values in the server. Finally, the bug could be originating from the output/render point.\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart TD\n    subgraph Inputs[\"Inputs\"]\n        var_input[/\"&lt;code&gt;input$x&lt;/code&gt;\n                   &lt;code&gt;input$y&lt;/code&gt; \n                   &lt;code&gt;input$z&lt;/code&gt; \n                   &lt;code&gt;input$alpha&lt;/code&gt;\n                   &lt;code&gt;input$size&lt;/code&gt;\n                   &lt;code&gt;input$plot_title&lt;/code&gt;\"/]\n    end\n    subgraph React[\"Reactives\"]\n        var_inputs&gt;\"&lt;code&gt;var_inputs()&lt;/code&gt; \"]\n        inputs&gt;\"&lt;code&gt;inputs()&lt;/code&gt;\"]\n        \n        \n        \n    end\n    subgraph Output[\"Output\"]\n        output[\\\"output$scatterplot\"\\]\n        \n    end\n\n    Inputs &lt;==&gt; |\"Incorrect &lt;code&gt;inputId&lt;/code&gt;&lt;br&gt;or &lt;code&gt;outputId&lt;/code&gt;\"|var_inputs \n    var_inputs &lt;==&gt; |\"&lt;code&gt;observe()&lt;/code&gt;&lt;br&gt;listener error\"|inputs\n    inputs &lt;==&gt; |\"&lt;code&gt;render_*&lt;/code&gt;&lt;br&gt;function error\"|output\n    \n    style var_input stroke:#333,stroke-width:1px,rx:5,ry:5 \n\n\n Possible locations of bugs in a reactive model\nUnderstanding the interplay of reactivity, lazy evaluation, asynchronous execution, and hidden states will help us diagnose and resolve bugs in our Shiny app-packages. We have to employ specific strategies and tools to handle Shiny bugs effectively, and some of the traditional debugging approaches can fall short in reactive contexts. The chapters in this section will cover how to adapt common methods for debugging R code to use with our Shiny application.",
    "crumbs": [
      "Debug"
    ]
  },
  {
    "objectID": "debug.html#footnotes",
    "href": "debug.html#footnotes",
    "title": "Debug",
    "section": "",
    "text": "The definition in this article from AWS gives a great general overview of debugging.↩︎\nOur variable input model is in R/mod_var_input.R.↩︎\nThe graph display module is in R/mod_scatter_display.R.↩︎\nThe graph utility function is in R/scatter_plot.R↩︎",
    "crumbs": [
      "Debug"
    ]
  },
  {
    "objectID": "debugger.html",
    "href": "debugger.html",
    "title": "10  Debuggers",
    "section": "",
    "text": "10.1 Interactive debugging\nBugs can cause our app to crash, produce incorrect results or displays, and result in other unexpected behaviors. Fixing bugs in our app-package is an important step to ensure our application continues behaving as expected. This chapter will cover how to use an interactive debugger to help us find the root cause of bugs and errors.\nDebugging in RStudio  is covered elsewhere,1 so we’ll focus on debugging our Shiny app code using Positron’s  interactive debugger.\nInteractive debugging (e.g., using browser() or setting a breakpoint) allows us to ‘peek inside’ a function’s scope to view intermediate values/variables and break down the execution line by line.\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart LR\n        Start([\"Begin&lt;br&gt;Execution\"])\n        Browser{{\"Breakpoint&lt;br&gt;or &lt;code&gt;browser&lt;/code&gt;?\"}}\n        subgraph Debugger [\"&lt;strong&gt;Debugger&lt;/strong&gt;\"]\n            Step(\"Enter&lt;br&gt;debugger\")\n            Step --&gt; |\"Step Through&lt;br&gt;Code\"|Debug{{\"Done&lt;br&gt;debugging?\"}}\n\n            Debug --&gt;|\"No\"| Step\n            Debug --&gt;|\"Yes\"| Exit(\"Exit&lt;br&gt;debugger\")\n    \n        end\n        Resume([\"Resume&lt;br&gt;Execution\"])\n    \n    Start --&gt; Browser\n    Browser --&gt;|\"Yes\"| Debugger\n    Exit --&gt; Resume\n    Browser --&gt;|\"No\"| Resume\n    \n    %% style FunctionScope fill:#FFF,color:#000,stroke:#333,font-size:14px\n    %% style Start fill:#FFF,stroke:#333,stroke-width:1px,color:#000,font-size:14px\n    %% style Browser fill:#ffcccb,stroke:#e60000,stroke-width:3px,color:#000,font-size:14px\n    %% style Debugger fill:#F8F8FA,stroke:#4CB7DB,stroke-width:3px,rx:10,ry:10,font-size:14px\n    %% style Step1 fill:#4CB7DB,color:#000,stroke:none,rx:15,ry:15,font-size:14px\n    %% style Step2 fill:#4CB7DB,color:#000,stroke:none,rx:15,ry:15,font-size:14px\n    %% style Debug fill:#ffcccb,stroke:#e60000,stroke-width:3px,color:#000,font-size:14px\n    %% style Exit fill:#4CB7DB,color:#000,stroke:none,rx:15,ry:15,font-size:14px\n    %% style Resume fill:#FFF,stroke:#333,stroke-width:1px,color:#000,font-size:14px\n\n\n Interactive debugger with browser() or breakpoint\nUnfortunately, using browser() and breakpoints are not as straightforward within reactive contexts. browser() interacts with the R interpreter by temporarily suspending execution and redirecting the input to evaluate R expressions in the context of the function or script that called it.\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"14px\"}}}%%\nflowchart TD\n        Running([\"Being&lt;br&gt;execution\"]) \n            subgraph Browse[\"&lt;strong&gt;browser() Scope&lt;/strong&gt;\"]\n                Browser(\"&lt;code&gt;browser()&lt;/code&gt;\")\n                subgraph Debugger[\"&lt;strong&gt;Interactive Debugger&lt;/strong&gt;\"]\n                 Step[\\\"Inspect variables&lt;br&gt;and values\"/]\n                end\n        end\n        Resume([\"Resume&lt;br&gt;execution\"])\n\nRunning --&gt;|\"Encounter\"| Browser --&gt; |\"Enter\"|Step --&gt;|\"Exit\"|Resume\n    \n    %% subgraphs\n    %% style Function fill:#FFF,color:#000,stroke:#333,font-size:14px %%\n    %% style BrowserStep stroke:#4CBB9D,color:#000,stroke-width:3px,rx:10,ry:10,font-size:14px  %%\n    %% style Debugger fill:#F8F8FA,color:#000,stroke:#4CB7DB,stroke-width:3px,rx:10,ry:10,font-size:14px %%\n    \n    %% nodes \n    %% style Running fill:#FFF,color:#000,stroke:#333,rx:10,ry:10,font-size:14px %%\n    %% style Encounter fill:#4CBB9D,color:#FFFFFF,stroke:none,rx:10,ry:10,font-size:14px %%\n    %% style Step1 fill:#4CB7DB,color:#000,stroke:none,rx:15,ry:15,font-size:14px %%\n    %% style Step2 fill:#4CB7DB,color:#000,stroke:none,rx:10,ry:10,font-size:14px %%\n    %% style ExitBrowser fill:#4CBB9D,color:#FFFFFF,stroke:none,rx:20,ry:10,font-size:14px %%\n    %% style Resume fill:#FFF,color:#000,stroke:#333,rx:10,ry:10,font-size:14px %%\n    \n\n\n How browser() works in regular R function\nShiny’s asynchronous execution makes it difficult for browser() to pause the flow of execution, making maintaining an interactive debugging session challenging.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debugger.html#sec-debug-browser",
    "href": "debugger.html#sec-debug-browser",
    "title": "10  Debuggers",
    "section": "",
    "text": "10.1.1 Reactive browsing\nIn a Shiny context, code inside the server function is executed asynchronously in response to user inputs or reactive dependencies. Shiny does not directly expose the control flow to the user, but we want to pause this execution without altering or stopping the reactive flow.\nFortunately, Shiny already has a function that performs this: observe(). Within a Shiny server() function, any call to observe() creates a reactive observer that ‘listens’ for changes to reactive dependencies (and runs any enclosed code whenever those dependencies change).\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"14px\"}}}%%\nflowchart TD\n        Running([\"Being&lt;br&gt;execution\"]) \n        subgraph Observe[\"&lt;strong&gt;observe() Scope&lt;/strong&gt;\"]\n                Observer(\"&lt;code&gt;observe({&lt;br&gt;&lt;br&gt;})&lt;/code&gt;\")\n            subgraph Browse[\"&lt;strong&gt;browser() Scope&lt;/strong&gt;\"]\n                Browser(\"&lt;code&gt;browser()&lt;/code&gt;\")\n                subgraph Debugger[\"&lt;strong&gt;Interactive Debugger&lt;/strong&gt;\"]\n                 Step[\\\"Inspect variables&lt;br&gt;and reactives\"/]\n                end\n            end\n        end\n        Resume([\"Resume&lt;br&gt;execution\"])\n\nRunning --&gt;|\"Encounter\"| Observer --&gt; Browser --&gt; |\"Enter\"|Step --&gt;|\"Exit\"|Resume\n\n    %% style Server fill:#FFF,color:#000,stroke:#333,font-size:14px\n    %% style StartReact fill:#FFF,color:#000,stroke:#333,font-size:14px\n    %% style EndReact fill:#FFF,color:#000,stroke:#333,font-size:14px\n\n    %% style Observer fill:#FFF,stroke:#FEDBC1,stroke-width:3px,font-size:14px\n    %% style ObserveExecution fill:#FEDBC1,stroke:none,rx:10,ry:10,font-size:14px\n    \n    %% style Browser fill:#4CBB9D,color:#000,stroke:none,rx:20,ry:10,font-size:14px\n    %% style Browse stroke:#4CBB9D,color:#000,fill:#FFF,stroke-width:3px,rx:10,ry:10,font-size:14px\n    \n    %% style Debugger fill:#F8F8FA,stroke:#4CB7DB,stroke-width:3px,rx:10,ry:10,font-size:14px\n    %% style Step fill:#4CB7DB,stroke:none,rx:10,ry:10\n\n    %% style ExitBrowser fill:#4CBB9D,color:#000,stroke:none,rx:20,ry:10,font-size:14px\n    %% style ExitObserver fill:#FEDBC1,color:#000,stroke:none,rx:20,ry:10,font-size:14px\n\n\n Reactive browser() in an observe()er \n\n\n\nWhen browser() is called from within the observe() scope, the code execution pauses and temporarily suspends the reactive flow so we can inspect the environment (without altering or stopping the reactive flow).",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debugger.html#example-ggplot2movies-app",
    "href": "debugger.html#example-ggplot2movies-app",
    "title": "10  Debuggers",
    "section": "10.2 Example: ggplot2movies app",
    "text": "10.2 Example: ggplot2movies app\nIn the Resources chapter we developed a slight variation of our app with the ggplot2movies data.2 In the following sections we’re going to use the interactive debugger to see the inner workings of the ‘Remove missing’ checkbox.\n\n\n\n\n\n\n\nRemove missing checkbox in ggplot2movies development application (click to enlarge)\n\n\nWe’ll begin by placing the observe() and browser() breakpoint inside the module server function containing the ‘Remove missing’ input (right after the moduleServer() function). We’ll close the observe() scope after the reactive inputs() are created:\n\n\nshow/hide debugging functions in the module server function\ndev_mod_scatter_server &lt;- function(id, var_inputs) {\n  moduleServer(id, function(input, output, session) {\n1    observe({\n2      browser()\n      \n3      all_data &lt;- fst::read_fst(\"tidy_movies.fst\")\n\n4      graph_data &lt;- reactive({\n        if (input$missing) {\n          tidyr::drop_na(data = all_data)\n        } else {\n          all_data\n        }\n      }) |&gt;\n        bindEvent(input$missing)\n\n5      inputs &lt;- reactive({\n        plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = var_inputs()$alpha,\n          size = var_inputs()$size,\n          plot_title = plot_title\n        )\n      })\n    })\n    \n6    observe({\n      output$scatterplot &lt;- renderPlot({\n        plot &lt;- sap::scatter_plot(\n          df = graph_data(),\n          x_var = inputs()$x,\n          y_var = inputs()$y,\n          col_var = inputs()$z,\n          alpha_var = inputs()$alpha,\n          size_var = inputs()$size\n        )\n        plot +\n          ggplot2::labs(\n            title = inputs()$plot_title,\n            x = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$x), \"_\", \" \"),\n            y = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$y), \"_\", \" \")\n          ) +\n          ggplot2::theme_minimal() +\n          ggplot2::theme(legend.position = \"bottom\")\n      })\n    }) |&gt;\n      bindEvent(graph_data(), inputs())\n    \n  })\n}\n\n\n\n1\n\nObserver scope\n\n\n2\n\nCall to browser() (execution paused)\n\n3\n\nRead tidy_movies.fst data\n\n\n4\n\nMissing data checkbox logic\n\n\n5\n\nReactive values from user inputs\n\n6\n\nModule graph code (outside of observe() scope)\n\n\n\n\nThen we’ll load the changes:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nAnd launch the app using:\n\nlaunch_app(app = \"ggp2\")\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('10_debugger')\n\n\n\n\n\n\n\nLoading code changes\n\n\n\n\n\n\n Don’t forget to load any debugging calls with devtools::load_all() before re-launching the app!\ndevtools::load_all('.')\nOr\nCtrl/Cmd + Shift + L\n\n\n\n\nAs noted above, browser() pauses code execution and activates the interactive debugger mode, allowing us to view objects, execute code, and ‘step through’ the function line-by-line.\n\n10.2.1 IDE Changes\nWhen the app is launched, Positron  alerts us that we’re in debugging mode by making a few changes to the IDE:3\n\nSidebar\n\nThe Run and Debug sidebar menu item is displayed and the footer is highlighted in blue4\n\n\n\n\n\n\n\n\nPositron IDE in debugger mode (click to enlarge)\n\n\n\n\nEditor\nThe dev_mod_scatter.R file in the Editor highlights the browser() function in yellow\n\n\n\n\n\n\n\nDebugger in file Editor (click to enlarge)\n\n\n\n\nConsole\nThe Console tells us browser() was ‘Called from: observe()’ and displays the interactive debugger prompt:\n\n\n\n\n\n\n\nDebugger in file Editor (click to enlarge)\n\n\nobserve() does not inherently pause or interrupt other reactive processes—it just triggers when changes occur within its scope. So when we’re using observe() for debugging, we need to define the context (or scope) for its behavior.\nThe output in the Console tells us the tidy_movies.fst data are downloaded, but our placement suspends the execution of the application before these data are loaded and the graph is rendered in the UI.\n\n\n\n\n\n\n\n\n\nDebugger in Console (click to enlarge)\n\n\n\n\n\n\n\nSuspended ggplot2movies data app (click to enlarge)\n\n\n\n\n\nThe interactive debugger can only access variables and values inside the observe() scope, but this process can be incredibly useful for addressing bugs (and for exploring how an application works). In the next sections, we’ll ‘step through’ the module function to explore how the missing values are removed from the graph.\n\n\n\n10.2.2 Variables and values\nWe want to use the interactive debugger to proceed through the module function until the data object enters the logic for the missing checkbox, and then we can confirm its structure.\n\n\nStep through/execute each line of code by entering n in the Console.\n\nBrowse[1]&gt; n\n\nAs we ‘step through’ the function, Positron’s  Console displays the debug at location, followed by the code line number:\n\n\n\n\n\n\n\nFull path and line number to the file containing our call to browser() (click to enlarge)\n\n\nIn the Editor, the same line of code is highlighted in yellow:\n\n\n\n\n\n\n\nCorresponding line number in Editor (click to enlarge)\n\n\nThe line creating graph_data gives us a hint for how the missing data are removed (i.e., with bindEvent()), but we’ll explore this more in Print debugging.\n\n\n\n\n\n\n\ngraph_data() reactive creation (click to enlarge)\n\n\nUnder Locals in the DEBUG VARIABLES sidebar, we can see all_data is listed as a &lt;data.frame&gt;, and graph_data are listed as a &lt;reactive.event&gt;:\n\n\n\n\n\n\n\nClick to enlarge DEBUG VARIABLES in sidebar\n\n\nIn the next section, we’ll explore these variables (and the reactive inputs).\n\n\n10.2.3 Inspecting variables\nWe can use the Console to evaluate code while the interactive debugger is running. This comes in handy if we want to check the structure of an object inside a module (like all_data).\n\n\n\n\n\n\nBrowse[1]&gt; str(all_data)\n\n\n'data.frame':   58788 obs. of  10 variables:\n$ title      : chr  \"$\" \"$1000 a Touchdown\" ...\n$ year       : int  1971 1939 1941 1996 1975 ...\n$ length     : int  121 71 7 70 71 91 93 25 97 ...\n$ budget     : int  NA NA NA NA NA NA NA NA NA ...\n$ rating     : num  6.4 6 8.2 8.2 3.4 4.3 5.3 ...\n$ votes      : int  348 20 5 6 17 45 200 24 18 51 ...\n$ mpaa       : Factor w/ 5 levels \"G\",\"PG\",\"PG-13\" ...\n$ genre_count: int  2 1 2 1 0 1 2 2 1 0 ...\n$ genres     : chr  \"Comedy, Drama\" \"Comedy\" ...\n$ genre      : Factor w/ 8 levels \"Action\": 6 3 6 ...\n\n\n\nThis gives us an idea of the total rows before missing are removed.\n\n\n10.2.4 Inspecting values\nThe reactive values and inputs can also be viewed in the Console, and we can see graph_data() is ‘bound’ to input$missing with bindEvent(). We can confirm the input$missing value in the Console:\n\n\n\n\n\n\nBrowse[1]&gt; input$missing\n\n\n[1] TRUE\n\n\n\nThis tells us the ‘Remove missing’ checkbox has been selected, and we can verify the missing values have been removed from graph_data():\n\n\n\n\n\n\nBrowse[1]&gt; identical(\n              nrow(tidyr::drop_na(all_data)), \n              nrow(graph_data())\n            )\n\n\n[1] TRUE\n\n\n\nUsing browser() to ‘step through’ an application gives us a better understanding of the ‘order of execution’, and it lets us see how input$missing and bindEvent() work together to remove the missing values with the checkbox.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debugger.html#recap",
    "href": "debugger.html#recap",
    "title": "10  Debuggers",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: Interactive Debuggers\n\n\n\n\n\n\nDuring regular development, an interactive debugger can let us inspect variables and execute the code line-by-line. In Shiny functions, the debugger lets us track the execution of reactive expressions and observers, which allows us to unravel reactivity-related issues that are often difficult to diagnose.\nbrowser() and observe() are powerful tools for debugging our application. Navigating a function using the interactive debugger gives us control over the execution of each line.\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debugger.html#footnotes",
    "href": "debugger.html#footnotes",
    "title": "10  Debuggers",
    "section": "",
    "text": "For an introduction to the IDE’s debugging tools, see Debugging with the RStudio IDE. Debugging is also covered in Advanced R, 2ed and Mastering Shiny.↩︎\nYou can refresh your memory on the ggplot2movies application in Section 9.2.1.↩︎\nWatch this video to learn more about Positron.↩︎\nPrevious versions of Positron highlighted the footer in red.↩︎",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Debuggers</span>"
    ]
  },
  {
    "objectID": "debug_print.html",
    "href": "debug_print.html",
    "title": "11  Print debugging",
    "section": "",
    "text": "11.1 Exposing variables and values\nIn the previous chapter we covered the interactive debugger in Positron  with browser() and observe(). In this chapter, we’ll explore another commonly used technique for identifying and resolving issues or errors in your code: print debugging.\nPrint debugging uses a simpler approach than the interactive debugger, and it’s well-suited for a variety of development workflows. Print debugging involves inserting a print() (or cat()) statement into the body of a function to output variables, values, or other important information at various points.\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart LR\n    Insert([\"Insert call&lt;br&gt;to &lt;code&gt;print()&lt;/code&gt;&lt;br&gt;\"])\n    Print(\"Encounter&lt;br&gt;&lt;code&gt;print()&lt;/code&gt; or&lt;br&gt;&lt;code&gt;cat()&lt;/code&gt;\")\n    Insert --&gt; Exec\n    Exec(\"Execute&lt;br&gt;function\") --&gt; Print(\"Encounter&lt;br&gt;&lt;code&gt;print()&lt;/code&gt;\")  \n    Print --&gt; Issue{{\"&lt;strong&gt;&lt;em&gt;Output&lt;br&gt;reveals&lt;br&gt;issue?&lt;/em&gt;&lt;/strong&gt;\"}}\n    Issue -- \"Yes\" --&gt; Mod([\"Modify&lt;br&gt;function\"])\n    Issue -- \"No\" --&gt; Insert\n\n\n Print debugging with print() function calls",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_print.html#sec-debug-print",
    "href": "debug_print.html#sec-debug-print",
    "title": "11  Print debugging",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('11_debug-print')",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_print.html#sec-print-debug-observe-cat-print",
    "href": "debug_print.html#sec-print-debug-observe-cat-print",
    "title": "11  Print debugging",
    "section": "11.2 Reactive printing",
    "text": "11.2 Reactive printing\nTo track reactivity, we need to place the print functions in a reactive expression, observer, or event handler. This allows us to see when these values are triggered (and any other values they work with).\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"13px\"}}}%%\nflowchart LR\n        Insert([\"Insert call&lt;br&gt;to &lt;code&gt;print()&lt;/code&gt;\"]) \n        Exec(\"Execute&lt;br&gt;function\") \n        Insert --&gt; Exec --&gt; Print(\"Encounter&lt;br&gt;&lt;code&gt;print()&lt;/code&gt;\") \n        subgraph Reactive[\"Reactive Context\"]\n            Print \n            Issue{{\"&lt;strong&gt;&lt;em&gt;Output&lt;br&gt;reveals&lt;br&gt;issue?&lt;/em&gt;&lt;/strong&gt;\"}}\n            Print --&gt; Issue\n        end\n        Issue -- \"Yes\" --&gt; Mod([\"Modify&lt;br&gt;function\"])\n        Issue -- \"No\" --&gt; Insert\n\n\n Reactive print debugging with print() function calls \n\n\n\nUsing well-placed calls to print() or cat() allows us to display input values, which helps us to understand the inner-workings of our application.\nFor example, placing the code below in the server function of our variable input module will print the selected variables to the console:\n\nmod_var_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n\n1    observe({\n2      cat(\"Selected x, y, and color:\\n\")\n3      print(c('x' = input$x,\n              'y' = input$y, \n              'color' = input$z))\n    }) |&gt;\n4      bindEvent(c(input$x, input$y, input$x))\n    \n    return(\n      reactive({\n        list(\n          \"y\" = input$y,\n          \"x\" = input$x,\n          \"z\" = input$z,\n          \"alpha\" = input$alpha,\n          \"size\" = input$size,\n          \"plot_title\" = input$plot_title\n        )\n      })\n    )\n\n  })\n}\n\n\n1\n\nWrap in observe() to provide reactive context for printing\n\n\n2\n\nPrint message with cat()\n\n3\n\nPrint reactives with print()\n\n\n4\n\nBind this event to print whenever the variable inputs change\n\n\n\n\nAfter running the function, we can view the output in the Console (or log file).\n\n\n\n\n\n\n\nVariables printed to Console (click to enlarge)\n\n\nUnfortunately, print() and cat() can only provide a snapshot of values or variables at the location and time of the print call. This limits their usefulness in exploring the other parts of the environment or interacting with the running application.\nHowever, we can place verbatimTextOutput() in our module UI function:\n\n\nshow/hide updated mod_var_input_ui()\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n1    verbatimTextOutput(ns(\"vars\")),\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n1\n\nPrint the values to the UI\n\n\n\n\nAnd an accompanying renderPrint() in the module server function to print the values in the UI:\n\n\nshow/hide updated mod_var_input_server()\nmod_var_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n\n1    observe({\n2      cat(\"Selected x, y, and color:\\n\")\n3      print(c('x' = input$x,\n              'y' = input$y, \n              'color' = input$z))\n      \n4      output$vars &lt;- renderPrint({\n        list('x' = input$x, \n             'y' = input$y, \n             'color' = input$z) \n      })\n    }) |&gt;\n5      bindEvent(c(input$x, input$y, input$x))\n    \n    return(\n      reactive({\n        list(\n          \"y\" = input$y,\n          \"x\" = input$x,\n          \"z\" = input$z,\n          \"alpha\" = input$alpha,\n          \"size\" = input$size,\n          \"plot_title\" = input$plot_title\n        )\n      })\n    )\n\n  })\n}\n\n\n\n1\n\nReactive context\n\n2\n\nPrint message with cat()\n\n3\n\nPrint to inputs with print()\n\n4\n\nPrint inputs to UI\n\n\n5\n\nBind this event to print whenever the variable inputs change\n\n\n\n\n\n\n\n\n\n\n\nVariables printed to UI (click to enlarge)\n\n\nThis allows us to view the inputs in the UI as they change in the server.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_print.html#sec-print-debug-reactive-values-to-list",
    "href": "debug_print.html#sec-print-debug-reactive-values-to-list",
    "title": "11  Print debugging",
    "section": "11.3 Reactive values",
    "text": "11.3 Reactive values\nA powerful tool for capturing and printing input values in the server is reactiveValuesToList():\n\n1reactiveValuesToList(x = , all.names = )\n\n\n1\n\nI recommend setting all.names to TRUE.\n\n\n\n\nThis function can be used inside server-side code (modules or server functions) to collect all the input values. When placed in the app server function, the function will return the inputs from both modules.\nBelow is an example of using reactiveValuesToList() inside the our app server function:\n\nmovies_server &lt;- function(input, output, session) {\n\n      output$vals &lt;- renderPrint({\n        app_vals &lt;- reactiveValuesToList(x = input, all.names = TRUE)\n        str(app_vals)\n      })\n      \n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\nWe’ll also add the following to the bslib = TRUE section of movies_ui() to print the output of the reactive list to the UI:\n\nmovies_ui &lt;- function(bslib = FALSE) {\n  addResourcePath(\n    prefix = 'www',\n    directoryPath = system.file('www/', package = 'sap'))\n  if (isFALSE(bslib)) {\n    tagList(\n        bslib::page_fillable(\n          h1(\"Movie Reviews\"),\n          bslib::layout_sidebar(\n            sidebar =\n              bslib::sidebar(\n                title = tags$h4(\"Sidebar inputs\"),\n                img(\n                  src = \"www/shiny.png\",\n                  height = 60,\n                  width = 55,\n                  style = \"margin:10px 10px\"\n                ),\n                mod_var_input_ui(\"vars\")\n              ),\n            bslib::card(\n              full_screen = TRUE,\n              bslib::card_header(\n                tags$h4(\"Scatter Plot\")\n              ),\n              bslib::card_body(fillable = TRUE,\n                mod_scatter_display_ui(\"plot\")\n              ),\n              bslib::card_footer(\n                tags$blockquote(\n                  tags$em(\n                    tags$p(\n                      \"The data for this application comes from the \",\n                      tags$a(\"Building web applications with Shiny\",\n                        href = \"https://rstudio-education.github.io/shiny-course/\"\n                      ),\n                      \"tutorial\"\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n  } else {\n    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            mod_var_input_ui(\"vars\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n                bslib::card_header(\n                  tags$img(\n                  src = \"www/bootstrap.png\",\n                  height = 80,\n                  width = 100,\n                  style = \"margin:10px 10px\"\n                )\n              ),\n             bslib::card_body(\n1              verbatimTextOutput(outputId = \"vals\"),\n              mod_scatter_display_ui(\"plot\")\n            )\n          )\n        )\n      )\n    )\n  }\n} \n\n\n1\n\nPrinted reactive value outputs\n\n\n\n\nAfter loading the changes to our package, we can view the application with the captured and printed reactive values:\n\n\n\n\n\n\n\nClick to enlarge\n\n\nNote the difference between the two printed values: the output in the sidebar has been printed from within the module server function, so the input names are contained within that namespace (i.e., x, y, etc.). However, the list returned from reactiveValuesToList() has been placed in the app server function, so we can see the module id appended to the input name (i.e., vars-y, vars-x, etc.).",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_print.html#recap",
    "href": "debug_print.html#recap",
    "title": "11  Print debugging",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: Print Debugging\n\n\n\n\n\n\nThe advantages of print debugging are 1) it’s easy to insert a few lines of code and run the program, 2) it works in any programming environment, even if sophisticated debugging tools aren’t available, and 3) it doesn’t require special configurations or debugging tools.\nHowever, the downside is we can’t pause execution or inspect the app state in real-time. We only can see what we explicitly print, and if we miss a key variable or condition, we have to to insert, remove, or adjust print functions, which can be time-consuming. Excessive print functions can also clutter the code and output especially in large or complex application.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Print debugging</span>"
    ]
  },
  {
    "objectID": "debug_apps.html",
    "href": "debug_apps.html",
    "title": "12  Debugging apps",
    "section": "",
    "text": "Abstract syntax trees\nIn the previous chapters we demonstrated how to combine browser() and observe() for interactive debugging. We also covered how to combine reactiveValuesToList(), verbatimTextOutput(), and renderPrint() to view reactive values in the UI.\nWhen debugging Shiny apps, it’s likely you’ll use a combination of these methods (depending on the bug or issue).\nShiny app-packages can quickly become a complex and intertwined web of functions: utility functions, modules, user interface (UI) elements, server logic, etc. Before we jump into debugging modules, we’ll revisit their function and purpose by considering the following description of namespaces from the NS() function documentation:\nTo visualize the hierarchical relationship between the functions in our app, we’ll use abstract syntax trees (ast()) from the lobstr package.1\nAbstract folder trees can be used to help construct a simplified call stack for applications (especially if we are using multiple utility functions or nested modules).",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-apps-abstract-syntax-trees",
    "href": "debug_apps.html#sec-debug-apps-abstract-syntax-trees",
    "title": "12  Debugging apps",
    "section": "",
    "text": "“a namespace is to an ID as a directory is to a file.”\n\n\n\n\n\n\n\n\nFor example, launch_app() calls the display_type() utility function, then movies_ui() and movies_server():\n\n\n\n█─launch_app \n├─█─display_type \n├─█─movies_ui \n└─█─movies_server \n\n\n\n\n\n\n\n\n\n\nmovies_ui() and movies_server() call their respective UI and server module functions:\n\n\n\n█─launch_app \n├─█─display_type \n├─█─movies_ui \n│ ├─█─mod_var_input_ui \n│ └─█─mod_scatter_display_ui \n└─█─movies_server \n  ├─█─mod_var_input_server \n  └─█─mod_scatter_display_server \n\n\n\n\n\n\n\n\n\n\nAnd mod_scatter_display_server() calls the scatter_plot() utility function:\n\n\n\n█─launch_app \n├─█─display_type \n├─█─movies_ui \n│ ├─█─mod_var_input_ui \n│ └─█─mod_scatter_display_ui \n└─█─movies_server \n  ├─█─mod_var_input_server \n  └─█─mod_scatter_display_server \n    └─█─scatter_plot",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-apps-modules",
    "href": "debug_apps.html#sec-debug-apps-modules",
    "title": "12  Debugging apps",
    "section": "12.1 Debugging modules",
    "text": "12.1 Debugging modules\nIn this branch of sap, the inputs has been split into two separate modules: variable inputs and aesthetic inputs. The variable input module collects and returns the selected columns from the movies data, and the aesthetics input module collects and returns the alpha, point size, and (optional) graph title.\nThis updates our abstract syntax tree to the following:\n\n\n█─launch_app \n├─█─display_type \n├─█─movies_ui \n│ ├─█─mod_var_input_ui \n│ ├─█─mod_aes_input_ui \n│ └─█─mod_scatter_display_ui \n└─█─movies_server \n  ├─█─mod_var_input_server \n  ├─█─mod_aes_input_server \n  └─█─mod_scatter_display_server \n    └─█─scatter_plot \n\n\n\n12.1.1 Input modules\nThe diagram below illustrates the changes to the variable input module.\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    User([\"User\"])\n    mod_var_input_ui[\"&lt;strong&gt;mod_var_input_ui()&lt;/strong&gt;\"]\n    mod_aes_input_ui[\"&lt;strong&gt;mod_aes_input_ui()&lt;/strong&gt;\"]\n    \n    subgraph mod_var_input_server[\"&lt;strong&gt;mod_var_input_server()&lt;/strong&gt;\"]\n        VarReactives[/\"input$x&lt;br&gt;input$y&lt;br&gt;input$z\"/]\n    end\n    subgraph mod_aes_input_server[\"&lt;strong&gt;mod_aes_input_server()&lt;/strong&gt;\"]\n        AesReactives[/\"input$alpha&lt;br&gt;input$size&lt;br&gt;input$plot_title\"/]\n    end\n\n    selected_vars[/\"selected variables\"/]\n    selected_aes[/\"selected aesthetics\"/]\n    \n    User --&gt; |\"&lt;em&gt;Selects X, Y, and Color...&lt;/em&gt;\"|mod_var_input_ui\n    User --&gt; |\"&lt;em&gt;Selects Size, Alpha and optional Title...&lt;/em&gt;\"|mod_aes_input_ui\n    mod_var_input_ui --&gt; |\"&lt;em&gt;Collects&lt;br&gt;variables...&lt;/em&gt;\"|mod_var_input_server\n    mod_aes_input_ui --&gt; |\"&lt;em&gt;Collects aesthetics...&lt;/em&gt;\"|mod_aes_input_server\n    VarReactives --&gt; selected_vars\n    AesReactives --&gt; selected_aes\n    \n    style mod_var_input_ui stroke-width:2px,rx:3,ry:3\n    style mod_aes_input_ui stroke-width:2px,rx:3,ry:3\n    style mod_var_input_server stroke-width:2px,rx:3,ry:3\n    style mod_aes_input_server stroke-width:2px,rx:3,ry:3\n    style VarReactives font-size: 14px\n    style AesReactives font-size: 14px\n\n\n Variable Inputs modules \n\n\n\nmod_var_input_ui(): Our variable input module will now only collect the x, y, and color variables from the movies data.\n\n\nshow/hide R/mod_var_input.R\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    )\n  )\n}\n\nmod_var_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n    \n    return(\n      reactive({\n        list(\n1          \"y\" = input$y,\n2          \"x\" = input$x,\n3          \"z\" = input$z\n        )\n      })\n    )\n\n  })\n}\n\n\n\n1\n\nReturned x axis variable\n\n\n2\n\nReturned y axis variable\n\n\n3\n\nReturned color variable\n\n\n\n\nmod_aes_input_ui(): The new aesthetic input module will collect the alpha, size, and optional plot title values.\n\n\nshow/hide R/mod_aes_input.R\nmod_aes_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"x\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\nmod_aes_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n    \n    return(\n      reactive({\n        list(\n1          \"alpha\" = input$alpha,\n2          \"size\" = input$size,\n3          \"plot_title\" = input$x\n        )\n      })\n    )\n\n  })\n}\n\n\n\n1\n\nReturned alpha aesthetic\n\n\n2\n\nReturned size aesthetic\n\n\n3\n\nReturned plot title\n\n\n\n\nEach module will have a dedicated namespace inside the movies_ui() and movies_server() functions, but this requires a minor adjustment to the mod_scatter_display_server() and movies_server() functions:\nmod_scatter_display_server(): We need to adjust the function arguments and the creation of the inputs() reactive:\n\n\nshow/hide mod_scatter_display_server()\n1mod_scatter_display_server &lt;- function(id, var_inputs, aes_inputs) {\n\n  moduleServer(id, function(input, output, session) {\n\n    inputs &lt;- reactive({\n2      plot_title &lt;- tools::toTitleCase(aes_inputs()$plot_title)\n        list(\n4          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n3          alpha = aes_inputs()$alpha,\n          size = aes_inputs()$size,\n          plot_title = plot_title\n        \n        )\n    })\n    \n    output$scatterplot &lt;- renderPlot({\n      plot &lt;- scatter_plot(\n        # data --------------------\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n            x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n            y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n1\n\nAdd function argument for aesthetics\n\n\n2\n\nOptional title input\n\n\n3\n\nAlpha and size inputs\n\n\n4\n\nVariable reactive inputs\n\n\n\n\nmovies_server(): We now have two reactive variables: the selected_vars and selected_aes:\n\n\nshow/hide\nmovies_server &lt;- function(input, output, session) {\n      \n1      selected_vars &lt;- mod_var_input_server(\"vars\")\n  \n2      selected_aes &lt;- mod_aes_input_server(\"aes\")\n\n      mod_scatter_display_server(\"plot\", \n3                                  var_inputs = selected_vars,\n4                                  aes_inputs = selected_aes)\n      \n}\n\n\n\n1\n\nCollected variable inputs\n\n\n2\n\nCollected aesthetic inputs\n\n\n3\n\nVariable input argument for graph display\n\n\n4\n\nAesthetic input argument for graph display\n\n\n\n\nThe diagram below illustrates the changes to the functions above:\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    User([\"User\"])\n    mod_var_input_ui[\"&lt;strong&gt;mod_var_input_ui()&lt;/strong&gt;\"]\n    mod_aes_input_ui[\"&lt;strong&gt;mod_aes_input_ui()&lt;/strong&gt;\"]\n    mod_scatter_display_ui[\"&lt;strong&gt;mod_scatter_display_ui&lt;/strong&gt;\"] \n    \n    subgraph mod_scatter_display_server[\"&lt;strong&gt;mod_scatter_display_server()&lt;/strong&gt;\"]\n        var_inputs[\\\"var_inputs()\"\\]\n        inputs[\\\"inputs()\"\\]\n        scatter_plot(\"scatter_plot()\")\n    end\n    \n    subgraph mod_var_input_server[\"&lt;strong&gt;mod_var_input_server()&lt;/strong&gt;\"]\n        VarReactives[/\"input$x&lt;br&gt;input$y&lt;br&gt;input$z\"/]\n    end\n    subgraph mod_aes_input_server[\"&lt;strong&gt;mod_aes_input_server()&lt;/strong&gt;\"]\n        AesReactives[/\"input$alpha&lt;br&gt;input$size&lt;br&gt;input$plot_title\"/]\n    end\n\n    selected_vars[/\"selected variables\"/]\n    selected_aes[/\"selected aesthetics\"/]\n    \n    User --&gt; |\"&lt;em&gt;Selects X, Y, and Color...&lt;/em&gt;\"|mod_var_input_ui\n    User --&gt; |\"&lt;em&gt;Selects Size, Alpha and optional Title...&lt;/em&gt;\"|mod_aes_input_ui\n    mod_var_input_ui --&gt; |\"&lt;em&gt;Collects&lt;br&gt;variables...&lt;/em&gt;\"|mod_var_input_server\n    mod_aes_input_ui --&gt; |\"&lt;em&gt;Collects aesthetics...&lt;/em&gt;\"|mod_aes_input_server\n    VarReactives --&gt; selected_vars\n    AesReactives --&gt; selected_aes\n    selected_vars & selected_aes --&gt;|\"&lt;em&gt;Input argument for...&lt;/em&gt;\"|mod_scatter_display_server\n    var_inputs --&gt; inputs --&gt; scatter_plot\n    scatter_plot --&gt;|\"&lt;em&gt;Renders plot...&lt;/em&gt;\"|mod_scatter_display_ui\n    mod_scatter_display_ui --&gt;|\"&lt;em&gt;Displays output...&lt;/em&gt;\"|Display([\"Graph\"])\n    \n    style mod_scatter_display_ui stroke-width:2px,rx:3,ry:3\n    style mod_scatter_display_server stroke-width:2px,rx:3,ry:3\n    style mod_var_input_ui stroke-width:2px,rx:3,ry:3\n    style mod_var_input_server stroke-width:2px,rx:3,ry:3\n    style scatter_plot stroke-width:2px,rx:10,ry:10\n    style VarReactives font-size: 14px\n    style AesReactives font-size: 14px\n    \n\n\n Variable and aesthetic input modules \n\n\n\nUncoupling the input modules will make it easier to independently modify and debug their corresponding graph elements.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-ui",
    "href": "debug_apps.html#sec-debug-ui",
    "title": "12  Debugging apps",
    "section": "12.2 UI function debugging",
    "text": "12.2 UI function debugging\nIn mod_var_input_ui() and mod_aes_input_ui(), the NS() function is used to encapsulate input IDs within a namespace.\nWe will place a verbatimTextOutput() in both UI module functions:2\n\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n1    strong(\n      code(\"var_input\"),\n      \"module reactive \",\n      code(\"inputs\")\n      ),\n2    verbatimTextOutput(ns(\"vals\"))\n  )\n}\n\n\n1\n\nOptional label\n\n\n2\n\nInclude the ns() for the inputId\n\n\n\n\n\nmod_aes_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"x\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    ),\n1    strong(\n      code(\"aes_input\"),\n      \"module reactive \",\n      code(\"inputs\")\n      ),\n2    verbatimTextOutput(ns(\"vals\"))\n  )\n}\n\n\n1\n\nOptional label\n\n\n2\n\nInclude the ns() for the inputId",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-server",
    "href": "debug_apps.html#sec-debug-server",
    "title": "12  Debugging apps",
    "section": "12.3 Server function debugging",
    "text": "12.3 Server function debugging\nIn the corresponding server functions, we’ll capture the reactive values and print the list using lobstr::tree():3\n\nmod_var_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n\n    observe({\n2      output$vals &lt;- renderPrint({\n1        all_vals &lt;- reactiveValuesToList(input,\n3                                         all.names = TRUE)\n4        lobstr::tree(all_vals)\n      })\n    }) |&gt; \n5      bindEvent(c(input$x, input$y, input$x))\n    \n    return(\n      reactive({\n        list(\n          \"y\" = input$y,\n          \"x\" = input$x,\n          \"z\" = input$z\n        )\n      })\n    )\n\n  })\n}\n\n\n1\n\nCollect reactive values in module\n\n\n2\n\nPrint these values to the UI\n\n\n3\n\nInclude all reactive objects\n\n\n4\n\nVisualize using lobstr::tree()\n\n\n5\n\nBind to inputs\n\n\n\n\n\nmod_aes_input_server &lt;- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n\n    observe({\n2      output$vals &lt;- renderPrint({\n1        all_vals &lt;- reactiveValuesToList(input,\n3                                         all.names = TRUE)\n4        lobstr::tree(all_vals)\n      })\n    }) |&gt; \n5      bindEvent(c(input$alpha, input$size, input$x))\n    \n    return(\n      reactive({\n        list(\n          \"alpha\" = input$alpha,\n          \"size\" = input$size,\n          \"plot_title\" = input$x\n        )\n      })\n    )\n\n  })\n}\n\n\n1\n\nCollect reactive values in module\n\n\n2\n\nPrint these values to the UI\n\n\n3\n\nInclude all reactive objects\n\n\n4\n\nVisualize using lobstr::tree()\n\n\n5\n\nBind to inputs\n\n\n\n\nWe see the following in the sidebar after loading, documenting, installing and launching our app;\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\n\n\n\n\n\nReactive values for the variable input module:\n\n\n\n\n\n\n\n\n\nReactive values in variable input module\n\n\n\n\n\n\n\n\n\n\n\nReactive values for the aesthetic input module:\n\n\n\n\n\n\n\n\n\nReactive values in aesthetics input module\n\n\n\n\n\nIn the variable and aesthetic module namespaces, NS() ensures all the inputs are unique within the module (even when multiple modules are used in the same application).\n\n&lt;list&gt;\n├─y: \"audience_score\"\n├─x: \"imdb_rating\"\n└─z: \"mpaa_rating\"\n\nYou probably noticed that I’ve renamed the inputId for the plot title to x, but we avoid any namespace collisions because each ID is stored safely within a module.\n\n&lt;list&gt;\n├─alpha: 0.5\n├─size: 2\n└─x: \"\"\n\nThis encapsulation is similar to how a directory provides a distinct context for files, preventing naming conflicts within a file system.\nIf we repeat this method in movies_ui() and movies_server():\n\n\nshow/hide movies_ui()\nmovies_ui &lt;- function(bslib = FALSE) {\n  addResourcePath(\n    prefix = 'www',\n    directoryPath = system.file('www/', package = 'sap'))\n  if (isFALSE(bslib)) {\n    tagList(\n        bslib::page_fillable(\n          h1(\"Movie Reviews\"),\n          bslib::layout_sidebar(\n            sidebar =\n              bslib::sidebar(\n                title = tags$h4(\"Sidebar inputs\"),\n                img(\n                  src = \"www/shiny.png\",\n                  height = 60,\n                  width = 55,\n                  style = \"margin:10px 10px\"\n                ),\n                mod_var_input_ui(\"vars\"),\n                mod_aes_input_ui(\"aes\")\n              ),\n            bslib::card(\n              full_screen = TRUE,\n              bslib::card_header(\n                tags$h4(\"Scatter Plot\")\n              ),\n              bslib::card_body(fillable = TRUE,\n1                strong(\n                  code(\"movies_server()\"),\n                  \"reactive values\"\n                  ),\n                verbatimTextOutput(outputId = \"vals\"),\n                mod_scatter_display_ui(\"plot\")\n              ),\n              bslib::card_footer(\n                tags$blockquote(\n                  tags$em(\n                    tags$p(\n                      \"The data for this application comes from the \",\n                      tags$a(\"Building web applications with Shiny\",\n                        href = \"https://rstudio-education.github.io/shiny-course/\"\n                      ),\n                      \"tutorial\"\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n  } else {\n    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            mod_var_input_ui(\"vars\"),\n            mod_aes_input_ui(\"aes\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n                bslib::card_header(\n                  tags$img(\n                  src = \"www/bootstrap.png\",\n                  height = 80,\n                  width = 100,\n                  style = \"margin:10px 10px\"\n                )\n              ),\n             bslib::card_body(\n2              strong(\n                code(\"movies_server()\"),\n                \"reactive values\"\n                ), \n              verbatimTextOutput(outputId = \"vals\"),\n              mod_scatter_display_ui(\"plot\")\n            )\n          )\n        )\n      )\n    )\n  }\n} \n\n\n\n1\n\nLabel and output for printed reactive values\n\n\n2\n\nLabel and output for printed reactive values (bslib UI option)\n\n\n\n\n\n\nshow/hide movies_server()\nmovies_server &lt;- function(input, output, session) {\n\n2      output$vals &lt;- renderPrint({\n1        app_vals &lt;- reactiveValuesToList(x = input,\n                                      all.names = TRUE)\n3        lobstr::tree(app_vals)\n      })\n      \n      selected_vars &lt;- mod_var_input_server(\"vars\")\n      selected_aes &lt;- mod_aes_input_server(\"aes\")\n\n      mod_scatter_display_server(\"plot\", \n                                  var_inputs = selected_vars, \n                                  aes_inputs = selected_aes)\n}\n\n\n\n1\n\nCapture reactive values\n\n\n2\n\nRender reactive values\n\n\n3\n\nPrint list as folder tree\n\n\n\n\nLoad the package and run the app:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nThe printed output from movies_ui() andmovies_server() is prefixed with the namespace (i.e., vars- or aes-), reflecting the hierarchical organization of the input IDs, much like file paths in a directory structure.\n\n\n\n\n\n\n\nReactive values in movies_ui()\n\n\nBy using reactiveValuesToList() and lobstr::tree() in combination with verbatimTextOutput() and renderPrint(), we are effectively debugging and inspecting the module’s reactive inputs.\n\n&lt;list&gt;\n├─vars-y: \"audience_score\"\n├─vars-x: \"imdb_rating\"\n├─vars-z: \"mpaa_rating\"\n├─aes-alpha: 0.5\n├─aes-size: 2\n└─aes-x: \"\"\n\nCapturing and rendering reactive values in the UI gives us the benefits of print debugging while our Shiny app is running. When it’s combined with observe() and browser(), we can get a direct view of the application state and the program flow at specific execution points.\n\n\nLaunch app with the shinypak package:\n\nlaunch('12.1_debug-mods')",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#sec-debug-apps-module-comms",
    "href": "debug_apps.html#sec-debug-apps-module-comms",
    "title": "12  Debugging apps",
    "section": "12.4 Module communication",
    "text": "12.4 Module communication\nWhen we load, document, install and view the application in this branch we find an error with the graph display:\n\n\n\n\n\n\n\nError in graph display\n\n\nThe call stack (printed to the Console) displays the following information:\n\nWarning: Error in tools::toTitleCase: 'text' must be a character vector\n  208: stop\n  207: tools::toTitleCase\n  206: &lt;reactive&gt;\n  204: .func\n  201: contextFunc\n  200: env$runWith\n  189: ctx$run\n  188: self$.updateValue\n  186: inputs\n  178: renderPlot\n  176: func\n  136: drawPlot\n  122: &lt;reactive:plotObj&gt;\n  102: drawReactive\n   89: renderFunc\n   88: output$plot-scatterplot\n    3: runApp\n    2: print.shiny.appobj\n    1: &lt;Anonymous&gt;\n\nThe output in the Console is helpful (we know the error is coming from the tools::toTitleCase() function), but we need to narrow it down because we’re using this function in multiple places.\nTo use the interactive debugger, we’ll add browser() and observe() in the movies_server() function to capture the behaviors of both the variables and aesthetics modules:\n\nmovies_server &lt;- function(input, output, session) {\n\n      output$vals &lt;- renderPrint({\n        app_vals &lt;- reactiveValuesToList(x = input, all.names = TRUE)\n        lobstr::tree(app_vals)\n      })\n1      observe({\n2        browser()\n      \n      selected_vars &lt;- mod_var_input_server(\"vars\")\n  \n      selected_aes &lt;- mod_aes_input_server(\"aes\")\n\n      mod_scatter_display_server(\"plot\", \n                                  var_inputs = selected_vars, \n                                  aes_inputs = selected_aes)\n        \n    })\n      \n}\n\n\n1\n\nObserver scope\n\n\n2\n\nActivate debugger\n\n\n\n\nThen we’ll load, document, install and launch the app:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nThe application launches, but browser() pauses the execution of the modules and activates the IDE’s debugger. This allows us to view the objects that are available in movies_server() before the variables are passed to the graph rendering functions.\nWe’ll proceed with the interactive debugger until both selected_vars and selected_aes are returned from the input modules:\n\nBrowse[1]&gt; n\nBrowse[1]&gt; n\nBrowse[1]&gt; n\n\n\n\n\n\n\n\n\nReactive inputs returned from modules\n\n\nThis tells us both objects are returned from their respective module server functions. But we should pause and examine the structure of selected_aes:\nBrowse[1]&gt; str(selected_aes)\nfunction ()  \n - attr(*, \"observable\")=Classes 'Observable', 'R6' reactive({\n    list(alpha = input$alpha, size = input$size, plot_title = input$x)\n}) \n - attr(*, \"cacheHint\")=List of 1\n  ..$ userExpr: language {  list(alpha = input$alpha, size = input$size, \n      plot_title = input$x) }\n - attr(*, \"class\")= chr [1:3] \"reactiveExpr\" \"reactive\" \"function\"\nThe output above display selected_vars the method, not the selected input values. To view these, we need to include the parentheses:\nBrowse[1]&gt; str(selected_aes())\nList of 3\n $ alpha     : num 0.5\n $ size      : int 2\n $ plot_title: chr \"\"\nThis confirms that the UI values are being collected by the aesthetic input module and stored in selected_aes, so the error must be coming from inside one of the modules.\n\n\n\n\n\n\nWe’ve inspected the values in the exchange between movies_ui() and movies_server():\n\n\n\n█─launch_app \n├─█─movies_ui \n└─█─movies_server \n\n\n\n\nWe’ll remove (or comment out) the calls to observe() and browser() from movies_server() and repeat a similar process in mod_scatter_display_server(), but include the calls to observe() and browser() after moduleServer(). Then we’ll load, document, and install the package and run the application again:\n\nmod_scatter_display_server &lt;- function(id, var_inputs, aes_inputs) {\n\n  moduleServer(id, function(input, output, session) {\n\n1    observe({\n      browser()\n\n    inputs &lt;- reactive({\n      plot_title &lt;- tools::toTitleCase(aes_inputs()$x)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = aes_inputs()$alpha,\n          size = aes_inputs()$size,\n          plot_title = plot_title\n        \n        )\n    })\n    \n    output$scatterplot &lt;- renderPlot({\n      plot &lt;- scatter_plot(\n        # data --------------------\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n            x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n            y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n      \n    })\n\n  })\n\n}\n\n\n1\n\nWrap browser() in observe() and place after the call to moduleServer()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvance the debugger to the line after inputs() is created with var_inputs() and aes_inputs()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can see the input()$plot_title appears to be a character, but the structure of inputs() returns the error we saw in the Console\n\n\n\n\n\n\n\n\n\n\n\n12.4.1 Verifying inputs\nNow that we’ve isolated the error to the tools::toTitleCase() call in the creation of the inputs() reactive. We can confirm this in the interactive debugger:\nBrowse[1]&gt; tools::toTitleCase(aes_inputs()$x)\nError in tools::toTitleCase(aes_inputs()$x) : \n  'text' must be a character vector\nUpon further inspection, we discover the source of the error:\n\n\n\n\n\n\nBug\n\n\nFix\n\n\n\n\n\n\n\n\n\ntools::toTitleCase(aes_inputs()$x)\n\n\ntools::toTitleCase(aes_inputs()$plot_title)\n\n\n\nThe approach above have shown us 1) all modules are communicating properly, and 2) where to make changes in the scatter plot display module to render the graph.\n\n\n\n\n\n\n\nModule communication\n\n\nI’ve reverted the code to display the error in this branch so it’s easier to follow along. Each of the apps in the inst/ folder have also been updated, and I encourage you to explore how the bug effects launching each app structure.\n\n\n\n\n\n\nDebugging Apps\n\n\n\n\n\n\nThe Shiny documentation also has a list of methods for debugging apps, and learning how to read call stacks (or a stacktrace) will help you debug your shiny app.4, 5\n\n\n\n\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('12.2_debug-mods')",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "debug_apps.html#footnotes",
    "href": "debug_apps.html#footnotes",
    "title": "12  Debugging apps",
    "section": "",
    "text": "Create abstract syntax trees with the ast() function and read the Code is a tree section in Advanced R, 2ed.↩︎\nWe covered using reactiveValuesToList(), renderPrint() and verbatimTextOutput() in Section 11.3.↩︎\nWe covered using reactiveValuesToList(), renderPrint() and verbatimTextOutput() in Section 11.3.↩︎\nWatch this video to learn about call stacks and abstract folder trees with lobstr.↩︎\nStack traces are also covered in Advanced R, 2ed, Mastering Shiny, and in the Shiny documentation. I’ve summarized some tips on reading Shiny call stacks in the stack traces section on the Appendix.↩︎",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging apps</span>"
    ]
  },
  {
    "objectID": "logging.html",
    "href": "logging.html",
    "title": "13  Logging",
    "section": "",
    "text": "13.1 Why Use Logging?\nAnother proactive approach to debugging Shiny applications is implementing logging. Logs help with debugging, auditing, and monitoring and should be considered an essential feature while developing a Shiny app, especially when building an R package. This chapter introduces integrating logging in a Shiny app-package to make debugging and issue tracking more efficient.\nLogging applications app-package lets us track the application flow and record user interactions and inputs, and can also be used to identify runtime errors and unexpected behaviors. Log messages are more structured, flexible, and configurable than print statements or the interactive debugger. Logging is particularly useful in production environments, where direct debugging may not be possible. Logs can also be saved for future analysis, even after the application has stopped running.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#why-use-logging",
    "href": "logging.html#why-use-logging",
    "title": "13  Logging",
    "section": "",
    "text": "13.1.1 Architecture\nWe’re going to start logging the behaviors in the inst/tidy-movies application. The architecture of this application has been updated to include the two new input modules (see Section 9.2.1):\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart LR\n        subgraph R[\"&lt;strong&gt;R/ folder&lt;/strong&gt;\"]\n            subgraph launch[\"launch_app('ggp2')\"]\n                display_type[\"display_type()\"]\n            end\n                mod_aes_input_ui[\"mod_aes_input_ui()\"]\n                mod_aes_input_server[\"mod_aes_input_server\"]\n                mod_var_input_server[\"mod_var_input_server()\"]\n                scatter_plot[\"scatter_plot()\"]\n        end\n\n        subgraph tidy_movies[\"&lt;strong&gt;tidy-movies/ folder&lt;/strong&gt;\"]\n            subgraph app[\"app.R file\"]\n                subgraph SubR[\"&lt;strong&gt;R/ folder&lt;/strong&gt;\"]\n                devUI[\"devUI()\"]\n                dev_mod_vars_ui[\"dev_mod_vars_ui()\"]\n                dev_mod_scatter_ui[\"dev_mod_scatter_ui()\"]\n                devUI --&gt;|\"&lt;em&gt;Calls&lt;/em&gt;\"|dev_mod_vars_ui & dev_mod_scatter_ui\n                devServer[\"devServer()\"]\n                dev_mod_scatter_server[\"dev_mod_scatter_server()\"]\n                devServer --&gt;|\"&lt;em&gt;Calls&lt;/em&gt;\"|dev_mod_scatter_server\n                end\n            end\n            data[(\"tidy_movies.fst\")]\n            img[/\"imdb.png\"\\]\n        end\n        \n\n        launch ==&gt; |\"&lt;strong&gt;&lt;code&gt;shinyAppDir()&lt;/code&gt;&lt;/strong&gt;\"|app\n        mod_aes_input_ui -.-&gt;|\"&lt;em&gt;Called from&lt;/em&gt;\"|devUI\n        mod_var_input_server & mod_aes_input_server -.-&gt;|\"&lt;em&gt;Called from&lt;/em&gt;\"|devServer\n        scatter_plot --&gt; |\"&lt;em&gt;Called from&lt;/em&gt;\"|dev_mod_scatter_server\n        \n        \n    %% R/\n    style R fill:#e8f0f5,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% standalone app function\n    style launch fill:#F6F6F6,color:#000,stroke:#333,stroke-width:1px,rx:10,ry:10\n    %% modules \n    style mod_var_input_server color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style mod_aes_input_ui color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style mod_aes_input_server color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    %% utility functions\n    style scatter_plot fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    style display_type fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    \n    %% tidy-movies/ \n    style tidy_movies fill:#e8f0f5,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% tidy-movies/R\n    style SubR fill:#f7fafb,stroke:#333,stroke-width:1px,rx:3,ry:3\n    %% tidy-movies/R/ files\n    style devUI stroke:#333,stroke-width:1px,rx:6,ry:6\n    style devServer stroke:#333,stroke-width:1px,rx:6,ry:6\n    style dev_mod_scatter_server color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style dev_mod_scatter_ui color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    style dev_mod_vars_ui color:#000,fill:#f5f5f5,stroke:#333,stroke-width:1px,rx:12,ry:12\n    %% files \n    style app fill:#f8f6e7,color:#000\n    style data fill:#f8f6e7,color:#000\n    style img fill:#f8f6e7,color:#000\n\n\n Architecture of app functions in inst/tidy-movies/ folder \n\n\n\nTo launch the inst/tidy-movies app, load, document, and install sap and run:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlaunch_app(\"ggp2\")\n\n\n\n\n\n\n\n\nLaunching inst/tidy-movies app with launch_app()\n\n\nThe reactive values from the R/mod_var_input.R are printed to the Console from the previous chapter (See Section 12.2).\n\n\n13.1.2 Validating inputs\nshiny::validate() can be used to prevent unexpected errors by preventing execution of subsequent code if the provided validation conditions fail.\n\nneed() is used inside validate() to check if a condition is met, and try() catches errors that might occur if inputs are NULL or missing.\nIf an error occurs, try() prevents the application from crashing and instead returns an error object.\n\nFor example, the alpha and size inputs can validated with try() and need():\n\nvalidate(\n  need(\n    try(input$alpha &gt;= 0 & input$alpha &lt;= 1),\n    \"Alpha must be between 0 and 1\"\n  )\n)\n\n\n\n\ninput$alpha\nBehavior\n\n\n\n\n0.5 (valid)\n✅ Passes validation\n\n\n1.5 (invalid)\n❌ Error: \"Alpha must be between 0 and 1\"\n\n\nNULL\n❌ Error: \"Alpha must be between 0 and 1\"\n\n\nNA\n❌ Error: \"Alpha must be between 0 and 1\"\n\n\n\"high\" (string)\n❌ Error: \"Alpha must be between 0 and 1\"\n\n\n\n\nvalidate(\n  need(\n    try(input$size &gt; 0),\n    \"Size must be positive\"\n  )\n)\n\n\n\n\ninput$size\nBehavior\n\n\n\n\n3 (valid)\n✅ Passes validation\n\n\n-2 (invalid)\n❌ Error: \"Size must be positive\"\n\n\nNULL\n❌ Error: \"Size must be positive\"\n\n\nNA\n❌ Error: \"Size must be positive\"\n\n\n\"large\" (string)\n❌ Error: \"Size must be positive\"\n\n\n\n\n\n13.1.3 Handling errors\nThe tryCatch function can be used by itself to log unexpected errors gracefully. Below is an example of using it with reactive() and combining it message():\n\nsafe_reactive &lt;- reactive({\n    tryCatch({\n        # Code that might throw an error\n        \n    }, error = function(e) {\n        message(paste0(\"An error occurred:\", e$message))\n    })\n})",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#custom-logging-functions",
    "href": "logging.html#custom-logging-functions",
    "title": "13  Logging",
    "section": "13.2 Custom logging functions",
    "text": "13.2 Custom logging functions\nLogging can be implemented without any dependencies. The base package has many tools we can use to write a custom logging function. Below is an example logging utility function we could add to the R/ folder and use in our app(s):\n\n#' Log Application Behaviors\n#'\n#' A simple logging function for logging Shiny events and behaviors.\n#' \n#' @param message log message\n#' @param log_file name of log file (defaults to \"app_log.txt\")\n#' @param save print or save log file\n#'\n#' @return A log message to the console and the `log_file`.\n#'\n#' @family **Utility Functions**\n#' \n#' @examples\n#' if (interactive()) {\n#'   log_message(\"message\")\n#' }\n#' \n#' @export\nlog_message &lt;- function(message, log_file = \"logs/app_log.txt\", save = FALSE) {\n  \n1  log_dir &lt;- dirname(log_file)\n  \n2  if (!dir.exists(log_dir)) {\n    dir.create(log_dir, recursive = TRUE)\n  }\n  \n  timestamp &lt;- format(Sys.time(), \"%Y-%m-%d %H:%M:%S\")\n3  log_entry &lt;- sprintf(\"[%s] %s\", timestamp, message)\n  \n  if (save) {\n4    tryCatch({\n5        cat(log_entry, \"\\n\", file = log_file, append = TRUE)\n      },\n      error = function(e) {\n        warning(sprintf(\"Failed to write to log file '%s': %s\", log_file, e$message)) \n      })\n  }\n  \n6  message(log_entry)\n}\n\n\n1\n\nThis function uses dirname() to dynamically extract the directory path from log_file.\n\n\n2\n\ndir.exists() and dir.create() ensure the folder exists (recursive = TRUE is for nested directories).\n\n\n3\n\nThe sprintf() function is preferred over cat() or paste0() for clearer and faster string formatting.\n\n\n4\n\nThe file-writing logic is wrapped in tryCatch() to gracefully handle errors (e.g., file permission issues), and we’ve added a warning() if writing to the log file fails.\n\n\n5\n\nWe explicitly add the newline (\\n) directly in the cat() function, ensuring the log entry is written properly even if message lacks a newline.\n\n\n6\n\nFinally, the message() is preferred here instead of print() for consistent output formatting.\n\n\n\n\nAdapted to use in the inst/tidy-movies/ app, the tryCatch() function might look like:\n\n    all_data &lt;- tryCatch({\n      \n1      log_message(message = \"Loading fst data\",\n        log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n      \n      fst::read_fst(\"tidy_movies.fst\")\n      \n    }, error = function(e) {\n      \n2      log_message(message = sprintf(\"Error loading fst data: %s\", e$message),\n        log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n      \n3      stop(\"Data loading failed.\")\n\n    })\n\n\n1\n\nSaving to _logs because it’s easier to separate from other app folders.\n\n\n2\n\nPrint error message from tryCatch()\n\n\n3\n\nStop creation of reactive.\n\n\n\n\nAfter loading and installing our package, the output from the log is saved in the log file (and printed to the Console) when our app stops running:\n\n\n\n\n\n\n\nLogging data upload with log_message()\n\n\n\n13.2.1 Logging events\nWe’ll continue to integrate log messages into the inst/tidy-movies app by inserting log_message() at critical points, such creating reactive expressions. For example, dev_mod_scatter_server() creates the graph_data() reactive based on the missing data checkbox user input:\n\ngraph_data &lt;- reactive({\n  if (input$missing) {\n    graph_data &lt;- tidyr::drop_na(data = all_data)\n  } else {\n    graph_data &lt;- all_data\n  }\n}) |&gt;\n  bindEvent(input$missing)\n\nWe’ll add validate() and tryCatch() with a log_message() to log if 1) graph_data() contains all of the observations or the missing values have been removed, and 2) if the reactive was created successfully.\n\ngraph_data &lt;- reactive({\n  \n1  validate(\n    need(try(is.logical(input$missing)), \n          \"Missing must be logical\")\n  )\n  \n    tryCatch({\n      if (input$missing) {\n        \n2        log_message(message = \"Removing missing values.\",\n                    log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n        graph_data &lt;- tidyr::drop_na(data = all_data)\n        \n      } else {\n        \n3        log_message(message = \"Using all data.\",\n                    log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n        graph_data &lt;- all_data\n        \n      }\n      \n      graph_data\n      \n    }, error = function(e) {\n      \n4      log_message(message = sprintf(\"Error processing graph data: %s\", e$message),\n        log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n5      NULL\n      \n    })\n}) |&gt; \n  bindEvent(input$missing)\n\n\n1\n\nValidation for missing checkbox input\n\n\n2\n\nConfirm missing values and create graph_data\n\n\n3\n\nUse all data and create graph_data\n\n\n4\n\nPrint and log message is error occurs\n\n5\n\nReturn null value for error\n\n\n\n\nThese logs will tell us the application loaded the .fst data and removed the missing values, but we should also check what happens when we change something, so we’ll adapt the code used to create our inputs() reactive with the log_message() function:\n\ninputs &lt;- reactive({\n\n  tryCatch({\n    plot_title &lt;- tools::toTitleCase(aes_inputs()$plot_title)\n    \n1    if (nchar(plot_title) &gt; 0) {\n      log_message(\n        sprintf(\"Processing plot title: '%s'\", plot_title), \n        log_file = \"_logs/ggp2_log.txt\")\n    }\n    \n      input_list &lt;- list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = aes_inputs()$alpha,\n        size = aes_inputs()$size,\n        plot_title = plot_title\n      )\n    \n2    log_message(\n      sprintf(\"Inputs: %s\", \n              paste(\n                names(input_list), input_list, sep = \" = \", collapse = \", \")\n              ),\n            log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n    \n    input_list\n  }, error = function(e) {\n    \n3    log_message(\n      sprintf(\"Error in processing inputs: %s\", conditionMessage(e)),\n      log_file = \"_logs/ggp2_log.txt\", save = TRUE)\n    \n4    NULL\n  })\n})\n\n\n1\n\nLog the plot title.\n\n\n2\n\nLog the final input list.\n\n\n3\n\nLog the error if anything goes wrong.\n\n\n4\n\nReturn NULL on error to prevent breaking downstream dependencies.\n\n\n\n\nAfter loading and installing sap, we launch the inst/tidy-movies app again, but this time we un-check the remove missing checkbox and add a new title before stopping the application.\n\nlaunch_app(\"ggp2\")\n\n\n\n\n\n\n\n\nLog messages from inputs()\n\n\nTo view the log file, we need to use system.file() (we’re launching the app from the installed location, not the version we’re developing in the inst/tidy-movies/ folder). I’ve added readLines() and writeLines() so it prints nicely to the Console:\n\nsystem.file('tidy-movies', '_logs', 'ggp2_log.txt', \n            package = 'sap') |&gt; \n            readLines() |&gt; \n            writeLines()\n\n[2025-01-29 11:34:40] Loading fst data \n[2025-01-29 11:34:40] Removing missing values. \n[2025-01-29 11:34:40] Inputs: x = year, y = budget, z = mpaa, alpha = 0.5, size = 2, plot_title =  \n[2025-01-29 11:35:46] Loading fst data \n[2025-01-29 11:35:46] Removing missing values. \n[2025-01-29 11:35:46] Inputs: x = year, y = budget, z = mpaa, alpha = 0.5, size = 2, plot_title =  \n[2025-01-29 11:35:52] Loading fst data \n[2025-01-29 11:35:52] Removing missing values. \n[2025-01-29 11:35:52] Inputs: x = year, y = budget, z = mpaa, alpha = 0.5, size = 2, plot_title =  \n[2025-01-29 11:35:57] Inputs: x = year, y = budget, z = mpaa, alpha = 0.5, size = 2, plot_title = Title \nIn practice, we’d insert logging messages with log_message() and tryCatch() for application startup, loading data/connecting to databases, API calls, and when using Shiny’s internal validation/error handling functions. In the next section, we’re going to explore using add-on packages to implement logging in our app-package.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#app-logs-with-logger",
    "href": "logging.html#app-logs-with-logger",
    "title": "13  Logging",
    "section": "13.3 App logs with logger",
    "text": "13.3 App logs with logger\n\n\n\n\n\n\nLogging frameworks\n\n\n\n\n\n\nThe R ecosystem offers several libraries for logging.\nThe most popular options are:\n\nfutile.logger: A lightweight and flexible logging package.\nlogger: A modern, extensible, and user-friendly library.\nlog4r: Inspired by the Java log4j library, suitable for structured logging.\n\n\n\n\n\nThis section will focus on the logger package because it is simple, easy to integrate with Shiny, and extensible.\n\ninstall.packages(\"pak\")\npak::pak(\"daroczig/logger\")\n\nAdd logger to the package dependencies in the DESCRIPTION file and use the logger::fun() syntax to avoid adding @import or @importFrom roxygen tags.\n\nusethis::use_package('logger')\n\n\n13.3.1 Log levels\nThe logger package has a few configurations that can be very helpful for app-package development. We’ll start with a basic example using logger::log_info():\n\nname &lt;- \"world\"\nlogger::log_info('Hello, {name}')\n\nINFO [2025-01-22 11:07:52] Hello, world\nThe output is a nicely formatted log message, and by default logger supports glue syntax. However, the following function (logger::log_debug()) doesn’t return a log message to the Console:\n\nlogger::log_debug('Hello, {name}')\n\nThis is because the logger package has a threshold configuration that controls the ‘verbosity’ of the logs printed to the Console. If we check the log_threshold(), we see it’s set to INFO:\n\nlogger::log_threshold()\n\nLog level: INFO\nIf we reset the logger::log_threshold() to DEBUG, we will see the call in the Console.\n\nlogger::log_threshold('DEBUG')\nlogger::log_debug('Hello, {name}')\n\nDEBUG [2025-01-22 11:08:36] Hello, world\nWe can set the log threshold dynamically to control the verbosity of logs:\n\nlogger::log_threshold('TRACE') # fine-grained, verbose logging for development\nlogger::log_threshold('DEBUG') # verbose logging for development\nlogger::log_threshold('WARN')  # only warnings and errors for production\n\nWhile developing app-packages, I recommend broadly characterizing the logger log levels into the following categories:\n\n\n\n\n\n\n\nDevelopment\nDescriptive messages for easier debugging\n\n\n\n\n\n\n\n\n\nLevel\nDetails\n\n\n\n\nTRACE\nFine-grained tracking for debugging flows (e.g., reactive updates, function calls).\n\n\nDEBUG\nDiagnostic information for inputs, intermediate states, and outputs.\n\n\n\n\n\n\n\n\n\n\n\n\nProduction\nLower verbosity levels\n\n\n\n\n\n\n\n\n\nLevel\nDetails\n\n\n\n\nINFO\nSession-level events and significant actions (e.g., app startup, data loading).\n\n\nWARN\nSuspicious but non-fatal conditions (e.g., unusual input values or data sizes).\n\n\nERROR\nHandled errors with appropriate messaging and graceful recovery.\n\n\nFATAL\nCritical failures leading to app crashes or irrecoverable states.\n\n\n\n\n\n\n\n13.3.2 Storing log files\nBy default, logger logs are written to the console, but the logger::appender_file() function can direct log messages to a file (or to a database or external logging system).1\nWe also want to periodically archive old logs to prevent storage issues. Storing log messages as JSON objects is sometimes preferred because JSON files are structured, machine-readable, and can easily integrate with logging tools like Logstash, Kibana (ELK Stack) or other log management solutions.\n\n\n13.3.3 Custom logger functions\nWe’ll write a custom logging function with logger to so our app logs are formatted and managed a consistent manner. Below is a logr_msg() utility function for inserting logger-style logs in our application.\n\nlogr_msg &lt;- function(message, level = \"INFO\", log_file = NULL, json = FALSE) {\n  \n1  logger::log_appender(appender = logger::appender_console)\n  \n  if (!is.null(log_file)) {\n2    if (json) {\n      logger::log_layout(layout = logger::layout_json())\n3    } else {\n      logger::log_appender(appender = logger::appender_tee(log_file))\n    }\n  }\n  \n4  logger::log_formatter(formatter = logger::formatter_glue)\n  \n5  switch(\n    level,\n    \"FATAL\" = logger::log_fatal(\"{message}\"),\n    \"ERROR\" = logger::log_error(\"{message}\"),\n    \"WARN\" = logger::log_warn(\"{message}\"),\n    \"SUCCESS\" = logger::log_success(\"{message}\"),\n    \"INFO\" = logger::log_info(\"{message}\"),\n    \"DEBUG\" = logger::log_debug(\"{message}\"),\n    \"TRACE\" = logger::log_trace(\"{message}\"),\n6    logger::log_info(\"{message}\")\n  )\n}\n\n\n1\n\nAll logs print to console\n\n2\n\nWrite logs to JSON if the json = TRUE\n\n\n3\n\nDefault appender_tee for plain text logs\n\n\n4\n\nSet the default formatter\n\n\n5\n\nHandle all log levels\n\n\n6\n\nDefault to INFO\n\n\n\n\nlog_appender controls where the log messages go. It specifies the “destination” for each log message, whether that’s the Console, a file, or both.\nlog_formatter is like a template for log messages–it determines how log each message is structured and displayed. We can control what information is included in each message (like the timestamp, log level, and the actual message), and how this information is formatted. Predefined formatters (like formatter_glue) uses glue syntax to create flexible and readable formats.\nWe’ll demonstrate logr_msg() with the mod_var_input_server() function, which returns the variable inputs from the UI. The message in logr_msg() is built with glue::glue() and includes the three reactive inputs from this module. We’re also appending the log output to a new log file (_logs/app_log.txt).\n\nmod_var_input_server &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    \n1    logr_msg(\"mod_var_input_server started\",\n      level = \"TRACE\", log_file = \"_logs/app_log.txt\")\n    \n    observe({\n2        logr_msg(\n          glue::glue(\"Reactive inputs: \n                      x = {input$x}, y = {input$y}, z = {input$z}\"),\n          level = \"DEBUG\", log_file = \"_logs/app_log.txt\")\n    }) |&gt; \n      bindEvent(c(input$x, input$y, input$z))\n\n    return(\n      reactive({\n3        logr_msg(\n          glue::glue(\"Reactive inputs returned: \n                      x = {input$x}, y = {input$y}, z = {input$z}\"),\n          level = \"DEBUG\", log_file = \"_logs/app_log.txt\")\n        list(\n          \"x\" = input$x,\n          \"y\" = input$y,\n          \"z\" = input$z\n        )\n      })\n    )\n  })\n}\n\n\n1\n\nTRACE log for starting the module\n\n\n2\n\nDEBUG log for collecting inputs\n\n3\n\nDEBUG log for returning inputs\n\n\n\n\nAn advantage to using the logger package is that our log messages are automatically printed to the Console while the application is launched, although when we load and install sap and launch the inst/tidy-movies app, we don’t see any logs:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlaunch_app(\"ggp2\")\n\n\n\n\n\n\n\n\nInitial messages from logr_msg()\n\n\nTo view the log in our app, we need to set the log threshold:\n\nlogger::log_threshold('TRACE')\nlaunch_app(\"ggp2\")\n\nThe logs are now printed to the console and we can see the level, timestamp, and message:\n\n\n\n\n\n\n\nUpdates from logr_msg()",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#logging-and-debugging",
    "href": "logging.html#logging-and-debugging",
    "title": "13  Logging",
    "section": "13.4 Logging and debugging",
    "text": "13.4 Logging and debugging\nOur primary application (i.e. the app launched with launch_app()) is currently displaying and error message:\n\n\n\n\n\n\n\nError message in launch_app()\n\n\nLet’s try to visualize the call stack and namespaces in this app. The diagram below shows how the variable and aesthetic input modules communicate the user selections across the namespaces in UI and server functions.\n\n\n\n\n\n\n\n%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"16px\"}}}%%\nflowchart TD\n    subgraph Launch[\"&lt;strong&gt;launch_app()&lt;/strong&gt;\"]\n        subgraph Server[\"&lt;strong&gt;movies_server()&lt;/strong&gt;\"]\n            subgraph VarServerNS[\"&lt;strong&gt;Variable Namespace&lt;strong&gt;\"]\n                VarInpuServer[\"Server Module:&lt;br&gt;&lt;code&gt;mod_var_input_server()&lt;/code&gt;\"]\n            end\n            subgraph AesServerNS[\"&lt;strong&gt;Aesthetics Namespace&lt;strong&gt;\"]\n                AesInpuServer[\"Server Module:&lt;br&gt;&lt;code&gt;mod_aes_input_server()&lt;/code&gt;\"]\n            end\n            subgraph GraphServerNS[\"&lt;strong&gt;Graph Namespace&lt;strong&gt;\"]\n                DisplayServer[\"Server Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_server()&lt;/code&gt;\"]\n                PlotUtil[\"Utility Function:&lt;br&gt;&lt;code&gt;scatter_plot()&lt;/code&gt;\"]\n            end\n        end\n        subgraph UI[\"&lt;strong&gt;movies_ui()&lt;/strong&gt;\"]\n            subgraph VarUINS[\"&lt;strong&gt;Variable Namespace&lt;strong&gt;\"]\n                VarInpuUI[\"UI Module:&lt;br&gt;&lt;code&gt;mod_var_input_ui()&lt;/code&gt;\"]\n            end\n            subgraph AesUINS[\"&lt;strong&gt;Aesthetics Namespace&lt;strong&gt;\"]\n                AesInpuUI[\"UI Module:&lt;br&gt;&lt;code&gt;mod_aes_input_ui()&lt;/code&gt;\"]\n            end\n            subgraph GraphUINS[\"&lt;strong&gt;Graph Namespace&lt;strong&gt;\"]\n                DisplayUI[\"UI Module:&lt;br&gt;&lt;code&gt;mod_scatter_display_ui()&lt;/code&gt;\"]\n            end\n        end\n\n        VarInpuUI &lt;==&gt; |\"shared namespace\"|VarInpuServer\n        AesInpuUI &lt;==&gt; |\"shared namespace\"|AesInpuServer\n        DisplayServer &lt;--&gt; PlotUtil &lt;==&gt; |\"shared namespace\"|DisplayUI\n    end\n\n    VarInpuServer &lt;-.-&gt;|\"Communicates &lt;code&gt;selected_vars&lt;/code&gt;&lt;br&gt;across namespaces\"| DisplayServer\n    AesInpuServer &lt;-.-&gt;|\"Communicate &lt;code&gt;selected_aes&lt;/code&gt;&lt;br&gt;across namespaces\"| DisplayServer\n    \n    %% standalone app function \n    style Launch fill:#F6F6F6,color:#000,stroke:#333\n    %% modules\n    style VarInpuUI color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    style AesInpuServer color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    style AesInpuUI color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    style DisplayServer color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    style DisplayUI color:#000,fill:#f5f5f5,stroke-width:2px,rx:3,ry:3\n    %% Utility Functions\n    style PlotUtil fill:#595959,color:#FFF,stroke:#333,stroke-width:1px,rx:25,ry:25\n    %% namespaces\n    style VarServerNS fill:#f8f6e7,stroke-width:1px,rx:6,ry:6\n    style VarUINS fill:#f8f6e7,stroke-width:1px,rx:6,ry:6\n    style AesServerNS fill:#f8f6e7,stroke-width:1px,rx:6,ry:6\n    style AesUINS fill:#f8f6e7,stroke-width:1px,rx:6,ry:6\n    style GraphServerNS fill:#f8f6e7,stroke-width:1px,rx:6,ry:6\n    style GraphUINS fill:#f8f6e7,stroke-width:1px,rx:6,ry:6\n    %% UI and Server\n    style Server fill:#e8f0f5,stroke-width:1px,rx:12,ry:12\n    style UI fill:#e8f0f5,stroke-width:1px,rx:12,ry:12\n\n\n Primary launch_app() app \n\n\n\nBelow are examples of various log levels using logr_msg() to help us debug the error in the primary application.\n\n13.4.1 TRACE logs\n\nIn movies_server(), add a TRACE log message for signaling the server function has executed.\n\n\n  logr_msg(message = \"Server function execution completed\", \n           level = \"TRACE\", log_file = \"_logs/app_log.txt\")\n\n\nIn mod_scatter_display_server(), add a TRACE log messages for initiating the scatterplot graph\n\n\nlogr_msg(\"Preparing scatterplot in mod_scatter_display_server\", \n          level = \"TRACE\", log_file = \"_logs/app_log.txt\")\n\n\n\n13.4.2 INFO logs\n\nIn launch_app(), add an INFO log message to print the application being launched with the app argument\n\n\n  logr_msg(glue::glue(\"Launching app: {app}\"), level = \"INFO\",\n    log_file = \"_logs/app_log.txt\")\n\n\nIn movies_ui(), add an INFO log message with the value of the bslib argument\n\n\n  logr_msg(\n    glue::glue(\"Launching UI with bslib = {bslib}\"),\n    level = \"INFO\", log_file = \"_logs/app_log.txt\")\n\n\n\n13.4.3 WARN logs\n\nIn mod_aes_input_server(), add a WARN log message (with validate) for input warnings.\n\n\n      validate(\n        need(try(input$alpha &gt;= 0 & input$alpha &lt;= 1), \n              \"Alpha must be between 0 and 1\")\n      )\n      if (input$alpha &lt; 0 || input$alpha &gt; 1) {\n        logr_msg(message = \"Alpha value out of range: {alpha}\", \n        level = \"WARN\", log_file = \"_logs/app_log.txt\")\n      }\n\n\n\n13.4.4 ERROR logs\n\nIn movies_ui(), Add logic and an ERROR log message to monitor the format of the bslib argument\n\n\nif (!is.logical(bslib)) {\n  logr_msg(\"Argument 'bslib' must be a logical value\", \n    level = \"ERROR\", log_file = \"_logs/app_log.txt\")\n    stop(\"Invalid argument: 'bslib' must be TRUE or FALSE.\")\n  }\n\n\nIn mod_scatter_display_server(), add an ERROR log messages (with tryCatch()) to monitor the rendered output\n\n\n  tryCatch({\n    plot &lt;- scatter_plot(\n      # data --------------------\n      df = movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size\n    )\n    plot +\n      ggplot2::labs(\n        title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n      ) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  }, error = function(e) {\n  \n  logr_msg(glue::glue(\"Failed to render scatterplot. Reason: {e$message}\"), \n           level = \"ERROR\", log_file = \"_logs/app_log.txt\")\n  \n  })\n\n\n\n13.4.5 FATAL logs\n\nIn launch_app(), add a FATAL log message (along with tryCatch() and stop()) to monitor the application being launched\n\n\n  tryCatch({\n    \n    if (app == \"bslib\") {\n      shinyApp(\n        ui = movies_ui(bslib = TRUE),\n        server = movies_server,\n        options = options\n      )\n    } else if (app == \"ggp2\") {\n      shinyAppDir(\n        appDir = system.file(\"tidy-movies\", package = \"sap\"),\n        options = options\n      )\n    } else if (app == \"quarto\") {\n      quarto::quarto_preview(\n        system.file(\"quarto\", \"index.qmd\", package = \"sap\"), \n        render = \"all\"\n      )\n    } else {\n      app &lt;- \"movies\"\n      shinyApp(\n        ui = movies_ui(...),\n        server = movies_server,\n        options = options\n      )\n    }\n    \n  }, error = function(e) {\n    \n    logr_msg(glue::glue(\"Application failed to launch. Reason: {e$message}\"), \n             level = \"FATAL\",\n             log_file = \"_logs/app_log.txt\")\n    \n    stop(\"Application launch failed. Check logs for details.\")\n    \n  })\n\nTo use logs during development to trace the flow of our application, we need to set the threshold to TRACE or DEBUG after loading and install.\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlogger::log_threshold('TRACE')\nlaunch_app()\n\n\n\n\n\n\n\n\nLog error message in launch_app()\n\n\nWhile developing our application, we can run the app interactively and monitor the logs in the console. If the application has been deployed, we can search the log files using R (or the command line):\nIn R:\n\nreadLines(\"_logs/app_log.txt\") |&gt; \n  stringr::str_view(\"ERROR\")\n\n│ &lt;ERROR&gt; [2025-01-29 13:55:36] Failed to render scatterplot. \n  Reason: 'text' must be a character vector\nCommand line:\ncat _logs/app_log.txt | grep \"ERROR\"\nERROR [2025-01-29 13:55:36] Failed to render scatterplot. \n  Reason: 'text' must be a character vector\n\n\n\n\n\n\nInitialize logging with .onLoad()\n\n\n\n\n\n\nWe can set up logger’s logging configuration in an onLoad function of the zzz.R file:\n.onLoad &lt;- function(libname, pkgname) {\n    # configure logger log messages to console\n    logger::log_appender(logger::appender_console)\n    # configure logger log messages to file\n    logger::log_appender(logger::appender_file('sap_apps.log'))\n    # set default log level to DEBUG\n    logger::log_threshold('DEBUG') \n}\nThis setup ensures that logging is ready as soon as your package is loaded.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#package-startup-messages",
    "href": "logging.html#package-startup-messages",
    "title": "13  Logging",
    "section": "13.5 Package startup messages",
    "text": "13.5 Package startup messages\nPackage startup messages help create a welcoming and professional impression when users load your app-package. These messages can also inform users of any specific requirements, dependencies, or potential conflicts. Package startup messages can also include the logging system (i.e., logger) being used, which can be helpful for debugging or monitoring during development or runtime.\n\n13.5.1 .onAttach()\nWrite package startup messages in the .onAttach() function (stored in R/zzz.R).2 The example below includes a welcome message, the current Git branch, dependencies (imports, depends, and suggests), and the path where this package is loaded from.\n\n\nshow/hide\n.onAttach &lt;- function(libname, pkgname) {\n  \n1    branch &lt;- if (isTRUE(system(\"git rev-parse --is-inside-work-tree\", intern = TRUE) == \"true\")) {\n2    tryCatch({\n      system(\"git rev-parse --abbrev-ref HEAD\", intern = TRUE)\n    }, error = function(e) \"unknown\")\n  } else {\n    \"not a Git repository\"\n  }\n\n3  version &lt;- utils::packageVersion(pkgname)\n\n4  description &lt;- utils::packageDescription(pkgname)\n  imports &lt;- description$Imports\n  suggests &lt;- description$Suggests\n  depends &lt;- description$Depends\n\n5  parse_dependencies &lt;- function(dep_string) {\n    if (is.null(dep_string)) return(\"None\")\n    deps &lt;- strsplit(dep_string, \",\\\\s*\")[[1]]\n    paste(deps, collapse = \", \")\n  }\n\n6  imports &lt;- parse_dependencies(imports)\n  suggests &lt;- parse_dependencies(suggests)\n  depends &lt;- parse_dependencies(depends)\n  \n7  cli::cli_h2(\"Welcome to the {.pkg {pkgname}} package (version {version}) {cli::symbol$smiley}!\")\n8  cli::cli_h3(\"Current branch:\")\n  cli::cli_text(\"{.emph {cli::symbol$pointer} {branch}}\")\n9  cli::cli_h3(\"Dependencies:\")\n10  cli::cli_text(\"{.emph {cli::symbol$pointer} Imports: {imports}}\")\n11  cli::cli_text(\"{.emph {cli::symbol$pointer} Suggests: {suggests}}\")\n12  cli::cli_text(\"{.emph {cli::symbol$pointer} Depends: {depends}}\")\n13  cli::cli_h3(\"Loaded from:\")\n14  cli::cli_text(\"{.emph {cli::symbol$pointer} {libname}}\")\n15  cli::cli_inform(c(), class = \"packageStartupMessage\")\n}\n\n\n\n1\n\nCheck if the current folder is a Git repo.\n\n\n2\n\nCapture the current branch if it’s a Git repo.\n\n\n3\n\nPackage version.\n\n\n4\n\nDependencies from DESCRIPTION.\n\n\n5\n\nParse and format dependencies function.\n\n\n6\n\nCleaned dependencies.\n\n\n7\n\nWelcome message.\n\n\n8\n\nGit branch.\n\n\n9\n\nDependencies (header).\n\n\n10\n\nDependencies (Imports from DESCRIPTION).\n\n\n11\n\nDependencies (Suggests from DESCRIPTION).\n\n\n12\n\nDependencies (Depends from DESCRIPTION).\n\n\n13\n\nSource of installed packages.\n\n\n14\n\nlibname (a character string giving the library directory where the package defining the namespace was found.)\n\n\n15\n\nOutput with appropriate class.\n\n\n\n\nWhen we loading sap, we see the output from our startup message:\n\n\n\n\n\n\n\nPackage startup message in sap`\n\n\nIncluding a startup message is a helpful tool, but it should be thoughtfully crafted to enhance the user experience without being intrusive. Avoid including a startup message if the app-package if the message doesn’t add meaningful value and becomes unnecessary “noise” for users.\nAlso, be sure to allow users to disable the message if possible (e.g., using suppressPackageStartupMessages()):\n\ninstall.packages('pak')\npak::pak('mjfrigaard/sap')\nsuppressPackageStartupMessages(library(sap))",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#recap",
    "href": "logging.html#recap",
    "title": "13  Logging",
    "section": "Recap",
    "text": "Recap\nLogging is an invaluable tool for debugging Shiny applications in an R package. By strategically placing log messages and configuring log levels, you can gain deep insights into your application’s behavior. However, we also want to be selective with logging and avoid exposing or storing sensitive data.\nThe techniques discussed in this chapter will help you efficiently diagnose and resolve issues, making your Shiny applications more robust and reliable.",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "logging.html#footnotes",
    "href": "logging.html#footnotes",
    "title": "13  Logging",
    "section": "",
    "text": "Integrate with external logging systems (e.g., Syslog or Telegram) using custom appenders.↩︎\nRead more in the ‘Hooks for Namespace Events’ documentation.↩︎",
    "crumbs": [
      "Debug",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "tests.html",
    "href": "tests.html",
    "title": "Tests",
    "section": "",
    "text": "Testing your app\nExpand the callout boxes below to review what we’ve covered in the previous chapters on debugging:\nWe’re now ready to test the code and features in our app-package. The next section covers the following topics:",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#test-suite",
    "href": "tests.html#test-suite",
    "title": "Tests",
    "section": "Test suite",
    "text": "Test suite\nTest suite starts by showing how to create the testthat infrastructure then, dives into creating test files, the mechanics unit tests and expectations, and running tests during development\n\n14.2 Setting up testthat tests\n14.3 Creating unit tests\n14.3.2 test_that() tests\n14.3.3 expect_ations\n14.4 Running tests\n\nThis chapter also introduces keyboard shortcuts for testing and testthat’s behavior-driven development functions:\n\n14.4.1 Keyboard shortcuts\n14.3.4 BDD test functions",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#specifications",
    "href": "tests.html#specifications",
    "title": "Tests",
    "section": "Specifications",
    "text": "Specifications\nSpecifications discusses how to collect and organize information to write tests for your application:\n\n15.1 Application requirements\n15.1.1 User Specifications\n15.1.2 Features, and\n15.1.3 Functional Requirements\n\nThis chapter also gives examples of behavior-driven development tests features and how to track specifications and tests together:\n\n15.3 BDD and testthat\n15.4 Traceability Matrix",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#test-tools",
    "href": "tests.html#test-tools",
    "title": "Tests",
    "section": "Test tools",
    "text": "Test tools\nThis chapter introduces:\n\n16.1 Test fixtures\n16.2 Test helpers\n16.2.2 Test development, and\n16.3.1 Reviewing _snaps/\n\nEach tool can contribute to testing your Shiny app-package in a unique way (they’re also relatively recent additions to the testthat framework)",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#testing-modules",
    "href": "tests.html#testing-modules",
    "title": "Tests",
    "section": "Testing modules",
    "text": "Testing modules\nShiny’s testServer() function can be useful for performing integration tests with module server functions. Testing modules gives examples of using testServer() to verify module communication (i.e., passing data between modules):\n\n17.1.1 Testing return values\n17.1.3 Testing module parameters\n17.2 Module test coverage\n17.2.1 Testing module outputs",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "tests.html#system-tests",
    "href": "tests.html#system-tests",
    "title": "Tests",
    "section": "System tests",
    "text": "System tests\nThe final chapter in this section covers setting up and running system (or end-to-end tests with shinytest2):\n\n18.2 Setting up shinytest2\n18.3 Record a test\n18.4 shinytest2 and BDD\n18.5 The test.mode option\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests"
    ]
  },
  {
    "objectID": "test_suite.html",
    "href": "test_suite.html",
    "title": "14  Test suite",
    "section": "",
    "text": "14.1 testthat framework\nTesting Shiny applications poses some unique challenges. Shiny functions are written in the context of its reactive model,1 so some standard testing techniques and methods for regular R packages don’t directly apply. This chapter covers setting up the testthat’s infrastructure, keyboard shortcuts for commonly used functions, and running tests in RStudio  vs. Positron .\ntestthat is the standard package for testing in R packages and one of the most widely used and supported packages on CRAN. Its widespread adoption is due to its ability to simplify the setup, creation, and execution of unit tests.\nIn our app-package, we’ll use testthat unit tests to ensure the underlying logic (i.e., non-reactive utility functions) behaves correctly. We can extend testthat’s framework for integration tests with Shiny’s testServer() function and system tests with the shinytest2 package. Together, these tools provide a comprehensive testing suite for an app-package.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#sec-tests-suite-use-testthat",
    "href": "test_suite.html#sec-tests-suite-use-testthat",
    "title": "14  Test suite",
    "section": "14.2 Setting up testthat tests",
    "text": "14.2 Setting up testthat tests\nThe testthat package has been around for over a decade and thus has undergone various changes that require us to specify the edition we intend to use (currently, it’s the third):2\n\nusethis::use_testthat(3)\n\nSetting up your testing infrastructure with use_testthat() does the following:\n\nIn the DESCRIPTION file, testthat (&gt;= 3.0.0) is listed under Suggests\nConfig/testthat/edition: 3 is also listed in the DESCRIPTION to specify the testthat edition\nA new tests/ folder is created, with a testthat/ subfolder\nThe tests/testthat/testthat.R file is created\n\nWe now have a tests/ folder to store our testthat tests.\n\ntests/\n  ├── testthat/\n1  └── testthat.R\n\n2 directories, 1 file\n\n\n1\n\nReferred to as the ‘test runner,’ because it runs all our tests (do not edit this file).",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#sec-tests-suite-use-test",
    "href": "test_suite.html#sec-tests-suite-use-test",
    "title": "14  Test suite",
    "section": "14.3 Creating unit tests",
    "text": "14.3 Creating unit tests\n\n\nLaunch app with the shinypak package:\n\nlaunch('10_test-suite')\n\nThe standard workflow for writing testthat unit tests consists of the following:\nNew tests are created with usethis::use_test():\n\nusethis::use_test(\"scatter_plot\") \n\n\ntestthat recommends having a corresponding test file in tests/testthat/ (with the test- prefix) for the files in R/.\n\n\n14.3.1 test- files\nTest files: the IDE will automatically create and open the new test file:\n✔ Writing 'tests/testthat/test-scatter_plot.R'\n• Modify 'tests/testthat/test-scatter_plot.R'\n\n\n14.3.2 test_that() tests\nEach new test file contains a boilerplate test_that() test:\n\n1test_that(desc = \"multiplication works\", code = {\n \n})\n\n\n1\n\ndesc is the test context (supplied in \"quotes\"), and code is the test code (supplied in {curly brackets}).\n\n\n\n\n\n\n14.3.3 expect_ations\nThe expectations typically have two arguments: observed and expected.\n\n1expect_equal(\n2  object = 2 * 2,\n3  expected = 4\n  ) \n\n\n1\n\nA testthat expectation function\n\n\n2\n\nThe output or behavior being tested\n\n\n3\n\nA predefined output or behavior\n\n\n\n\nThe observed object is an artifact of some code we’ve written, and it’s being compared against an expected result.\n\n\n14.3.4 BDD test functions\n\n\n\n\n\n\n Positron Version\n\n\n\n\n\n\nAt the time of this writing, the 2024.09.0-1 pre-release of Positron was available for testing.\n\n\n\n\ntestthat also has two behavior-driven development (BDD) functions for performing tests: describe() and it().\n\n“Use describe() to verify that you implement the right things and use [it()] to ensure you do the things right.” - testthat documentation\n\n\n1describe(\"Description of feature or specification\",\n      code = { \n2    it(\"Functionality under test\",\n3        code = {\n            expect_equal( \n            object = 2 * 2, \n            expected = 4 \n            )\n        })\n    })\n\n\n1\n\ndescribe() the feature or specification\n\n\n2\n\nCapture it() in a test\n\n\n3\n\nWrite expectations\n\n\n\n\nWe’ll cover BDD more in the next chapter, but for now just know that each call to it() behaves like test_that().",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#sec-tests-suite-running-tests",
    "href": "test_suite.html#sec-tests-suite-running-tests",
    "title": "14  Test suite",
    "section": "14.4 Running tests",
    "text": "14.4 Running tests\nAnother devtools habit to adopt is regularly writing and running tests. Below we’ll cover writing and running tests in RStudio  and Positron .\n\n14.4.1 Keyboard shortcuts\nR Packages, 2ed also suggests binding test_active_file() and test_coverage_active_file() to keyboard shortcuts. I highly recommend using a shortcut while developing tests because it will improve your ability to iterate quickly.\n\n\n\n\n\n\ndevtools function\n\n\n \n\n\nKeyboard shortcut\n\n\n\n\n\n\n\n\n\ntest()\n\n\n \n\n\nCtrl/Cmd + Shift + T\n\n\n\n\n\n\n\n\n\ntest_active_file()\n\n\n \n\n\nCtrl/Cmd + T\n\n\n\n\n\n\n\n\n\ntest_coverage_active_file()\n\n\n \n\n\nCtrl/Cmd + Shift + R\n\n\n\n\nFollow these instructions to create a new keyboard shortcut in RStudio . Positron  already includes the devtools::test() shortcut, but the other two (test_active_file() and test_coverage_active_file()) will have to be added manually (see instructions here).\n\n\n14.4.2 Tests in RStudio \nIn RStudio , test_active_file() (or Ctrl/Cmd + T) will test the current test file:\n\n\n\ntest_active_file() or Ctrl/Cmd + T in RStudio\n\n\nThe output will provide feedback on whether the test passes or fails (and occasionally some encouragement).\nWhen we’ve written multiple test files, we can run all the tests in our app-package using the Build pane or the keyboard shortcut (Ctrl/Cmd + Shift + T)\n\n\n\n\n\n\n\n\n\nRun all tests\n\n\n\n\n\n\n\ndevtools::test()\n\n\n\n\n\nRStudio  can be configured to include additional columns, which can be helpful during test development. Below is an example workflow with the R/scatter_plot.R file, it’s accompanying test file, the Build pane, and the Console.\n\n\n\n\n\n\n\nTest workflow in RStudio\n\n\n\n\n14.4.3 Tests in Positron \nIf we click on the Testing sidebar menu item with our test file open, Positron  will display the hierarchy of the describe() and it() functions:\n\n\n\n\n\nTesting icon in Positron sidebar menu\n\n\n\n\n\n\n\n\n\nBDD testing functions in Positron\n\n\nPositron  gives us multiple options for running tests. For running individual tests, we can use the Run Test icons:\n\n\n\n\n\n\n\n\n\nRun Test in Testing sidebar menu item\n\n\n\n\n\n\n\nRun Test in test file\n\n\n\n\n\nWhen testing the active file in Positron , the results are displayed in the Console:\n\n\n\n\n\n\n\ntest_active_file() in Positron\n\n\nTo run all the tests in our app-package, we can use the keyboard shortcut or the Run Tests icon:\n\n\n\n\n\n\n\n\n\nRun Tests in Testing sidebar menu item\n\n\n\n\n\n\n\nRun Tests in test file\n\n\n\n\n\nThe Ctrl/Cmd + Shift + T shortcut will call devtools::test() and display the results in a new R Terminal task:",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#recap",
    "href": "test_suite.html#recap",
    "title": "14  Test suite",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRECAP   \n\n\n\n\n\n\n\ntestthat setup\n\nuse_testthat(): sets up testing infrastructure in your app-package\n\nTest files\n\nuse_test(): creates new test files (with test- prefix). The test file names should generally match the file names be belowR/.\n\nBDD test functions\n\ndescribe(): Feature descriptions and any relevant background information\nit(): Scenarios and test code with expectations (Then statement = functional requirement).\n\nRunning tests\n\ntest_active_file(): runs tests in the current open test file\ntest_coverage_active_file(): test coverage for the current open test file\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_suite.html#footnotes",
    "href": "test_suite.html#footnotes",
    "title": "14  Test suite",
    "section": "",
    "text": "The ‘Reactivity - An overview’ article gives an excellent description (and mental module) of reactive programming.↩︎\nRead more about changes to the third edition to testthat in R Packages, 2ed↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Test suite</span>"
    ]
  },
  {
    "objectID": "test_specs.html",
    "href": "test_specs.html",
    "title": "15  Specifications",
    "section": "",
    "text": "15.1 Application requirements\nThis chapter focuses on what to test–or specifically, how to figure out what to test. This process usually involves converting a list of user needs into testable requirements. The following chapters in this section have examples of tests, but don’t go into depth on how to write tests. Excellent resources exist for writing unit tests in R packages 1 and testing shiny apps. 2 3 The goal of this chapter is to illustrate the connections between the user’s needs, the code below R/, and developing tests.\n(If you’re using devtools, you won’t have to worry about installing testthat and covr)\nInformation about the various tasks and activities an application is expected to perform in typically stored in some kind of software requirements specification (SRS) document.4 The SRS can include things like distinct design characteristics, budgetary, technological, or timeline restrictions, etc. This document breaks down an application’s intended purpose (i.e., the problem it’s designed to solve) into three general areas: user specifications, features, and functional requirements.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#sec-tests-specs-app-reqs",
    "href": "test_specs.html#sec-tests-specs-app-reqs",
    "title": "15  Specifications",
    "section": "",
    "text": "15.1.1 User Specifications\n\n\nLaunch app with the shinypak package:\n\nlaunch('11_tests-specs')\n\nThe user specifications are the goals and objectives stakeholders want to achieve with the application. They use terms like ‘deliver value’ and ‘provide insight’ and provide the basis for deriving the application’s features. 5\n\n\n15.1.2 Features\nFeatures translate the user expectations into an application capabilities. Generally speaking, features capture the tasks and activities user should “be able to” accomplish with the application (i.e., explore data with a graph).\n\n\n15.1.3 Functional Requirements\nFunctional requirements are written for developers and provide the technical details on each feature. A single feature often gives rise to multiple functional requirements (these are where users needs come into direct contact with code)6\n\nIn summary\nThe areas above help direct the development process, albeit from slightly different perspectives.\n\nThe user specifications capture the needs and expectations of the end-user.\nThe features describe the high-level capabilities of the application.\nFunctional requirements are the testable, specific actions, inputs, and outputs.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#application-developemnt",
    "href": "test_specs.html#application-developemnt",
    "title": "15  Specifications",
    "section": "15.2 Application developemnt",
    "text": "15.2 Application developemnt\nThe Shiny application development process follows something like the figure below:\n\n\n\nGeneral application development process\n\n\nThe figure above is an oversimplification, but it highlights a common separation (or ‘hand-off’) between users/stakeholders and developers. In the sections below, we’ll look at two common development processes: test-driven and behavior-driven development.\n\nTest-driven development\nIf sap was built using test-driven development (TDD), the process might look something like this:\n\nGather user needs and translate into application features:\n\nDocument the application’s capabilities for exploring movie review variables from IMDB and Rotten Tomatoes.\nInclude feature descriptions for displaying continuous variables (i.e., ‘critics score’ and ‘audience score’) categorical variables (i.e., ‘MPAA’ ), graph visual attributes (size, color, opacity), and an optional plot title.\n\nWrite Tests:\n\nWrite tests to ensure the graph displays relationships between a set of continuous and categorical variables when the app launches.\n\nRun Tests:\n\nBefore writing any code, these tests will fail.\n\nDevelop Features:\n\nWrite UI, server, module, and utility functions for user inputs and graph outputs.\n\nRerun Tests:\n\nIf the graph has been correctly implemented in the application, the tests should pass.\n\nWrite more Tests:\n\nAdd more tests for additional functionalities (e.g., an option to remove missing values from graph).\n\n\nStarting with tests and writing just enough code to get them to pass often results in developing less (but better) code. The drawback to this approach is a strict focus on the function being tested and not the overall objective of the application.\n\n\nBehavior-driven development\nIn behavior-driven development (BDD) (or behavior-driven testing), users and developers work together to understand, define and express application behaviors in non-technical language, 7\n\n“Using conversation and examples to specify how you expect a system to behave is a core part of BDD” - BDD in Action, 2ed\n\nPlacing an emphasis on writing human-readable expectations for the application’s behaviors makes it easier to develop tests that can focus on verifying each user need exists (and is functioning properly). In BDD, the application’s expected capabilities are captured in Features and illustrated with concrete examples, or Scenarios.\n\nFeature\nIn BDD, a Feature describes an implemented behavior or capability in the application, from a user’s perspective. Typically, these are written in the Gherkin format using specific keywords:8\n\nAs a ...\n\nI want ...\n\nSo that ...\n\nBelow is an example Gherkin Feature for the graph in launch_app():\nFeature: Visualization\n    As a user\n    I want to see the changes in the plot\n    So that I can visualize the impact of my customizations\nAs you can see, the feature uses plain language and the wording is user-centric, so it remains accessible to both developers and users (or other non-technical stakeholders).\n\n\nScenario\nA Gherkin Scenario provides a concrete example of how the Feature works and has the following general format:\n\nGiven ...\n\nWhen ...\n\nThen ...\n\nAn example Scenario for launch_app() might be:\n  Scenario: Viewing the Data Visualization\n    Given I have launched the application\n    And it contains movie review data from IMDB and Rotten Tomatoes\n    And the data contains variables like 'Critics Score' and 'MPAA'\n    When I interact with the controls in the sidebar panel\n    Then the graph should update with the selected options\n\n\nBackground\nInstead of repeating any pre-conditions in each Scenario (i.e., the steps contained in the “Given” and first “And” statement), we can establish the context with a Background:\n  Background: Launching the application\n    Given I have launched the application\n    And it loads with movie review data from IMDB and Rotten Tomatoes\n    \n  Scenario: Viewing the Data Visualization\n    Given the data contains variables like 'Critics Score' and 'MPAA'\n    When I interact with the controls in the sidebar panel\n    Then the graph should update with the selected options\nAdopting the Gherkin format (or something similar) provides a common language to express an application’s behavior:\n\nAs developers, we can work with users and shareholders to write specifications that describe the expected behavior of each Feature\nWhen developing tests, we can group the tests by their Feature and Scenarios\nEach test can execute a step (i.e., the Then statements).\n\nIn the next section we’ll cover how to map test code for each Scenario step with testthat.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#sec-tests-specs-bdd-testthat",
    "href": "test_specs.html#sec-tests-specs-bdd-testthat",
    "title": "15  Specifications",
    "section": "15.3 BDD and testthat",
    "text": "15.3 BDD and testthat\ntestthat’s BDD functions (describe() and it()) allow us add Gherkin-style features and scenarios to our test files, ensuring the application remains user-centric while meeting the technical specifications.9\n\n15.3.1 Describe the feature\nWe can use the language from our Feature, Background, and Scenario to in the description in the argument of describe():\n\ntestthat::describe(\n  description = \"Feature: Visualization\n                   As a user\n                   I want to see the changes in the plot\n                   So that I can visualize the impact of my customizations\",\n  code = {\n  \n})\n\nWe can also nest describe() calls, which means we can include the Background (or other relevant information):\n\n1describe(\n  \"Feature: Visualization\n      As a user\n      I want to see the changes in the graph\n      So that I can visualize the impact of my customizations.\", \n  code = {\n    \n2  describe(\n    \"Background: Launching the application\n        Given I have launched the application\n        And it loads with movie review data from IMDB and Rotten Tomatoes\", \n    code = {   \n               \n      })\n    \n  })\n\n\n1\n\nBDD Feature (title and description)\n\n\n2\n\nBackground (preexisting conditions before each scenario)\n\n\n\n\n\n\n15.3.2 Confirm it with a test\nInside describe(), we can include multiple it() blocks which “functions as a test and is evaluated in its own environment.”\nIn the example below, we’ll use an it() block to test the example scenario from above:10\n\n1testthat::describe(\n  \"Feature: Visualization\n      As a user\n      I want to see the changes in the graph\n      So that I can visualize the impact of my customizations.\", \n  code = {\n  \n2  testthat::describe(\n    \"Background: Launching the application\n        Given I have launched the application\n        And it loads with movie review data from IMDB and Rotten Tomatoes\",\n      code = {\n      \n3    testthat::it(\n      \"Scenario: Viewing the Data Visualization\n         Given the data contains variables like 'Critics Score' and 'MPAA'\n         When I interact with the controls in the sidebar panel\n         Then the graph should update with the selected options\",\n        code = {\n4          # test code\n        })\n      \n    })\n  \n})\n\n\n1\n\nBDD Feature (title and description)\n\n\n2\n\nBackground (preexisting conditions before each scenario)\n\n3\n\nScenario (a concrete examples that illustrates a feature)\n\n4\n\nTest code\n\n\n\n\nIn the scenario above, Then contains the information required for the testthat expectation. This could be expect_snapshot_file() or vdiffr::expect_doppelganger()–whichever makes sense from the user’s perspective.\nThese are generic examples, but hopefully the tests in the upcoming chapters convey how helpful and expressive BDD functions can be (or they inspire you to properly implement what I’m attempting to do in your own app-packages).11",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#sec-tests-specs-traceability-matrix",
    "href": "test_specs.html#sec-tests-specs-traceability-matrix",
    "title": "15  Specifications",
    "section": "15.4 Traceability Matrix",
    "text": "15.4 Traceability Matrix\nAfter translating the user needs into functional requirements, we can identify what needs to be tested by building a look-up table (i.e., a matrix).\nI like to store early drafts of the requirements and traceability matrix in a vignette:12\n\nusethis::use_vignette(\"specs\")\n\nAdding our first vignette to the vignettes/ folder does the following:\n\nAdds the knitr and rmarkdown packages to the Suggests field in DESCRIPTION13\n\nSuggests: \n    knitr,\n    rmarkdown\n\nAdds knitr to the VignetteBuilder field14\n\nVignetteBuilder: knitr\n\nAdds inst/doc to .gitignore and *.html, *.R to vignettes/.gitignore\n\nThe first column in the traceability matrix contains the user specifications, which we can ‘trace’ over to the functional requirements and their relevant tests.15\n\n\nTraceability Matrix\n\n\n\n\n\n\n\n\nSpecifications\nFeatures\nRequirements\nTest\n\n\n\n\nS1: The application should source movie review data from platforms like IMDB or Rotten Tomatoes\nF1.1:\nFeature: Movie Review Dataset Variables\nAs a user\nI want to have a dataset with variables from IMDB and Rotten Tomatoes\nIn order to provide comprehensive movie reviews\nBackground:\nGiven the application has access to IMDB and Rotten Tomatoes APIs\nScenario: Movie Review Continuous and Categorical Variables\nWhen the application loads from IMDB and Rotten Tomatoes movie review data\nThen the dataset should include a continuous critic ratings variable\nAnd the dataset should include a continuous audience ratings variable\nAnd the dataset should include a categorical mpaa ratings variable\nAnd the dataset should include a categorical genres variable\n\n\n\n\n\nBuilding a traceability matrix ensures:\n\nAll user specifications have accompanying application features.\nEach feature has been broken down into precise, measurable, and testable functional requirements.\nTests have been written for each functional requirement.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#recap",
    "href": "test_specs.html#recap",
    "title": "15  Specifications",
    "section": "Recap",
    "text": "Recap\n\n\nLaunch app with the shinypak package:\n\nlaunch('11_tests-specs')\n\nUnderstanding the relationship between user specifications, features, and functional requirements gives us the information we need to build applications that satisfy the technical standards while addressing user needs. Documenting requirements in Gherkin-style features and scenarios allows us to capture the application’s behavior without giving details on how the functionality is implemented.\nIn the next chapter, we’re going to cover various tools to improve the tests in your app-package. The overarching goal of these tools is to reduce code executed outside of your tests (i.e., placed above the call to test_that() or it()).\n\n\n\n\n\n\nRecap: Test Specifications\n\n\n\n\n\n\n\nSpecifications\n\nScoping tests: user specifications outline software goals and needs, and the functional requirements provide the technical details to achieve them.\n\nUser specifications: descriptions of what a user expects the application to do (i.e., the user ‘wish list’ of features they want in the application).\nFeatures: detailed list of the main capabilities and functions the application needs to offer to users.\nFunctional requierments: testable, specific step-by-step instructions for ensuring the application does what it’s supposed to do.\nTraceability matrix: tracking tool for connecting the users ‘wish list’ (i.e, specifications) to what’s being tested.\n\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_specs.html#footnotes",
    "href": "test_specs.html#footnotes",
    "title": "15  Specifications",
    "section": "",
    "text": "Unit tests are covered extensively in R Packages, 2ed and the testthat documentation↩︎\nMastering shiny dedicates an entire Chapter to Testing.) shinytest2 also has excellent documentation (and videos), and I highly recommend reading through those resources.↩︎\nI will cover a few tips and tricks I’ve learned for testing module server functions with testServer() because they’re not in the documentation.↩︎\nRead more about what goes in the Software Requirements Specification↩︎\nUser Specifications are sometimes referred to as “user stories,” “use cases,” or “general requirements”↩︎\n‘Features’ and ‘functional requirements’ are sometimes used interchangeably, but they refer to different aspects of the application. Features are high-level capabilities an application should have, and often contain a collection of smaller functionalities (broken down into the specific functional requirements).↩︎\nRead more about behavior-driven development↩︎\nGherkin is the domain-specific language format used for expressing software behaviors. Tools like Cucumber or SpecFlow maps and executes the Gherkin descriptions against the code to generate a pass/fail report status for each requirement.↩︎\nRead more about describe() and it() in the testthat documentation. and in the appendix.↩︎\nEach it() block contains the expectations (or what you would traditionally include in test_that()).↩︎\nFor an excellent description on the relationships between behavior-driven development, test-driven development, and domain-driven design, I highly recommend BDD in Action, 2ed by John Ferguson Smart and Jan Molack.↩︎\nStoring the traceability matrix in a vignette is great for developers, but using an issue-tracking system with version control is also a good idea, like GitHub Projects or Azure DevOps.↩︎\nWe briefly covered the Suggests field in Dependencies, but in this case it specifically applies to “packages that are not necessarily needed. This includes packages used only in examples, tests or vignettes…” - Writing R Extensions, Package Dependencies↩︎\nThe documentation on VignetteBuilder gives a great example of why knitr and rmarkdown belong in Suggests and not Imports.↩︎\nWhen building tables in vignettes, I highly recommend using the Visual Markdown mode.↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Specifications</span>"
    ]
  },
  {
    "objectID": "test_tools.html",
    "href": "test_tools.html",
    "title": "16  Test tools",
    "section": "",
    "text": "16.1 Test fixtures\nThis chapter introduces tools to help write clean and efficient tests. These files, folders and methods can be included in our app-package test suite and are thoroughly described in R Packages, 2ed and the testthat documentation, but within the context of a standard R package. The sections below contain examples of each tool implemented in our example app-package.1\nOne of the recent updates to the testthat package (version 3.2.0) emphasizes limiting code that exists outside of our tests.2\nStrategies for reducing or removing the code outside of test_that() tests include:3\nCode outside of test_that() usually serves a specific purpose (load or manipulate data, set options, create folders or files, etc). The topics in this chapter will demonstrate how to include these behaviors in our tests without placing code outside of the test scope.4\nTest fixtures can be anything used to create repeatable test conditions (data, file paths, functions, etc.). Good test fixtures provide a consistent, well-defined test environment, and then are removed/destroyed when the test is executed. This ensures any changes made during the test don’t persist or interfere with future tests.5\nIn R packages, test fixtures are stored in the tests/testthat/fixtures/ folder:6\ntests/\n├── testthat/\n│   └── fixtures/                                         \n└── testthat.R",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#sec-test-fixtures",
    "href": "test_tools.html#sec-test-fixtures",
    "title": "16  Test tools",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('12.1_tests-fixtures')\n\n\n\n\n16.1.1 Test data\nLarge static data files are an example of a test fixture.7 Any code used to create test data should be stored with the output file (using a clear naming convention).\nFor example, I’ve stored the code used to create a ‘tidy’ version of the ggplot2movies::movies data along with the output dataset in tests/testthat/fixtures/:\n\ntests\n├── testthat\n│   ├── fixtures\n1│   │   ├── make-tidy_ggp2_movies\n2│   │   └── tidy_ggp2_movies.rds\n│   └── test-scatter_plot.R\n└── testthat.R\n\n3 directories, 4 files\n\n\n1\n\nThe code used to create the test data (make-make_tidy_ggp2_movies.R)\n\n2\n\nThe test data file (i.e., tidy_ggp2_movies.rds):\n\n\n\n\nData files stored in tests/testthat/fixtures/ can be accessed with testthat::test_path() inside each test.\n\n\n16.1.2 Example test fixture\nBelow is a test for the scatter_plot() utility function that answers the question, ‘does the plot generate without producing an error?’ using the tidy_ggp2_movies.rds test fixture.\nThis type of test appropriate because we want to confirm the data source will generate a plot object when passed to our graphing utility function, not necessarily to verify the specific contents of the graph.8\n\n1describe(\n  \"Feature: Scatter plot data visualization\n     As a film data analyst\n     I want to explore IMDB.com movie review data \n     So that I can examine relationships between movie reivew metrics\n   Background:\n     Given I have IMDB movie reviews data  \n     And the data contains continuous variables like 'rating'\n     And the data contains categorical variables like 'mpaa'\", \n     code = {\n2    it(\n      \"Scenario: Scatter plot initial x, y, color values \n         When I launch the Scatter Plot Data Visualization\n         And I have a IMDB dataset of movie reviews \n         Then the plot should show 'Rating' on the x-axis\n         And the plot should show 'Length' on the y-axis\n         And the points on the plot should be colored by 'MPAA' rating\", \n        code = {\n3    ggp2_scatter_inputs &lt;- list(\n          x = \"rating\",\n          y = \"length\",\n          z = \"mpaa\",\n          alpha = 0.75,\n          size = 3,\n          plot_title = \"Enter plot title\"\n        )\n4    tidy_ggp2_movies &lt;- readRDS(test_path(\"fixtures\",\n                                \"tidy_ggp2_movies.rds\"))\n5    app_graph &lt;- scatter_plot(tidy_ggp2_movies,\n      x_var = ggp2_scatter_inputs$x,\n      y_var = ggp2_scatter_inputs$y,\n      col_var = ggp2_scatter_inputs$z,\n      alpha_var = ggp2_scatter_inputs$alpha,\n      size_var = ggp2_scatter_inputs$size\n    )\n6    expect_true(ggplot2::is.ggplot(app_graph))\n  }) \n\n})\n\n\n1\n\nFeature\n\n\n2\n\nScenario\n\n\n3\n\nTest inputs\n\n\n4\n\nTest fixture\n\n\n5\n\nCreate observed object\n\n\n6\n\nExpectation\n\n\n\n\nIf the tidy_ggp2_movies.rds file in the tests/testthat/fixtures/ folder are going to be used repeatedly, it might make sense to store the data in inst/extdata/ or data-raw/. Test fixtures are described in-depth in R Packages, 2ed and in the testthat documentation.\n\nTests in RStudio Tests in Positron",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#sec-test-helpers",
    "href": "test_tools.html#sec-test-helpers",
    "title": "16  Test tools",
    "section": "16.2 Test helpers",
    "text": "16.2 Test helpers\n\n\n“Helper files are a mighty weapon in the battle to eliminate code floating around at the top-level of test files.” Testthat helper files, R Packages, 2ed\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('12.2_tests-helpers')\n\nTest helpers reduce repeated/duplicated test code. In general, objects or values that aren’t large enough to justify storing as static test fixtures can be created with helper functions. Helper functions are stored in tests/testthat/helper.R, which is automatically loaded with devtools::load_all():\n\ntests/\n  ├── testthat/\n1  │   ├── fixtures/\n  │   │   ├── make-tidy_ggp2_movies.R\n  │   │   └── tidy_ggp2_movies.rds\n2  │   ├── helper.R\n3  │   └── test-scatter_plot.R\n  └── testthat.R\n\n\n1\n\nTest fixture scripts and .rds files\n\n\n2\n\nHelper functions\n\n\n3\n\nTest file\n\n\n\n\nTest helpers should only be created if they make testing easier when the tests fail. The article, ‘Why Good Developers Write Bad Unit Tests’, provides great advice on complexity vs. clarity when writing unit tests,\n\n‘think about what will make the problem obvious when a test fails. Refactoring may reduce duplication, but it also increases complexity and potentially obscures information when things break.’\n\nR programmers resist copy + paste programming, and in most cases this makes sense. After all, R is a functional programming language, so it’s tempting to bundle any repeated code into a function and store it in the tests/testthat/helper.R file.\nHowever, when we’re writing tests, it’s more important that tests are easy to read and understand when they fail.\nFor example, consider the ggp2_scatter_inputs inputs passed to the scatter_plot() function in the previous test:\n\nggp2_scatter_inputs &lt;- list(  \n        x = \"rating\",\n        y = \"length\",\n        z = \"mpaa\",\n        alpha = 0.75,\n        size = 3,\n        plot_title = \"Enter plot title\"\n)            \n\nWe could write a var_inputs() function that stores these values in a list. In our tests, this would allow us to use var_inputs() with the same ‘reactive syntax’ we use with scatter_plot() in the module server function:\n\nvar_inputs &lt;- function() {\n   list(x = \"rating\",\n        y = \"length\",\n        z = \"mpaa\",\n        alpha = 0.75,\n        size = 3,\n        plot_title = \"Enter plot title\")\n}\nvar_inputs()\n## $x\n## [1] \"rating\"\n## \n## $y\n## [1] \"length\"\n## \n## $z\n## [1] \"mpaa\"\n## \n## $alpha\n## [1] 0.75\n## \n## $size\n## [1] 3\n## \n## $plot_title\n## [1] \"Enter plot title\"\n\nWhile this removes duplicated code, it also makes it less clear for the reader what var_inputs() contains and where it was created (without opening the helper.R file).\n\n1tidy_ggp2_movies &lt;- readRDS(test_path(\"fixtures\",\n                                \"tidy_ggp2_movies.rds\"))\n  \napp_graph &lt;- scatter_plot(\n  tidy_ggp2_movies,\n2  x_var = var_inputs()$x,\n  y_var = var_inputs()$y,\n  col_var = var_inputs()$z,\n  alpha_var = var_inputs()$alpha,\n  size_var = var_inputs()$size)\n\ntestthat::expect_true(ggplot2::is.ggplot(app_graph))\n\n\n1\n\nLoad test fixture\n\n\n2\n\nIdentical to the code in mod_scatter_display_server()\n\n\n\n\nIn contrast, the make_ggp2_inputs() function below creates inputs for the scatter_plot() utility function:\n\nmake_ggp2_inputs &lt;- function() {\n  glue::glue_collapse(\"list(x = 'rating',\n     y = 'length',\n     z = 'mpaa',\n     alpha = 0.75,\n     size = 3,\n     plot_title = 'Enter plot title'\n     )\"\n  )\n}\n\nI can call make_ggp2_inputs() in the Console and it will return the list of values to paste into each test:\n\nmake_ggp2_inputs()\nlist(y = 'audience_score', \n     x = 'imdb_rating',\n     z = 'mpaa_rating',\n     alpha = 0.5,\n     size = 2,\n     plot_title = 'Enter plot title'\n    )\n\nThis reduces the number of keystrokes per test, but doesn’t obscure the source of the values in the test.\nglue::glue_collapse() is your friend when you want to quickly reproduce code for your tests. make_var_inputs() creates the list of inputs for testing the original movies data:\n\nmake_var_inputs &lt;- function() {\n  glue::glue_collapse(\"list(y = 'audience_score', \n     x = 'imdb_rating',\n     z = 'mpaa_rating',\n     alpha = 0.5,\n     size = 2,\n     plot_title = 'Enter plot title'\n    )\")\n}\n\n\n\n\n\n\n\nViolating the DRY principle\n\n\n\n\n\n\nIf you have repeated code in your tests, consider the following questions below before creating a helper function:\n\nDoes the code help explain what behavior is being tested?\nWould a helper make it harder to debug the test when it fails?\n\nIt’s more important that test code is obvious than DRY, because it’s more likely you’ll be dealing with this test when it fails (and you’re not likely to remember why all the top-level code is there).\n\n\n\n\n\n16.2.1 Test logger\nI prefer test outputs to be verbose, so I usually create a test_logger() helper function that allows me to give more context and information with each test:\n\n# test logger helper\ntest_logger &lt;- function(start = NULL, end = NULL, msg) {\n  if (is.null(start) & is.null(end)) {\n    cat(\"\\n\")\n    logger::log_info(\"{msg}\")\n  } else if (!is.null(start) & is.null(end)) {\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n  } else if (is.null(start) & !is.null(end)) {\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n  } else {\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n  }\n}\n\ntest_logger() can be used to ‘log’ the start and end of each test, and it includes a message argument (msg) I’ll use to reference the test description argument in each it() call.9\nI tend to use functions like test_logger() enough to justify placing them in a testing utility file (R/testthat.R) below R/. Including testing functions in the R/ folder also ensures they’re documented (and any dependencies become part of your app-package).10\n\n\n16.2.2 Test development\nWhile developing, using keyboard shortcuts makes it easier to iterate between building fixtures, writing and running tests, and checking code coverage.\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + T\n\n\n\n\n\n\n\ndevtools:::test_active_file()\n FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-10-27 12:39:23] [ START fixture = tidy_ggp2_movies.rds]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nINFO [2023-10-27 12:39:23] [ START fixture = tidy_ggp2_movies.rds]\n\nINFO [2023-10-27 12:39:23] [ START data = movies.rda]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\nINFO [2023-10-27 12:39:23] [ END data = movies.rda]\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + R\n\n\n\n\n\n\n\n\ndevtools:::test_coverage_active_file()\n\n\n\n\n\n\n\n\nTest coverage on active file",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#sec-test-snapshots",
    "href": "test_tools.html#sec-test-snapshots",
    "title": "16  Test tools",
    "section": "16.3 Test snapshots",
    "text": "16.3 Test snapshots\n\n\nLaunch app with the shinypak package:\n\nlaunch('12.3_tests-snapshots')\n\nWriting tests for UI outputs can be difficult because their “correctness” is somewhat subjective and requires human judgment. If the expected output we’re interesting in testing is cumbersome to describe programmatically, we can consider using a snapshot tests. Examples of this include UI elements (which are mostly HTML created by Shiny’s UI layout and input/output functions) and data visualizations.11\n\n\n\n\n\n\nMocking\n\n\n\n\n\n\nTest mocks are covered in Appendix E, but the example isn’t from our app-package (it comes from the package development masterclass given at posit::conf(2023)).\n\n\n\n\nI’ve included a small UI function (text_logo()) in the R/ folder of sap:\n\n\nshow/hide text_logo()\n#' Create a Text-based Logo in HTML\n#'\n#' `text_logo()` generates a text-based logo enclosed within HTML tags, allowing\n#' for the specification of the heading size (h1 through h6). The logo features\n#' a stylized representation of a face within arrows, using ASCII characters.\n#'\n#' @param size A character string specifying the heading size for the logo. \n#' Valid options include \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", and \"h6\". \n#' Defaults to \"h3\".\n#'\n#' @return An HTML object containing the logo. This object can be directly used\n#' in R Markdown documents or Shiny applications to render the logo in a web page.\n#'\n#' @examples\n#' # Generate a logo with default size h3\n#' text_logo()\n#'\n#' # Generate a logo with size h1\n#' text_logo(size = \"h1\")\n#'\n#'\n#' @export\ntext_logo &lt;- function(size = 'h3') {\n  if (any(size %in% c(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"))) {\n  htmltools::HTML(\n    paste0(\n    \"&lt;span&gt;\\n\", \n      paste0(\"  &lt;\", size, \"&gt;\", collapse = \"\"), \"\\n\",\n      \"    &lt;code&gt;√\\\\/--‹(•_•)›--√\\\\/&lt;/code&gt;\\n\", \n      paste0(\"  &lt;\", size, \"/&gt;\", collapse = \"\"), \"\\n\",\n    \"&lt;/span&gt;\\n\"\n      )\n    )\n  } else {\n    rlang::abort(paste(size, \"isnt supported\", sep = \" \"))\n  }\n}\n\n\nThis function generates the HTML so we can include a small logo in the UI.12\n\n\n\n\n\n\nThe output in the UI:\n\n\ntext_logo()\n\n\n\n\nThe pre-rendered HTML:\n\n\n&lt;span&gt;\n  &lt;h3&gt;\n    &lt;code&gt;√\\/--‹(•_•)›--√\\/&lt;/code&gt;\n  &lt;/h3&gt;\n&lt;/span&gt;\n\n\n\nReviewing the entire HTML contents of movies_ui() to see if text_logo() is working isn’t practical, but we can store it’s results in a snapshot file using expect_snapshot(). In tests/testthat/test-text_logo.R, I’ll write the following tests:13\n\n\n\n\n\n\nWarning: snapshots and multiple line descriptions\n\n\n\n\n\n\nIt’s important to include any multiple-line text in the describe() block when creating snapshots with expect_snapshot(). Multiline text in the desc of test_that() will always overwrite the snapshot file.\nThank you to @LDSamson for bringing this to my attention!\nSee this issue for more information.\n\n\n\n\n\nConfirm the default size argument:\n\ndescribe(\n    \"Scenario: Generating a logo with default size\n    Given the user did not specify a [size] in text_logo()\n    When text_logo() is invoked without a [size] argument\n    Then the correct HTML for a ['h3'] text logo is returned\",\n    code = {\n\n    test_that(\"text_logo()\", code = {\n      test_logger(start = \"snap\", msg = \"text_logo()\")\n      expect_snapshot(text_logo())\n      test_logger(end = \"snap\", msg = \"text_logo()\")\n    })\n  })\n\nConfirm a new size argument:\n\n  describe(\n    \"Scenario: Generating a logo of a specified size\n    Given the user wants a ['h1'] sized text logo\n    When text_logo(size = 'h1') is invoked \n    Then the correct HTML for a ['h1'] text logo is returned\", \n    code = {\n\n    test_that(\"text_logo('h1')\", code = {\n      test_logger(start = \"snap\", msg = \"text_logo('})')\")\n      expect_snapshot(text_logo(\"h1\"))\n      test_logger(start = \"snap\", msg = \"text_logo('h1')\")\n    })  \n  })\n\nConfirm an invalid size argument:\n\ndescribe(\n  \"Scenario: Attempting to generate a logo with an invalid size\n  Given the user specifies an invalid [size] for the text logo\n  When text_logo() is invoked with an invalid [size] argument\n  Then an error is returned stating the [size] is not recognized\", \n  code = {\n  test_that(\"text_logo('invalid')\", code = {\n    test_logger(start = \"snap\", msg = \"text_logo('invalid')\")\n    expect_error(text_logo(\"massive\"), NULL)\n    test_logger(end = \"snap\", msg = \"text_logo('invalid')\")\n    })\n  })\n\n\nWhen I test this file, I see the following results and output from test_logger() along with two warnings about the creating of the snapshot files:\n\ndevtools:::test_active_file()\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-11-17 08:50:55] [ START snap = text_logo()]\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 1 ]\nINFO [2023-11-17 08:50:55] [ END snap = text_logo()]\n\nINFO [2023-11-17 08:50:55] [ START snap = text_logo('h1')]\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 2 ]\nINFO [2023-11-17 08:50:55] [ START snap = text_logo('h1')]\n\nINFO [2023-11-17 08:50:55] [ START snap = text_logo('invalid')]\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 3 ]\nINFO [2023-11-17 08:50:55] [ END snap = text_logo('invalid')]\n── Warning (test-text_logo.R:13:7): text_logo() ──\nAdding new snapshot:\nCode\n  text_logo()\nOutput\n  &lt;span&gt;\n    &lt;h3&gt;\n      &lt;code&gt;√\\/--‹(•_•)›--√\\/&lt;/code&gt;\n    &lt;/h3&gt;\n  &lt;/span&gt;\n\n── Warning (test-text_logo.R:22:7): text_logo('h1') ──\nAdding new snapshot:\nCode\n  text_logo(\"h1\")\nOutput\n  &lt;span&gt;\n    &lt;h1&gt;\n      &lt;code&gt;√\\/-‹(•_•)›-√\\/&lt;/code&gt;\n    &lt;/h1&gt;\n  &lt;/span&gt;\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 3 ]\n\n16.3.1 Reviewing _snaps/\nSnapshots are stored in the tests/testthat/_snaps/ folder. The output from expect_snapshot_file() is a markdown file with contents similar to what we saw above in the warning message. Should the markdown file contents change in future test runs, the tests will fail and we’ll be prompted to review the changes. 14\nFor example, if the &lt;span&gt; changed to a &lt;div&gt; in text_logo() and caused a test failure, I could review the changes in tests/testthat/_snaps/text_logo.md with testthat::snapshot_review('text_logo'):\n\n\n\n\n\n\n\n\n\n(a) testthat::snapshot_review('text_logo')\n\n\n\n\n\nFigure 16.1: Click Accept: Accepting snapshot: 'tests/testthat/_snaps/text_logo.md'\n\n\n\nFor examples of snapshot tests for graphical outputs, review the examples in Appendix E.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#recap",
    "href": "test_tools.html#recap",
    "title": "16  Test tools",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: Test tools\n\n\n\n\n\n\n\nTest tools\n\nIn this chapter, we’ve covered powerful testing tools provided by the testthat package. Let’s briefly recep what we’ve learned:\n\nTest Fixtures: We’ve seen how test fixtures are reliable for setting up a consistent testing environment. Using fixtures to load test data ensures that each test runs under uniform conditions. This approach enhances our tests’ reliability and simplifies the testing process by abstracting standard setup and teardown tasks.\n\nFixtures prepare the test environment and the initial state. The tidy_ggp2_movies.rds data is a test fixture, and it creates the tidy_ggp2_movies data within the test scope.\n\nTest Helpers: Helpers allow us to encapsulate repetitive tasks or setup configurations, making our tests cleaner, more readable, and easier to maintain. Whether it’s a custom function to create mock Shiny sessions or a utility for simulating user input, helpers streamline the testing workflow significantly.\n\nIf find yourself writing small, reusable pieces of code to perform specific tasks inside your tests, consider converting them into a function in tests/testthat/helper.R.\n\nTest Snapshots: Snapshot testing introduces the tests/testthat/_snaps folder for capturing and comparing the Shiny application state over time. Snapshot testing helps ensure that changes to the application do not unintentionally alter its behavior or appearance, and snapshot files allow us to quickly identify and address regressions by automatically detecting differences between the expected and actual snapshots.\n\nTest complex outputs using snapshots, but cautiously. Snapshots are susceptibile to failure with small (sometimes inconsequential) changes, which produce false negatives test failures.\n\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_tools.html#footnotes",
    "href": "test_tools.html#footnotes",
    "title": "16  Test tools",
    "section": "",
    "text": "The three chapters in R Packages, 2ed, dedicated to testing are Testing basics, Designing your test suite, and Advanced testing techniques↩︎\nRead a summary of the changes to the testthat package on the tidyverse blog↩︎\nthese tips (and more!) were covered in the Package Development Masterclass delivered at posit::conf(2023)↩︎\nRead more about BDD functions in the appendix.↩︎\nFor a concrete example, see this article on self-cleaning tests.↩︎\nThe name ‘fixtures’ isn’t required (you can name this folder anything).↩︎\nCreating a tidied version of ggplot2movies::movies would be costly to re-create with every test, so it’s advised to store it as an static test fixture.↩︎\nSnapshot tests would be more appropriate for answering the question, ‘is the plot visually correct?’.↩︎\nIf you like verbose logging outputs, check out the logger package↩︎\nPlacing common files for testing below R/ is covered in R Packages, 2ed↩︎\nGraph snapshots are covered in Section E.1.↩︎\nThis is a simple example, but I chose it because it needs some tricky escape characters to work.↩︎\nMastering Shiny covers creatng a snapshot file to test UI elements, but also notes this is probably not the best approach.↩︎\nWe’ll encounter this folder again in the Chapter 18 on system tests with shinytest2.↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Test tools</span>"
    ]
  },
  {
    "objectID": "test_modules.html",
    "href": "test_modules.html",
    "title": "17  Testing modules",
    "section": "",
    "text": "17.1 Integration tests\nIn the previous chapters we covered adding test fixtures and helpers to our test suite. In this chapter, we’re going briefly discuss some tips for testing modules with testServer()–specifically, how to verify modules are transferring values correctly.\nIntegration tests verify that functions and components work together, and often involves instantiating multiple objects to interact with each other in a single test.\nWe can combine the BDD functions with testServer() to test reactive interactions between modules. For example, to confirm that the drop-down feature requirement is working (i.e., that user-inputs are updating in the application), we need to test two changes:\nThe feature, background, and scenario for the changes in mod_var_input_server() are provided below:\ndescribe(\n  \"Feature: Scatter Plot Configuration in Movie Review Application\n      As a user \n      I want the initial graph pre-configured with variables and aesthetics,\n      So that I can change the inputs and see a meaningful visualization.\", \n  code = {\n  \n  describe(\n    \"Background: Initial scatter plot x, y, color values \n         Given the movie review application is loaded\n         And the scatter plot initial x-axis value is [IMDB Rating] \n         And the scatter plot initial y-axis value is [Audience Score]\n         And the scatter plot initial color value is [MPAA Rating]\n         And the initial opacity of the points is set to [0.5]\n         And the initial size of the points is set to [2]\n         And the initial plot title is set to [Enter plot title]\", code = {\n           \n  it(\"Scenario: Changing scatter plot x, y, color values\n       Given the movie review application is loaded\n       When I choose the [Critics Score] variable for the x-axis\n       And I choose the [Runtime] variable for the y-axis\n       And I choose the [Title type] variable for color\n       Then the scatter plot should show [Critics score] on the x-axis\n       And the scatter plot should show [Runtime] on the y-axis\n       And the points on the scatter plot should be colored by [Title type]\n       And the opacity of the points should be set to [0.5]\n       And the size of the points should be set to [2]\n       And the plot title should be [Enter plot title]\", code = {\n         \n         shiny::testServer(app = mod_var_input_server, expr = {\n            \n           # test code ----- \n           \n         })  \n       })\n    })\n})",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#integration-tests",
    "href": "test_modules.html#integration-tests",
    "title": "17  Testing modules",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('13_tests-modules')\n\n\n\nValues passed to the UI are returned from mod_var_input_server()\n\nThe reactive values returned from mod_var_input_server() are passed into mod_scatter_display_server() and available as the reactive object inputs()\n\n\n\n\n\n\n\nBDD refresher: features & scenarios\n\n\n\n\n\n\nIn BDD, requirements are written plain language ‘feature files’ using a series of keywords:\n\n1Feature:\n  As a\n  I want\n  So that\n  \n2  Background:\n3    Given\n    And\n    \n4  Scenario:\n5    When\n6    And\n7    Then\n\n\n1\n\nHigh-level description (title and description)\n\n\n2\n\nSteps or conditions that exist before each scenario\n\n\n3\n\nUsed to describe the initial context or preconditions for the scenario\n\n\n4\n\nA series of steps outlining a concrete examples that illustrates a feature\n\n\n5\n\nUsed to describe an event, or an action\n\n\n6\n\nUse to combine Given, When, or Then\n\n\n7\n\nUse to verify expected outcomes that are observable by a user\n\n\n\n\nFeature and Background information can be included in nested describe() blocks, but every Scenario (i.e., Then) keyword should have a corresponding it() or test_that() call.\nRead more about Gherkin on the Cucumber website..\n\n\n\n\n\n\n\n17.1.1 Testing return values\nInside testServer(), we can create a list of initial graph inputs for mod_var_input_server(), then pass identical values to session$setInputs(), and confirm the returned object with session$returned():1\n\n1    shiny::testServer(app = mod_var_input_server, expr = {\n      \n      test_logger(start = \"var_inputs\", msg = \"initial returned()\")\n      \n      # create list of output vals\n2      test_vals &lt;- list(y = \"imdb_rating\",\n                        x = \"audience_score\",\n                        z = \"mpaa_rating\",\n                        alpha = 0.75,\n                        size = 3,\n                        plot_title = \"Example title\")\n\n      # change inputs\n3      session$setInputs(y = \"imdb_rating\",\n                        x = \"audience_score\",\n                        z = \"mpaa_rating\",\n                        alpha = 0.75,\n                        size = 3,\n                        plot_title = \"Example title\")\n\n      expect_equal(\n4        object = session$returned(),\n        expected = test_vals\n      )\n\n      test_logger(end = \"var_inputs\", msg = \"initial returned()\")\n      \n})\n\n\n1\n\nCall to testServer()\n\n\n2\n\nCreate output values for comparison\n\n\n3\n\nSet each input using setInputs(input = )\n\n\n4\n\nConfirm returned values against test_vals\n\n\n\n\nThe test above confirms the initial values can be passed and returned from mod_var_input_server().\n\n\n17.1.2 Flushing the reactives\nIf we want to test changing inputs, we should call session$flushReact() to remove the values set by session$setInputs() 2\n\n1shiny::testServer(app = mod_var_input_server, expr = {\n    # flush reactives\n2    session$flushReact()\n    test_logger(start = \"var_inputs\", msg = \"updated returned()\")\n    # set inputs\n3    session$setInputs(y = \"critics_score\",\n                      x = \"runtime\",\n                      z = \"title_type\",\n                      alpha = 0.5,\n                      size = 2,\n                      plot_title = \"Enter plot title\")\n\n4    expect_equal(object = session$returned(),\n      expected = list(y = \"critics_score\",\n                      x = \"runtime\",\n                      z = \"title_type\",\n                      alpha = 0.5,\n                      size = 2,\n                      plot_title = \"Enter plot title\"))\n    \n    test_logger(end = \"var_inputs\", msg = \"updated returned()\")\n})\n\n\n1\n\nCall to testServer()\n\n\n2\n\nFlush reactives from previous expect_equal()\n\n3\n\nSet changed input values using setInputs(input = )\n\n\n4\n\nConfirm returned values against session$returned()\n\n\n\n\nThe final result of running test_active_file() on test-mod_var_input.R is below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-11-08 20:00:39] [ START var_inputs = initial returned()]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nINFO [2023-11-08 20:00:39] [ END var_inputs = initial returned()]\n\nINFO [2023-11-08 20:00:39] [ START var_inputs = updated returned()]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\nINFO [2023-11-08 20:00:39] [ END var_inputs = updated returned()]\n\n\n17.1.3 Testing module parameters\nNow that we’ve confirmed mod_var_input_server() is returning the initial updated values, we want to make sure reactive values are passed correctly into mod_scatter_display_server().\nIn movies_server(), when we pass selected_vars to the var_inputs argument, we’re not passing the returned values (this is why we don’t need the parentheses). We’re calling on the method (or function) created by the call to reactive() (inside mod_var_input_server()).\nI’ve included the movies_server() function below to refresh our memory of how this should work:3\n\nmovies_server &lt;- function(input, output, session) {\n\n1      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\n1\n\nCalls return(reactive(list(...)))\n\n\n\n\nWhen we pause execution with Posit Workbench’s debugger we can see the difference between calling selected_vars and selected_vars():\n\n\n\n\n\n\nBrowse[1]&gt; selected_vars\nreactive({\n    list(\n      y = input$y, \n      x = input$x, \n      z = input$z, \n      alpha = input$alpha, \n      size = input$size, \n      plot_title = input$plot_title\n      )\n})\n\n\n \n\n\nBrowse[1]&gt; selected_vars()\n$y\n[1] \"audience_score\"\n\n$x\n[1] \"imdb_rating\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\nWe’ll cover using browser() and the IDE’s debugger more the debug section.\nThe feature and scenario for the functionality above is captured in testthat’s BDD functions below:\n\ndescribe(\n  \"Feature: Scatter Plot Configuration in Movie Review Application\n      As a user \n      I want the initial graph pre-configured with variables and aesthetics,\n      So that I can immediately see a meaningful visualization.\",\n  code = {\n    it(\n      \"Scenario: Scatter plot initial x, y, color values \n         Given the movie review application is loaded\n         When I view the initial scatter plot\n         Then the scatter plot should show 'IMDB Rating' on the x-axis\n         And the scatter plot should show 'Audience Score' on the y-axis\n         And the points on the scatter plot should be colored by 'MPAA Rating'\n         And the size of the points should be set to '2'\n         And the opacity of the points should be set to '0.5'\n         And the plot title should be 'Enter plot title'\",\n      code = {\n        \n      })\n  })\n\nInside testServer(), if we’re testing a module function that collects the reactive values, we need to wrap those values in reactive() in the args() argument: 4\n\nshiny::testServer(\n  app = mod_scatter_display_server,\n  args = list(\n    var_inputs =\n1      reactive(\n        list( \n            x = \"critics_score\",\n            y = \"imdb_rating\",\n            z = \"mpaa_rating\",\n            alpha = 0.5,\n            size = 2,\n            plot_title = \"Enter Plot Title\"\n          )\n        )\n  ),\n  expr = {\n    test_logger(start = \"display\", msg = \"selected_vars initial values\")\n2    expect_equal(\n      object = inputs(),\n      expected = list(\n        x = \"critics_score\",\n        y = \"imdb_rating\",\n        z = \"mpaa_rating\",\n        alpha = 0.5,\n        size = 2,\n        plot_title = \"Enter Plot Title\"\n      )\n    )\n    test_logger(end = \"display\", msg = \"selected_vars initial values\")\n})\n\n\n1\n\nList of reactive variable inputs\n\n\n2\n\nCompare inputs() to initial values\n\n\n\n\nI’ve included the example above because it’s not included on the testServer() documentation, and I’ve found this method works well if you want to confirm two modules are communicating (i.e., returning and collecting outputs). System test with shinytest2 are a better option if we’re trying to capture a more comprehensive execution path (i.e., user scenario) in the application.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#sec-tests-mods-coverage",
    "href": "test_modules.html#sec-tests-mods-coverage",
    "title": "17  Testing modules",
    "section": "17.2 Module test coverage",
    "text": "17.2 Module test coverage\nWhen we check the code coverage for the test above, we can see it confirms var_inputs is communicating the reactive values to inputs() in mod_scatter_display_server(), but this test doesn’t execute the call to plotOutput():\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + R\n\n\n\n\n\n\n\n\ndevtools:::test_coverage_active_file()\n\n\n\n\n\n\n\n17.2.1 Testing module outputs\nTo confirm the plot is being created properly in mod_scatter_display_server(), we can’t use the ggplot2::is.ggplot() function because the plot is being rendered by renderPlot(). However, we can verify the structure of the output$scatterplot object using any of the following expectations:\n\nexpect_true(\n  object = is.list(output$scatterplot))\n\nexpect_equal(\n  object = names(output$scatterplot),\n  expected = c(\"src\", \"width\", \"height\", \"alt\", \"coordmap\"))\n\nexpect_equal(\n  object = output$scatterplot[[\"alt\"]],\n  expected = \"Plot object\")\n\nIt’s also possible to build the graph inside the test using the same code from the module server function, then confirm it with ggplot2::is.ggplot():\n\n1    plot &lt;- scatter_plot(movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size) +\n    ggplot2::labs(\n      title = inputs()$plot_title,\n      x = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$x), \"_\", \" \"),\n      y = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$y), \"_\", \" \")) +\n    ggplot2::theme_minimal() +\n    ggplot2::theme(legend.position = \"bottom\")\n    \n2    testthat::expect_true(ggplot2::is.ggplot(plot))\n\n\n1\n\nBuild graph (same code from module function)\n\n\n2\n\nConfirm ggplot2 object is built\n\n\n\n\nIf we’re still skeptical this test is confirming the plot is being built correctly, we can pass plot to print() in the test and the plot will appear in the Plots pane.\n\n\n\n\n\n\n\nPassing plot to print() will send the graph to the Plots pane",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#recap",
    "href": "test_modules.html#recap",
    "title": "17  Testing modules",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: testing modules\n\n\n\n\n\n\n\n\nTesting modules\n\nThis chapter delves into the intricacies of testing Shiny modules. Let’s briefly recap the key points covered:\n\nsession$returned(): allows us to capture and examine the values returned by server-side functions, which is essential for validating the behavior of modules in response to user inputs and server-side processing.\nsession$flushReact() is crucial for testing reactive expressions and observers.\n\nUsing session$flushReact() forces the reactive system to execute, enabling us to test the outcomes of reactive expressions and observe their effects within the context of the module’s functionality.\n\nargs = list(): We discussed the importance of parameterizing module server functions using args = list() to facilitate more flexible and comprehensive testing.\n\nparameterizing modules can easily simulate various scenarios and inputs, enhancing test coverage and the robustness of each module’s functionality.\n\nModule Test Coverage: we outlined strategies for identifying critical paths through our module’s functionality, testing a range of inputs and user interactions, and ensuring that tests are efficient and maintainable.\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_modules.html#footnotes",
    "href": "test_modules.html#footnotes",
    "title": "17  Testing modules",
    "section": "",
    "text": "Read more about returned values in the section titled, ‘Modules with return values’ in the Shiny documentation.↩︎\nRead more about flushing reactive values in the section titled, ‘Flushing Reactives’ in the Shiny documentation.↩︎\nselected_vars are the reactive plot values returned from mod_var_input_server().↩︎\nRead more about adding parameters to testServer() in the section titled, ‘Modules with additional parameters’ in the Shiny documentation.↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Testing modules</span>"
    ]
  },
  {
    "objectID": "test_system.html",
    "href": "test_system.html",
    "title": "18  System tests",
    "section": "",
    "text": "18.1 Current tests\nThis chapter covers using shinytest2 and testthat to perform system tests on the features and scenarios in your app-package.\nSystem (or end-to-end) tests simulate real user interactions in a ‘pre-production’ environment to verify the whole application (or system) works.1 Approaches to system testing vary, but in general, we’ll want to run a system test for each feature in our application before a release.\nIf we’ve been documenting our unit and integration tests with BDD feature and scenario descriptions, the system tests can be used to confirm the functional requirements for the primary execution path (or user experience) before release.\nThe current files in our tests folder are below:\ntests\n├── testthat\n│   ├── fixtures\n│   │   ├── make-tidy_ggp2_movies.R\n│   │   └── tidy_ggp2_movies.rds\n│   ├── helper.R\n│   ├── test-mod_scatter_display.R\n│   ├── test-mod_var_input.R\n│   └── test-scatter_plot.R\n└── testthat.R\n\n3 directories, 7 files\nThe output from devtools::test() is below:\ndevtools::test()",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#current-tests",
    "href": "test_system.html#current-tests",
    "title": "18  System tests",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('13_tests-modules')\n\n\n\n\n\nℹ Testing sap\n✔ | F W  S  OK | Context\n⠏ |          0 | mod_scatter_display  \nLoading required package: shiny\nINFO [2024-05-20 04:19:55] [ START display = selected_vars initial values]\n⠋ |          1 | mod_scatter_display                                    \nINFO [2024-05-20 04:19:55] [ END display = selected_vars initial values]\nINFO [2024-05-20 04:19:55] [ START display = scatterplot[['alt']] = 'Plot object']\n⠙ |          2 | mod_scatter_display                                            \nINFO [2024-05-20 04:19:56] [ END display = scatterplot[['alt']] = 'Plot object']\nINFO [2024-05-20 04:19:56] [ START display = inputs() creates ggplot2 object]\nINFO [2024-05-20 04:19:56] [ END display = inputs() creates ggplot2 object]\n✔ |          3 | mod_scatter_display\n⠏ |          0 | mod_var_input                                            \nINFO [2024-05-20 04:19:56] [ START var_inputs = initial returned()]\nINFO [2024-05-20 04:19:56] [ END var_inputs = initial returned()]\nINFO [2024-05-20 04:19:56] [ START var_inputs = updated returned()]\nINFO [2024-05-20 04:19:56] [ END var_inputs = updated returned()]\n✔ |          2 | mod_var_input\n⠏ |          0 | scatter_plot                                               \nINFO [2024-05-20 04:19:56] [ START fixture = tidy_ggp2_movies.rds]\nINFO [2024-05-20 04:19:56] [ START fixture = tidy_ggp2_movies.rds]\nINFO [2024-05-20 04:19:56] [ START data = sap::movies]\n⠙ |          2 | scatter_plot                                 \nINFO [2024-05-20 04:19:56] [ END data = sap::movies]\n✔ |          2 | scatter_plot\n══ Results ═══════════════════════════════════════════════════════════════════════\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 7 ]\n\nNice code.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#sec-tests-system-shinytest2",
    "href": "test_system.html#sec-tests-system-shinytest2",
    "title": "18  System tests",
    "section": "18.2 Setting up shinytest2",
    "text": "18.2 Setting up shinytest2\nshinytest2 requires a few steps to get up and running (most notably the chromote package), but you’ll find excellent documentation on the package website.2\nThe shinytest2::use_shinytest2() performs the following setup steps:\n\n✔ Adding shinytest2::load_app_env() to tests/testthat/setup-shinytest2.R\n✔ Adding *_.new.png to .gitignore\n✔ Adding _\\\\.new\\\\.png$ to .Rbuildignore\n✔ Adding shinytest2 to Suggests field in DESCRIPTION\n\nWe also get some advice on using shinytest2 functions in our code:\n• In your package code, use `rlang::is_installed(\"shinytest2\")` or\n  `rlang::check_installed(\"shinytest2\")` to test if shinytest2 is installed\n• Then directly refer to functions with `shinytest2::fun()`\nAfter setting up shinytest2, be sure you can create a new chromote session like the one below:\n\nlibrary(chromote)\nb &lt;- ChromoteSession$new()\nb$view()\n\n\n\n\n\n\n\n\n\n\n(a) Chromium headless browser\n\n\n\n\n\nFigure 18.1: A new Chromote session",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#sec-tests-system-recording-tests",
    "href": "test_system.html#sec-tests-system-recording-tests",
    "title": "18  System tests",
    "section": "18.3 Record a test",
    "text": "18.3 Record a test\nIf we launch the test recorder with shinytest2::record_test(), change the inputs in our application, click on Expect Shiny values and Save test and exit, a test is recorded to a new test file: tests/testthat/test-shinytest2.R\n\n\n\nCreating a test with shinytest2::record_test()\n\n\nThe test runs and saves the PNG snapshot and test values to the tests/testthat/_snaps/ folder:\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\nWarning (test-shinytest2.R:23:3): {shinytest2} recording: sap-feature-01\nAdding new file snapshot: 'tests/testthat/_snaps/sap-feature-01-001_.png'\n\nWarning (test-shinytest2.R:23:3): {shinytest2} recording: sap-feature-01\nAdding new file snapshot: 'tests/testthat/_snaps/sap-feature-01-001.json'\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\n\n\n\n\n\nloadSupport warning with shinytest2\n\n\n\n\n\n\nAfter setting up shinytest2, the tests/testthat/setup-shinytest2.R file contains a call to shinytest2::load_app_env(). This runs automatically with shinytest2 tests and produces a familiar warning:\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears\n  to contain an R package. Sourcing files in R/ may cause unexpected behavior.\nWe covered this warning message in the Launch chapter, and it’s being addressed in a future release of shinytest2\n\n\n\n\nIf we view the contents test-shinytest2.R we find each action we performed in the test recorder has a corresponding call in the test:\n\nlibrary(shinytest2)\ntest_that(\"{shinytest2} recording: sap-feature-01\", {\n1  app &lt;- AppDriver$new(name = \"sap-feature-01\", height = 887, width = 1241)\n2  app$set_inputs(`vars-y` = \"imdb_num_votes\")\n3  app$set_inputs(`vars-x` = \"critics_score\")\n4  app$set_inputs(`vars-z` = \"genre\")\n5  app$set_inputs(`vars-alpha` = 0.7)\n6  app$set_inputs(`vars-size` = 3)\n7  app$set_inputs(`vars-plot_title` = \"New plot title\")\n8  app$expect_values()\n})\n\n\n1\n\nInitialize the AppDriver$new() with the name of the test and the dimensions of the Chromium browser.\n\n\n2\n\nChange the y axis (vars-y) to ‘IMBD number of votes’ (imdb_num_votes)\n\n\n3\n\nChange the x axis (vars-x) to ‘Critics Score’ (critics_score)\n\n\n4\n\nChange the color by (vars-z) to ‘Genre’ (genre)\n\n\n5\n\nChange the point opacity (vars-alpha) to ‘0.7’\n\n\n6\n\nChange the point size (vars-alpha) to ‘3’\n\n\n7\n\nChange the plot title to (vars-plot_title) to ‘New plot title’\n\n8\n\nExport the test values\n\n\n\n\nWe’ll use this initial test as a template for writing the steps in our test Scenarios.",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#sec-tests-system-shinytest2-bdd",
    "href": "test_system.html#sec-tests-system-shinytest2-bdd",
    "title": "18  System tests",
    "section": "18.4 shinytest2 and BDD",
    "text": "18.4 shinytest2 and BDD\nThere are multiple ways to approach your test layout with testthat’s describe(), it() and/or test_that() functions. Below is an example with dedicated Feature and Scenario descriptions, a reference to the feature number in the it() (or test_that()) call:\n\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie reivew sources\", {\n             \ndescribe(\"Scenario: Change dropdown values for plotting\n            Given the movie review application is loaded\n            When I choose the variable [ ] for the x-axis\n            And I choose the variable [ ] for the y-axis\n            And I choose the variable [ ] for the color\n            And I choose the size of the points to be [ ]\n            And I choose the opacity of the points to be [ ]\n            And I enter '[ ]' for the plot title\n           \n            Then the scatter plot should show [ ] on the x-axis\n            And the scatter plot should show [ ] on the y-axis\n            And the points on the scatter plot should be colored by [ ]\n            And the size of the points on the scatter plot should be [ ]\n            And the opacity of the points on the scatter plot should be [ ]\n            And the title of the plot should be '[ ]'\", {\n              \n              it(\"Feature 01\", {\n                    app &lt;- AppDriver$new(name = \"feature-01\", \n                                       height = 800, width = 1173)\n                  app$set_inputs(`vars-y` = \"imdb_num_votes\")\n                  app$set_inputs(`vars-x` = \"critics_score\")\n                  app$set_inputs(`vars-z` = \"genre\")\n                  app$set_inputs(`vars-alpha` = 0.7)\n                  app$set_inputs(`vars-size` = 3)\n                  app$set_inputs(`vars-plot_title` = \"New plot title\")\n                  app$expect_values()\n              })\n      })\n})\n\nWith this approach you can create the test file as soon as you have a Feature description (and come back later to fill in the Scenarios and tests).\nAn alternative approach is to use nested describe() functions and include each of the Scenario’s Then steps in the it() or test_that() call (these are what will actually be tested):\n\nlibrary(shinytest2)\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie reivew sources\", {\n             \n  describe(\"Scenario A: Change dropdown values for plotting\n             Given the movie review application is loaded\n             When I choose the variable [ ] for the x-axis\n             And I choose the variable [ ] for the y-axis\n             And I choose the variable [ ] for the color\", {\n        it(\"Then the scatter plot should show [ ] on the x-axis\n             And the scatter plot should show [ ] on the y-axis\n             And the points on the scatter plot should be colored by [ ]\", {\n1              app &lt;- AppDriver$new(name = \"feature-01-senario-a\",\n                                     height = 800, width = 1173)\n                app$set_inputs(`vars-y` = \"imdb_num_votes\")\n                app$set_inputs(`vars-x` = \"critics_score\")\n                app$set_inputs(`vars-z` = \"genre\")\n                app$expect_values()\n       })\n     })\n             \n  describe(\"Scenario B: Change dropdown values for plotting\n              Given the movie review application is loaded\n              When I choose the size of the points to be [ ]\n              And I choose the opacity of the points to be [ ]\n              And I enter '[ ]' for the plot title\", {\n         it(\"Then the size of the points on the scatter plot should be [ ]\n              And the opacity of the points on the scatter plot should be [ ]\n              And the title of the plot should be '[ ]'\", {\n2              app &lt;- AppDriver$new(name = \"feature-01-senario-b\",\n                                     height = 800, width = 1173)\n                app$set_inputs(`vars-alpha` = 0.7)\n                app$set_inputs(`vars-size` = 3)\n                app$set_inputs(`vars-plot_title` = \"New plot title\")\n                app$expect_values()\n        })\n      })\n})\n\n\n1\n\nTest for scenario A\n\n\n2\n\nTest for scenario B\n\n\n\n\nAn important note with this approach is the different names for each AppDriver$new() (otherwise we’d be overwriting the previous snapshot/values).\n\n18.4.1 Testing apps in inst/\nIf we want to test a feature for one of the alternative applications in sap, we can pass their location to the app_dir argument of AppDriver$new(). In the test below, the scenario describes changing inputs for x, y, and color, and removing the missing values from the graph:\n\nlibrary(shinytest2)\ndescribe(\n  \"Feature 1: Scatter plot data visualization dropdowns\n     As a film data analyst\n     I want to explore movie review variables from IMDB (ggplot2movies::movies data)\n     So that I can analyze relationships between movie attributes and ratings\", {\n  describe(\n    \"Scenario: Change dropdown values for plotting\n        Given the movie review application is loaded\n        When I choose the variable ['Length'] for the x-axis\n        And I choose the variable ['Rating'] for the y-axis\n        And I choose the variable ['Genre'] for the color\n        And I click the ['Remove missing'] checkbox\", code = {\n    it(\"Then the scatter plot should show ['Length'] on the x-axis\n        And the scatter plot should show ['Rating'] on the y-axis\n        And the points on the scatter plot should be colored by ['Genre']\n        And the missing values should be removed from the plot\", {\n            \n    test_logger(start = 'ggp2movies-feat-01', msg = \"update x, y, z, missing\")\n      \n1    app &lt;- AppDriver$new(app_dir = system.file(\"dev\", package = \"sap\"),\n                         name = \"ggp2movies_app-feature-01\", \n2                         wait = FALSE, timeout = 30000,\n                         height = 800, width = 1173)\n      app$set_inputs(`vars-y` = \"length\")\n      app$set_inputs(`vars-x` = \"rating\")\n      app$set_inputs(`vars-z` = \"genre\")\n      app$set_inputs(`plot-missing` = TRUE)\n      app$expect_values()\n          \n      test_logger(end = 'ggp2movies-feat-01', msg = \"update x, y, z, missing\")\n      \n      })\n   })\n})\n\n\n1\n\nUse system.file() to access application in inst/tidy-data\n\n\n2\n\nAdjust the wait and timeout so the test will run\n\n\n\n\nNot that I’ve changed the wait and timeout arguments in AppDriver$new() because this tests takes over 10 seconds to complete (which I can see with my test_logger() output):\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2024-05-21 12:39:03] [ START ggp2movies-feat-01 = update x, y, z, missing]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nINFO [2024-05-21 12:40:11] [ END ggp2movies-feat-01 = update x, y, z, missing]\nWhen I confirm this in the output png file, I can see the x, y, and color values have been changed (and the missing values have been removed).\n\n\n\nFile saved in tests/testthat/_snaps/ggp2movies_app-feature-01-001_.png'",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#sec-tests-system-test-mode",
    "href": "test_system.html#sec-tests-system-test-mode",
    "title": "18  System tests",
    "section": "18.5 The test.mode option",
    "text": "18.5 The test.mode option\nIf you recall, we’ve included an argument in both of our standalone app functions to allow for options to be passed to shinyApp().\n\nlaunch_app(options = list())\n\nIf we’re testing our application, we can include the test.mode = TRUE option, which will return any values passed to exportTestValues():\n\nlaunch_app(options = list(test.mode = TRUE), run = 'p')\n\nWe can also include this in our .Rprofile as:3\n\noptions(shiny.testmode = TRUE)\n\nTo export values, place the name of exported reactive values in curly brackets ({}). Below is an example using the inputs() reactive object in the mod_scatter_display_server():\n\nexportTestValues(\n   x = { inputs()$x },\n   y = { inputs()$y },\n   z = { inputs()$z },\n   alpha = { inputs()$alpha },\n   size = { inputs()$size },\n   title = { inputs()$plot_title }\n  )\n\nIn our test, we can create the AppDriver$new() object, extract the values with get_values(), then write tests against any of the exported values:\n\napp &lt;- AppDriver$new(name = \"test-values\",\n                     height = 800, width = 1173,\n                     wait = FALSE, timeout = 300000)\n\ntest_values &lt;- app$get_values()\n\ntest_values[['export']]\n\n$`plot-alpha`\n[1] 0.5\n\n$`plot-size`\n[1] 2\n\n$`plot-title`\n[1] \"\"\n\n$`plot-x`\n[1] \"imdb_rating\"\n\n$`plot-y`\n[1] \"audience_score\"\n\n$`plot-z`\n[1] \"mpaa_rating\"",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#test-_snaps",
    "href": "test_system.html#test-_snaps",
    "title": "18  System tests",
    "section": "18.6 Test _snaps/",
    "text": "18.6 Test _snaps/\nAfter writing our system tests and running devtools::test(), the tests/testthat/_snaps/ folder contains the follow folders and files:\ntests/testthat/_snaps/\n├── app-feature-01\n│   ├── feature-01-senario-a-001.json\n│   ├── feature-01-senario-a-001_.png\n│   ├── feature-01-senario-b-001.json\n│   └── feature-01-senario-b-001_.png\n├── ggp2_app-feature-01\n│   ├── ggp2launch_app-feature-01-001.json\n│   └── ggp2launch_app-feature-01-001_.png\n└── shinytest2\n    ├── sap-feature-01-001.json\n    └── sap-feature-01-001_.png\n\n4 directories, 8 files\nThese outputs correspond to the three system test files in the tests/testthat/:\ntests/testthat\n├── fixtures/\n│   ├── make-tidy_ggp2_movies.R\n│   └── tidy_ggp2_movies.rds\n├── helper.R\n├── setup-shinytest2.R\n├── test-app-feature-01.R\n├── test-ggp2_app-feature-01.R\n├── test-mod_scatter_display.R\n├── test-mod_var_input.R\n├── test-scatter_plot.R\n└── test-shinytest2.R\n\n6 directories, 18 files\n\n\n\n\n\n\nThe _snaps folder\n\n\n\n\n\n\nI’ve removed the tests/testthat/_snaps/ folder from the GitHub repo, so users can run the tests and generate the snapshots in their local environment.\n\n\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('14_tests-system')",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#recap",
    "href": "test_system.html#recap",
    "title": "18  System tests",
    "section": "Recap",
    "text": "Recap\nBehavior-driven development (or behavior-driven testing) fills the gulf between non-technical stakeholders and developers by encouraging natural, descriptive language (often complete sentences) to define and communicate the application requirements.\nCapturing the application’s desired behaviors in Features (As a , I want, So that) and Scenarios (Given, When, Then) provides a testing script that’s clear and easy to follow. Using the BDD format also makes system tests easier to update if the features and scenarios change.\n\n\n\n\n\n\nRecap   \n\n\n\n\n\n\n\nSystem tests\n\n\nrecord_test() simplifies the creation of system tests by recording interactions with your Shiny app.\n\nUsing record_test() accelerates test creation and ensures our tests accurately reflect user behavior, making it easier to catch issues that could affect user experience.\n\nUse AppDriver$new() to manually create tests for more control and customization.\n\nScripting tests with shinytest2 allows for detailed user interactions and testing specific functionalities in isolation or under unique conditions, offering a granular approach to system testing.\n\nUse exportTestValues() in tandem with test.mode to expose and verify the internal state of a Shiny app during tests.\n\nThis technique is crucial for testing the logic and data behind your app’s UI, ensuring that the app looks right and operates correctly under various scenarios.\n\n\nBDD functions\n\nUsing testthat’s BDD functions makes system tests easier to update if the features and scenarios change.\n\nCapturing the application’s desired behaviors in Features (As a , I want, So that) and Scenarios (Given, When, Then) provides a testing script that’s clear and easy to follow.\n\nuse describe() and it() to add features and sceanrios in test files.\ndescribe('Feature...', code = {\n    it('Scenario...', code = { ... })\n})\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "test_system.html#footnotes",
    "href": "test_system.html#footnotes",
    "title": "18  System tests",
    "section": "",
    "text": "System tests should strive to replicate the production conditions, even when/if it’s not possible to perfectly replicate the environment.↩︎\nA great place to start is the Getting Started vignette.↩︎\nWe covered the .Rprofile in Section 4.7.3.↩︎",
    "crumbs": [
      "Tests",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>System tests</span>"
    ]
  },
  {
    "objectID": "deploy.html",
    "href": "deploy.html",
    "title": "Deploy",
    "section": "",
    "text": "Deploy\nExpand the callout boxes below to review the previous testing chapters:\nThis section covers two common methods for deploying a Shiny app-package: 1) Docker images and containers, 2) using GitHub Actions for Continuous Integration (CI) and Continuous Deployment (CD), and 3) building and deploying a package website.",
    "crumbs": [
      "Deploy"
    ]
  },
  {
    "objectID": "deploy.html#docker",
    "href": "deploy.html#docker",
    "title": "Deploy",
    "section": "Docker",
    "text": "Docker\nDocker covers how using Docker can simplify setting up your R environment and reduce the “it works on my machine” problem:\n\n20.1 What is Docker?\n20.2 Installing Docker\n20.3 Writing a Dockerfile\n20.4 Build the Docker image\n20.4.1 Running the container\n20.5 Docker & golem\n20.6 Docker in app-packages",
    "crumbs": [
      "Deploy"
    ]
  },
  {
    "objectID": "deploy.html#github-actions",
    "href": "deploy.html#github-actions",
    "title": "Deploy",
    "section": "GitHub Actions",
    "text": "GitHub Actions\nContinuous Integration/Continuous Deployment (CI/CD) can be implemented for your Shiny app-package using GitHub actions. This chapter covers the following workflows:\n\n21.1 Code styling and linting\n21.2 Shiny app deployment\n21.3 Shiny apps & Docker",
    "crumbs": [
      "Deploy"
    ]
  },
  {
    "objectID": "deploy.html#package-websites",
    "href": "deploy.html#package-websites",
    "title": "Deploy",
    "section": "Package websites",
    "text": "Package websites\npkgdown helps us easily create websites for our app-packages. This chapter covers:\n\n22.1 Setting up pkgdown\n22.2 Building site\n22.3 Customize site layout\n22.3.3 Function reference\n22.4 Deploying your site",
    "crumbs": [
      "Deploy"
    ]
  },
  {
    "objectID": "shinyappsio.html",
    "href": "shinyappsio.html",
    "title": "19  shinyapps.io",
    "section": "",
    "text": "19.1 Deploying the app\nBelow we’ll cover deploying your Shiny app-package in RStudio  and Positron . The Positron  IDE was still in the early stages of development when this section was written, so some of these steps may change in future versions.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "shinyappsio.html#deploying-the-app",
    "href": "shinyappsio.html#deploying-the-app",
    "title": "19  shinyapps.io",
    "section": "",
    "text": "19.1.1 In RStudio \nTo deploy the app, I can click on the Publish icon:\n\n\n\nSend app.R to Console and click Publish\n\n\nMake sure all the files in the package are selected, then click Publish\n\n\n\nPublishing apps to shinyapps.io\n\n\nThe Deploy pane will open and you’ll see a deployment log as your application is sent to the server:\n\n\nshow/hide deployment log\n── Preparing for deployment ────────────────────────────────────────────────────\n✔ Deploying \"movie-reviews\" using \"server: shinyapps.io / username: yourusername\"\nℹ Creating application on server...\n✔ Created application with id 12692760\nℹ Bundling 27 files: .Rbuildignore, app.R, data/movies.rda, data/movies.RData, \nDESCRIPTION, inst/extdata/movies.fst, NAMESPACE, README.md, www/shiny.png,\nman/display_type.Rd, man/launch_app.Rd, man/mod_scatter_display_server.Rd,\nman/mod_scatter_display_ui.Rd, man/mod_var_input_server.Rd, \nman/mod_var_input_ui.Rd, man/movies_server.Rd, man/movies_ui.Rd, man/movies.Rd,\n…, R/movies_ui.R, and R/scatter_plot.R\nℹ Capturing R dependencies with renv\n✔ Found 61 dependencies\n✔ Created 389,882b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 9093617\n── Deploying to server ─────────────────────────────────────────────────────────\nWaiting for task: 1456625417\n  building: Building image: 11062313\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 11062313\n  deploying: Starting instances\n  rollforward: Activating new instances\n  success: Stopping old instances\n── Deployment complete ─────────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://yourusername.shinyapps.io/app-name/&gt;\nDeployment completed: https://yourusername.shinyapps.io/app-name//\n\n\n\n19.1.1.1 Deploy logs\nOn shinyapps.io, the deployment log shows the loadSupport() warning persists (but the application still deploys. The server-side warning is a known issue.1\nshinyapps[12692760]: Running as user: uid=10001(shiny) gid=10001(shiny) groups=10001(shiny)\nshinyapps[12692760]: Connect version: 2024.05.0\nshinyapps[12692760]: LANG: C.UTF-8\nshinyapps[12692760]: Working directory: /srv/connect/apps/movie-reviews\nshinyapps[12692760]: Using R 4.4.0\nshinyapps[12692760]: R.home(): /opt/R/4.4.0/lib/R\nshinyapps[12692760]: Content will use current R environment\nshinyapps[12692760]: R_LIBS: (unset)\nshinyapps[12692760]: .libPaths(): /usr/lib/R, /opt/R/4.4.0/lib/R/library\nshinyapps[12692760]: shiny version: 1.9.1\nshinyapps[12692760]: httpuv version: 1.6.15\nshinyapps[12692760]: rmarkdown version: (none)\nshinyapps[12692760]: knitr version: (none)\nshinyapps[12692760]: jsonlite version: 1.8.8\nshinyapps[12692760]: RJSONIO version: (none)\nshinyapps[12692760]: htmltools version: 0.5.8.1\nshinyapps[12692760]: reticulate version: (none)\nshinyapps[12692760]: Using pandoc: /opt/connect/ext/pandoc/2.16\nshinyapps[12692760]: \nshinyapps[12692760]: Starting R with process ID: '31'\nshinyapps[12692760]: Shiny application starting ...\nshinyapps[12692760]: Warning in warn_if_app_dir_is_package(appDir) :\nshinyapps[12692760]:   Loading R/ subdirectory for Shiny application, \n  but this directory appears to contain an R package. Sourcing files \n  in R/ may cause unexpected behavior. See `?loadSupport` for more details.\nshinyapps[12692760]: ℹ Loading sap\nshinyapps[12692760]: \nshinyapps[12692760]: Listening on http://127.0.0.1:123456\n\n\n\n19.1.2 In Positron \nAfter loading, documenting, and installing our app-package, we can deploy it in Positron  using the rsconnect::deployApp() function.\n\n\n\nDeploying Shiny app from Positron’s Console\n\n\nAs we can see, Positron doesn’t open a Deploy window or separate Terminal task for launching the application (it’s printed directly to the Console).",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "shinyappsio.html#the-rsconnect-folder",
    "href": "shinyappsio.html#the-rsconnect-folder",
    "title": "19  shinyapps.io",
    "section": "19.2 The rsconnect folder",
    "text": "19.2 The rsconnect folder\nWhen deploying a Shiny app, the rsconnect/ folder is automatically created to store configuration settings and deployment metadata for the app. Below are a few points to consider with regard to this folder:",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "shinyappsio.html#footnotes",
    "href": "shinyappsio.html#footnotes",
    "title": "19  shinyapps.io",
    "section": "",
    "text": "You can learn more about this warning by reading these posts on StackOverflow: How can I deploy my shiny app as a package?; Problem with directory when deploying app on shinyapps, and this post on Posit Community: Errors when deploying app on shinyapps.io.↩︎",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>shinyapps.io</span>"
    ]
  },
  {
    "objectID": "docker.html",
    "href": "docker.html",
    "title": "20  Docker",
    "section": "",
    "text": "20.1 What is Docker?\nDocker containers ensure your Shiny applications are deployed with the necessary tools and resources (dependencies, libraries, etc.) without significantly interfering with the native operating system or hardware.\nWith Docker, each Shiny application runs from an image in an isolated container, which ensures your app works consistently, regardless of where it’s deployed.1\nThree terms to know when working with Docker are Dockerfile, image, and container. Containers and images work together but they serve different purposes in the Docker ecosystem.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-what-is-docker",
    "href": "docker.html#sec-docker-what-is-docker",
    "title": "20  Docker",
    "section": "",
    "text": "Dockerfile: The file containing instructions on how to build the Docker image.\nDocker Image: A snapshot of the Shiny application and its dependencies, built based on the Dockerfile.\nDocker Container: A runtime instance of the Docker image, isolated from the host system, ensuring consistent behavior across environments. When we run an image, Docker creates a container from that image. A Docker image can exist without a container, but all containers must be instantiated from an image.\n\n\n20.1.1 How Docker works\nImagine your computer as a building. In this building, your operating system (OS) is like a big kitchen where everyone cooks. If someone (a software application) needs the oven at a specific temperature or requires a particular ingredient, this can interfere with what someone else (i.e., other applications) wants to cook. This situation is somewhat analogous to the competition for resources software applications can have while running on a particular machine.\nDocker containers are like individual, self-contained mini-kitchens containing appliances, ingredients, and utensils. Each mini-kitchen can operate independently, regardless of what’s happening in the others. Docker images can contain different ‘recipes’ for software applications, and each application can have different requirements (dependencies, libraries, versions, etc.).2\n\nInside our app-packages, we can write a Dockerfile (a text file containing a series of instructions) that defines how to build the Docker image. The image is a snapshot representing our Shiny app and its dependencies. Docker containers are instantiated with the build command, which reads and executes the instructions inside the Dockerfile and creates a runtime instance of the image.\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'fontFamily': 'monospace'}}}%%\n\nflowchart TB\n    subgraph App-Package\n        subgraph Dockerfile\n            A[\"Instructions\"] --&gt; B[\"Docker Image\"]\n        end\n        subgraph Container\n            B --&gt; C[\"Docker Container\"]\n            C --&gt; D[\"Image & dependencies are safely stored\"]\n            C --&gt; E[\"Ensures consistency across environments\"]\n        end\n    end\n    F[\"Host System\"] --&gt;|Isolated from...| App-Package\n\n\n  style A fill:#8dd38d,color:#000000;\n  style B fill:#89D6FB,color:#000000,stroke:none,rx:10,ry:10;\n  style C fill:#89D6FB,color:#000000,stroke:none,rx:10,ry:10;\n  style F fill:#5c6192,color:#FFFFFF,stroke:none,rx:10,ry:10;\n\n\n\n\n\n\nThe image containing our applications’ dependencies is safely stored inside the container, which ensures consistency across environments. The container also isolates the image (and the application) from the host system.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-install",
    "href": "docker.html#sec-docker-install",
    "title": "20  Docker",
    "section": "20.2 Installing Docker",
    "text": "20.2 Installing Docker\nFollow the instructions found on the Docker website to install Docker Desktop. I’ll be demonstrating how to use Docker on a macOS (but it’s available on most operating systems).\nAfter installation, Docker Desktop will initially show no active images/containers:3\n\n\n\n\n\n\n\nDocker Desktop Containers (Mac)\n\n\nThe development process for your Shiny app-package doesn’t change until you’re ready to deploy your application.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-dockerfile",
    "href": "docker.html#sec-docker-dockerfile",
    "title": "20  Docker",
    "section": "20.3 Writing a Dockerfile",
    "text": "20.3 Writing a Dockerfile\nWe’ll be using the sap example from the previous chapter as an example (the folder/file structure is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('15_docker')\n\n\n\nview app-package folder tree\n├── DESCRIPTION\n├── Dockerfile\n├── NAMESPACE\n├── R\n│   ├── data.R\n│   ├── display_type.R\n│   ├── ggp2_movies_app.R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   ├── launch_app.R\n│   ├── movies_server.R\n│   ├── movies_ui.R\n│   ├── scatter_plot.R\n│   └── testthat.R\n├── README.md\n├── app.R\n├── data\n│   ├── movies.RData\n│   └── movies.rda\n├── data-raw\n│   └── tidy_movies.R\n├── inst\n│   ├── dev\n│   │   ├── R\n│   │   │   ├── devServer.R\n│   │   │   ├── devUI.R\n│   │   │   ├── dev_mod_scatter.R\n│   │   │   └── dev_mod_vars.R\n│   │   ├── app.R\n│   │   ├── imdb.png\n│   │   └── tidy_movies.fst\n│   ├── extdata\n│   │   └── movies.fst\n│   ├── prod\n│   │   └── app\n│   │       └── app.R\n│   └── www\n│       ├── bootstrap.png\n│       └── shiny.png\n├── man\n│   ├── display_type.Rd\n│   ├── ggp2_movies_app.Rd\n│   ├── mod_scatter_display_server.Rd\n│   ├── mod_scatter_display_ui.Rd\n│   ├── mod_var_input_server.Rd\n│   ├── mod_var_input_ui.Rd\n│   ├── movies.Rd\n│   ├── launch_app.Rd\n│   ├── movies_server.Rd\n│   ├── movies_ui.Rd\n│   ├── scatter_plot.Rd\n│   └── test_logger.Rd\n├── sap.Rproj\n├── tests\n│   ├── testthat\n│   │   ├── fixtures\n│   │   │   ├── make-tidy_ggp2_movies.R\n│   │   │   └── tidy_ggp2_movies.rds\n│   │   ├── helper.R\n│   │   ├── setup-shinytest2.R\n│   │   ├── test-app-feature-01.R\n│   │   ├── test-ggp2_app-feature-01.R\n│   │   ├── test-mod_scatter_display.R\n│   │   ├── test-mod_var_input.R\n│   │   ├── test-scatter_plot.R\n│   │   └── test-shinytest2.R\n│   └── testthat.R\n└── vignettes\n    └── test-specs.Rmd\n\n16 directories, 54 files\n\n\nWhen our application is ready to deploy, we’ll create a Dockerfile, which is a plain-text file (no extension). Dockerfiles are a blend of commands, numeric values, and character strings with the following general conventions:\n\nEach line in the Dockerfile starts with an instruction. These aren’t case-sensitive, but it’s common practice to capitalize each command.\nComments or explanatory notes begin with #. These will be ignored by the Docker engine.\n\nBelow are two lines from the Dockerfile found in the excellent post titled, R Shiny Docker: How To Run Shiny Apps in a Docker Container. This is a great place to familiarize yourself with deploying a non-package Shiny application with Docker.4\n\n# build image \nFROM rocker/shiny\n\n# create location for app\nRUN mkdir /home/shiny-app\n\nAs you can see, the Dockerfile combines instructions (FROM, RUN) with command-line arguments (mkdir). You don’t have to be a command-line expert to write a Dockerfile (but knowing a few can get you out of a jam 5).\n\n20.3.1 Create image\nDocker files start by building an image. In our case, we want an image configured to run R, which has been provided for us by the generous folks at the rocker project.\nThe Shiny rocker image is for Shiny apps:\n\nFROM rocker/shiny\n\n\n\n20.3.2 Install dependencies\nUse RUN and R -e to install dependencies for our app in the container from CRAN.6\n\nRUN R -e 'install.packages(c(\"rlang\", \"stringr\", \"shiny\", \"ggplot2\", \"remotes\"))'\n\n\n\n20.3.3 Create location for app\n\nRUN mkdir creates a new /deploy directory in the container\nADD . /deploy copies the files from the current directory (on the host machine) into the /deploy directory inside the container\nWORKDIR /deploy sets the /deploy directory as the working directory for any subsequent instructions.\n\n\nRUN mkdir /deploy\nADD . /deploy\nWORKDIR /deploy\n\n\n\n20.3.4 Install app-package\nremotes::install_local() will the R package specified in the local directory (where our Shiny app-package lives), without upgrading dependencies.\n\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\n\n\n\n20.3.5 Clean up\nRUN rm -rf /deploy cleans up and reduces the size of the container.\n\nRUN rm -rf /deploy\n\n\n\n20.3.6 Expose port\nMake our Shiny app available on EXPOSE 8180.\n\nEXPOSE 8180\n\n\n\n20.3.7 Launch app\nWhen the container starts, set Shiny to listen on port 8180, then launch the Shiny app from our sap package. The port we exposed in the Dockerfile should match the shiny.port option.\n\nCMD R -e \"options('shiny.port'=8180,shiny.host='0.0.0.0');library(sap);sap::launch_app()\"",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-build-image",
    "href": "docker.html#sec-docker-build-image",
    "title": "20  Docker",
    "section": "20.4 Build the Docker image",
    "text": "20.4 Build the Docker image\nThe final Dockerfile we’ll use to launch our application is below:\n\nFROM rocker/shiny\nRUN R -e 'install.packages(c(\"rlang\", \"stringr\", \"shiny\", \"ggplot2\", \"remotes\"))'\nRUN mkdir /deploy\nADD . /deploy\nWORKDIR /deploy\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\nRUN rm -rf /deploy\nEXPOSE 8180\nCMD R -e \"options('shiny.port'=8180,shiny.host='0.0.0.0');library(sap);sap::launch_app()\"\n\nTo build the Docker image and create a new container, run the docker build command in the Terminal with a tag (-t), a name for the image (movies-app-docker-demo), and the location (.):\n\ndocker build -t movies-app-docker-demo .\n\nAs the docker image builds you’ll see the output in the Terminal:\n\n\n\n\n\nAfter the image is built, we’ll see a new image listed in Docker desktop:\n\n\n\n\n\n\n20.4.1 Running the container\nAfter building the image, we can run the new container using docker run\n\ndocker run -p 8180:8180 movies-app-docker-demo\n\nIn the Terminal, we’ll see an R session initialize, and the R function calls from the last line of our Dockerfile:\nR version 4.4.1 (2024-06-14) -- \"Race for Your Life\"\nCopyright (C) 2024 The R Foundation for Statistical Computing\nPlatform: x86_64-pc-linux-gnu\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n&gt; options('shiny.port'=8180,shiny.host='0.0.0.0');library(sap);sap::launch_app()\nLoading required package: shiny\n\nListening on http://0.0.0.0:8180\nCopy the hyperlink above and place it in the browser to view the application:\n\n\n\n\n\nNew Docker containers are named using a random combination of adjectives and famous scientists’ surnames (unless the --name flag is added).\n\n\n\n\n\nYou can change the name of a Docker image by stopping the container and passing docker rename &lt;old_name&gt; &lt;new_name&gt; to the Terminal:\n\ndocker rename unruffled_bhabha launch_app\n\nEach Docker container is created from the image (which is specified in the Dockerfile). The image serves as a blueprint for the containers, and we could create multiple containers from the same image:\n\n\n\n\n\n\n\nRunning and stopping Docker containers",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-golem",
    "href": "docker.html#sec-docker-golem",
    "title": "20  Docker",
    "section": "20.5 Docker & golem",
    "text": "20.5 Docker & golem\nThe golem package has multiple functions for building Docker files and images. There are a few notable points to make about some of the Docker images created with golem:\n\ngolem’s Docker functions can produce multiple Docker files (golem::add_dockerfile_with_renv() creates a tmp/deploy folder and adds the following files)\n\n\nView deploy/ folder\ndeploy/\n  ├── Dockerfile\n  ├── Dockerfile_base\n  ├── README\n  ├── gap_0.0.0.9000.tar.gz\n  └── renv.lock.prod\n\n\ngolem’s Docker files typically use the R build from rocker (and include a version):\n\n\nView R version build\nFROM rocker/verse:4.3.2\n\n\ngolem Docker files might also include additional commands for installing/updating command-line (linux) tools for downloading/exchanging data:\n\n\nView apt-get commands\nRUN apt-get update && apt-get install -y  libcurl4-openssl-dev libicu-dev libssl-dev libxml2-dev make pandoc zlib1g-dev\n\n\nThey also usually the remotes package to specify the version of each package and whether to upgrade (or not):\n\n\nView remotes::install_version()\nRUN R -e 'install.packages(\"remotes\")'\nRUN Rscript -e 'remotes::install_version(\"rlang\",upgrade=\"never\",version=\"1.1.2\")'\nRUN Rscript -e 'remotes::install_version(\"stringr\",upgrade=\"never\",version=\"1.5.1\")'\nRUN Rscript -e 'remotes::install_version(\"shiny\",upgrade=\"never\",version =\"1.8.0\")'\nRUN Rscript -e 'remotes::install_version(\"ggplot2\",upgrade=\"never\",version=\"3.4.4\")'\n\n\n\n\n\n\n\n\n\nRUN R -e vs RUN Rscript -e\n\n\n\n\n\n\nBoth R -e and RUN Rscript -e will execute R expressions from the command line.\n\nR -e is straightforward and typically used to evaluate a single expression (i.e., install.packages())\nRUN Rscript -e is more commonly used for running scripts or more specialized commands:\n\npkgs &lt;- c('glue', 'cli')\ninstall.packages(pkgs)\n\n\n\n\nThere are additional differences, but these are important if you want to include additional requirements or control the version of R (or a package dependency). golem’s Docker images are more (you guessed it) opinionated, but every time I’ve used one it works right “out of the box.”",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#sec-docker-app-packages",
    "href": "docker.html#sec-docker-app-packages",
    "title": "20  Docker",
    "section": "20.6 Docker in app-packages",
    "text": "20.6 Docker in app-packages\nYou can include a Dockerfile in an app-package by adding it to the .Rbuildignore file.7\n\n^.*\\.Rproj$\n^\\.Rproj\\.user$\n^sap\\.Rcheck$\n^sap.*\\.tar\\.gz$\n^sap.*\\.tgz$\n^Dockerfile$\n\nThis will ensure it won’t interfere with your app-package builds. Docker also has it’s own ignore file (.dockerignore), which can include similar contents to the .gitignore:\n\n.RData\n.Rhistory\n.git\n.gitignore\nmanifest.json\nrsconnect/\n.Rproj.user\n\nNote that if you include a .dockerignore file, you should also include this pattern in the .Rbuildignore:\n\n^.*\\.Rproj$\n^\\.Rproj\\.user$\n^sap\\.Rcheck$\n^sap.*\\.tar\\.gz$\n^sap.*\\.tgz$\n^Dockerfile$\n^\\.dockerignore$",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#recap",
    "href": "docker.html#recap",
    "title": "20  Docker",
    "section": "Recap",
    "text": "Recap\nThis has been a brief overview of using Docker to deploy your Shiny App-Package.\n\n\n\n\n\n\nRecap: \n\n\n\n\n\n\nDocker files are used to build images, which defines an environment for the Shiny application to run. The container is the actual running instance of that environment.\n\nDocker images are immutable, meaning they do not change. Once an image is created, it remains unchanged inside a container.\nDocker containers can be started, stopped, moved, and deleted, but each time a container is run, it’s created from an image.\n\n\n\n\n\nDocker is covered again in the golem chapter and on the Shiny frameworks supplemental website. If you’d like to learn more, Appsilon has a great introduction to Docker (mentioned above).8 I also found the Dockerizing shiny applications post helpful. 9\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "docker.html#footnotes",
    "href": "docker.html#footnotes",
    "title": "20  Docker",
    "section": "",
    "text": "Read more about Docker in the official documentation.↩︎\nDocker containers are similar to virtual machine environments (like VMware), but don’t use a significant portion of the hardware system’s resources.↩︎\nIf you follow the Docker ‘Walkthroughs’ in the Learning Center, you might see the welcome-to-docker container listed.↩︎\nI’ve altered the comments of the original Dockerfile, so be sure to read the entire blog post before copying + pasting this into your workflow.↩︎\nI love the help files on https://linuxize.com/, and this tutorial is a nice introduction to the command-line.↩︎\nWe’ll need remotes to install our app-package locally (i.e., with remotes::install_local(upgrade=\"never\")).↩︎\n.Rbuildignore includes files that we need to have in our app-package, but don’t conform to the standard R package structure (and shouldn’t be included when building our app-package from the source files).↩︎\nAppsilon has a few posts on Docker: ‘R Shiny Docker: How To Run Shiny Apps in a Docker Container’ and ‘Renv with Docker: How to Dockerize a Shiny Application with an Reproducible Environment’↩︎\nThis is the second post in a series (see the first post here).↩︎",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Docker</span>"
    ]
  },
  {
    "objectID": "gha.html",
    "href": "gha.html",
    "title": "21  GitHub Actions",
    "section": "",
    "text": "GitHub Actions\nContinuous integration\nContinuous deployment\nProperly implemented CI/CD is like a well-oiled machine, where each part works seamlessly with the others, which saves time, reduces errors, and makes the process efficient and reliable.\nActions allow us to create custom workflows to automatically build, test, and deploy our code. Workflows can be triggered by a push to a branch, a pull request, a specific time schedule, or another GitHub event.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#github-actions",
    "href": "gha.html#github-actions",
    "title": "21  GitHub Actions",
    "section": "",
    "text": "GitHub Actions (or Actions, for short) is a feature provided by GitHub that enables automation of various development workflows. These workflows are defined in YAML files and can automate some of the repetitive tasks in the development lifecycle, right within a GitHub repository.\n\n\n\n\n\n\n\n\n\nGitHub Actions\n\n\n\n\n\n\n\nThe workflow file\nThe YAML workflow file configures and defines the automated tasks run in a GitHub repository. Workflows typically include fields for building, testing, and deploying code, and are structured into several key sections:\n\non\n\n“An event is a specific activity in a repository that triggers a workflow run.”\n\n\n\n\n\n\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\n\n\non defines the event(s) that trigger the workflow.2\n\n\n\n\n\n\nname\n\n\n\n\n\n\nname: shiny\n\n\n\nname is an optional field to identify a workflow in the Actions tab of the GitHub repository.3\n\n\n\n\n\n\njobs\n\n“A job is a set of steps in a workflow that is executed on the same runner.”\n\n\n\n\n\n\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n\n\n\nThe job and it’s identifier (check) are used to reference the runner, in this example it’s ubuntu-latest.\n\n\n\n\n\n\n\n\n\n\njobs:\n  check:\n    runs-on: ${{ matrix.config.os }}\n    \n\n\n\nmatrix runs jobs across different operating systems, programming language versions, etc.\n\n\n\n\n\n\n\n\n\n\n    name: ${{ matrix.config.os }} (${{ matrix.config.r }})\n    \n\n\n\n\n\n\n\n\n\n    strategy:\n      fail-fast: false\n      matrix:\n        config:\n          - {os: macos-latest,   r: 'release'}\n          - {os: windows-latest, r: 'release'}\n          - {os: ubuntu-latest,   r: 'release'}\n\n\n\nfail-fast: false means the workflow will continue running even if one of the matrix jobs fails.\n\n\n\n\n\n\nsteps\n\n“Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step.”\n\n\n\n\n\n\n\nsteps:\n    - uses: actions/checkout@v2\n\n    - name: Set up R\n      uses: r-lib/actions/setup-r@v2\n\n    - name: Install package\n      run: |\n        install.packages('remotes')\n        remotes::install_local('.')\n      shell: Rscript {0}\n      \n\n\n\nsteps define a series of tasks or actions that the job will execute. These steps check out the code, set up an R environment, and installs a local package\n\n\n\n\n\n\n\n\n\n\nWhat is shell: Rscript {0}?\n\n\n\n\n\n\n  name: Install packages\n  run: |\n    pkgs &lt;- c('glue', 'cli')\n    install.packages(pkgs)\n  shell: Rscript {0}\nThe command install.packages(pkgs) is run as an R script:\n\nshell specifies which command-line interpreter (bash, pwsh, python, or Rscript) to use for the run commands\nRscript is the command-line tool provided by R to execute R scripts and commands in a non-interactive environment.\n{0} is a placeholder for the R commands written in the run section.\n\n\n\n\n\n\n\nComments\nLines beginning with # will not be executed. It’s common to provide 1) a reference to the workflow source (r-lib/actions in this case) and 2) a link for help with debugging build failures.\n# Workflow derived from https://github.com/r-lib/actions/tree/v2/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\n\n\n\nWorkflow permissions\nIn order for workflows to run, we’ll need to make sure Actions have read and write permissions. We can do this by clicking on the repository’s Settings tab, then expand the Actions menu and select General:\n\n\n\nRepository Action settings\n\n\nIn the General settings, we want to confirm the workflow has Read and write permissions permissions (if this needs to be been changed, be sure to click Save).\n\n\n\nWorkflow permissions\n\n\nNow our workflows can commit and push changes to the repository.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#sec-gha-style",
    "href": "gha.html#sec-gha-style",
    "title": "21  GitHub Actions",
    "section": "21.1 Code styling and linting",
    "text": "21.1 Code styling and linting\nIn R packages, we can set up the GitHub Action infrastructure with usethis::use_github_action(). The name can be any of the workflow files available at r-lib/actions. The first workflow we’ll be demonstrating can be used to automate the code style in an app-package.\n\n\nLaunch app with the shinypak package:\n\nlaunch('16.1_gha-style')\n\n\nusethis::use_github_action(\"style\")\n\n✔ Setting active project to '/projects/apps/sap'\n✔ Creating '.github/'\n✔ Adding '*.html' to '.github/.gitignore'\n✔ Creating '.github/workflows/'\n✔ Saving 'r-lib/actions/examples/style.yaml@v2' to '.github/workflows/style.yaml'\nThe output tells us a local .github/workflows/style.yaml file has been copied from the r-lib/actions/examples/style.yaml@v2 into the .github/workflows folder:\n.github/\n  └── workflows\n    └── style.yaml\n\n2 directories, 1 file\nThe documentation for the style.yaml@v2 file tells us this workflow,\n\n“styles the R code in a package, then commits and pushes the changes to the same branch.”\n\nThe code styling in this workflow is handled by the styler package, which “formats your code according to the tidyverse style guide.”\nThree functions in the 16.1_gha-style branch have altered to have zero style (R/display_type.R, R/mod_var_input.R, and R/test_logger.R). You can copy the code for these functions in the chunk below:4\n\n\nshow/hide no-style code\n# display_type ----\ndisplay_type &lt;- function(run = \"w\") {\n  if(Sys.getenv(\"RSTUDIO\") == \"1\"){\n    switch(run,\n      p=options(shiny.launch.browser=.rs.invokeShinyPaneViewer),\n      b=options(shiny.launch.browser=.rs.invokeShinyWindowExternal),\n      w=options(shiny.launch.browser=.rs.invokeShinyWindowViewer),\n      NULL=options(shiny.launch.browser=NULL))\n    environment &lt;- \"RStudio\"\n    shinyViewerType &lt;- getOption('shiny.launch.browser') |&gt; \n                        attributes() |&gt; unlist() |&gt; unname()\n    cli::cli_alert_info(\"App running in {environment}\")\n    cli::cli_alert_info(\"shinyViewerType set to {shinyViewerType}\")\n  }else{\n    environment &lt;- \"RStudio\"\n    cli::cli_alert_info(\"App not running in {environment}\")\n  } \n}\n\n# mod_var_input_ui ----\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"), selected = \"audience_score\"\n    ),\n    selectInput(inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"), selected = \"imdb_rating\"\n    ),\n    selectInput(inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"), selected = \"mpaa_rating\"\n    ),\n    sliderInput(inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1, value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\", min = 0, max = 5, value = 2\n    ),\n    textInput(inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n# test_logger ----\ntest_logger &lt;- function(start = NULL, end = NULL, msg) {\n  \n  if (is.null(start) & is.null(end)) {\n    \n    cat(\"\\n\")\n    \n    logger::log_info(\"{msg}\")\n    \n    } else if (!is.null(start) & is.null(end)) {\n    \n    cat(\"\\n\")\n    \n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n  \n    } else if (is.null(start) & !is.null(end)) {\n      \n    cat(\"\\n\")\n      \n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n    \n    } else {\n      \n    cat(\"\\n\")\n      \n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n    \n    cat(\"\\n\")\n    \n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n    \n    }\n  \n}\n\n\nWe’ll make one small change to style.yaml before pushing it to GitHub. Instead of having the workflow automatically commit and push the styled code changes to the same branch, we’ll limit the code styling to the 16.1_gha-style branch:\non:\n  push:\n    branches: [16.1_gha-style]\n    paths: [\"**.[rR]\", \"**.[qrR]md\", \"**.[rR]markdown\", \"**.[rR]nw\", \"**.[rR]profile\"]\nThis change ensures our style workflow will be triggered only for pushes to the specified branches (and when changes are made to files with the specified extensions in path).\nAfter saving these changes to .github/workflows/style.yaml, we’ll add, commit, and push the changes to GitHub,\ngit add .\ngit commit -m \"updates to style workflow\"\n[16.1_gha-style 899bd38] updates to style workflow\n 4 files changed, 43 insertions(+), 45 deletions(-)\ngit push\nEnumerating objects: 17, done.\nCounting objects: 100% (17/17), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (8/8), done.\nWriting objects: 100% (9/9), 950 bytes | 25.00 KiB/s, done.\nTotal 9 (delta 6), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (6/6), completed with 6 local objects.\nTo https://github.com/mjfrigaard/sap.git\n   d366e0f..899bd38  16.1_gha-style -&gt; 16.1_gha-style\nIf we view the Actions tab, we’ll see the workflow listed with the name of our commit message:\n\n\n\nCurrently running workflows\n\n\nClicking on the workflow reveals the following:\n\n\n\nname of running workflow\n\n\nThe style widget contains each step in the workflow file. If we click on it we can see each step executed in real-time. Below we can see the dependencies installed from the pak lockfile:\n\n\n\n\n\n\n\n\n\nClick on the style widget\n\n\n\n\n\n\n\nView the Install dependencies workflow step running\n\n\n\n\n\nThe actual styling comes is in the Style step:\n\n\n\nStyle workflow step running\n\n\nWhen the workflow has finished, we can pull the style changes to our local branch and view the styled files:5\ngit pull\nremote: Enumerating objects: 4, done.\nremote: Counting objects: 100% (4/4), done.\nremote: Total 4 (delta 3), reused 4 (delta 3), pack-reused 0\nUnpacking objects: 100% (4/4), 450 bytes | 56.00 KiB/s, done.\nFrom https://github.com/mjfrigaard/sap\n   899bd38..0ad97cf  16.1_gha-style -&gt; origin/16.1_gha-style\nUpdating 899bd38..0ad97cf\nFast-forward\n R/display_type.R  | 13 +++----------\n R/mod_var_input.R | 30 ++++++++++++++++++++----------\n R/test_logger.R   | 30 ++++++++++--------------------\n 3 files changed, 33 insertions(+), 40 deletions(-)",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#sec-gha-shiny",
    "href": "gha.html#sec-gha-shiny",
    "title": "21  GitHub Actions",
    "section": "21.2 Shiny app deployment",
    "text": "21.2 Shiny app deployment\nIn this section we’ll be adapting the GitHub Action workflow file provided for deploying a Shiny applications. Before we get to the workflow file, we need to address a few settings and configurations that need to take place outside of the workflow file.\n\n\nLaunch app with the shinypak package:\n\nlaunch('16.2_gha-shiny')\n\n\n21.2.1 Creating repository secrets\nWe need to make sure our rsconnect secrets are stored with the GitHub repository (so we can access them from within the workflow file). To do this, we’re going to return to the Settings tab on the sap repository, expand Secrets and variables under Security, and select Actions:6\n\n\n\n\n\n\n\nSecrets and variables for sap repository\n\n\nUse New repository secret to create three new secrets: RSCONNECT_USER, RSCONNECT_TOKEN, and RSCONNECT_SECRET. You can access these in your shinyapps.io account:\n\n\n\n\n\n\n\nToken and Secret from shinyapps.io\n\n\nWhen you’re finished, should see the following three Repository secrets:\n\n\n\n\n\n\n\nRepository secrets in sap\n\n\n\n\n21.2.2 Enable private repositories\nWe also need to make sure our shinyapps.io account allows us to install from private GitHub repositories during a workflow deployment. We can do this in the Profile menu item in our dashboard:\n\n\n\n\n\n\n\nUpdate Authentication in shinyapps.io profile\n\n\nClicking Update Authentication will open your Posit profile settings, where you can enable private repositories.\n\n\n\n\n\n\n\nPrivate repo access also enabled\n\n\n\n\n21.2.3 Capture dependencies\nThe documentation for ‘Shiny App Deployment’ indicates we need to create a renv lockfile in the 16.2_gha-shiny branch.7\nWe can create the lockfile with the code below:\n\ninstall.packages('renv')\nrenv::init(force = TRUE)\n\nThis project contains a DESCRIPTION file.\nWhich files should renv use for dependency discovery in this project? \n\n1: Use only the DESCRIPTION file. (explicit mode)\n2: Use all files in this project. (implicit mode)\nWe’re going to use the explicit mode, because the dependencies in the DESCRIPTION should be all that’s needed to run and deploy the application.\nSelection: 1\n- Using 'explicit' snapshot type. Please see `?renv::snapshot` for more details.\n\nThis project already has a private library. What would you like to do? \n\n1: Activate the project and use the existing library.\n2: Re-initialize the project with a new library.\n3: Abort project initialization.\nWe will start fresh and create a new project library:\nSelection: 2\n- Resolving missing dependencies ...\nAfter renv has discovered and installed the dependencies, the R session will restart and we’ll see the following new folder/files:\n\n1├── .Rprofile\n├── renv/\n│   ├── activate.R\n2│   └── settings.json\n3└── renv.lock\n\n\n1\n\n.Rprofile contains a call to source(\"renv/activate.R\"), which manages the project-level dependencies\n\n\n2\n\nrenv settings\n\n\n3\n\nrenv lockfile\n\n\n\n\nWhen using renv in package development, we want to be sure to run renv::install() and renv::update():\n\nrenv::install()\n\n\n- There are no packages to install.\n\n\nrenv::update()\n\n\n- Checking for updated packages ... Done!\n- All packages appear to be up-to-date.\n\n\n\n21.2.4 shiny-deploy.yaml\nWe can include the ‘Shiny App Deployment’ workflow file in sap with usethis::use_github_action(\"shiny-deploy\"):8\n\nusethis::use_github_action(\"shiny-deploy\")\n\n\n✔ Creating '.github/'\n✔ Adding '^\\\\.github$' to '.Rbuildignore'\n✔ Adding '*.html' to '.github/.gitignore'\n✔ Creating '.github/workflows/'\n✔ Saving 'r-lib/actions/examples/shiny-deploy.yaml@v2' to '.github/workflows/shiny-deploy.yaml'\n\nThis example workflow file is designed to deploy a Shiny application to a server. We’re going to make a few changes to shiny-deploy.yaml so it will deploy the application stored in the 16.2_gha-shiny branch.\nThe example shiny workflow includes calls to rsconnect::setAccountInfo() and rsconnect::deployApp(). We’ll perform a sanity check and confirm we can deploy the application using the information we’ve collected:\n\nStart by entering your rsconnect info:\n\ninstall.packages('rsconnect')\nrsconnect::setAccountInfo(\n  name = \"mjfrigaard\",\n  token = \"YOUR TOKEN\", \n  secret = \"YOUR SECRET\")\n\n\nThen try to deploy the application using rsconnect::deployApp():\n\n\nlibrary(sap)\nrsconnect::deployApp(\n  appName = \"shinyAppPkgsCICD\",\n  account = \"mjfrigaard\",\n  server = \"shinyapps.io\",\n  forceUpdate = TRUE)\n\n\nReading the deployment log will tells us if the secret, token, configuration, and lockfile are all working:\n\n\n\n── Preparing for deployment ──────────────────────────────────────────────────\n✔ Deploying \"shinyAppPkgsCICD\" using \"server: shinyapps.io / username: mjfrigaard\"\nℹ Bundling 50 files: .github/workflows/shiny-deploy.yaml, .Rbuildignore, ..., \ntests/testthat.R, and vignettes/test-specs.Rmd\nℹ Capturing R dependencies with renv\n✔ Found 99 dependencies\n✔ Created 2,431,325b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 8130675\n── Deploying to server ─────────────────────────────────────────────────────────\nWaiting for task: 1372980209\n  building: Processing bundle: 8130675\n  building: Building image: 9770352\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 9770352\n  deploying: Starting instances\n  unstaging: Stopping old instances\n── Deployment complete ─────────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://mjfrigaard.shinyapps.io/shinyAppPkgsCICD/&gt;\n\nMaking sure my application will deploy locally with the code I plan on putting in a workflow file makes me confident it run when it’s triggered. Below we’ll adapt the .github/workflows/shiny-deploy.yaml file to deploy sap.\n\n21.2.4.1 Trigger\n\n\n\n\n\n\non:\n  push:\n    branches: [16.2_gha-shiny]\n    \nname: shiny\n\n\n\nThe event we want the workflow triggered on is a push to the 16.2_gha-shiny branch\n\nWe’ll change the name to shiny\n\n\n\n\n\n\n21.2.4.2 Jobs\n\n\n\n\n\n\njobs:\n  shiny-deploy:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n\n\n\njobs remains unchanged, but the identifier should match the name. 9\n\n\n\n\n\n\n21.2.4.3 Steps\n\n\n\n\n\n\n    steps:\n      - uses: actions/checkout@v3\n\n\n\nCheck out the repository code\n\n\n\n\n\n\n\n\n\n\n      - uses: r-lib/actions/setup-pandoc@v2\n\n\n\nSet up Pandoc for document conversions\n\n\n\n\n\n\n\n\n\n\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          use-public-rspm: true\n\n\n\nSet up R environment\na. use-public-rspm is the public RStudio package manager\n\n\n\n\n\n\n\n\n\n\n      - uses: r-lib/actions/setup-renv@v2\n\n\n\nSet up renv to manage the project-specific dependencies captured in renv.lock\n\n\n\n\n\n\n\n\n\n\n      - name: Install rsconnect\n        run: install.packages(\"rsconnect\")\n        shell: Rscript {0}\n\n\n\nInstall rsconnect the step to deploy our app to the Shiny server\na. run installs the rsconnect package\n\n\n\n\nIn the following steps, we’ll provide our account username (ACCOUNT) and a name for our app (shinyAppPkgsCICD). This will deploy an application at https://&lt;ACCOUNT&gt;.shinyapps.io/&lt;APPNAME&gt;/\n\n\n\n\n\n\n    - name: Authorize and deploy app\n      env: \n        APPNAME: shinyAppPkgsCICD\n        ACCOUNT: mjfrigaard\n        SERVER: shinyapps.io \n\n\n\nAuthorize and deploy app defines the step to deploy our Shiny app\n\nenv sets up the environment variables APPNAME, ACCOUNT, and SERVER\n\n\n\n\nThe final run step sets the account information using rsconnect::setAccountInfo() and deploys the app to the specified server using rsconnect::deployApp():\n    run: |\n      rsconnect::setAccountInfo(\"${{ secrets.RSCONNECT_USER }}\", \"${{ secrets.RSCONNECT_TOKEN }}\", \"${{ secrets.RSCONNECT_SECRET }}\")\n      rsconnect::deployApp(appName = \"${{ env.APPNAME }}\", account = \"${{ env.ACCOUNT }}\", server = \"${{ env.SERVER }}\", forceUpdate = TRUE)\n    shell: Rscript {0}\nWhen we add, commit, and push the changes to the repo, we see the following deployment log:\ngit add .\ngit commit -m \"shiny deploy workflow\"\ngit push\n[16.2_gha-shiny 7953a5c] shiny deploy workflow\n 10 files changed, 2130 insertions(+)\n create mode 100644 .Rprofile\n create mode 100644 .github/.gitignore\n create mode 100644 .github/workflows/shiny-deploy.yaml\n create mode 100644 renv.lock\n create mode 100644 renv/.gitignore\n create mode 100644 renv/activate.R\n create mode 100644 renv/settings.json\n create mode 100644 rsconnect/shinyapps.io/mjfrigaard/shinyAppPkgsCICD.dcf\nWe can see the workflow running on the Actions tab of the sap repository:\n\n\n\n\n\n\n\nshiny deploy workflow running\n\n\nWhen it’s finished, we can see the deployment log from the workflow looks similar to the log we saw locally:\n\n\n\n\n\n\n\ndeploy log from workflow\n\n\nYou can view the deployed application here: https://mjfrigaard.shinyapps.io/shinyAppPkgsCICD/",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#sec-gha-shiny-docker",
    "href": "gha.html#sec-gha-shiny-docker",
    "title": "21  GitHub Actions",
    "section": "21.3 Shiny apps & Docker",
    "text": "21.3 Shiny apps & Docker\nWe covered Docker in the previous chapter, which builds and application in an image and containerizes it’s deployment. In this section we’ll combine Docker and GitHub Actions to automate deployment of our app. Automating app deployments will minimize the risk of environmental discrepancies (avoiding the “it works on my machine” problem) and manual deployment processes. Plus, if something goes wrong after a workflow run, rolling back to a previous version in Git is straightforward.\n\n\nLaunch app with the shinypak package:\n\nlaunch('16.3_gha-docker')\n\n\n21.3.1 Secrets and tokens\nMost of the steps below are covered in the excellent blog post by Nicola Rennie10 I’ve updated the contents to work with a Shiny app-package.\nTo make sure our Connect username, token, and secret travels with our Dockerfile, we will need to store them as environmental variables.\nEnvironmental variables can be set/unset with Sys.setenv()/Sys.unsetenv():\n\nSys.setenv(RSCONNECT_USER = '&lt;username&gt;', \n  RSCONNECT_TOKEN = '&lt;token&gt;', \n  RSCONNECT_SECRET = '&lt;secret&gt;')\n\nThese environmental variables are be passed to rsconnect::setAccountInfo() with a deploy.R file.\n\n\n21.3.2 deploy.R\ndeploy.R contains the calls to rsconnect::setAccountInfo() and rsconnect::deployApp() we had in our previous workflow file. Sys.getenv() will retrieve the username, token, and secret stored with Sys.setenv():\n\nsetAccountInfo(name = Sys.getenv(\"RSCONNECT_USER\"),\n               token = Sys.getenv(\"RSCONNECT_TOKEN\"),\n               secret = Sys.getenv(\"RSCONNECT_SECRET\"))\ndeployApp(appDir = \".\", \n  appName = \"shinyAppPkgsDockerCiCd\", \n  account = \"mjfrigaard\", \n    server = \"shinyapps.io\", \n    forceUpdate = TRUE)\n\nThe deploy.R script should be placed in the root folder of sap. By default, this will deploy the application launched with app.R. We’ll change this to the application launched with ggp2_movies_app() by changing the contents of app.R to the following:\n\n\nshow/hide updated app.R\n# set option to turn off loadSupport() ----\nwithr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        library(sap)\n      },\n      error = function(e) {\n        pkgload::load_all()\n      }\n    )\n    # create shiny object from dev/ ----\n    shinyAppDir(appDir = \n                system.file(\"dev\", package = \"sap\"))\n  } else {\n    pkgload::load_all()\n    sap::ggp2_movies_app(options = list(test.mode = FALSE))\n  }\n})\n\n\n\n\n21.3.3 Dockerfile\nThe Dockerfile will look similar to the example in the Docker chapter, but with a few important changes:\n\nThe /home/shinyAppPkgsDockerCiCd directory is not only the image location we’ll be launching the application from, it’s also the URL for the deployed app:\n\nhttps:// username .shinyapps.io/shinyAppPkgsDockerCiCd/\n\nWe’ll include rsconnect and bslib in the list of packages to install.\n\nThe final command runs the application from the deploy.R file\n\nFROM rocker/shiny\nRUN mkdir /home/shinyAppPkgsDockerCiCd\nADD . /home/shinyAppPkgsDockerCiCd\nWORKDIR /home/shinyAppPkgsDockerCiCd\nRUN R -e 'install.packages(c(\"rlang\", \"stringr\", \"shiny\", \"ggplot2\", \"remotes\", \"rsconnect\", \"bslib\"))'\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\nEXPOSE 8180\nCMD Rscript deploy.R\n\n\n21.3.4 docker.yml\n\n\n\n\n\n\nname: docker-shiny, shinyrpkgs\n\non:\n  push:\n    branches: [ 16.3_gha-docker ]\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build image\n        run: docker build -t shinyrpkgs . \n\n\n\nAdd a name for the Docker/Shiny workflow\nSpecify the triggering event the workflow will run on\nThe job will run on ubuntu-latest (with docker id)\nCheckout the code\nBuild the docker image with docker build\n\n\n\n\nThe final execute step is runs docker run and passes our environment variables to the secrets we have stored in GitHub (i.e., with secrets.&lt;SECRET_NAME&gt;):\n      - name: execute\n        run: &gt;\n          docker run -e RSCONNECT_USER=${{ secrets.RSCONNECT_USER }} -e RSCONNECT_TOKEN=${{ secrets.RSCONNECT_TOKEN }}  -e RSCONNECT_SECRET=${{ secrets.RSCONNECT_SECRET }} shinyrpkgs  \n       \n\n\n21.3.5 App dependencies\nrsconnect has a handy appDependencies() function that returns a data.frame of packages, versions, and repositories for your application:\n\nhead(rsconnect:::appDependencies(appDir = \".\"))\n\n\n#&gt;        Package  Version Source               Repository\n#&gt; 1  AsioHeaders 1.22.1-2   CRAN https://cran.rstudio.com\n#&gt; 2         MASS   7.3-60   CRAN https://cran.rstudio.com\n#&gt; 3       Matrix    1.6-4   CRAN https://cran.rstudio.com\n#&gt; 4           R6    2.5.1   CRAN https://cran.rstudio.com\n#&gt; 5 RColorBrewer    1.1-3   CRAN https://cran.rstudio.com\n#&gt; 6         Rcpp   1.0.12   CRAN https://cran.rstudio.com\n\nPassing appDependencies() in your app-package’s root directory will tell you if any packages have missing Source or Repository values (this can cause the deployment to fail).\nI also recommend running attachment::att_amend_desc() to capture all the dependencies in the DESCRIPTION. For example, att_amend_desc() added the following packages to the Suggests field in the DESCRIPTION:11\n[+] 2 package(s) added: shinytest2, testthat.\n\n\n21.3.6 Docker build\nIn the docker workflow log, we can see the commands from our Dockerfile executed to install the necessary packages:\n\n\n\nInstalling R packages from Dockerfile\n\n\nAfter installing the dependencies, the sap.tar.gz is installed from *source*:\n\n\n\nBuilding our app-package from *source*\n\n\nThe output above should look familiar–it’s very similar to what we see when we run devtools::load_all().\n\n\n\n\n\n\nCapturing and recording dependencies with renv\n\n\n\n\n\n\nIn the Shiny workflow example above, we captured the application dependencies with renv. However, in this Docker and Shiny workflow, we didn’t create a renv.lock file or a renv/ folder.\nWe get away with this because when the workflow runs, renv is used to capture the dependencies (line 9-12 in the output below). We see a message about the packages listed in the Suggests field or our DESCRIPTION:\n\n\n\n\n\n\n\nDocker dependencies\n\n\nNot having shinytest2 and testthat packages installed won’t interfere with our application deploying because these packages are listed in the Suggests field in the DESCRIPTION file and are used intests/.\n\n\n\n\nAfter installing the dependencies, we can see the Shiny deployment log execute in the workflow:\n\n\n\n\n\n\n\nDocker deploy log\n\n\nView the deployed application here.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#recap",
    "href": "gha.html#recap",
    "title": "21  GitHub Actions",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: GitHub Actions\n\n\n\n\n\n\n\n\nGitHub Actions can be used to set up the necessary R environment and dependencies required to deploy the application from your app-package, while allowing secure account credentials stored in GitHub secrets.\nThe workflows in this chapter are only triggered by changes to the 16.1_gha-style, 16.2_gha-shiny, and 16.3_gha-docker branches of the sap repository.\nGitHub Actions can streamline a secure deployment process, which allows you to focus more on developing your application.\nRead about GitHub Actions in the rhino framework in this appendix section\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "gha.html#footnotes",
    "href": "gha.html#footnotes",
    "title": "21  GitHub Actions",
    "section": "",
    "text": "This chapter will only cover CI/CD with GitHub Actions. Travis-CI has been around longer than GitHub Actions, and if you’d like to compare the two, I recommend this article.↩︎\nTriggers can be push and/or pull events to specific branches, creating a release, commenting on an issue, or even configured to run at scheduled times.↩︎\nIf name is not provided, GitHub will use the file path↩︎\nWe’ll be covering code styling in the Style chapter.↩︎\nYou can find more examples of common GitHub Actions for R packages in r-lib/actions/examples.↩︎\nGitHub secrets should be specified by the user following the instructions in the Creating secrets for a repository article.↩︎\n“This action assumes you have an renv lockfile in your repository that describes the R packages and versions required for your Shiny application.” - Shiny App Deployment↩︎\nInstructions for the GitHub Action Shiny deployment can be found here↩︎\nrun-on is the latest Ubuntu runner and env is the GITHUB_PAT environment variable is your GitHub personal access token (access a secret with secrets.&lt;SECRET_NAME&gt;)↩︎\nAutomatically deploying a Shiny app for browsing #RStats tweets with GitHub Actions. Nicola Rennie. October 3, 2022.↩︎\natt_amend_desc() adds a dev folder with a YAML config file, but you can remove this before building/deploying.↩︎",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GitHub Actions</span>"
    ]
  },
  {
    "objectID": "pkgdown.html",
    "href": "pkgdown.html",
    "title": "22  pkgdown",
    "section": "",
    "text": "22.1 Setting up pkgdown\nIn this chapter, we’ll cover setting up a pkgdown website for our app-package. Building a package website isn’t required, but it’s a great way to confirm your package is documented and structured correctly, and it gives you an opportunity to share all of your hard work! pkgdown can be configured to automatically generate a beautiful website from a pre-specified Git branch GitHub Actions.\nA pkgdown website makes our Shiny app and its accompanying package more accessible to potential users by providing them with a central location for any information they need (app features, updates, etc.).\nThe magic of pkgdown is it’s conversion of an existing R package structure into a website with documentation for our application.\npkgdown has a usethis function similar to testthat for setup:1\nuse_pkgdown_github_pages() takes care of (most of) the setup for our app-package website, but we’ll break down the steps below.2 I’ve replaced my GitHub username with &lt;username&gt; and the name of the app-package/repository with &lt;pkgName&gt;):",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-setup",
    "href": "pkgdown.html#sec-pkgdown-setup",
    "title": "22  pkgdown",
    "section": "",
    "text": "install.packages(\"pkgdown\")\n\nusethis::use_pkgdown_github_pages()\n\n\n22.1.1 _pkgdown.yml\nThe initial output after running use_pkgdown_github_pages() looks something like the following:\n✔ Setting active project to '/Users/&lt;username&gt;/projects/&lt;pkgName&gt;'\n✔ Adding '^_pkgdown\\\\.yml$', '^docs$', '^pkgdown$' to '.Rbuildignore'\n✔ Adding 'docs' to '.gitignore'\n✔ Writing '_pkgdown.yml'\n• Modify '_pkgdown.yml'\n✔ Recording 'https://&lt;username&gt;.github.io/&lt;pkgName&gt;/' as site's url in '_pkgdown.yml'\n✔ Adding 'https://&lt;username&gt;.github.io/&lt;pkgName&gt;/' to URL\n✔ Setting 'https://&lt;username&gt;.github.io/&lt;pkgName&gt;/' as homepage of GitHub repo '&lt;username&gt;/&lt;pkgName&gt;'\n_pkgdown.yml is initially created with only the url, template, and bootstrap version:\nurl: https://&lt;username&gt;.github.io/&lt;pkgName&gt;/\ntemplate:\n  bootstrap: 5\nThese fields are all that’s required to launch your pkgdown site, but in the following sections we’ll cover how to edit _pkgdown.yml to customize the fonts, colors, contents, and layout of our site.\n\n\n22.1.2 gh-pages branch\nuse_pkgdown_github_pages() sets up publishing our app-package site from an ‘orphan branch from GitHub pages’:\n✔ Initializing empty, orphan 'gh-pages' branch in GitHub repo '&lt;username&gt;/&lt;pkgName&gt;'\n✔ GitHub Pages is publishing from:\n• URL: 'https://&lt;username&gt;.github.io/&lt;pkgName&gt;/'\n• Branch: 'gh-pages'\n\n\n\n\n\n\n Orphan branches\n\n\n\n\n\n\nAn orphan branch is a new Git branch with no commit history, effectively starting a new ‘root’ in our project’s development history. For our app-package, the gh-pages branch serves as a new line of development, completely separated from all other branches.\n\n\n\n\nWe’re also told GitHub pages will be publishing our app-package website at the following URL: https://&lt;username&gt;.github.io/&lt;pkgName&gt;/\n\n\n22.1.3 .github/workflows/\nuse_pkgdown_github_pages() creates a GitHub Action workflow folder (.github/workflows/) with a YAML file (pkgdown.yaml):\n• Path: '/'\n✔ Creating '.github/'\n✔ Adding '^\\\\.github$' to '.Rbuildignore'\n✔ Adding '*.html' to '.github/.gitignore'\n✔ Creating '.github/workflows/'\n✔ Saving 'r-lib/actions/examples/pkgdown.yaml@v2' to '.github/workflows/pkgdown.yaml'\n• Learn more at &lt;https://github.com/r-lib/actions/blob/v2/examples/README.md&gt;.\nWe’re also told the contents in this file are copied from the r-lib/actions repository (which we’ve covered previously in Section 21.1 and Section 21.2).",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-site-contents",
    "href": "pkgdown.html#sec-pkgdown-site-contents",
    "title": "22  pkgdown",
    "section": "22.2 Building site",
    "text": "22.2 Building site\nusethis has two functions for building your pkgdown site:\n\nbuild_site()\nbuild_site_github_pages()\n\nWe used use_pkgdown_github_pages() to configure our app-package, so we’ll use build_site_github_pages() to build our site.\npkgdown::build_site_github_pages()\nIn the following sections, we’ll take a look at how the files and folders in our app-package are used to create the site’s contents. As mentioned above, the great thing about pkgdown sites is that they use our existing package structure to build a beautiful site that’s easy to navigate (with minimal changes).\n\n22.2.1 docs/\nThe docs/ folder contains the .html files for our website (that’s why ^docs$ was added to the .Rbuildignore and docs was added to the .gitignore). After creating a home for our site contents, the site initialization files are copied from the local pkgdown installation into docs/\n== Building pkgdown site ======================================================\nReading from: '/Users/&lt;username&gt;/&lt;pkgName&gt;'\nWriting to:   '/Users/&lt;username&gt;/&lt;pkgName&gt;/docs'\n\n\n22.2.2 README.md -&gt; index.html\nThe landing page (index.html) for our app-package website is built from the README.md file. An example of the site URL is below:\nhttps://&lt;username&gt;.github.io/&lt;pkgName&gt;/index.html\nThe &lt;username&gt; is our GitHub username, and the &lt;pkgName&gt; is the name of our package. The authors.html is built from the Author and Maintainer fields in the DESCRIPTION file. Long-form documentation can be stored in vignettes (Section 1.15.3) which will be converted into articles (covered below).\n\n\n\n\n\n\nStandard README for your app-package\n\n\n\n\n\n\nIf you’d like a boilerplate README.md for an R package, you can use usethis::use_readme_rmd():\nusethis::use_readme_rmd()\n✔ Setting active project to '/Users/&lt;username&gt;/projects/&lt;pkgName&gt;'\n✔ Writing 'README.Rmd'\n✔ Adding '^README\\.Rmd$' to '.Rbuildignore'\n• Modify 'README.Rmd'\n✔ Writing '.git/hooks/pre-commit'\nAt minimum, the README.Rmd should include:\n\nThe purpose/goal of your app-package\n\nInstructions for installation\n\nLinks to a deployed version (if applicable)\n\nSupporting packages\n\nIf I chose to use this README.md file, I usually remove the .git/hooks/pre-commit (so they don’t interfere with my personal add/commit/push process).\nunlink('.git/hooks/pre-commit')\n\n\n\n\n\n\n22.2.3 man/ -&gt; Reference\nThe functions documented in the man/ folder are converted into individual items in the Reference menu item (see Chapter 5). I’ve included two examples below:\n\n\n\n\n\n\nman/\n  ├── display_type.Rd\n  └── ggp2_launch_app.Rd\n\n\n-- Building function reference ---------\nWriting 'reference/index.html'\nReading 'man/display_type.Rd'\nWriting 'reference/display_type.html'\nReading 'man/ggp2_launch_app.Rd'\nWriting 'reference/ggp2_launch_app.html'\n\n\n\n\nFunctions will only be included in the Reference if they’ve been exported (see Section 6.1)\nIf we’ve been thorough in documenting, the @seealso and @family tags will create hyperlinks between our utility functions, modules, UI/server/standalone app functions (see Section 5.2)\nThe @examples will be run and displayed (Section 5.1.6)\n\n\n\n22.2.4 vignettes -&gt; Articles\nAny of the .Rmd in the vignettes folder will be rendered as HTML articles under the Articles menu item. The exception to this is any vignettes with the same name as our app-package (which will automatically be listed under a menu dropdown titled “Get Started”):3\n\n\n\n\n\n\nvignettes/\n  ├── sap.Rmd\n  └── specs.Rmd\n\n\n-- Building articles -------------\nWriting 'articles/index.html'\nReading 'vignettes/sap.Rmd'\nWriting 'articles/sap.html'\nReading 'vignettes/specs.Rmd'\nWriting 'articles/specs.html'\n== DONE ==========================\n\n\n\nThe final step in the build process is to add a .nojekyll file in the repository (this hidden file is necessary for pkgdown sites configured to deploy from GitHub pages).\n-- Extra files for GitHub pages ----------------------------------------------\nWriting '.nojekyll'",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-layouts",
    "href": "pkgdown.html#sec-pkgdown-layouts",
    "title": "22  pkgdown",
    "section": "22.3 Customize site layout",
    "text": "22.3 Customize site layout\nWe can customize the look of our pkgdown site by editing the contents of _pkgdown.yml.\n\n22.3.1 Themes, colors and fonts\nBelow are some examples of the fields that control the bootswatch theme (&lt;THEME&gt;), code syntax highlighting(&lt;HIGHLIGHTING&gt;):\n\n\n\n\n\n\nYAML Fields\ntemplate:\n  bootstrap: 5\n  bootswatch: &lt;THEME&gt;\n  theme: &lt;HIGHLIGHTING&gt;\n\n\nIn _pkgdown.yml\ntemplate:\n  bootstrap: 5\n  bootswatch: united\n  theme: atom-one-light\n\n\n\nWe can use the bslib package for additional control over the fonts and colors on our site. The &lt;COLOR&gt; should be replaced with a color hex, and &lt;FONT&gt; can include any freely available Google fonts.4\n\n\n\n\n\n\nYAML Fields\n  bslib:\n    primary: \"&lt;COLOR&gt;\"\n    code-color: \"&lt;COLOR&gt;\"\n    code-bg: \"&lt;COLOR&gt;\"\n    base_font:\n      google: &lt;FONT&gt;\n    heading_font:\n      google: &lt;FONT&gt;\n    code_font:\n      google: &lt;FONT&gt;\n\n\nIn _pkgdown.yml\n  bslib:\n    primary: \"#007987\"\n    secondary: \"#f5feff\"\n    base_font:\n      google: Ubuntu\n    heading_font:\n      google: Fira Sans Condensed\n    code_font:\n      google: Inconsolata\n\n\n\nYou can see the theme, color, and font choices below:\n\n\n\npkgdown template in yml\n\n\n\n\n22.3.2 Articles\nThe articles should include a link to the landing page for our app, and provide detailed examples of how it works, including links to any additional resources or documentation.\nThe navbar components can also be customized with titles, sections, and article names. In _pkgdown.yml, the articles are listed under components, and we will add a text title (Docs) and sub-heading (Specs):\n\n\n\n\n\n\nIn _pkgdown.yml\nnavbar:\n components:\n   articles:\n    text: Docs\n    menu:\n    - text: \"Specs\"\n\n\nOutput\n\n\n\nNavbar components\n\n\n\n\n\nAny vignette with a filename that matches the package name is automatically named ‘Getting Started’ in the navbar. We can also add sections with article titles by placing them in text fields. These are listed under the menu (note the indentation), with a path to the html file.\n\nBelow I’ve listed the App Specifications vignette under a \"Specs\" section (see Chapter 15), and linked to articles/specs.html:\n\n\n\n\n\n\n\nIn _pkgdown.yml\n    text: Docs\n    menu:\n    - text: \"Specs\"\n    - text: App Specifications\n      href: articles/specs.html\n\n\nOutput\n\n\n\nArticle sections\n\n\n\n\n\nUse ------- with a text field to create horizontal separators between sections (without a corresponding href).\n\nI’ve added a Features section and a Application Features vignette (stored in vignettes/features.Rmd and published to articles/features.html):\n\n\n\n\n\n\n\nIn _pkgdown.yml\n    text: Docs\n    menu:\n    - text: \"Specs\"\n    - text: App Specifications\n      href: articles/specs.html\n    - text: -------\n    - text: \"Features\"\n    - text: App Features\n      href: articles/features.html\n\n\nOutput\n\n\n\nArticles separator\n\n\n\n\n\n\n\n22.3.3 Function reference\npkgdown will automatically generate a Package index section for any object with an .Rd file in the man/ folder. This includes functions we’ve explicitly exported with (i.e., with @export) and functions we’ve documented with @keywords internal.5\nBy default, the function are sorted alphabetically, but we can customize them into sections with titles and descriptions using the fields below in _pkgdown.yml:\nreference:\n- title: \"&lt;TITLE&gt;\"\n  desc: &gt;\n    &lt;DESCRIPTION&gt;\n  contents:\n  - &lt;FUNCTION&gt;\nFor example, we can include a section for the modules we’re exporting from our app-package:\n\n\n\n\n\n\nIn _pkgdown.yml\nreference:\n- title: \"Modules\"\n  desc: &gt;\n    App modules\n\n\nOutput\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCustomizing Reference\n\n\n\n\n\n\nThe _pkgdown.yml file must include all exported functions if you customize the reference field. If not, you’ll see an error when you try to build your site:\n-- Building function reference ------------------------------------\nError in `check_missing_topics()`:\n! All topics must be included in reference index\n✖ Missing topics: &lt;FUN&gt;\nℹ Either add to _pkgdown.yml or use @keywords internal\n\n\n\n\nTo help organize and display the functions in your app-package, we can use tidyselect helpers6 in the bullets below contents.\nFor example, we can list modules with starts_with(\"mod\"):7\n\n\n\n\n\n\nIn _pkgdown.yml\nreference:\n- title: \"Modules\"\n  desc: &gt;\n    Application modules\n  contents:\n  - starts_with(\"mod\")\n\n\nOutput\n\n\n\n\n\n\n\n\nWe can also use _pkgdown.yml to list any datasets we’ve documented (see Section 7.3) in our app-package.\n\n\n\n\n\n\nIn _pkgdown.yml\n- title: \"Data\"\n  desc: \"App data\"\n  contents:\n  - movies\n\n\nOutput",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-workflow",
    "href": "pkgdown.html#sec-pkgdown-workflow",
    "title": "22  pkgdown",
    "section": "22.4 Deploying your site",
    "text": "22.4 Deploying your site\nThe .github/workflows/pkgdown.yaml file automates building and deploying our app-package’s pkgdown site. This workflow file is configured to be triggered by specific GitHub events, build the website using the standard package files, then deploys it to GitHub Pages. Below we’ll breakdown the fields and values of the workflow (and their functions):\n\n22.4.1 Triggers\n\n\n\n\n\n\n1. Set to trigger on pushes or pull_requests made to the main or master branches (we’ll change these to only trigger on the 17_pkgdown branch).\n\n\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n\n\n\n\n\n\n\n\n\n \n\n\na. Also triggers when a release is published, allowing the website to showcase the latest version of the package.8\n\n\n  release:\n    types: [published]\n\n\n\n\n\n\n\n\n\n \n\n\nb. workflow_dispatch allows the workflow to be manually triggered from the GitHub Actions web interface (for ad-hoc updates).9\n\n\n  workflow_dispatch:\n\n\n\n\n\n22.4.2 Jobs\n\n\n\n\n\n\n2. name defines a single job with the ID pkgdown.\n\n\nname: pkgdown\n\n\n\n\n\n\n\n\n\n3. jobs specifies the job ID (pkgdown) and runs the job on the latest Ubuntu runner provided by GitHub Actions.\n\n\njobs:\n  pkgdown:\n    runs-on: ubuntu-latest\n\n\n\n4. The comment # Only restrict concurrency for non-PR jobs refers to the concurrency field,10 which prevents concurrent runs of the job for non-pull request events (avoiding conflicts or redundant deployments). a. group11 uses a dynamic expression to differentiate between pull_request events and github.event_name, using the run ID (github.run_id) for pull requests to allow concurrency.\n    concurrency:\n      group: pkgdown-${{ github.event_name != 'pull_request' || github.run_id }}\n5. env sets the GITHUB_PAT environment variable using the GitHub token, secrets.GITHUB_TOKEN (which allows the workflow to authenticate and perform operations within the repository).\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n\n\n\n\n\n\n6. permissions explicitly grants the workflow write permissions to the repository, enabling it to push changes (like an updated website).\n\n\n    permissions:\n      contents: write\n\n\n\n\n\n22.4.3 Steps\n\n\n\n\n\n\n7. Checks out the repository’s code, making it available to subsequent steps.\n\n\n  steps:\n    - uses: actions/checkout@v4\n\n\n\n\n\n\n\n\n\n8. Installs pandoc, which is necessary for rendering markdown documents and vignettes.\n\n\n    - uses: r-lib/actions/setup-pandoc@v2\n\n\n\n\n\n\n\n\n\n9. Sets up the R environment and configures it to use the public RStudio package manager (use-public-rspm) for faster package installations.\n\n\n    - uses: r-lib/actions/setup-r@v2\n      with:\n        use-public-rspm: true\n\n\n\n\n\n\n\n\n\n10. Installs the dependencies required by our app-package and pkgdown.\n\n\n    - uses: r-lib/actions/setup-r-dependencies@v2\n\n\n\n\n\n\n\n\n\n \n\n\na. Specifies installing any::thing from pkgdown and the local:: package (our app-package).12\n\n\n      with:\n        extra-packages: any::pkgdown, local::.\n        needs: website\n\n\n\n11. Executes pkgdown::build_site_github_pages() within an R script shell to build the pkgdown website. It’s configured not to start a new R process for the build and not to install our app-package (assuming dependencies are already handled in step 10).\n    - name: Build site\n      run: pkgdown::build_site_github_pages(new_process = FALSE, install = FALSE)\n      shell: Rscript {0}\n12. Uses JamesIves/github-pages-deploy-action@v4.5.0 to deploy the site to GitHub Pages (provided the event is not a pull request).\n    - name: Deploy to GitHub pages 🚀\n      if: github.event_name != 'pull_request'\n      uses: JamesIves/github-pages-deploy-action@v4.5.0\n\n\n\n\n\n\n \n\n\na. Specifies not to clean the deployment branch, deploys it to the gh-pages branch, and sets the site content source folder to docs\n\n\n      with:\n        clean: false\n        branch: gh-pages\n        folder: docs\n\n\n\n.github/workflows/pkgdown.yaml performs more operations than the previous workflows. However, these extra steps allow us to use the gh-pages branch to maintain and showcase up-to-date package documentation for users, contributors, and collaborators. When we’re happy with the layout of our website in _pkgdown.yml, we can add, commit, and push the changes back to the repo:\ngit add .\ngit commit -m \"updates to _pkgdown.yml\"\ngit push",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#sec-pkgdown-github",
    "href": "pkgdown.html#sec-pkgdown-github",
    "title": "22  pkgdown",
    "section": "22.5 GitHub",
    "text": "22.5 GitHub\nBack in GitHub, we can see our previous Style (Section 21.1), shiny (Section 21.2), and docker-shiny, moviesapp (Section 21.3) workflows:\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('17_pkgdown')\n\nAfter pushing the changes to the 17_pkgdown branch, a new workflow is created and run in the Actions tab:\n\n\n\nWorkflow created on push to 17_pkgdown branch\n\n\nThe workflow file triggers the following steps:\n\n\n\nGitHub Pages Deploy Action\n\n\n\nThe process begins with checking the necessary configurations for deployment and using the Deploy Token… 🔑 for authentication.\nChecking configuration and starting deployment… 🚦\nDeploying using Deploy Token… 🔑\nGit is set up and configured (similar to a new user) with user credentials (&lt;username&gt; and &lt;username&gt;@pm.me), but also includes:\n\nsetting up a safe directory (--add safe.directory),\nignoring case (config core.ignorecase false),\nremoving any extra headers (http.https://github.com/.extraheader), and\nadding remote origin to point to the GitHub repository where the sap package resides (remote add origin).\n\nConfiguring git…\n/usr/bin/git config --global --add safe.directory /home/runner/work/&lt;pkgName&gt;/&lt;pkgName&gt;\n/usr/bin/git config user.name &lt;username&gt;\n/usr/bin/git config user.email &lt;username&gt;@pm.me\n/usr/bin/git config core.ignorecase false\n/usr/bin/git config --local --unset-all http.https://github.com/.extraheader\n/usr/bin/git remote rm origin\n/usr/bin/git remote add origin ***github.com/&lt;username&gt;/&lt;pkgName&gt;.git\nGit configured… 🔧\nThe workflow checks for an existing gh-pages branch in the repository (which is the branch we’ve configured to serve the website content).\nStarting to commit changes…\n/usr/bin/git ls-remote --heads ***github.com/&lt;username&gt;/&lt;pkgName&gt;.git refs/heads/gh-pages\n7cac1013e4a324d943d2b33ed6d52f0cf6b243a6    refs/heads/gh-pages\nA Git worktree13 is created for the gh-pages branch, which allows multiple branches within the same repository (without having to clone the repository again).\n\nThe worktree is prepared in a detached HEAD state, and then the gh-pages branch is checked out:\n\nCreating worktree…\n/usr/bin/git fetch --no-recurse-submodules --depth=1 origin gh-pages\nFrom https://github.com/&lt;username&gt;/&lt;pkgName&gt;\n * branch            gh-pages   -&gt; FETCH_HEAD\n * [new branch]      gh-pages   -&gt; origin/gh-pages\n/usr/bin/git worktree add --no-checkout --detach github-pages-deploy-action-temp-deployment-folder\nPreparing worktree (detached HEAD 742bb18)\n/usr/bin/git checkout -B gh-pages origin/gh-pages\nThe website content generated by pkgdown in the docs directory is copied into the worktree directory, ensuring that all necessary files are updated with the latest changes:\n\nchmod is used to ‘change access permissions’14\n\n-R applies the permission changes to the directory specified and to all of the subdirectories and files\n\n+rw adds both read and write permissions for the user, group, and others to the files/directories targeted by this command\n\n/usr/bin/chmod -R +rw /home/runner/work/&lt;pkgName&gt;/&lt;pkgName&gt;/docs\n/usr/bin/rsync -q -av --checksum --progress /home/runner/work/&lt;pkgName&gt;/&lt;pkgName&gt;/docs/. github-pages-deploy-action-temp-deployment-folder --exclude .ssh --exclude .git --exclude .github\nThe changes are added, committed, and then force-pushed to the gh-pages branch:\n\nThe content is updated to reflect the latest version of the website associated the sap R package\n\nThe commit message includes a deployment tag and the hash of the commit from the deployment\n\nChecking if there are files to commit…\n/usr/bin/git add --all .\n/usr/bin/git checkout -b github-pages-deploy-action/kpvxdgnej\nSwitched to a new branch 'github-pages-deploy-action/kpvxdgnej'\nForce-pushing changes...\n/usr/bin/git push --force ***github.com/&lt;username&gt;/&lt;pkgName&gt;.git github-pages-deploy-action/kpvxdgnej:gh-pages\nTo https://github.com/&lt;username&gt;/&lt;pkgName&gt;.git\n   7cac101..aab5105  github-pages-deploy-action/kpvxdgnej -&gt; gh-pages\nChanges committed to the gh-pages branch… 📦\nAfter successfully pushing the changes to the gh-pages branch, the workflow performs cleanup jobs:\n\nreset the branch pointer, and\n\nremove the temporary worktree directory\n\nRunning post deployment cleanup jobs… 🗑️\n/usr/bin/git checkout -B github-pages-deploy-action/kpvxdgnej\nReset branch 'github-pages-deploy-action/kpvxdgnej'\n/usr/bin/chmod -R +rw github-pages-deploy-action-temp-deployment-folder\n/usr/bin/git worktree remove github-pages-deploy-action-temp-deployment-folder --force\nThe workflow finishes and signals the deployment has been successfully completed.\nCompleted deployment successfully! ✅\n\nBack in the Actions tab, we see a new pages build and deployment workflow has been created with a ‘bot’ tag:\n\nThe updates to _pkgdown.yml workflow represents the changes we committed and pushed to the 17_pkgdown branch (#10), but we configured our website to be served from the gh-pages branch (#11). Each time we push changes to 17_pkgdown and trigger the pkgdown workflow, a corresponding pages build and deployment workflow will be triggered to build and deploy the site:\n\n\n\nBuild and deploy pkgdown site\n\n\nThis automated deployment process is essential for maintaining up-to-date documentation or website content for R packages (like sap) without manual intervention, making it easier for developers to focus on development while ensuring that users always have access to the latest information.\nView the package website here.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#recap",
    "href": "pkgdown.html#recap",
    "title": "22  pkgdown",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: \n\n\n\n\n\n\n\npkgdown is handy for creating beautiful, functional websites for your app-package. Package sites help share your app-package with others in a more engaging and informative way.\n\nInstallation\ninstall.packages('pkgdown)`\nSetup: create a configuration file that pkgdown will use to build your site with one of the usethis functions below:\nusethis::use_pkgdown_github_pages()\n# or\n# usethis::use_pkgdown() \n\nThese create a _pkgdown.yml configuration file that lets us customize how our site looks and which parts of our app-package are diplayed/highlighted.\n\nCustomize: we can change our pkgdown site theme, set colors and fonts, organize the navigation bar, and add custom sections and pages. For an app-package, this means we can create a landing page for our Shiny app, provide detailed articles on how it works, and link to any additional resources or documentation.\nBuilding Your Site\npkgdown::build_site_github_pages()\n# or \n# pkgdown::build_site()\nbuild_site_github_pages() goes through our app-package (function documentation, and examples, RMarkdown vignettes, README, NEWS, etc.) and assembles a coherent, navigable site.\nDeploying Your Site: after building a pkgdown site, we can use GitHub Actions to upload the generated website contents to GitHub Pages, which hosts our app-package site directly from a GitHub repository.",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "pkgdown.html#footnotes",
    "href": "pkgdown.html#footnotes",
    "title": "22  pkgdown",
    "section": "",
    "text": "usethis also has a generic function for using pkgdown (use_pkgdown()), but we’re going to cover building and deploying our app-package site using GitHub pages. Read more about use_pkgdown() in the usethis documentation.↩︎\nInternally, this function calls usethis::use_pkgdown(), usethis::use_github_pages(), and usethis::use_github_action(\"pkgdown\"). Read more in the usethis documentation.↩︎\nI created this vignette with usethis::use_vignette(\"sap\") and included instructions for launching the various apps in sap.↩︎\nRead more about bslib in pkgdown sites in the documentation.↩︎\nFunctions with @keywords internal aren’t listed in the package index, but can be accessed with pkg:::fun() (like the test_logger() function in sap).↩︎\nRead more about how to build the function reference here↩︎\nUsing the mod_ as a prefix for module functions is a habit I’ve adopted from the golem package (specifically, the add_module() function).↩︎\n“You can create releases to bundle and deliver iterations of a project to users.”↩︎\n“To enable a workflow to be triggered manually, you need to configure the workflow_dispatch event.”↩︎\n“Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time.”↩︎\n“Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.”↩︎\nThe needs: website fields might be a placeholder? I’m unaware of the needs keyword applied within a with clause for setting up dependencies. This also could be intended as a comment or note for future adjustments…↩︎\n“A git repository can support multiple working trees, allowing you to check out more than one branch at a time.”↩︎\n“chmod changes the permissions of each given file according to mode, where mode describes the permissions to modify.”↩︎",
    "crumbs": [
      "Deploy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>pkgdown</span>"
    ]
  },
  {
    "objectID": "frameworks.html",
    "href": "frameworks.html",
    "title": "Frameworks",
    "section": "",
    "text": "Shiny frameworks\nThis section covers four popular Shiny frameworks:\nFor a complete description of how each application was created, see the Shiny frameworks supplemental website.",
    "crumbs": [
      "Frameworks"
    ]
  },
  {
    "objectID": "frameworks.html#shiny-frameworks",
    "href": "frameworks.html#shiny-frameworks",
    "title": "Frameworks",
    "section": "",
    "text": "gap\ngap is a golem app-package\n\n\n\n\n\n\n\n\n\nChapter 22 Applications\n\n\n\n\n\n\nThe applications in Chapter 22 (golem) can be accessed with the launch() or get() functions from the shinypak R package:\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\nlibrary(shinypak)\n\nChapter 22 applications:\n\nlist_apps(regex = '^22')\n## # A tibble: 1 × 2\n##   branch     last_updated       \n##   &lt;chr&gt;      &lt;dttm&gt;             \n## 1 22_pkgdown 2024-08-23 07:16:31\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlap\nlap is a leprechaun app-package\n\n\n\n\n\n\n\n\n\nChapter 23 Applications\n\n\n\n\n\n\nThe applications in Chapter 23 (leprechaun) can be accessed with the launch() or get() functions from the shinypak R package:\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\nlibrary(shinypak)\n\nChapter 23 applications:\n\nlist_apps(regex = '^23')\n## # A tibble: 1 × 2\n##   branch   last_updated       \n##   &lt;chr&gt;    &lt;dttm&gt;             \n## 1 23_golem 2024-08-23 07:47:08\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrap\nrap is a rhino app (pseudo-package)1\n\n\n\n\n\n\n\n\n\nChapter 24 Applications\n\n\n\n\n\n\nThe applications in Chapter 24 (rhino) can be accessed with the launch() or get() functions from the shinypak R package:\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\nlibrary(shinypak)\n\nChapter 24 applications:\n\nlist_apps(regex = '^24')\n## # A tibble: 1 × 2\n##   branch        last_updated       \n##   &lt;chr&gt;         &lt;dttm&gt;             \n## 1 24_leprechaun 2024-09-03 14:24:11",
    "crumbs": [
      "Frameworks"
    ]
  },
  {
    "objectID": "frameworks.html#footnotes",
    "href": "frameworks.html#footnotes",
    "title": "Frameworks",
    "section": "",
    "text": "rhino apps aren’t R packages–they’re dependencies are managed with a dependencies.R file and box modules.↩︎",
    "crumbs": [
      "Frameworks"
    ]
  },
  {
    "objectID": "golem.html",
    "href": "golem.html",
    "title": "23  golem",
    "section": "",
    "text": "23.1 gap (a golem app-package)\nThis chapter walks through building a version of the sap with the golem framework. The resulting app-package (gap) is in the 18_golem branch.\nThe version/description of golem used in this Shiny app-package is:\nAfter checking out the 18_golem branch, be sure to load, document, and install the application.\ngap exports the movies data and the standalone app function, run_app().\nlibrary(gap)\ngap::run_app()\nIn the sections below, I’ll note various features and workflows that differ from standard package (or app-package) development.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#gap-a-golem-app-package",
    "href": "golem.html#gap-a-golem-app-package",
    "title": "23  golem",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('18_golem')\n\n\n\n\n\n\n\n\n\n\n(a) gap movies app\n\n\n\n\n\nFigure 23.1: After loading, documenting, and installing gap, launch the movies with run_app()",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#dev-scripts",
    "href": "golem.html#dev-scripts",
    "title": "23  golem",
    "section": "23.2 dev scripts",
    "text": "23.2 dev scripts\nNew golem apps have a dev/ folder with scripts for setting up your application, development, and launching/deploying.\n\ndev\n├── 01_start.R\n├── 02_dev.R\n└── 03_deploy.R\n\nThe package website has each script available in vignettes: 01_start, 02_dev, 03_deploy",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#set-up",
    "href": "golem.html#set-up",
    "title": "23  golem",
    "section": "23.3 Set up",
    "text": "23.3 Set up\nThe dev/01_start.R file opens when the new golem app-package launches. Following the steps in 01_start.R sets up the following files, folders, and options in your golem app-package:\n\nDESCRIPTION: golem has a custom function for entering many of the fields we covered in the Packages chapter 1\ngolem has functions that automatically set multiple options in the golem-config.yml 2 and package dependencies 3\nusethis functions are called for a LICENSE4, creating (and building5) a README6 a CODE_OF_CONDUCT.md7, adding a Lifecycle badge8, and the NEWS.md file.9 Many of these functions and files are covered in the Whole App Game chapter.\nIf you aren’t using Git, there’s an option to initiate a Git repo 10\nThe testing infrastructure is set up using the custom golem::use_recommended_tests() function, which creates the necessary testthat folders we covered in the Test suite chapter 11, but also adds a collection of boilerplate tests.\ngolem apps also have custom functions for creating a series of UI 12 and server 13 utility functions (and their accompanying tests).",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#development",
    "href": "golem.html#development",
    "title": "23  golem",
    "section": "23.4 Development",
    "text": "23.4 Development\nAfter setting up the golem app-package with dev/01_start.R, the dev/02_dev.R file opens and contains the following functions/options for developing your application.\n\nPackage dependencies: imports are managed with the attachment package14\n\n\nCode files: new code files in golem apps can be created with a variety of helper functions. \n\nModules: add_module() adds a .R file with a mod_ prefix (an optional test can be included with the with_test = TRUE argument) \nUtility functions: utility functions can be added with add_utils() or add_fct() (also include the with_test option for tests). golem_utils_* files contain commonly used UI and server functions. \nThe primary app UI and server functions are stored in R/app_ui.R and R/app_server.R. \nThe standalone app function is stored in R/run_app.R. \nR/_disable_autoload.R disables shiny::loadSupport() (an option we covered in the Launch chapter) \nR/app_config.R contains configuration functions:\n\n\napp_sys() is a wrapper for system.file() \nget_golem_config() reads environment variables (i.e., GOLEM_CONFIG_ACTIVE) and the contents of inst/golem-config.yml:\n\n\n\n\nR\n1├── _disable_autoload.R\n2├── app_config.R\n3├── app_server.R\n├── app_ui.R\n4├── data.R\n5├── golem_utils_server.R\n├── golem_utils_ui.R\n6├── mod_scatter_display.R\n7├── mod_var_input.R\n8├── utils_mod_scatter_display.R\n9├── utils_tests.R\n10└── run_app.R\n\n1 directory, 11 files\n\n\n1\n\nTurn off loadSupport()\n\n\n2\n\nConfigure app functions\n\n3\n\nApp UI and server functions\n\n\n4\n\nData documentation\n\n\n5\n\ngolem utility functions\n\n\n6\n\nScatter plot module\n\n\n7\n\nVariable input module\n\n8\n\nScatter plot utility function (scatter_plot())\n\n9\n\nTest utility function (test_logger())\n\n10\n\nStandalone app function\n\n\n\n\n\nExternal files: adding external files is handled with golem_add_external_resources(), which uses the same methods we covered in the Resources chapter.15\n\n\nWORDLIST: includes the word ‘golem’ and is an artifact from spellcheck argument in use_recommended_tests(). 16 \napp/ contains the application files. 17 \nextdata/ contains the external data files. 18 \ngolem-config.yml is used to set various configuration options. 19\n\n\n\ninst\n├── WORDLIST\n├── app\n│   └── www\n│       ├── favicon.ico\n│       ├── golem-hex.png\n│       └── shiny.png\n├── extdata\n│   ├── movies.RData\n│   └── tidy_movies.fst\n└── golem-config.yml\n\n4 directories, 7 files\n\n\nData: the data in golem app-packages function like the data folder and files in a standard R package we covered in the Data chapter. \n\ndata/: contains the movies.rda file used in the application \ndata-raw/: movies.R reads in data-raw/movies.RData and creates data/movies.rda \n\ntidy_movies.R reads in the ggplot2movies::movies data and creates the inst/extdata/tidy_movies.fst data.\n\n\n\n\ndata\n└── movies.rda\n\n1 directory, 1 file\n\n\ndata-raw\n├── movies.R\n├── movies.RData\n└── tidy_movies.R\n\n1 directory, 2 files\n\n\nDocumentation: the roxygen2 documentation in golem app-package files comes with boilerplate tags and descriptions similar to those covered in the Documentation chapter. \n\nman/: By default, modules created with add_module() aren’t exported 20 \nvignettes/: Package vignettes in golem app-packages operate like vignettes in standard R packages.\n\n\n\nman\n1├── app_server.Rd\n├── app_ui.Rd\n2├── golem_add_external_resources.Rd\n3├── mod_scatter_display_server.Rd\n├── mod_scatter_display_ui.Rd\n├── mod_plot_ui.Rd\n├── mod_var_input_server.Rd\n├── mod_var_input_ui.Rd\n4├── movies.Rd\n5├── run_app.Rd\n6├── scatter_plot.Rd\n7└── test_logger.Rd\n\n1 directory, 12 files\n\n\n1\n\nPrimary UI and server functions (‘pre-packaged’ in golem apps)\n\n2\n\nExternal resources utility function (‘pre-packaged’ in golem apps)\n\n\n3\n\nModules\n\n4\n\nData documentation\n\n5\n\nThe ‘pre-packaged’ standalone app function (only export from golem apps)\n\n\n6\n\nPlot utility function (exported from gap)\n\n\n7\n\nTest utility function\n\n\n\n\n\nvignettes/\n└── tests_and_coverage.Rmd\n\n1 directory, 1 file",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#tests",
    "href": "golem.html#tests",
    "title": "23  golem",
    "section": "23.5 Tests",
    "text": "23.5 Tests\ngolem applications provide a lot of boilerplate tests.\n\ntests\n1├── README.md\n2├── spelling.R\n├── testthat\n│   ├── _snaps\n3│   ├── fixtures\n│   │   ├── make-tidy_ggp2_movies.R\n│   │   └── tidy_ggp2_movies.rds\n4│   ├── helper.R\n5│   ├── setup-shinytest2.R\n6│   ├── test-app-feature-01.R\n7│   ├── test-golem-recommended.R\n8│   ├── test-golem_utils_server.R\n9│   ├── test-golem_utils_ui.R\n10│   ├── test-mod_scatter_display.R\n11│   ├── test-mod_var_input.R\n12│   ├── test-shinytest2.R\n13│   └── test-utils_mod_scatter_display.R\n└── testthat.R\n\n4 directories, 15 files\n\n\n1\n\nCreated from covrpage package\n\n\n2\n\nCreated from spelling package\n\n\n3\n\nTest fixtures\n\n\n4\n\nTest helpers\n\n\n5\n\nSetting up shinytest2\n\n\n6\n\nshinytest2 feature test\n\n\n7\n\nCreated with: golem::use_recommended_tests()\n\n8\n\nCreated with: golem::use_utils_ui(with_test = TRUE)\n\n9\n\nCreated with: golem::use_utils_server(with_test = TRUE)\n\n10\n\nCreated with: golem::add_module(name = 'scatter_display', with_test = TRUE)\n\n11\n\nCreated with: golem::add_module(name = 'var_input', with_test = TRUE)\n\n12\n\nTest recording from shinytest2::record_test()\n\n\n13\n\nUtility function test (scatter_plot())\n\n\n\n\n\nTests: The testing framework for golem app-packages is set up with golem::use_recommended_tests() in the dev/01_start.R script.21 \n\nA tests/README.md file is created by the covrpage package 22 \ntests/spelling.R adds functionality from the spelling package 23 \ntestthat: The two golem utility function files (golem_utils_server.R, and golem_utils_ui.R) have accompanying tests files. \n\nThe with_test argument creates test files for modules and utility functions. 24\n\n\n\n\n23.5.1 Unit tests\nI’ve converted the tests from the previous chapters for the modules and utility functions in gap:\n\ntest-golem-recommended.R contains tests for the functions included in your new golem app (app_ui(), app_sys(), etc.)\ntest-golem_utils_server.R contains utility functions that might be useful in the server\ntest-golem_utils_ui.R contains utility functions that might be useful in the ui\nThe tests for scatter_plot() is in the test-utils_mod_scatter_display.R file.\n\n\n\n23.5.2 Module tests\n\nThe communication between mod_var_input_server() and mod_scatter_display_server() are in test-mod_var_input.R and test-mod_scatter_display.R\n\n\n\n23.5.3 System tests\nThe two system tests are in test-shinytest2.R and test-app-feature-01.R:\n\ntest-shinytest2.R is the initial resulting test from shinytest2::record_test() covered in System tests\ntest-app-feature-01.R contains feature tests\n\n\n\n\n\n\n\nloadSupport() warning with shinytest2\n\n\n\n\n\n\nAfter setting up shinytest2, the tests/testthat/setup-shinytest2.R file contains a call to shinytest2::load_app_env(). This runs automatically with shinytest2 tests and produces a familiar warning:\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears\n  to contain an R package. Sourcing files in R/ may cause unexpected behavior.\nWe covered this warning message in the Launch chapter, and it’s being addressed in a future release of shinytest2",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#deployment",
    "href": "golem.html#deployment",
    "title": "23  golem",
    "section": "23.6 Deployment",
    "text": "23.6 Deployment\nWhen you’re ready to deploy your golem app, the dev/03_deploy.R file contains a ‘pre deployment checklist’ with multiple options for deploying your application.\n\n23.6.1 Posit platforms\n\ndevtools::check() and devtools::build() are called.25\ngolem has functions for RStudio Connect, shinyapps.io, and Shiny server,26 as well as options for deploying your application using rsconnect::deployApp(). 27\n\n\n\n23.6.2 Docker\ngolem has multiple options for creating Docker files:\n\ngolem::add_dockerfile() adds the following Dockerfile:\n\n\nshow/hide Dockerfile\nFROM rocker/verse:4.3.2\nRUN apt-get update && apt-get install -y  libcurl4-openssl-dev libicu-dev libssl-dev libxml2-dev make pandoc zlib1g-dev && rm -rf /var/lib/apt/lists/*\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/\nRUN echo \"options(repos = c(CRAN = 'https://cran.rstudio.com/'), download.file.method = 'libcurl', Ncpus = 4)\" | tee /usr/local/lib/R/etc/Rprofile.site | tee /usr/lib/R/etc/Rprofile.site\nRUN R -e 'install.packages(\"remotes\")'\nRUN Rscript -e 'remotes::install_version(\"glue\",upgrade=\"never\", version = \"1.6.2\")'\nRUN Rscript -e 'remotes::install_version(\"rlang\",upgrade=\"never\", version = \"1.1.2\")'\nRUN Rscript -e 'remotes::install_version(\"stringr\",upgrade=\"never\", version = \"1.5.1\")'\nRUN Rscript -e 'remotes::install_version(\"knitr\",upgrade=\"never\", version = \"1.45\")'\nRUN Rscript -e 'remotes::install_version(\"waldo\",upgrade=\"never\", version = \"0.5.2\")'\nRUN Rscript -e 'remotes::install_version(\"shiny\",upgrade=\"never\", version = \"1.8.0\")'\nRUN Rscript -e 'remotes::install_version(\"rmarkdown\",upgrade=\"never\", version = \"2.25\")'\nRUN Rscript -e 'remotes::install_version(\"config\",upgrade=\"never\", version = \"0.3.2\")'\nRUN Rscript -e 'remotes::install_version(\"spelling\",upgrade=\"never\", version = \"2.2.1\")'\nRUN Rscript -e 'remotes::install_version(\"shinytest2\",upgrade=\"never\", version = \"0.3.1\")'\nRUN Rscript -e 'remotes::install_version(\"ggplot2movies\",upgrade=\"never\", version = \"0.0.1\")'\nRUN Rscript -e 'remotes::install_version(\"logger\",upgrade=\"never\", version = \"0.2.2\")'\nRUN Rscript -e 'remotes::install_version(\"golem\",upgrade=\"never\", version = \"0.4.1\")'\nRUN Rscript -e 'remotes::install_version(\"ggplot2\",upgrade=\"never\", version = \"3.4.4\")'\nRUN Rscript -e 'remotes::install_github(\"rstudio/htmltools@a8a3559edbfd9dda78418251e69273fa9dfeb9bc\")'\nRUN Rscript -e 'remotes::install_github(\"r-lib/testthat@fe50a222c62cc8733b397690caf3b2a95856f902\")'\nRUN mkdir /build_zone\nADD . /build_zone\nWORKDIR /build_zone\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\nRUN rm -rf /build_zone\nEXPOSE 80\nCMD R -e \"options('shiny.port'=80,shiny.host='0.0.0.0');library(gap);gap::run_app()\"\n\n\ngolem::add_dockerfile_with_renv() creates a tmp/deploy folder and adds the following files:\n\n\ndeploy/\n  ├── Dockerfile\n  ├── Dockerfile_base\n  ├── README\n  ├── gap_0.0.0.9000.tar.gz\n  └── renv.lock.prod\n\n\nREADME\n\ndocker build -f Dockerfile_base --progress=plain -t gap_base .\ndocker build -f Dockerfile --progress=plain -t gap:latest .\ndocker run -p 80:80 gap:latest\n# then go to 127.0.0.1:80\n\nDockerfile\n\n\nshow/hide Dockerfile\nFROM gap_base\nCOPY renv.lock.prod renv.lock\nRUN R -e 'renv::restore()'\nCOPY gap_*.tar.gz /app.tar.gz\nRUN R -e 'remotes::install_local(\"/app.tar.gz\",upgrade=\"never\")'\nRUN rm /app.tar.gz\nEXPOSE 80\nCMD R -e \"options('shiny.port'=80,shiny.host='0.0.0.0');library(gap);gap::run_app()\"\n\n\nDockerfile_base\n\n\nshow/hide Dockerfile_base\nFROM rocker/verse:4.3.2\nRUN apt-get update -y && apt-get install -y  make zlib1g-dev git libicu-dev && rm -rf /var/lib/apt/lists/*\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/\nRUN echo \"options(renv.config.pak.enabled = FALSE, repos = c(CRAN = 'https://cran.rstudio.com/'), download.file.method = 'libcurl', Ncpus = 4)\" | tee /usr/local/lib/R/etc/Rprofile.site | tee /usr/lib/R/etc/Rprofile.site\nRUN R -e 'install.packages(\"remotes\")'\nRUN R -e 'remotes::install_version(\"renv\", version = \"1.0.3\")'\nCOPY renv.lock.prod renv.lock\nRUN R -e 'renv::restore()'\n\n\ngap_0.0.0.9000.tar.gz is a compressed version of our app-package to deploy in the Docker container.\nrenv.lock.prod is a JSON file with a list of packages used in our app-package.\n\nYou can read more details about deploying with Docker on the Shiny Frameworks supplemental website.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#summary-of-golem-features",
    "href": "golem.html#summary-of-golem-features",
    "title": "23  golem",
    "section": "23.7 Summary of golem features",
    "text": "23.7 Summary of golem features\ngolems helper functions and dev scripts make application development fast–I was able to create gap quickly, and all of the supporting packages (covrpage, attachment, spelling) make the development process faster/easier:\n\nThe two modules (mod_plot and mod_var) are easily created with add_module(), the utility function with add_utils()\n\nWe can easily add the modules to the app_ui() and app_server()\n\nApp images are moved into inst/app/www/\n\nThe movies data was added to inst/extdata/, then read into data/ folder with the data-raw/movies.R file.\nFor documentation, the attachment::att_amend_desc() function quickly captures any dependencies\n\nFinally, I loaded, documented, and installed the gap package and ran the application with gap::run_app()\n\nIf you’ve followed along with the preceding chapters, the golem framework will be familiar. In essence, golem takes many of the package development steps we’ve covered and bundles them into wrapper functions (i.e., add_module() is similar to running usethis::use_r() and usethis::use_test(), then adding an roxygen2 skeleton).",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#dependencies",
    "href": "golem.html#dependencies",
    "title": "23  golem",
    "section": "23.8 Dependencies",
    "text": "23.8 Dependencies\nIt’s also worth noting that using the golem framework adds golem as a dependency:\n\n# in the 18_golem branch of sap\npak::local_deps_explain(deps = 'golem', root = \".\")\n\ngap -&gt; golem \n\n23.8.1 gap dependencies\n\n\n\n\n\n\n\n\n\n\nSee the 09d_inst-prod branch of sap.\n\nFor comparison, this is the sap dependency tree (note that using devtools/usethis doesn’t make our app-package depend on these packages).\n\n# in the 09d_inst-prod branch of sap\npak::local_deps_explain(deps = 'devtools', root = \".\")\n\nx devtools\n\n# in the 09d_inst-prod branch of sap\npak::local_deps_explain(deps = 'usethis', root = \".\")\n\nx usethis",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#recap",
    "href": "golem.html#recap",
    "title": "23  golem",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRECAP   \n\n\n\n\n\n\n\nThe golem framework is a huge time saver if you’re familiar with R package development (and you’d prefer if many of these steps were bundled and optimized for ‘production grade’ Shiny apps). However, if you’re not familiar with package development, you might end up with app-packages that have bugs you can’t diagnose or fix.\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "golem.html#footnotes",
    "href": "golem.html#footnotes",
    "title": "23  golem",
    "section": "",
    "text": "Fields are filled with golem::fill_desc()↩︎\nOptions are set with with golem::set_golem_options()↩︎\nDependencies are installed with golem::install_dev_deps()↩︎\nCreated using usethis::use_mit_license()↩︎\nBuilt using devtools::build_readme()↩︎\nCreated using usethis::use_readme_rmd()↩︎\nCreated using usethis::use_code_of_conduct()↩︎\nCreated using usethis::use_lifecycle_badge()↩︎\nCreated using usethis::use_news_md()↩︎\nInitialize Git using usethis::use_git()↩︎\nThe tests/ folder and testthat files are included with golem::use_recommended_tests()↩︎\nCreate UI utility functions using golem::use_utils_ui()↩︎\nCreate server utility functions using golem::use_utils_server()↩︎\nattachment::att_amend_desc() parses the code under R/ and make sure the DESCRIPTION file is up-to-date↩︎\ngolem_add_external_resources() is a wrapper for golem::add_resource_path(), which is a wrapper for shiny::addResourcePath() (and app_sys() is a wrapper for system.file()).↩︎\nThe use_recommended_tests() is run in the dev/01_start.R file and if spellcheck is TRUE, creates the tests/spelling.R file and the inst/WORDLIST file.↩︎\nthe app/ folder is used to add external resources to the application (similar to the previous versions of sap).↩︎\nThis contains the RData file for the original movies data and the exported tidy_movies.fst file.↩︎\ngolem apps use a golem-config.yml file for setting various options. These are initially set with set_golem_options() (and based on the config package)↩︎\nThe noRd tag is added to module files created with add_module(), but you can export these functions by setting the export argument to TRUE. @importFrom is used to import NS() and tagList().↩︎\ntest-golem-recommended.R contains the recommended tests for app_ui(), app_server(), app_sys(), and golem-config.yml↩︎\nThe covrpage package is not on CRAN, but the development version always seems to work. Create the tests/README.md file with covrpage::covrpage().↩︎\nThe spelling package will spell check vignettes, packages, etc.↩︎\nwith_test = TRUE) adds tests in the dev/01_start.R script. Code files created with golem::add_module(), golem::add_utils(), and golem::add_fct() will also include a test file if with_test is set to TRUE.↩︎\nThis also includes a call to rhub::check_for_cran(), which may or may not be of concern for your application.↩︎\nThese functions will create and app.R file to launch and deploy your application.↩︎\nIncludes boilerplate for appName, appTitle, appFiles, etc.↩︎",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>golem</span>"
    ]
  },
  {
    "objectID": "leprechaun.html",
    "href": "leprechaun.html",
    "title": "24  leprechaun",
    "section": "",
    "text": "24.1 lap (a leprechaun app-package)\nThis chapter walks through building a version of the sap with the leprechaun framework. The resulting app-package (lap) is in the 19_leprechaun branch.\nThe version/description of leprechaun used in this Shiny app-package is:\nAfter checking out the 19_leprechaun branch, be sure to load, document, and install the application.\nlap exports the movies data and the standalone app function, run().\nlibrary(lap)\nlap::run()",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#lap-a-leprechaun-app-package",
    "href": "leprechaun.html#lap-a-leprechaun-app-package",
    "title": "24  leprechaun",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('19_leprechaun')\n\n\n\n\n\n\n\nlap movies app\n\n\n\n\nFigure 24.1: After loading, documenting, and installing lap, launch the movies with run()\n\n\n\n\n\n\n\n\n\nAccessing applications\n\n\n\n\n\n\nI’ve created the shinypak R package In an effort to make each section accessible and easy to follow:\nInstall shinypak using pak (or remotes):\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\n\nReview the chapters in each section:\n\nlibrary(shinypak)\nlist_apps(regex = 'leprechaun')\n## # A tibble: 1 × 2\n##   branch        last_updated       \n##   &lt;chr&gt;         &lt;dttm&gt;             \n## 1 24_leprechaun 2024-09-03 14:24:11\n\nLaunch the app:\n\nlaunch(app = \"19_leprechaun\")\n\nDownload the app:\n\nget_app(app = \"19_leprechaun\")",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#set-up",
    "href": "leprechaun.html#set-up",
    "title": "24  leprechaun",
    "section": "24.2 Set up",
    "text": "24.2 Set up\nCreating a new leprechaun app-package can be done with usethis::create_package()1 (which we covered in Packages). After your app-package is created, leprechaun::scaffold() builds the core app files:2\nCode files: the code files in new leprechaun apps include the following:\n\n_disable_autoload.R: Disables shiny::loadSupport() (covered in Launch)\nassets.R: includes serveAssets() for serving JavaScript files, remove_modules() and get_modules() for adding/removing modules, and the collapse_files() helper function for collapsing files.3\ninput-handlers.R: leprechaun_handler_df() and leprechaun_handler_list() are helper functions for including data and lists “from Websocket”.4\nleprechaun-utils.R: includes a make_send_message() function for “send custom messages to the front-end” with the “namespace carried along”. Read below for demonstration of how this is used.5\nrun.R: the standalone app function for your leprechaun app (covered in Launch). \nserver.R & ui.R are applications primary UI and server functions.\n\nui: contains the application UI and the assets() function (which calls serveAssets() covered above).6\nserver.R: creates send_message from make_send_message(session) (covered below).7\n\nzzz.R is a utility function file that holds the .onLoad() function for adding external resources (using methods covered in Resources).8\n\n\nR\n1├── _disable_autoload.R\n2├── assets.R\n3├── input-handlers.R\n4├── leprechaun-utils.R\n5├── run.R\n6├── server.R\n7├── ui.R\n8└── zzz.R\n\n1 directory, 8 files\n\n\n1\n\nDisables shiny::loadSupport()\n\n\n2\n\nIncludes functions for serving JavaScript files, adding/removing modules, and collapsing files.\n\n3\n\nUtility functions for handling lists and data.frames\n\n\n4\n\nContains the make_send_message() function for ‘send[ing] custom messages to the front-end’\n\n5\n\nStandalone app function\n\n\n6\n\nApp primary server function\n\n\n7\n\nApp primary ui function\n\n\n8\n\nIncludes wrapper for adding external files\n\n\n\n\n\nAdding dependencies: shiny, bslib, htmltools and pkgload should be added to the DESCRIPTION with usethis::use_package() (covered in the Dependencies chapter).\n\n\nImports: \n    bslib,\n    htmltools,\n    shiny\nSuggests: \n    pkgload\n\nThe lap folder structure should look familiar if you’ve been following along with the previous chapters. The standard R package files (DESCRIPTION, NAMESPACE, and .Rproj) are accompanied by a .leprechaun lock file.\n\nlap/\n├── .leprechaun\n├── DESCRIPTION\n├── NAMESPACE\n└── sap.Rproj\n\nThe initial call to leprechaun::scaffold() creates the following folders in the inst/ folder (recall that inst/ contents are available when the package is installed).\n\ninst/\n├── assets\n├── dev\n├── img\n└── run\n    └── app.R\n\n5 directories, 1 file\n\ninst/run/app.R contains a call to leprechaun::build(), pkgload::load_all(), then a call to the standalone app function, run().9",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#development",
    "href": "leprechaun.html#development",
    "title": "24  leprechaun",
    "section": "24.3 Development",
    "text": "24.3 Development\nCode files: new code files in leprechaun apps can be created with usethis::use_r() or with a helper function:\n\nCreate modules with add_module(). Modules created with add_module(\"name\") will have:10\n\nA module file with a module_name prefix (R/module_name.R)\n\nA module UI function: nameUI()\n\nA module server function: name_server()\n\n\nCreate an app.R file with add_app_file(). This includes a call to pkgload::load_all() and run().11 \nApp files: R/run.R contains functions for running the app.12 \nAdd the modules to R/ui.R and R/server.R. \n\nR/server.R includes a call to send_message by default.13\nR/ui.R holds the ui() and assets() functions.14\n\n\n\nUtility function: R/utils_scatter_plot.R holds the scatter_plot() utility function.15 \nAdding files: The R/zzz.R file contains the .onLoad() function, which wraps system.file('img', package = 'lap') and addResourcePath() for including external resources. \n\n\nR\n├── module_plot_display.R\n├── module_var_input.R\n├── run.R\n├── server.R\n├── ui.R\n└── utils_scatter_plot.R\n\n1 directory, 6 files\n\n\n24.3.1 Data files\n\nIncluding data files: the movies.RData data was moved into inst/extdata, then loaded into data/ with the script created with usethis::use_data_raw('movies') (similar to methods covered in the Data chapter):\n\n\ndata-raw/\n└── movies.R\n\n1 directory, 1 file\n\n\n└── extdata\n      └── movies.RData\n1 directory, 1 file\n\n\ndata\n└── movies.rda\n\n1 directory, 1 file\n\n\n\n24.3.2 Adding features\nThe leprechaun workflow involves a combination of use_ functions that are combined with leprechaun::build() to add various functionality to your application. I’ll demonstrate three options in the sections below:\n\n24.3.2.1 Use packer\nI’ll demo using the make_send_message() from the JavaScript example on the package website:\n\nRun packer::scaffold_leprechaun() \n\nDon’t be alarmed when calling packer::scaffold_leprechaun() downloads multiple folders into the root directory of your leprechaun app-package. 16 \n\nRun leprechaun::use_packer() \nRun leprechaun::build()\n\nThis creates inst/tidy-data/packer.R and inst/assets/index.js.\n\ninst\n├── assets\n│   └── index.js\n├── dev\n│   └── packer.R\n├── extdata\n│   └── movies.RData\n├── img\n└── run\n    └── app.R\n\nAssign the output from make_send_message() to send_message() in R/server.R, then pass the msgId and text of the message:\n\nserver &lt;- function(input, output, session){\n    ## New code --&gt;\n1  send_message &lt;- make_send_message(session)\n  \n2    send_message(\"show-packer\",\n                  text = \"this message is from your R/server.R file\")\n    \n   selected_vars &lt;- var_input_server(\"vars\")\n\n   plot_display_server(\"plot\", var_inputs = selected_vars)\n   ## New code &lt;--\n\n}\n\n\n1\n\nCreate send_message()\n\n\n2\n\nUse send_message() to send message the UI.\n\n\n\n\nAfter loading, documenting, and installing your app-package:\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\nRun the application:\n\nlap::run()\n\n\n\n\n\n\n\nsend_message() in lap::run()\n\n\n\n\nFigure 24.2: Adding the make_send_message() functionality to R/server.R\n\n\n\n\n\n24.3.2.2 Add images\nAdding images is simplified with the .onLoad() function, which I’ll demonstrate by adding the leprechaun.jpg image file to the UI function.\n\nPlace the leprechaun.jpg file in inst/img/ \nAdd the img/ path to the code to UI:\n\n\ntags$img(\n  src = \"img/leprechaun.jpg\", \n  height = \"25%\", \n  width = \"25%\")\n\n\nrun devtools::load_all(), devtools::document(), and devtools::install(), then run the application with run():\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlap::run()\n\n\n\n\n\n\n\n\n\n\n\nleprechaun.jpg in R/ui.R\n\n\n\n\nFigure 24.3: Adding images to inst/img/\n\n\n\n\n\n24.3.2.3 Use Sass\nTo add Sass styling, I can use leprechaun’s use_sass() function\n\nRun leprechaun::use_sass() \na scss/ folder will be created that contains _core.scss and main.scss\n\n\nscss\n├── _core.scss\n└── main.scss\n\n1 directory, 2 files\n\n\nThe original _core.scss file is below\n\nhtml{\n    .error {\n        color: red\n    }\n}\n\nChange the color: from red to green (#38B44A) using $accent: #38B44A;\n\n$accent: #38B44A;\n\nhtml{\n    h1 {\n        color: $accent;\n    }\n}\n\nSave this file and run leprechaun::build():17\n\n\nleprechaun::build()\n\n\n✔ Running packer.R\n✔ Bundled       \n✔ Running sass.R\n\n\nOnce again, run devtools::load_all(), devtools::document(), and devtools::install(), then run the application with run():\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\nCtrl/Cmd + Shift + D\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\nlap::run()\n\n\n\n\n\n\n\nFigure 24.4: Running lap with new Sass\n\n\n\n\n\n24.3.2.4 New root folders\nIt’s important to note that adding features to your leprechaun app-package will add non-standard directories to the root folder:\n\n├── node_modules/ &lt;- too many sub-folders to list here!\n├── package-lock.json\n├── package.json\n├── scss/\n│   ├── _core.scss\n│   └── main.scss\n├── srcjs/\n│   ├── config\n│   ├── index.js\n│   └── modules\n├── webpack.common.js\n├── webpack.dev.js\n└── webpack.prod.js\n\nThese folders are necessary for adding JavaScript/SCSS functionality, so don’t remove them (just make sure they’re added to the .Rbuildignore/.gitignore)",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#tests",
    "href": "leprechaun.html#tests",
    "title": "24  leprechaun",
    "section": "24.4 Tests",
    "text": "24.4 Tests\nleprechaun doesn’t any specific support for testing (like the golem framework), but we can create tests using any combination of testthat, testServer(), and shinytest2.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#lap-dependencies",
    "href": "leprechaun.html#lap-dependencies",
    "title": "24  leprechaun",
    "section": "24.5 lap dependencies",
    "text": "24.5 lap dependencies\nIt’s also worth noting that using the leprechaun framework doesn’t add itself as a dependency:\n\n# in the 19_leprechaun branch of sap\npak::local_deps_explain(deps = 'leprechaun', root = \".\")\n\nx leprechaun",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#recap",
    "href": "leprechaun.html#recap",
    "title": "24  leprechaun",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRECAP   \n\n\n\n\n\n\n\nleprechaun apps are built using the same methods as app-packages (devtools and usethis), and are intended to be a ‘leaner and smaller’ version of golem.\n\n‘it generates code and does not make itself a dependency of the application you build; this means applications are leaner, and smaller’\n\nleprechaun is similar to golem in that it ‘bundles’ various app-package development functions into helper/utility functions. For example, the .onLoad() function saves some time (at the cost of making your app code less clear and explicit).\nleprechaun also relies on external packages like packer to integrate and bundle external code files, so becoming more familiar with these packages will extend what you can build with leprechaun.\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "leprechaun.html#footnotes",
    "href": "leprechaun.html#footnotes",
    "title": "24  leprechaun",
    "section": "",
    "text": "Remember to provide a list of fields to usethis::create_package() for the DESCRIPTION file (or edit this manually).↩︎\nleprechaun::scaffold() has arguments for ui (fluidPage or navbarPage) bs_version (bootstrap version) and overwrite (if you need to start over).↩︎\nLink to R/assets.R file.↩︎\nLink to R/input-handlers.R file.↩︎\nLink to R/leprechaun-utils.R file.↩︎\nLink to R/ui.R file.↩︎\nLink to R/server.R file.↩︎\nLink to R/zzz.R file.↩︎\nLink to inst/run/app.R file.↩︎\nleprechaun modules do not have the same naming conventions as golem (or that I’ve recommended throughout this book).↩︎\npkgload::load_all() has reset set to TRUE and helpers set to FALSE.↩︎\nR/run.R includes functions for running the production (run()) and development (run_dev()) version of the application.↩︎\nmake_send_message() is in R/leprechaun-utils.R.↩︎\nassets() loads the resources called in the R/assets.R file with the serveAssets() function.↩︎\nThe same scatter_plot() function from sap (i.e, imports .data from rlang)↩︎\nsrcjs/, package-lock.json, package.json, webpack.common.js, webpack.dev.js and webpack.prod.js are added to the .Rbuildignore (and node_modules/ is added to the .gitignore).↩︎\nThe scss folder in the root directory is used by leprechaun::build() to create inst/tidy-data/sass.R.↩︎",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>leprechaun</span>"
    ]
  },
  {
    "objectID": "charpente.html",
    "href": "charpente.html",
    "title": "25  charpente",
    "section": "",
    "text": "25.1 cap (a charpente app-package)\nThis chapter walks through building a version of the sap with the charpente framework. The resulting app-package (cap) is in the 20_charpente branch.\npak::pak(\"RinteRface/charpente\")\nlibrary(charpente)\nThe version/description of charpente used in this Shiny app-package is:\nPackage\nVersion\nTitle\nDescription\n\n\n\n\ncharpente\n0.7.1\nSeamlessly design robust 'shiny' extensions\n'charpente' eases the creation of 'shiny' extensions like 'shinydashboard', 'bs4Dash', 'shinyMobile'. It provides helpers to quickly set up a relevant package structure, import all external web dependencies (JavaScript, CSS) as well as initialize input/output bindings and custom handlers boilerplates. 'charpente' offers tools to convert HTML code into R to dramatically speed up the development of the template components as well as an high level interface to 'htmltools'. 'charpente' is a chatty package relying on the same principle as 'usethis' and more recently 'golem', that is make ('shiny') developer's life much easier.\ncharpente is also covered in chapter 21 of the Outstanding User Interfaces with Shiny book.1",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>charpente</span>"
    ]
  },
  {
    "objectID": "charpente.html#set-up",
    "href": "charpente.html#set-up",
    "title": "25  charpente",
    "section": "25.2 Set up",
    "text": "25.2 Set up\nUse create_charpente_package() to create the necessary package structure for your Shiny app-package:\n\ncharpente::create_charpente_package(path = \"path/to/cap\")\n\ncharpente packages include various files and directories that serve specific purposes, particularly for managing JavaScript dependencies, CSS styles, and other related assets:\n\n├── CODE_OF_CONDUCT.md\n├── DESCRIPTION\n├── LICENSE\n├── LICENSE.md\n├── NAMESPACE\n├── NEWS.md\n├── R/\n│    └── cap-utils.R\n├── README.md\n├── cap.Rproj\n├── cran-comments.md\n├── inst/\n│    └── cap-0.0.0.9000\n├── node_modules/\n├── package-lock.json\n├── package.json\n├── srcjs/\n│    ├── main.js\n│    └── test\n├── styles/\n│    └── main.scss\n└── tests/\n    ├── testthat\n    └── testthat.R\n\n112 directories, 15 files\n\nThe new package has some files and folders we’re not used to seeing in R packages–namely package-lock.json, package.json, node_modules/, srcjs/, and styles/.\n\npackage-lock.json: package-lock.json is automatically generated for any operations where npm modifies either the node_modules tree or package.json. It describes the exact tree that was generated, so it is helpful for the consistent installation of dependencies.\n\n\n\nshow/hide esbuild entry in package-lock.json\n\n\"node_modules/@esbuild/aix-ppc64\": {\n  \"version\": \"0.19.12\",\n  \"resolved\": \"https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.19.12.tgz\",\n  \"integrity\": \"sha512-bmoCYyWdEL3wDQIVbcyzRyeKLgk2WtWLTWz1ZIAZF/EGbNOwSA6ew3PftJ1PqMiOOGu0OyFMzG53L0zqIpPeNA==\",\n  \"cpu\": [\n    \"ppc64\"\n  ],\n  \"dev\": true,\n  \"license\": \"MIT\",\n  \"optional\": true,\n  \"os\": [\n    \"aix\"\n  ],\n  \"engines\": {\n    \"node\": \"&gt;=12\"\n  }\n},\n\n\npackage.json: package.json holds various metadata relevant to this project. This file is used to give information to npm that allows it to identify the project as well as handle the project’s dependencies. It can also contain other metadata such as a project description, version, license, and configuration data.\n\n\n\nshow/hide package.json\n\n{\n  \"name\": \"cap\",\n  \"version\": \"0.0.0\",\n  \"description\": \"\",\n  \"private\": true,\n  \"main\": \"'main.js'\",\n  \"directories\": {\n    \"man\": \"man\"\n  },\n  \"type\": \"module\",\n  \"scripts\": {\n    \"test\": \"mocha srcjs/test\",\n    \"build-dev\": \"node esbuild.dev.js\",\n    \"build-prod\": \"node esbuild.prod.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"MIT + file LICENSE\",\n  \"devDependencies\": {\n    \"autoprefixer\": \"^10.4.19\",\n    \"esbuild\": \"^0.19.12\",\n    \"esbuild-sass-plugin\": \"^2.16.1\",\n    \"mocha\": \"^8.4.0\",\n    \"postcss\": \"^8.4.39\"\n  }\n}\n\n\nnode_modules/: The node_modules/ directory is where npm installs the project’s dependencies. Any packages installed locally will be stored here, allowing the project to access the required modules.\n\nBelow is an example node_modules folder in a new charpente package:\n\n\nshow/hide node_modules\nnode_modules\n├── @esbuild\n│    └── darwin-x64\n├── @ungap\n│    └── promise-all-settled\n├── ansi-colors\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    ├── package.json\n│    ├── symbols.js\n│    └── types\n├── ansi-regex\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── ansi-styles\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── anymatch\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.d.ts\n│    ├── index.js\n│    └── package.json\n├── argparse\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── argparse.js\n│    ├── lib\n│    └── package.json\n├── autoprefixer\n│    ├── LICENSE\n│    ├── README.md\n│    ├── bin\n│    ├── data\n│    ├── lib\n│    └── package.json\n├── balanced-match\n│    ├── LICENSE.md\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── binary-extensions\n│    ├── binary-extensions.json\n│    ├── binary-extensions.json.d.ts\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── brace-expansion\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── braces\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    ├── lib\n│    └── package.json\n├── browser-stdout\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── browserslist\n│    ├── LICENSE\n│    ├── README.md\n│    ├── browser.js\n│    ├── cli.js\n│    ├── error.d.ts\n│    ├── error.js\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── node.js\n│    ├── package.json\n│    └── parse.js\n├── camelcase\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── caniuse-lite\n│    ├── LICENSE\n│    ├── README.md\n│    ├── data\n│    ├── dist\n│    └── package.json\n├── chalk\n│    ├── index.d.ts\n│    ├── license\n│    ├── node_modules\n│    ├── package.json\n│    ├── readme.md\n│    └── source\n├── chokidar\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    ├── lib\n│    ├── package.json\n│    └── types\n├── cliui\n│    ├── CHANGELOG.md\n│    ├── LICENSE.txt\n│    ├── README.md\n│    ├── build\n│    ├── index.mjs\n│    ├── node_modules\n│    └── package.json\n├── color-convert\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── conversions.js\n│    ├── index.js\n│    ├── package.json\n│    └── route.js\n├── color-name\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── concat-map\n│    ├── LICENSE\n│    ├── README.markdown\n│    ├── example\n│    ├── index.js\n│    ├── package.json\n│    └── test\n├── debug\n│    ├── LICENSE\n│    ├── README.md\n│    ├── node_modules\n│    ├── package.json\n│    └── src\n├── decamelize\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── diff\n│    ├── CONTRIBUTING.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── dist\n│    ├── lib\n│    ├── package.json\n│    ├── release-notes.md\n│    └── runtime.js\n├── electron-to-chromium\n│    ├── LICENSE\n│    ├── README.md\n│    ├── chromium-versions.js\n│    ├── chromium-versions.json\n│    ├── full-chromium-versions.js\n│    ├── full-chromium-versions.json\n│    ├── full-versions.js\n│    ├── full-versions.json\n│    ├── index.js\n│    ├── package.json\n│    ├── versions.js\n│    └── versions.json\n├── emoji-regex\n│    ├── LICENSE-MIT.txt\n│    ├── README.md\n│    ├── es2015\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── package.json\n│    └── text.js\n├── esbuild\n│    ├── LICENSE.md\n│    ├── README.md\n│    ├── bin\n│    ├── install.js\n│    ├── lib\n│    └── package.json\n├── esbuild-sass-plugin\n│    ├── LICENSE\n│    ├── README.md\n│    ├── lib\n│    ├── package.json\n│    └── src\n├── escalade\n│    ├── dist\n│    ├── index.d.ts\n│    ├── license\n│    ├── package.json\n│    ├── readme.md\n│    └── sync\n├── escape-string-regexp\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── fill-range\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── find-up\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── flat\n│    ├── LICENSE\n│    ├── README.md\n│    ├── cli.js\n│    ├── index.js\n│    ├── package.json\n│    └── test\n├── fraction.js\n│    ├── LICENSE\n│    ├── README.md\n│    ├── bigfraction.js\n│    ├── fraction.cjs\n│    ├── fraction.d.ts\n│    ├── fraction.js\n│    ├── fraction.min.js\n│    └── package.json\n├── fs.realpath\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    ├── old.js\n│    └── package.json\n├── fsevents\n│    ├── LICENSE\n│    ├── README.md\n│    ├── fsevents.d.ts\n│    ├── fsevents.js\n│    ├── fsevents.node\n│    └── package.json\n├── function-bind\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── implementation.js\n│    ├── index.js\n│    ├── package.json\n│    └── test\n├── get-caller-file\n│    ├── LICENSE.md\n│    ├── README.md\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── index.js.map\n│    └── package.json\n├── glob\n│    ├── LICENSE\n│    ├── README.md\n│    ├── changelog.md\n│    ├── common.js\n│    ├── glob.js\n│    ├── package.json\n│    └── sync.js\n├── glob-parent\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── growl\n│    ├── History.md\n│    ├── Readme.md\n│    ├── lib\n│    ├── package.json\n│    └── test.js\n├── has-flag\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── hasown\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── package.json\n│    └── tsconfig.json\n├── he\n│    ├── LICENSE-MIT.txt\n│    ├── README.md\n│    ├── bin\n│    ├── he.js\n│    ├── man\n│    └── package.json\n├── immutable\n│    ├── LICENSE\n│    ├── README.md\n│    ├── dist\n│    └── package.json\n├── inflight\n│    ├── LICENSE\n│    ├── README.md\n│    ├── inflight.js\n│    └── package.json\n├── inherits\n│    ├── LICENSE\n│    ├── README.md\n│    ├── inherits.js\n│    ├── inherits_browser.js\n│    └── package.json\n├── is-binary-path\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── is-core-module\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── core.json\n│    ├── index.js\n│    ├── package.json\n│    └── test\n├── is-extglob\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── is-fullwidth-code-point\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── is-glob\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── is-number\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── is-plain-obj\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── isexe\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    ├── mode.js\n│    ├── package.json\n│    ├── test\n│    └── windows.js\n├── js-yaml\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── bin\n│    ├── dist\n│    ├── index.js\n│    ├── lib\n│    └── package.json\n├── locate-path\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── log-symbols\n│    ├── browser.js\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── minimatch\n│    ├── LICENSE\n│    ├── README.md\n│    ├── minimatch.js\n│    └── package.json\n├── mocha\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── assets\n│    ├── bin\n│    ├── browser-entry.js\n│    ├── index.js\n│    ├── lib\n│    ├── mocha.css\n│    ├── mocha.js\n│    ├── mocha.js.map\n│    └── package.json\n├── ms\n│    ├── index.js\n│    ├── license.md\n│    ├── package.json\n│    └── readme.md\n├── nanoid\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── async\n│    ├── bin\n│    ├── index.browser.js\n│    ├── index.cjs\n│    ├── index.d.ts\n│    ├── index.dev.js\n│    ├── index.js\n│    ├── index.prod.js\n│    ├── nanoid.js\n│    ├── non-secure\n│    ├── package.json\n│    └── url-alphabet\n├── node-releases\n│    ├── LICENSE\n│    ├── README.md\n│    ├── data\n│    └── package.json\n├── normalize-path\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── normalize-range\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── once\n│    ├── LICENSE\n│    ├── README.md\n│    ├── once.js\n│    └── package.json\n├── p-limit\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── p-locate\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── path-exists\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── path-is-absolute\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── path-parse\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── picocolors\n│    ├── LICENSE\n│    ├── README.md\n│    ├── package.json\n│    ├── picocolors.browser.js\n│    ├── picocolors.d.ts\n│    ├── picocolors.js\n│    └── types.ts\n├── picomatch\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    ├── lib\n│    └── package.json\n├── postcss\n│    ├── LICENSE\n│    ├── README.md\n│    ├── lib\n│    ├── node_modules\n│    └── package.json\n├── postcss-value-parser\n│    ├── LICENSE\n│    ├── README.md\n│    ├── lib\n│    └── package.json\n├── randombytes\n│    ├── LICENSE\n│    ├── README.md\n│    ├── browser.js\n│    ├── index.js\n│    ├── package.json\n│    └── test.js\n├── readdirp\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.d.ts\n│    ├── index.js\n│    └── package.json\n├── require-directory\n│    ├── LICENSE\n│    ├── README.markdown\n│    ├── index.js\n│    └── package.json\n├── resolve\n│    ├── LICENSE\n│    ├── SECURITY.md\n│    ├── async.js\n│    ├── bin\n│    ├── example\n│    ├── index.js\n│    ├── lib\n│    ├── package.json\n│    ├── readme.markdown\n│    ├── sync.js\n│    └── test\n├── safe-buffer\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.d.ts\n│    ├── index.js\n│    └── package.json\n├── sass\n│    ├── LICENSE\n│    ├── README.md\n│    ├── package.json\n│    ├── sass.dart.js\n│    ├── sass.default.cjs\n│    ├── sass.default.js\n│    ├── sass.js\n│    ├── sass.node.js\n│    ├── sass.node.mjs\n│    └── types\n├── serialize-javascript\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── source-map-js\n│    ├── LICENSE\n│    ├── README.md\n│    ├── lib\n│    ├── package.json\n│    ├── source-map.d.ts\n│    └── source-map.js\n├── string-width\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── strip-ansi\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── strip-json-comments\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── supports-color\n│    ├── browser.js\n│    ├── index.js\n│    ├── license\n│    ├── package.json\n│    └── readme.md\n├── supports-preserve-symlinks-flag\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── browser.js\n│    ├── index.js\n│    ├── package.json\n│    └── test\n├── to-regex-range\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n├── update-browserslist-db\n│    ├── LICENSE\n│    ├── README.md\n│    ├── check-npm-version.js\n│    ├── cli.js\n│    ├── index.d.ts\n│    ├── index.js\n│    ├── package.json\n│    └── utils.js\n├── which\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── bin\n│    ├── package.json\n│    └── which.js\n├── wide-align\n│    ├── LICENSE\n│    ├── README.md\n│    ├── align.js\n│    └── package.json\n├── workerpool\n│    ├── HISTORY.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── dist\n│    ├── package.json\n│    └── src\n├── wrap-ansi\n│    ├── index.js\n│    ├── license\n│    ├── node_modules\n│    ├── package.json\n│    └── readme.md\n├── wrappy\n│    ├── LICENSE\n│    ├── README.md\n│    ├── package.json\n│    └── wrappy.js\n├── y18n\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── build\n│    ├── index.mjs\n│    └── package.json\n├── yargs\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── browser.mjs\n│    ├── build\n│    ├── helpers\n│    ├── index.cjs\n│    ├── index.mjs\n│    ├── lib\n│    ├── locales\n│    ├── node_modules\n│    ├── package.json\n│    └── yargs\n├── yargs-parser\n│    ├── CHANGELOG.md\n│    ├── LICENSE.txt\n│    ├── README.md\n│    ├── browser.js\n│    ├── build\n│    └── package.json\n├── yargs-unparser\n│    ├── CHANGELOG.md\n│    ├── LICENSE\n│    ├── README.md\n│    ├── index.js\n│    └── package.json\n└── yocto-queue\n    ├── index.d.ts\n    ├── index.js\n    ├── license\n    ├── package.json\n    └── readme.md\n\n172 directories, 502 files\n\n\n\nsrcjs/: srcjs/ is intended to store source JavaScript files that you might write and use in your R package. These JavaScript files can then be processed and bundled for inclusion in the R package, particularly if you are using a package like charpente to manage and build JavaScript assets for use in Shiny applications or other interactive features.\n\nsrcjs/main.js: srcjs/main.js is the primary JavaScript file that may contain the main logic or functionality required by the package.\n\nimport \"../styles/main.scss\";\n\nsrcjs/test/test_basic.js\n\ndescribe('Basic test', () =&gt; {\n      it('should not fail', (done) =&gt; {\n        done();\n      });\n    });\nstyles/: The styles/ folder is used for storing CSS stylesheets. These stylesheets can define the visual appearance of your Shiny applications or any web components used within the R package. By organizing styles in this directory, you can manage and maintain the CSS separate from the R and JavaScript code.\nR/cap-utils.R: This file contains R functions and code that are part of the package. It is placed in the R/ directory, which is the primary location for all R code within the package.\ncran-comments.md: cran-comments.md includes notes and comments for the CRAN maintainers when submitting the package to CRAN. It typically contains information about the submission, testing, and any issues addressed.\ninst/cap-0.0.0.9000: inst/ can contain additional files that are to be installed with the package but are not part of the R code. These files might include documentation, data, or other resources.\n\nThese components are part of a modern approach to integrating JavaScript and CSS with R packages, especially for Shiny applications, ensuring that web dependencies are managed effectively and the package structure remains organized and maintainable.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>charpente</span>"
    ]
  },
  {
    "objectID": "charpente.html#development",
    "href": "charpente.html#development",
    "title": "25  charpente",
    "section": "25.3 Development",
    "text": "25.3 Development\n\n25.3.1 create_custom_handler()\nThe create_custom_handler() function is used to create a custom JavaScript handler. Here is an example of how to use it:\n# Load the charpente package\nlibrary(charpente)\n\n# Create a custom JS handler\ncharpente::create_custom_handler(\n  path = \"path/to/your/package\",\n  name = \"my_custom_handler\"\n)\n\n# Example content for inst/app/www/my_custom_handler.js\n# Add this JavaScript code to the created file\n\n#' Custom handler for special button click\n#' \n#' @noRd\nShiny.addCustomMessageHandler('customMessage', function(message) {\n  alert('Received custom message: ' + message);\n});\n\n\n25.3.2 create_input_binding()\nThe create_input_binding() function is used to create a custom Shiny input binding. Here is an example:\n# Load the charpente package\nlibrary(charpente)\n\n# Create a custom input binding\ncharpente::create_input_binding(\n  path = \"path/to/your/package\",\n  name = \"my_custom_input\"\n)\n\n# Example content for inst/app/www/my_custom_input.js\n# Add this JavaScript code to the created file\n\n#' Custom input binding for my_special_input\n#' \n#' @noRd\nvar myCustomInputBinding = new Shiny.InputBinding();\n$.extend(myCustomInputBinding, {\n  find: function(scope) {\n    return $(scope).find(\".my-special-input\");\n  },\n  getValue: function(el) {\n    return $(el).val();\n  },\n  setValue: function(el, value) {\n    $(el).val(value);\n  },\n  subscribe: function(el, callback) {\n    $(el).on(\"change.myCustomInputBinding\", function(e) {\n      callback();\n    });\n  },\n  unsubscribe: function(el) {\n    $(el).off(\".myCustomInputBinding\");\n  }\n});\nShiny.inputBindings.register(myCustomInputBinding);\n\n\n25.3.3 create_output_binding()\nThe create_output_binding() function is used to create a custom Shiny output binding. Here is an example:\n# Load the charpente package\nlibrary(charpente)\n# Create a custom output binding\ncharpente::create_output_binding(\n  path = \"path/to/your/package\",\n  name = \"my_custom_output\"\n)\n# Example content for inst/app/www/my_custom_output.js\n# Add this JavaScript code to the created file\n\n#' Custom output binding for my_special_output\n#' \n#' @noRd\nvar myCustomOutputBinding = new Shiny.OutputBinding();\n$.extend(myCustomOutputBinding, {\n  find: function(scope) {\n    return $(scope).find(\".my-special-output\");\n  },\n  renderValue: function(el, data) {\n    $(el).html(data);\n  }\n});\nShiny.outputBindings.register(myCustomOutputBinding);\n\n\n25.3.4 Putting It All Together in a Shiny App\nHere’s how you can use these custom bindings in a Shiny app within your package:\n\nUI\n\nlibrary(shiny)\n\napp_ui &lt;- fluidPage(\n  tags$head(\n    tags$script(src = \"www/my_custom_handler.js\"),\n    tags$script(src = \"www/my_custom_input.js\"),\n    tags$script(src = \"www/my_custom_output.js\")\n  ),\n  textInput(\"my_special_input\", \"Enter text\"),\n  actionButton(\"send_message\", \"Send Message\"),\n  div(class = \"my-special-output\", \"Output will appear here\")\n)\n\nServer\n\napp_server &lt;- function(input, output, session) {\n  observeEvent(input$send_message, {\n    session$sendCustomMessage(\"customMessage\", input$my_special_input)\n  })\n  \n  output$my_special_output &lt;- renderText({\n    paste(\"You entered:\", input$my_special_input)\n  })\n}\n\nRun the App\n\n# Create app.R in the inst/app directory\nlibrary(shiny)\nsource(\"app_ui.R\")\nsource(\"app_server.R\")\n\nshinyApp(ui = app_ui, server = app_server)\n# Add Shiny app structure\ncharpente::add_shiny(path = \"path/to/your/package\")\n\n# Add custom JS handlers and bindings\ncharpente::create_custom_handler(path = \"path/to/your/package\", name = \"my_custom_handler\")\ncharpente::create_input_binding(path = \"path/to/your/package\", name = \"my_custom_input\")\ncharpente::create_output_binding(path = \"path/to/your/package\", name = \"my_custom_output\")\nThese steps will create a structured R package with a Shiny application, incorporating custom JavaScript handlers and input/output bindings using the charpente package.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>charpente</span>"
    ]
  },
  {
    "objectID": "charpente.html#tests",
    "href": "charpente.html#tests",
    "title": "25  charpente",
    "section": "25.4 Tests",
    "text": "25.4 Tests",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>charpente</span>"
    ]
  },
  {
    "objectID": "charpente.html#deployment",
    "href": "charpente.html#deployment",
    "title": "25  charpente",
    "section": "25.5 Deployment",
    "text": "25.5 Deployment",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>charpente</span>"
    ]
  },
  {
    "objectID": "charpente.html#summary-of-charpente-features",
    "href": "charpente.html#summary-of-charpente-features",
    "title": "25  charpente",
    "section": "25.6 Summary of charpente features",
    "text": "25.6 Summary of charpente features",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>charpente</span>"
    ]
  },
  {
    "objectID": "charpente.html#dependencies",
    "href": "charpente.html#dependencies",
    "title": "25  charpente",
    "section": "25.7 Dependencies",
    "text": "25.7 Dependencies",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>charpente</span>"
    ]
  },
  {
    "objectID": "charpente.html#footnotes",
    "href": "charpente.html#footnotes",
    "title": "25  charpente",
    "section": "",
    "text": "Automate new template creation with {charpente}.↩︎",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>charpente</span>"
    ]
  },
  {
    "objectID": "rhino.html",
    "href": "rhino.html",
    "title": "26  rhino",
    "section": "",
    "text": "26.1 rap (a rhino app)\nThis chapter briefly describes a version of sap built using rhino. The resulting app (rap) is in the 21_rhino branch.\nThe branch in this chapter is slightly different than the previous golem and leprechaun branches, because instead of loading, documenting, and installing rap, we’re going to re-initialize the IDE by selecting Session &gt; Terminate R…\nWhen the IDE re-opens, we see the rap files and notice the Build pane has been removed:\nThe Build pane is deactivated because rhino applications aren’t R packages.1\nLaunch the application in rap by opening the app.R file and clicking Run App (or by passing rhino::app() into the Console).\nThe files in rap are below:\n1├── .Rprofile\n2├── .github/\n│   └── workflows\n├── .gitignore\n3├── .lintr\n4├── .renvignore\n├── .rscignore        \n├── README.md\n├── app\n│   ├── js\n│   ├── logic\n│   ├── main.R\n│   ├── static\n│   ├── styles\n│   └── view\n├── app.R\n├── config.yml\n5├── dependencies.R.\n├── sap.Rproj\n6├── renv\n│   ├── .gitignore.   \n│   ├── activate.R\n│   ├── library\n│   ├── settings.json\n│   └── staging\n├── renv.lock\n├── rhino.yml\n└── tests\n    ├── cypress\n    ├── cypress.json\n    └── testthat\n\n24 directories, 31 files\n\n\n1\n\nActivates the renv package\n\n2\n\nCI/CD via GitHub actions\n\n\n3\n\nLintr (from lintr package)\n\n\n4\n\nrenv ignore (works like .gitignore)\n\n\n5\n\nrhino app dependencies\n\n6\n\nrenv library of packages in app project\nAs we can see, most of the standard R package folders and files are missing from rap, because rhino applications use the box package for importing dependencies and organizing code.2",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#rhino-features",
    "href": "rhino.html#rhino-features",
    "title": "26  rhino",
    "section": "26.2 rhino features",
    "text": "26.2 rhino features\nThe rhino website explains the philosophy behind the application structure above, so I won’t repeat that information here. However, I highly recommend reading the available documentation on rhino and box before deciding to adopt this framework.3",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#box-modules",
    "href": "rhino.html#box-modules",
    "title": "26  rhino",
    "section": "26.3 box modules",
    "text": "26.3 box modules\nA box module (not to be confused with a Shiny module) is a collection of .R scripts in a specified folder. The modules in a new rhino app are stored in the app/logic/ and app/view/ folders:4\n\napp\n1├── js/\n2├── logic/\n3├── main.R\n4├── static/\n5├── styles/\n6└── view/\n\n6 directories, 1 file\n\n\n1\n\nJavaScript code\n\n2\n\nNon-shiny code\n\n\n3\n\nPrimary app file\n\n\n4\n\nStatic .js or .css\n\n\n5\n\nApp CSS files\n\n6\n\nShiny modules and app code\n\n\n\n\n\n26.3.1 Utility functions\nIn rap, I’ve placed the non-Shiny utility functions (i.e., the business logic) in app/logic:\n\napp/logic\n├── __init__.R\n1├── data.R\n2└── plot.R\n\n1 directory, 4 files\n\n\n1\n\nLoad movies data\n\n\n2\n\nscatter_plot() utility function\n\n\n\n\n\n\n26.3.2 Shiny modules\nOur Shiny box modules are placed in app/view, and separated into inputs and display:\n\napp/view\n├── __init__.R\n1├── display.R\n2└── inputs.R\n\n1 directory, 3 files\n\n\n1\n\nsimilar to the code from R/mod_var_input.R\n\n2\n\nsimilar to the code from R/mod_scatter_display.R\n\n\n\n\napp/view/inputs collects and returns the reactive values from the UI. The app/view/display module includes the app/logic/data and app/logic/plot modules.\n\n# app/view/display.R\n\n# import data and plot modules\nbox::use(\n  app / logic / data,\n  app / logic / plot\n)",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#appmain.r",
    "href": "rhino.html#appmain.r",
    "title": "26  rhino",
    "section": "26.4 app/main.R",
    "text": "26.4 app/main.R\nThe app/main.R file contains the primary UI and Server functions for the application. This file adds the shiny functions and the inputs and display modules from app/view:\n\n# app/main.R\n\n# shiny functions\nbox::use(\n  shiny[\n    NS, fluidPage, sidebarLayout, sidebarPanel,\n    mainPanel, fluidRow, column, tags, icon,\n    textOutput, moduleServer, renderText\n  ]\n)\n\n# import modules\nbox::use(\n  # load inputs module ----\n  app / view / inputs,\n  # load display module ----\n  app / view / display\n)\n\nNote that we don’t need to import app/logic modules in app/main.R, because they’re imported in their respective app/view modules.",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#tests",
    "href": "rhino.html#tests",
    "title": "26  rhino",
    "section": "26.5 Tests",
    "text": "26.5 Tests\nrhino apps have support for testing with testthat, shiny::testServer(), shinytest2, and Cypress.\n\ntests/\n1├── cypress\n│   └── integration\n│       └── app.spec.js\n├── cypress.json\n2└── testthat\n    └── test-main.R\n\n4 directories, 3 files\n\n\n1\n\nCypress test infrastructure\n\n\n2\n\ntestthat test infrastructure\n\n\n\n\nBelow is the boilerplate test code in the tests/testthat/test-main.R file:\n\n1box::use(\n  shiny[testServer], \n  testthat[...],\n)\n\nbox::use(\n  app/main[...],\n)\n\n2test_that(\"main server works\", {\n  testServer(server, {\n    expect_equal(output$message, \"Hello!\")\n  })\n})\n\n\n1\n\nbox module importing test package functions\n\n2\n\nUsing shiny::testServer() and testthat::test_that() functions in test.\n\n\n\n\nI’ve included tests for the utility functions and modules in the 21_rhino branch, but I’ll cover testing with rhino elsewhere.5",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#rhino-dependencies",
    "href": "rhino.html#rhino-dependencies",
    "title": "26  rhino",
    "section": "26.6 rhino dependencies",
    "text": "26.6 rhino dependencies\nIn rhino apps, dependencies are managed by renv and the dependencies.R file. The renv package is designed to,\n\n“create[s] and manage[s] project-local R libraries, save[s] the state of these libraries to a ‘lockfile’, and later restore[s] the library as required.” 6\n\nThe rhino::pkg_install() helper function updates both the dependencies.R file and renv library. Using dependencies.R, renv, and box modules removes the need to manage dependencies in a DESCRIPTION or NAMESPACE file.7",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#recap",
    "href": "rhino.html#recap",
    "title": "26  rhino",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRECAP   \n\n\n\n\n\n\n\nrhino takes a novel and innovative approach to developing Shiny applications (and covering all the ways they differ from app-packages is beyond the scope of this book). Feel free to review the code in the 21_rhino branch for a better understanding of how the box modules are structured and used within the ui and server.\nThe rhino framework isn’t used as wildly golem,8 but it’s been gaining popularity (and has been used in a recent pilot FDA submission).\n\n\n\n\n\n\n\nrhino CRAN downloads\n\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "rhino.html#footnotes",
    "href": "rhino.html#footnotes",
    "title": "26  rhino",
    "section": "",
    "text": "I re-initialize the session on the 21_rhino branch so I’m not tempted to load, document, install, or test the code using the IDE.↩︎\nImported dependencies in rhino apps use box modules instead of the DESCRIPTION and NAMESPACE.↩︎\nBe sure to read up on testing box modules and rhino applications with cypress and shinytest2.↩︎\nrhino recommends placing non-Shiny code in the app/logic folder and keeping all Shiny modules and reactive code in app/view.↩︎\nSee the Shiny frameworks supplemental website for more information on testing your rhino app.↩︎\nAs described in renv’s DESCRIPTION file↩︎\nBe sure to read the renv configuration article for a better understanding on how it works with rhino apps.↩︎\nCheck for yourself on cran-downloads↩︎",
    "crumbs": [
      "Frameworks",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>rhino</span>"
    ]
  },
  {
    "objectID": "special_topics.html",
    "href": "special_topics.html",
    "title": "Special topics",
    "section": "",
    "text": "App data\nThis section holds a collection of topics you might find useful when developing your app-package.\nIn App data, 29.1 reactiveValues() demonstrates how we can use reactiveValues() to store and retrieve reactive values from a ‘persistent’ object in our app. 29.1.5 Testing reactiveValues() also has examples of testing modules with values from a reactiveValues() object.\n29.2 session$userData gives an example of how to store persistent, non-reactive objects in your application (see also 9.2.1 A tidy-movies app).",
    "crumbs": [
      "Special topics"
    ]
  },
  {
    "objectID": "special_topics.html#stack-traces",
    "href": "special_topics.html#stack-traces",
    "title": "Special topics",
    "section": "Stack traces",
    "text": "Stack traces\nThe Stack traces chapter…",
    "crumbs": [
      "Special topics"
    ]
  },
  {
    "objectID": "special_topics.html#dependency-hell",
    "href": "special_topics.html#dependency-hell",
    "title": "Special topics",
    "section": "Dependency hell",
    "text": "Dependency hell\nThe 31  Dependency hell chapter…\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Special topics"
    ]
  },
  {
    "objectID": "code.html",
    "href": "code.html",
    "title": "27  Code Style",
    "section": "",
    "text": "27.1 Code style and formatting\nDuring development, it can be challenging to keep the code in your app-package clean and perfectly formatted. Fortunately, the R ecosystem has some excellent tools for making your code functional and easy to read.\nThe lintr and styler packages in R serve related but distinct purposes and have different focuses in their functionality. The primary difference between lintr and styler is that styler can automatically fix any stylistic issues it identifies in your code (rather than just reporting them).",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Code Style</span>"
    ]
  },
  {
    "objectID": "code.html#code-style-and-formatting",
    "href": "code.html#code-style-and-formatting",
    "title": "27  Code Style",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('21_style')\n\n\n27.1.1 lintr\nlintr is a static code analysis tool used to identify syntax errors, semantic issues, and violations of stylistic guidelines in your code. The package contains a list of ‘linters’ for various potential problems and can be customized according to your needs. lintr is designed to help improve your code’s quality and readability by generating reports in the ‘markers’ pane. Running lintr won’t automatically correct the identified issues (you’ll need to fix the linting issues it reports manually).\n\n\n27.1.2 styler\nOn the other hand, the purpose of styler is to ensure consistency in the code formatting, which is crucial if you’re working in a team or contributing to open-source projects (like tidyverse packages). The styler package will change your code’s format according to specified style guidelines. These changes include indentation, spaces, and line breaks that adhere to your style guidelines.\nWhile there is some overlap (both packages can help enforce coding style guidelines), lintr is a more general tool for code quality, spotting potential issues and bugs. At the same time, styler focuses on code formatting and can automatically apply fixes. Many developers find combining both can help catch potential issues and ensure a consistent, readable coding style.",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Code Style</span>"
    ]
  },
  {
    "objectID": "code.html#checking-your-code",
    "href": "code.html#checking-your-code",
    "title": "27  Code Style",
    "section": "27.2 Checking your code",
    "text": "27.2 Checking your code\nI’ve previously mentioned running devtools::check() can be overkill for your app-package (especially if it’s not destined for CRAN). A nice alternative to check() is the goodpractice package..\ngoodpractice::gp() inspects your package and prints any areas that might need ‘good practice’ advice:\n\nlibrary(goodpractice)\npkg_checks &lt;- gp(path = \".\")\npkg_checks\n\nPreparing: description\nPreparing: lintr\n  |====================================================================| 100%\nPreparing: namespace\nPreparing: rcmdcheck\n── GP sap ───────────────────────────────────────────────────────\n\nIt is good practice to\n\n  ✖ add a \"URL\" field to DESCRIPTION. It helps users find information about your\n    package online. If your package does not have a homepage, add an URL to \n    GitHub, or the CRAN package package page.\n  ✖ add a \"BugReports\" field to DESCRIPTION, and point it to a bug tracker. \n    Many online code hosting services provide bug trackers for free, \n    https://github.com, https://gitlab.com, etc.\n  ✖ avoid long code lines, it is bad for readability. Also, many people prefer \n    editor windows that are about 80 characters wide. Try make your lines \n    shorter than 80 characters\n\n    data-raw/tidy_movies.R:49:81\n    R/data.R:4:81\n    R/data.R:7:81\n    R/data.R:17:81\n    R/data.R:21:81\n    ... and 13 more lines\n\n  ✖ not import packages as a whole, as this can cause name clashes between the \n    imported packages. Instead, import only the specific functions you need.\n  ✖ fix this R CMD check NOTE: display_type: no visible binding for global \n    variable\n    ‘.rs.invokeShinyPaneViewer’ display_type: no visible binding for global \n    variable\n    ‘.rs.invokeShinyWindowExternal’ display_type: no visible binding for global\n    variable\n    ‘.rs.invokeShinyWindowViewer’ mod_scatter_display_server : &lt;anonymous&gt;: no \n    visible binding for global\n    variable ‘movies’ Undefined global functions or variables: \n    .rs.invokeShinyPaneViewer \n    .rs.invokeShinyWindowExternal \n    .rs.invokeShinyWindowViewer \n    movies\nWe can also check specific components of our package by looking up the available checks in all_checks():\n\ngrep(\"import\", x = all_checks(), value = TRUE)\n\n\n[1] \"no_import_package_as_a_whole\"                 \n[2] \"rcmdcheck_undeclared_imports\"                 \n[3] \"rcmdcheck_imports_not_imported_from\"          \n[4] \"rcmdcheck_depends_not_imported_from\"          \n[5] \"rcmdcheck_triple_colon_imported_objects_exist\"\n[6] \"rcmdcheck_unexported_base_objects_imported\"   \n[7] \"rcmdcheck_unexported_objects_imported\"        \n[8] \"rcmdcheck_empty_importfrom_in_namespace\"  \n\nAll of the checks with the rcmdcheck_ prefix are part of the R CMD check diagnostic, but goodpractice comes with other checks that are good practices (even if you’re not submitting your package to CRAN).\nFor example, no_import_package_as_a_whole checks the practice we covered in managing imports. If we pass the no_import_package_as_a_whole check as a character vector to the checks argument:\n\ngp(path = \".\", checks = 'no_import_package_as_a_whole')\n\nOnly this check is performed:\n\n── GP sap ───────────────────────────────────────────────────\n\nIt is good practice to\n\n  ✖ not import packages as a whole, as this can cause name clashes between\n    the imported packages. Instead, import only the specific functions you need.\n\n───────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Code Style</span>"
    ]
  },
  {
    "objectID": "code.html#recap",
    "href": "code.html#recap",
    "title": "27  Code Style",
    "section": "27.3 Recap",
    "text": "27.3 Recap\nThis chapter covered an introduction to some tools and practices for improving and maintaining the quality of the code in your app-package. Maintaining code style and standards (lintr and styler) and performing thorough checks to adhere to best practices (goodpractice) will ensure efficient and reliable development and deployment for your app.\n\n\n\n\n\n\nCode tools recap\n\n\n\n\n\n\nThis chapter covered:\nCode Linting and Styling:\n\nlintr is used for checking the code for potential errors and style issues\n\nCan help in identifying syntactical and stylistic problems that might lead to code inefficiency or errors\nLinters are instrumental in enforcing coding standards and ensuring consistency across the codebase\n\nstyler is used to automatically style the R code in your app-package\n\nstyler will format R code according to specified style guidelines, ensuring that the code is not only consistent in its look but also adheres to best practices\nAutomating styling can save time and reduces manual effort in code formatting\n\n\nManaging Dependencies:\n\nThe attachment package helps in managing these dependencies by automatically listing and updating the packages used in your app-package\n\natt_amend_desc scans the code and identifies all package dependencies\nmanaging dependencies ensures reproducibility and ease of package installation\n\ndesc assists in handling the DESCRIPTION file in your app-package\n\nprovides tools for reading, writing, and modifying the DESCRIPTION files\n\n\nCode Checks:\n\ngoodpractice is designed to help ensure best practices in R coding and package development are adhered to in your app-package\n\ngoodpractice::gp() performs a comprehensive analysis of the code (beyond devtools::check()) and checks for various potential issues like code complexity, redundancy, adherence to coding standards, etc\nOffers suggestions for improvements, making it a helpful tool for quality assurance in package development",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Code Style</span>"
    ]
  },
  {
    "objectID": "non_r_code.html",
    "href": "non_r_code.html",
    "title": "28  Non-R Code",
    "section": "",
    "text": "28.1 HTML & CSS",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Non-R Code</span>"
    ]
  },
  {
    "objectID": "non_r_code.html#javascript",
    "href": "non_r_code.html#javascript",
    "title": "28  Non-R Code",
    "section": "28.2 JavaScript",
    "text": "28.2 JavaScript",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Non-R Code</span>"
    ]
  },
  {
    "objectID": "app_data.html",
    "href": "app_data.html",
    "title": "29  App data",
    "section": "",
    "text": "29.1 reactiveValues()\nThis chapter covers using session$userData vs. reactiveValues() in an application to store values and objects. Whether to use session$userData or reactiveValues() will depend on the purpose you want them to serve (and what you want to store/access) in your application.\nCalling reactiveValues() creates “an object for storing reactive values.” We’ve been storing the reactive values returned from the var_input module in the selected_vars object, then passing these values into the scatter_display module. 1\nmovies_server &lt;- function(input, output, session) {\n\n1      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n2      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\n1\n\nreactive values returned from var_input module\n\n\n2\n\nreactive values passed to scatter_display module\nIn the steps below we’ll walk through an example of using reactiveValues() to capture the selected_vars values returned from the var_input module and passed to the scatter_display module.\nYou should note a series of changes made to movies_server() in this branch:\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n1    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n2    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = FALSE)\n    \n    # view output in the UI\n3    output$vals &lt;- renderPrint({\n\n    })\n\n    # pass reactive values to display\n4    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nNew reactiveValues() object\n\n\n2\n\nReturned values from mod_var_input_server() assigned to rVals$inputs\n\n\n3\n\nrenderPrint() for displaying reactive values in UI\n\n\n4\n\nrVals object passed to mod_scatter_display_server()\nIn the steps below, we’ll view the structure and function of rVals and the reactive values in the application using methods covered in the Debug section.",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "app_data.html#sec-reactiveValues",
    "href": "app_data.html#sec-reactiveValues",
    "title": "29  App data",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('26.1.0_reactive-values')\n\n\n\n\n\n\nreactiveValues() is used to create rVals\nInstead of creating the selected_vars, the output from mod_var_input_server() is assigned to rVals as inputs\nrVals is then passed as an input argument to mod_scatter_display_server()\n.dev arguments have been added to both module server functions (and have been set to FALSE)\n\n\n\n\n29.1.1 Step 1\nIn movies_server(), the .dev in mod_var_input_server() is set to TRUE (the updated movies_server() function is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.1.1_step_01')\n\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n\n    # pass reactive values to display\n    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\n.dev has been set to TRUE\n\n\n\n\nWhen we load the package and run the application, we see the following:2\n\n\n\n\n\n\n\n\n\n\n(a) .dev = TRUE in mod_var_input_server()\n\n\n\n\n\nFigure 29.1: reactive values from mod_var_input_server()\n\n\n\n\nThe output in the sidebar are the reactive values from the variable input module (mod_var_input_server()). The server function has been simplified to return the output from reactiveValuesToList(), and the output is being rendered in the sidebar when .dev is set to TRUE:\n\nmod_var_input_server &lt;- function(id, .dev = TRUE) {\n\n  moduleServer(id, function(input, output, session) {\n    \n    if (.dev) {\n      # view output in the UI\n      output$vals &lt;- renderPrint({\n        x &lt;- reactiveValuesToList(input, all.names = TRUE)\n        str(x)\n      })\n    }\n    \n    # return reactives\n    return(\n      reactive({\n        reactiveValuesToList(input, all.names = TRUE)\n      })\n    )\n\n  })\n}\n\n\n\n29.1.2 Step 2\nThe renderPrint() in movies_server() displays the structure of rVals in the mainPanel() (the updated movies_server() function is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.1.2_step_02')\n\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n2    output$vals &lt;- renderPrint({\n      str(rVals)\n    })\n\n    # pass reactive values to display\n    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n2\n\nDisplay output from str(rVals)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) str(rVals)from movies_server()\n\n\n\n\n\nFigure 29.2: rVals$inputs() from movies_server()\n\n\n\n\n\n29.1.2.1 What is reactiveValues()?\n\n“When you read a value from it, the calling reactive expression takes a reactive dependency on that value, and when you write to it, it notifies any reactive functions that depend on that value. Note that values taken from the reactiveValues() object are reactive, but the reactiveValues() object itself is not.” Shiny Documentation\n\nI’ve added emphasis to the quote above because it’s important to remember that any object assign to reactiveValue() should be treated like any reactive object (i.e., and inputId or object returned from reactive() or observe()).3\nFor example, if we try to access the input values as a list outside movies_server() or the module server function, we see the following error:4\n\nx &lt;- reactiveValues(\n  inputs = list(x = \"imdb_rating\",\n                y = \"audience_score\",\n                z = \"mpaa_rating\",\n                alpha = 0.5,\n                size = 2,\n                plot_title = \"Enter Plot Title\")\n  )\nx$inputs()\n\n\n## Error in `x$inputs`:\n## ! Can't access reactive value 'inputs' outside of reactive consumer.\n## ℹ Do you need to wrap inside reactive() or observe()?\n\n\n\n\n29.1.3 Step 3\nIn this branch, the renderPrint() displays the structure of rVals$inputs() (the updated movies_server() function is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.1.3_step_03')\n\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n2    output$vals &lt;- renderPrint({\n      str(rVals$inputs())\n    })\n\n    # pass reactive values to display\n    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n2\n\nDisplay str(rVals$inputs())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) str(rVals)from movies_server()\n\n\n\n\n\nFigure 29.3: rVals$inputs() from movies_server()\n\n\n\n\nThe rVals$inputs() being rendered in movies_server() are the returned values from the variable input module (and they’re identical to the values in the sidebar).\nWhen rVals is passed to mod_scatter_display_server(), the reactive inputs() object (passed inside the function) is built as rVals$inputs():\n\ninputs &lt;- reactive({\n  plot_title &lt;- tools::toTitleCase(rVals$inputs()[['plot_title']])\n    list(\n      x = rVals$inputs()[['x']],\n      y = rVals$inputs()[['y']],\n      z = rVals$inputs()[['z']],\n      alpha = rVals$inputs()[['alpha']],\n      size = rVals$inputs()[['size']],\n      plot_title = plot_title\n    )\n})\n\nThe mod_scatter_display_server() function will display the structure of rVals$inputs() if the .dev argument is set to TRUE:\n\n    if (.dev) {\n      # view output in the UI\n      output$display_vals &lt;- renderPrint({\n        str(\n          rVals$inputs()\n          )\n      })\n    }\n\n\n\n29.1.4 Step 4\nIn this final step, the .dev argument has been set to TRUE in the mod_scatter_display_server() (the updates movies_server() function is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.1.4_step_04')\n\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n2    output$vals &lt;- renderPrint({\n      rVals$inputs()\n    })\n\n    # pass reactive values to display\n3    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = TRUE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n\n2\n\nDisplay rVals$inputs()\n\n\n3\n\nSet .dev to TRUE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) .dev set to TRUE and reactive values from movies_server()\n\n\n\n\n\nFigure 29.4: Both module .dev arguments set to TRUE and rVals$inputs() from movies_server()\n\n\n\n\nThe display we’re seeing directly below the graph (i.e., under inputs() from display module) is the structure of rVals$inputs() from mod_scatter_display_server():\n\nif (.dev) {\n  # view output in the UI\n  output$display_vals &lt;- renderPrint({\n    str(\n      rVals$inputs()\n      )\n  })\n}\n\nAn important thing to note is that we can only reference rVals$inputs() in a reactive consumer (i.e., using reactive(), observe(), etc.). That’s why when we change any of the UI inputs, the values change in rVals$inputs() and in the inputs() object inside the display module.\nYou can also view these outputs using launch_app(run = 'b', bslib = TRUE).\n\n\n29.1.5 Testing reactiveValues()\nIf you decide to use reactiveValues() or session$userData, you’ll need to confirm these objects in your tests. The module tests for test-mod_scatter_display.R have been redesigned to handle the reactiveValues() input.5\nI’ll briefly summarize the changes below:\n\nargs = list() in testServer() now takes the output from helper functions (stored in tests/testthat/helper.R and R/testthat.R). 6\n\nmake_initial_rVals_inputs &lt;- function() {\n  rVals &lt;- reactiveValues(\n    inputs =\n      reactive(list(\n        x = \"imdb_rating\",\n        y = \"audience_score\",\n        z = \"mpaa_rating\",\n        alpha = 0.5,\n        size = 2,\n        plot_title = \"Enter Plot Title\"\n      ))\n  )\n  return(rVals)\n}\n\nThis creates a reaciveValues() list that can be used in the test:\n\nrVals &lt;- make_initial_rVals_inputs()\nrVals\n## &lt;ReactiveValues&gt; \n##   Values:    inputs \n##   Readonly:  FALSE\n\nWe can view it’s contents by wrapping it in isolate().\n\nisolate(rVals$inputs())\n## $x\n## [1] \"imdb_rating\"\n## \n## $y\n## [1] \"audience_score\"\n## \n## $z\n## [1] \"mpaa_rating\"\n## \n## $alpha\n## [1] 0.5\n## \n## $size\n## [1] 2\n## \n## $plot_title\n## [1] \"Enter Plot Title\"\n\nPassing make_initial_rVals_inputs() to the args in testServer() requires creating rVals (which can be referenced in the test as rVals$inputs():\n\n    shiny::testServer(app = mod_scatter_display_server,\n      args = list(rVals = make_initial_rVals_inputs()), expr = {\n        testthat::expect_equal(\n          object = rVals$inputs(),\n          expected = list(\n                x = \"imdb_rating\",\n                y = \"audience_score\",\n                z = \"mpaa_rating\",\n                alpha = 0.5,\n                size = 2,\n                plot_title = \"Enter Plot Title\"\n            )\n        )\n      })",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "app_data.html#sec-session-user-data",
    "href": "app_data.html#sec-session-user-data",
    "title": "29  App data",
    "section": "29.2 session$userData",
    "text": "29.2 session$userData\nObjects stored in session$userData are not inherently reactive, which makes it ideal for storing persistent values or data that don’t require (or trigger) reactivity. Below is a demonstration of using session$userData to store a non-reactive function to be used in the inst/tidy-data/ application.\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.2.0_user-data')\n\n\n29.2.0.1 Non-reactive objects\nObjects we want to pass inside the server (and modules) but don’t need to update or change are perfect for session$userData. The example we’ll use below is a function (make_dev_ggp2_movies()) that prepares the ggplot2movies::movies for the application:\n\n\nView make_dev_ggp2_movies() function\nmake_dev_ggp2_movies &lt;- function(con) {\n  movies_data &lt;- read.csv(file = con)\n  # specify genre columns\n  genre_cols &lt;- c(\n    \"Action\", \"Animation\",\n    \"Comedy\", \"Drama\",\n    \"Documentary\", \"Romance\",\n    \"Short\"\n  )\n  # calculate row sum for genres\n  movies_data$genre_count &lt;- rowSums(movies_data[, genre_cols])\n  # create aggregate 'genres' for multiple categories\n  movies_data$genres &lt;- apply(\n    X = movies_data[, genre_cols],\n    MARGIN = 1,\n    FUN = function(row) {\n      genres &lt;- names(row[row == 1])\n      if (length(genres) &gt; 0) {\n        return(paste(genres, collapse = \", \"))\n      } else {\n        return(NA)\n      }\n    }\n  )\n  # format variables\n  movies_data$genre_count &lt;- as.integer(movies_data$genre_count)\n  movies_data$genre &lt;- ifelse(test = movies_data$genre_count &gt; 1,\n    yes = \"Multiple genres\",\n    no = movies_data$genres\n  )\n  movies_data$genre &lt;- as.factor(movies_data$genre)\n  movies_data$mpaa &lt;- factor(movies_data$mpaa,\n    levels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"),\n    labels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\")\n  )\n\n  # reduce columns to only those in graph\n  movies_data[, c(\n    \"title\", \"year\", \"length\", \"budget\",\n    \"rating\", \"votes\", \"mpaa\", \"genre_count\",\n    \"genres\", \"genre\"\n  )]\n}\n\n\nmake_dev_ggp2_movies() is designed to take a path or URL (i.e., a connection) as an input and returns a dataset that can be used in the inst/tidy-data/ application.\nIn the inst/tidy-data/app.R file, the following changes have been made to devServer():\n\nsession$userData stores the contents of make_dev_ggp2_movies()\nreactiveValues() is used to create rVals 7\nThe values returned from mod_var_input_server() is assigned to rVals as inputs\ndev_mod_scatter_server() as been updated to include arguments for rVals, userData, con, and .dev\n\n\ndevServer &lt;- function(input, output, session) {\n  \n1  session$userData$make_dev_ggp2_movies &lt;- make_dev_ggp2_movies\n  \n2  rVals &lt;- reactiveValues()\n  \n3  rVals$inputs &lt;- sap::mod_var_input_server(\"vars\",\n                                                  .dev = TRUE)\n\n4  dev_mod_scatter_server(\"plot\",\n    rVals = rVals,\n    data_fun = session$userData$make_dev_ggp2_movies, \n    con = \"https://bit.ly/3FQYR8j\",\n    .dev = FALSE\n  )\n\n}\n\n\n1\n\nCreate userData$make_dev_ggp2_movies that holds make_dev_ggp2_movies()\n\n2\n\nCreate rVals\n\n3\n\nAssign output from mod_var_input_server() to rVals$inputs\n\n4\n\nUpdated dev_mod_scatter_server() function\n\n\n\n\nTo view what’s happening with session$userData, we’ll run the application using the Run App button at the top of app.R\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Initial app in dev/inst/app.R\n\n\n\n\n\nFigure 29.5: The reactive values from mod_var_input_server() in the sidebar\n\n\n\n\nWe’re using the same version of mod_var_input_server() from above that includes a .dev argument, so we know it’s displaying the contents from reactiveValuesToList() in the sidebar.\n\n\n29.2.1 Step 1\nIn devServer(), a renderPrint() call has been added to display the structure of session in the UI:\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.2.1_step_01')\n\n\ndevServer &lt;- function(input, output, session) {\n  \n  # add function to userData\n1  session$userData$make_dev_ggp2_movies &lt;- make_dev_ggp2_movies\n  \n  # create reactive values\n2  rVals &lt;- reactiveValues()\n  \n  # assign inputs to rVals\n3  rVals$inputs &lt;- sap::mod_var_input_server(\"vars\",\n                                                  .dev = TRUE)\n  \n  # view output in the UI\n4  output$vals &lt;- renderPrint({\n    str(session)\n  })\n\n5  dev_mod_scatter_server(\"plot\",\n    rVals = rVals,\n    data_fun = session$userData$make_dev_ggp2_movies, \n    con = \"https://bit.ly/3FQYR8j\",\n    .dev = FALSE\n  )\n  \n}\n\n\n1\n\nCreate userData$make_dev_ggp2_movies that holds make_dev_ggp2_movies()\n\n2\n\nCreate rVals\n\n3\n\nAssign output from mod_var_input_server() to rVals$inputs\n\n4\n\nPrint the structure of session to UI\n\n\n5\n\nUpdated dev_mod_scatter_server() function\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) str(session) dev/inst/app.R\n\n\n\n\n\nFigure 29.6: The str(session) from devServer()\n\n\n\n\n\n29.2.1.1 What is session?\nEach time the app launches, the session list is created and tied to that particular ’session.\n\n“An environment for app authors and module/package authors to store whatever session-specific data they want.” Shiny Documentation\n\nsession$userData can store objects that should persist across different reactive contexts, but don’t need reactive updating (and won’t trigger reactivity). On the other hand, reactiveValues() creates objects stored in a reactive ‘state’, which will trigger reactive updates in the UI.’8\ndev_mod_scatter_server() includes both reactiveValues() and session$userData. The arguments for rVals, data_fun, con, and .dev are described below:\n\nrVals is the reactiveValues() object with our input values\ndata_fun is session$userData$make_dev_ggp2_movies\ncon is the path or URL to the data_fun in session$userData 9\n\n\ndev_mod_scatter_server(\"plot\",\n  \n1  rVals = rVals,\n  \n2  data_fun = session$userData$make_dev_ggp2_movies,\n  \n3  con = \"https://bit.ly/3FQYR8j\",\n  \n4  .dev = FALSE)\n\n\n1\n\npass reactive values from reactiveValues()\n\n2\n\npass session$userData with make_dev_ggp2_movies()\n\n3\n\npass connection to non-reactive object\n\n\n4\n\nview userData value in module\n\n\n\n\nInside the display module (dev_mod_scatter_server()), the data_fun() function creates all_data with con:\n\n# use data_fun() function on con\nall_data &lt;- data_fun(con)\n\n\nThe inputs() list passed to the plotting function is very similar to the methods used in mod_scatter_display_server():\n\ninputs &lt;- reactive({\n  plot_title &lt;- tools::toTitleCase(rVals$inputs()[[\"plot_title\"]])\n  list(\n    x = rVals$inputs()[[\"x\"]],\n    y = rVals$inputs()[[\"y\"]],\n    z = rVals$inputs()[[\"z\"]],\n    alpha = rVals$inputs()[[\"alpha\"]],\n    size = rVals$inputs()[[\"size\"]],\n    plot_title = plot_title\n  )\n})\n\nThe structure of data_fun is be printed to the UI when the .dev argument is set to TRUE\n\n# view output in the UI\nif (.dev) {\n  # view output in the UI\n  output$data &lt;- renderPrint({\n    data_fun\n  })\n}\n\n\n\n\n\n29.2.2 Step 2\nChange .dev argument in dev_mod_scatter_server() to TRUE:\n\n\nLaunch app with the shinypak package:\n\nlaunch('26.2.2_step_02')\n\n\n  dev_mod_scatter_server(\"plot\",\n    rVals = rVals,\n    data_fun = session$userData$make_dev_ggp2_movies, \n    con = \"https://bit.ly/3FQYR8j\",\n1    .dev = TRUE\n  )\n\n\n1\n\nChange to TRUE\n\n\n\n\nLoad (with load_all()) and the app by clicking on the Run App icon:\n\n\n\n\n\n\n\n\n\n\n(a) data_fun dev_mod_scatter_server()\n\n\n\n\n\nFigure 29.7: The data_fun argument from dev_mod_scatter_server() is not reactive\n\n\n\n\nWe can see data_fun() is passed to dev_mod_scatter_server() from devServer() and is not a reactive (it’s a standard function we can apply to app_data).\nTests are more difficult for modules using session$userData, because these values are created when a Shiny app object is created (and exist inside the reactive context). This point is covered in more detail in this blog post.\n\n“reusing objects passed through session violates module independence – there is code inside the module that uses external objects without stating them explicitly as server arguments.”",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "app_data.html#recap",
    "href": "app_data.html#recap",
    "title": "29  App data",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: reactiveValues() & session$userData\n\n\n\n\n\n\nsession$userData\n\nsession$userData is best used with values or objects that persist across actions or navigation inside the app (i.e., maintaining values or data across pages of a multi-page app). session$userData can react to changes, but we’d need to explicitly create these reactive expressions or observers.\n\nreactiveValues()\n\nAn object created with reactiveValues() is designed to be reactive, so changing values will trigger reactivity in any observers and/or reactives that depend on those values. Remember that ‘values taken from the reactiveValues() object are reactive, but the reactiveValues() object itself is not.’\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "app_data.html#footnotes",
    "href": "app_data.html#footnotes",
    "title": "29  App data",
    "section": "",
    "text": "Mastering Shiny also has a great section on reactiveVal() and reactiveValues()↩︎\nThe methods used in this chapter can be found in the section on Debug↩︎\nRead more in the Shiny documentation.↩︎\nWe can access the values by wrapping the assigned object in isolate(). Read more in the documentation on reactiveValues().↩︎\nYou can view the full test-mod_scatter_display.R test file in the 24.1.4_step_04 branch.↩︎\nI resorted to both locations because the tests/testthat/helper.R file wasn’t loading with devtools::load_all()↩︎\nWe’ll cover how reactiveValues() works in Section 29.1 below.↩︎\nNotice session has :Classes 'ShinySession', 'R6'↩︎\nIn this case, con is a URL for a .csv version of ggplot2movies::movies)↩︎",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>App data</span>"
    ]
  },
  {
    "objectID": "stack_traces.html",
    "href": "stack_traces.html",
    "title": "30  Stack traces",
    "section": "",
    "text": "Alert\n\n\n\n\n\n\nThe contents for section are being revised. Thank you for your patience.\n\n\n\n\nIn this chapter covers how to read stack traces (or call stacks), which is the printout that follows programming errors.\n\n\nLaunch app with the shinypak package:\n\nlaunch('27_stack-traces')\n\n\n\n\n\n\n\nAccessing applications\n\n\n\n\n\n\nI’ve created the shinypak R package In an effort to make each section accessible and easy to follow:\nInstall shinypak using pak (or remotes):\n\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\n\nReview the chapters in each section:\n\nlibrary(shinypak)\nlist_apps(regex = '^27')\n## # A tibble: 0 × 2\n## # ℹ 2 variables: branch &lt;chr&gt;,\n## #   last_updated &lt;dttm&gt;\n\nLaunch the app:\n\nlaunch(app = \"27_stack-traces\")\n\nDownload the app:\n\nget_app(app = \"27_stack-traces\")\n\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Stack traces</span>"
    ]
  },
  {
    "objectID": "entanglement.html",
    "href": "entanglement.html",
    "title": "31  Dependency hell",
    "section": "",
    "text": "31.1 Exploring dependencies\nMastering dependency management\nThis chapter covers a few packages and tools to help explore, understand and keep track of your app-package dependencies.1 It’s not likely you’ll build an application that only relies on shiny, so it’s important to 1) know the packages and versions required for your application to function, and 2) ensure these packages are included in the correct DESCRIPTION field (or NAMESPACE).\nThe first package we’ll cover is pak, which is, “A Fresh Approach to R Package Installation.” pak includes two tools I’ve found to be incredibly helpful for understanding the dependencies in a given package (or a package I’m building): dependency trees and the dependency explainer.",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dependency hell</span>"
    ]
  },
  {
    "objectID": "entanglement.html#exploring-dependencies",
    "href": "entanglement.html#exploring-dependencies",
    "title": "31  Dependency hell",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('28_dependency-hell')\n\n\n31.1.1 Trees\npak::pkg_deps_tree() shows us the dependencies for a particular package. To demonstrate how this function works, we’ll explore the dependencies in three packages:\n\nrlang: “Functions for Base Types and Core R and ‘Tidyverse’ Features”\nlifecycle: “Manage the Life Cycle of your Package Functions”, and\nvctrs: “Vector Helpers”\n\nLet’s start with the rlang package:\n\npak::pkg_deps_tree(\"rlang\")\n\nrlang 1.1.1 ✨\n\nKey:  ✨ new\nrlang is “a collection of frameworks and APIs for programming with R” and it’s built with only base R packages (that’s why it’s DESCRIPTION file only Imports the utils package):\nImports:\n    utils\nNow lets look at lifecycle:\n\npak::pkg_deps_tree(pkg = \"lifecycle\")\n\nlifecycle 1.0.3 ✨ ⬇ (123.60 kB)               \n├─cli 3.6.1 ✨\n├─glue 1.6.2 ✨\n└─rlang 1.1.1 ✨\nlifecycle depends on cli, glue, and rlang.\n\ncli: “Helpers for Developing Command Line Interfaces”\nglue: “Interpreted String Literals”\n\nIf we look at the DESCRIPTION file for lifecycle, it also imports cli, glue, and rlang (and specifies versions for cli and rlang)\nImports:\n    cli (&gt;= 3.4.0),\n    glue,\n    rlang (&gt;= 1.1.0)\nFinally, lets look at the dependencies in the vctrs package. The DESCRIPTION file for vctrs imports cli, glue, lifecycle, and rlang\nImports:\n    cli (&gt;= 3.4.0),\n    glue,\n    lifecycle (&gt;= 1.0.3),\n    rlang (&gt;= 1.1.0)\nIf we check the dependency tree, we see the cli, glue, and rlang are listed twice (once for vctrs, and again for lifecycle):\n\npak::pkg_deps_tree(pkg = \"vctrs\")\n\nvctrs 0.6.4 ✨                               \n├─cli 3.6.1 ✨\n├─glue 1.6.2 ✨\n├─lifecycle 1.0.3 ✨ ⬇ (123.60 kB)\n│ ├─cli\n│ ├─glue\n│ └─rlang 1.1.1 ✨\n└─rlang\n\nKey:  ✨ new |  ⬇ download\nvctrs depends on cli, glue, rlang, and lifecycle (which also depends on cli, glue, and rlang)\n\n\n31.1.2 Explain\nWe can show dependency relationships with pak::pkg_deps_explain(). For example,\nHow does lifecycle depend on rlang?\n\npak::pkg_deps_explain(\"lifecycle\", \"rlang\")\n\nlifecycle -&gt; rlang \nHow does vctrs depend on rlang?\n\npak::pkg_deps_explain(\"vctrs\", \"rlang\")\n\nvctrs -&gt; lifecycle -&gt; rlang                                    \nvctrs -&gt; rlang\nvctrs directly depends on rlang and lifecycle (which also depends on rlang).\n\n\n31.1.3 Depends\nSo far we’ve been including add-on functions to the Imports field in the DESCRIPTION, which ensures the package is installed with our app-package, but not attached to the search list. However, if we include a package in the Depends field, it’s installed and attached.\nThis is rarely needed, but a great example is the relationship between devtools usethis:\n\npak::pkg_deps_explain(\"devtools\", \"usethis\")\n\ndevtools -&gt; usethis\nIn the DECRIPTION file for devtools, usethis is listed with a version number under Depends:\nDepends: \n    usethis (&gt;= 2.1.6)\n\n\n31.1.4 Case study: devtools\nThe conscious uncoupling of devtools split package development across multiple packages. Let’s see how this works, starting with the commonly used devtools function load_all()\n\n31.1.4.1 pkgload\nload_all() is handled by the pkgload package, which “Simulate[s] Package Installation and Attach”.\nHow does devtools depend on pkgload?\n\npak::pkg_deps_explain(\"devtools\", \"pkgload\")\n\ndevtools -&gt; pkgload                                            \ndevtools -&gt; roxygen2 -&gt; pkgload\ndevtools -&gt; testthat -&gt; pkgload\nThis relationship shows the three actions that call load_all() during package development:\n\ndevtools::load_all() actually calls pkgload::load_all()\ndevtools::document() and devtools::test() also call pkgload::load_all()\n\n\npak::pkg_deps_explain(\"devtools\", \"roxygen2\")\n\ndevtools -&gt; roxygen2\n\npak::pkg_deps_explain(\"devtools\", \"testthat\")\n\ndevtools -&gt; testthat",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dependency hell</span>"
    ]
  },
  {
    "objectID": "entanglement.html#tracking-dependencies",
    "href": "entanglement.html#tracking-dependencies",
    "title": "31  Dependency hell",
    "section": "31.2 Tracking dependencies",
    "text": "31.2 Tracking dependencies\nThe following packages will help keep your app-package dependencies managed in the DESCRIPTION file and the code below R/:\n\n31.2.1 attachment\nattachment was introduced in the golem chapter, but you don’t have to use the golem framework to take advantage of it’s functions. att_amend_desc() will update the package dependencies in the DESCRIPTION file.\nattachment::att_amend_desc()\nSaving attachment parameters to yaml config file\nUpdating sap documentation\nℹ Loading sap\nWriting NAMESPACE\nWriting NAMESPACE\nℹ Loading sap\n[+] 6 package(s) added: cli, tools, fst, ggplot2movies, glue, waldo.\nattachment::att_amend_desc() will automatically create a dev/ folder with a YAML configuration file:\ndev\n└── config_attachment.yaml\n\n1 directory, 1 file\nconfig_attachment.yaml contents:\npath.n: NAMESPACE\npath.d: DESCRIPTION\ndir.r: R\ndir.v: vignettes\ndir.t: tests\nextra.suggests: ~\npkg_ignore: ~\ndocument: yes\nnormalize: yes\ninside_rmd: no\nmust.exist: yes\ncheck_if_suggests_is_installed: yes\nThis can be deleted, but if you’re going to continue using attachment it’s worth customizing some of the options for your app-package.\n\n\n31.2.2 sinew\nThe sinew package also warrants mentioning because it can help ensure you’re namespacing functions from add-on packages, although it’s not automated like attachment::att_amend_desc(). The primary function in sinew is pretty_namespace().\nsinew::pretty_namespace(con = \"app.R\")\n\nAll Shiny app-packages will inherently depend on shiny, so including more dependencies can make developers justifiably uneasy. In this appendix, we’ll explore the package dependencies using the dependency lookup features from the pak package\n\n\n31.2.3 desc\nThe desc package provides functions for creating, reading, writing, and manipulating DESCRIPTION files. You can include additional dependencies to your DESCRIPTION using the desc_set_dep() function.\nlibrary(desc)\ndesc_set_dep(\"glue\", \"Imports\")\ndesc_get(\"Imports\")\nImports:\n    bslib,\n    cli,\n    glue,\n    ggplot2,\n    logger,\n    rlang,\n    sass,\n    shiny,\n    shinythemes,\n    stringr,\n    tools",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dependency hell</span>"
    ]
  },
  {
    "objectID": "entanglement.html#footnotes",
    "href": "entanglement.html#footnotes",
    "title": "31  Dependency hell",
    "section": "",
    "text": "Try to avoid dependency hell.↩︎",
    "crumbs": [
      "Special topics",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dependency hell</span>"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Appendix A — Glossary of terms",
    "section": "",
    "text": "App-package: An app-package is a package containing a shiny application. App-packages have all of the functionality of a standard R package, but also contain the files and folders required to successfully develop, run, and deploy a Shiny application. See the Shiny and Packages chapters for more information.1\nExternal resource/file: In Shiny app-packages, external files or resources are files used in the application that aren’t part of a standard R package. These can include images (.jpg, .png, etc.), JavaScript files (.js), and CSS or Sass styling (.css, .sass). See the Resources chapter for more information.2\nModule: Shiny modules3 are a pair of UI and server functions (linked by a shared id) to create a shared by isolated namespace. Using modules in a shiny application makes it possible to isolate individual components of an application during development. Additionally, since modules are functions, they can be reused throughout the application (and tested using Shiny’s testServer() function). See the Shiny chapter for more information.4\nPackage: A directory of functions, documentation, and/or data that can be installed and loaded into an R session. R packages include the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION). In Shiny App-packages, I extend this definition to include having access to the package development tools provided by devtools in the Posit Workbench IDE. See the Packages chapter for more information.5\nR Project: Any directory of R executable files with an RStudio/Posit workbench project file (.Rproj). See the Packages chapter for more information.6\nStandalone app function: A standalone app function encapsulates the UI and server components of a Shiny app into a single function. App function typically end with a call to shinyApp(ui, server, ...) and are used to launch or deploy the the app after installing or loading the app-package.7\nUtility/helper function: A utility or helper function is a non-Shiny function that is used for the business logic (i.e., data processing, manipulation, or other common operations) that supports the main functionalities of the application. See the Shiny and Packages chapters for more information.8",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Glossary of terms</span>"
    ]
  },
  {
    "objectID": "glossary.html#footnotes",
    "href": "glossary.html#footnotes",
    "title": "Appendix A — Glossary of terms",
    "section": "",
    "text": "App-packages are covered in Mastering Shiny and Engineering Production-Grade Shiny Apps↩︎\nExternal resources/files are covered in the Shiny documentation and in Engineering Production-Grade Shiny Apps↩︎\nModules are also part of the box package from the rhino framework, but these are different from Shiny modules.↩︎\nShiny modules are covered in the Shiny documentation, Mastering Shiny, and in Engineering Production-Grade Shiny Apps↩︎\nPackages are covered in Writing R Extensions and R Packages, 2ed↩︎\nRead more about R projects on the Posit website↩︎\nStandalone app functions are also covered in Mastering Shiny.↩︎\nUtility/helper function are covered in Mastering Shiny and Engineering Production-Grade Shiny Apps↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Glossary of terms</span>"
    ]
  },
  {
    "objectID": "github.html",
    "href": "github.html",
    "title": "Appendix B — GitHub",
    "section": "",
    "text": "B.1 Example Shiny project\nIf you’re new to GitHub, the steps below will walk you through setting up Git and GitHub from RStudio using the Git pane. The initial files in the project are below:\nLet’s assume we’ve just created projApp, a new Shiny application without the package structure (it was initially created using the New Project Wizard with a Git repo initialized).\nThe files in projApp are below:\nAfter creating the project, we’ll head over to GitHub and create am empty repo with the same name. We’ll see the following options:\nWe’re interested in the second option, “…push an existing repository from the command line”. One option is to copy the Git commands and enter them into the Terminal pane in Posit workbench, but we’re going to use Posit Workbench’s Git pane.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#example-shiny-project",
    "href": "github.html#example-shiny-project",
    "title": "Appendix B — GitHub",
    "section": "",
    "text": "projApp/\n  ├── app.R\n  └── projApp.Rproj\n\n1 directory, 2 files\n\n\n\n\n\n\n\n\n\n\n\n(a) New repository on GitHub\n\n\n\n\n\nFigure B.1: Empty GitHub repository options",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#committing-changes",
    "href": "github.html#committing-changes",
    "title": "Appendix B — GitHub",
    "section": "B.2 Committing changes",
    "text": "B.2 Committing changes\nWe’ll commit these initial files to the repo using the Commit icon in the Git pane (each file initially has a yellow question mark icon):\n\n\n\n\n\n\n\n\n\n(a) Commit changes\n\n\n\nAfter selecting each file, the icon turns to a blue ‘A’ (which means the file or change has been ‘added’ to the repo)\n\n\n\n\n\n\n(b) First commit\n\n\n\n\n\nFigure B.2: Click on Commit to open the Git window. Stage all the files, add a commit message, and click Commit\n\n\n\nWe’ll add a brief commit message and click Commit. This is the equivalent of entering the following commands in the Terminal:\n\ngit add .\ngit commit -m 'first commit'\n\n\n\n\n\n\n\nCommitting changes to a repository with a message\n\n\n\n\n\n\ngit commit -m 'first commit'\nWhen you run git commit -m 'first commit', you are committing your staged changes (i.e., changes you’ve previously added to the staging area using git add) with the message ‘first commit’.\nThis message is then stored in the Git history, allowing anyone who looks at the commit logs to see a brief description of what was done in that particular commit.\n\ngit commit: This command captures a snapshot of the changes in your project’s tracked files and directories. By committing, you’re saving the current state of those files in the Git repository.\n-m: This flag indicates that a commit message will be provided directly from the command line.\n'first commit': This is the commit message associated with this commit. Commit messages are useful for documenting the changes you’ve made, making it easier for others (and your future self) to understand the evolution and purpose of changes in the project.\n\n\n\n\n\nReview the output from the commit.\n\n\n\n\n\n\n\n\n\n(a) First commit output\n\n\n\n\n\nFigure B.3: The .gitignore, app.R, and sap.Rproj files have been committed to main\n\n\n\nThe output tells us the contents of projApp are part of our local main branch. Now we need to make sure the local branch has a remote on GitHub at the following URL: https://github.com/&lt;username&gt;/sap.git.\n\n\n\n\n\n\nAdd a new remote to your Git repository\n\n\n\n\n\n\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n\ngit remote: used to manage and set remotes (‘remote repositories’) for your project\nadd: specifies that you want to add a new remote.\norigin: a convention widely used in the Git community is to name the primary remote repository origin.\nhttps://github.com/&lt;username&gt;/&lt;repo&gt;.git: This is the URL to the Git repository (hosted on GitHub). Replace &lt;username&gt; with the GitHub username of the repository owner and &lt;repo&gt; with the name of the repository.\n\nSo, when you run this command, you’re telling Git: ‘I want to add a new remote called origin, and the URL for this remote is https://github.com/&lt;username&gt;/&lt;repo&gt;.git'.’\nAfter executing this command, you can then push to and pull from the repository using this remote by referring to its name (origin). For instance, git push origin master would push your local main branch to the main branch on the origin remote.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#new-branch-add-remote",
    "href": "github.html#new-branch-add-remote",
    "title": "Appendix B — GitHub",
    "section": "B.3 New branch, add remote",
    "text": "B.3 New branch, add remote\nClick the New Branch icon in the Git pane and create a new main branch. Then click on Add Remote… and name the remote origin.\n\n\n\n\n\n\n\n\n\n(a) Add branch and remote name\n\n\n\nThe Remote URL is the link from the Quick Setup above.\n\n\n\n\n\n\n(b) Add remote URL\n\n\n\n\n\nFigure B.4: Create new main branch to track origin\n\n\n\nAfter clicking Add and Create, you’ll be asked to checkout or overwrite the existing main branch. In this case, we can select Overwrite (because we’re already on the main branch).\n\n\n\n\n\n\n\n\n\n(a) Overwrite main\n\n\n\n\n\nFigure B.5",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#push-a-local-branch-to-remote-and-set-branch-to-track-remote-branch",
    "href": "github.html#push-a-local-branch-to-remote-and-set-branch-to-track-remote-branch",
    "title": "Appendix B — GitHub",
    "section": "B.4 Push a local branch to remote (and set branch to track remote branch)",
    "text": "B.4 Push a local branch to remote (and set branch to track remote branch)\nThe git push -u origin main commands tell Git to “push the main branch to the origin remote, and also set the local main branch to track the main branch on origin.”\n\ngit push: used to push commits from your local repository to a remote repository.\norigin: name of the remote repository you want to push to. When you clone a repo or add a remote using git remote add, it’s common to name the main remote origin (though it could technically be any name).\nmain: name of the branch you’re pushing to the remote repository.\n-u or --set-upstream: When this option is used, it sets a tracking relationship between the local and upstream remote branches. This means that in the future, using git pull or git push doesn’t require specifying the remote or branch (Git will know you’re referring to the origin/main branch).\n\n\n\n\n\n\n\n\n\n\n(a) branch main set up to track origin/main\n\n\n\n\n\nFigure B.6: main will now track the remote (origin)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "github.html#renaming-branches",
    "href": "github.html#renaming-branches",
    "title": "Appendix B — GitHub",
    "section": "B.5 Renaming branches",
    "text": "B.5 Renaming branches\nThe Git UI above called the git branch -B main commands, so we’ll break these down below:\n\ngit branch without any arguments would list all the local branches in the current repository. But, with certain options (like -M), you can perform other branch-related operations.\n-M: This option stands for ‘move/rename’ and forcibly renames the branch. If a branch named main already exists, it will be overwritten because of the forceful nature of the -M option. If you want to avoid accidentally overwriting an existing branch, you could use -m (lowercase) instead. The lowercase -m will rename only if the target name doesn’t already exist.\nmain: This is the new name for the currently checked-out branch.\n\n\n\n\n\n\n\nDo I have to call the default branch main?\n\n\n\n\n\n\nMost Git users started transitioning from master to main as the default branch name for new repositories, but it’s not required. You can call the default branch anythign (for example, in sap, the default is the first chapter (01_whole-app-game))\n\n\n\n\nThe complete workflow for setting up Git from the command line is below:\n# make and add changes \ngit add .\n# commit changes\ngit commit 'first commit'\n# set remote on GitHub\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n# rename the current branch to main\ngit branch -M main\n# push and set upstream to origin (remote)\ngit push -u origin main",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>GitHub</span>"
    ]
  },
  {
    "objectID": "create.html",
    "href": "create.html",
    "title": "Appendix C — Packages FAQ",
    "section": "",
    "text": "C.1 Can an .Rproj file convert an R project into an R package?\nThe technical answer is no, because the .Rproj only activates the Build pane in the IDE. The tools in the Build pane are directly connected to the devtools package (hence the PackageUseDevtools: Yes in the .Rproj file).\nThe seven mandatory fields are required in the DESCRIPTION to have a functioning R package.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Packages FAQ</span>"
    ]
  },
  {
    "objectID": "create.html#i-have-a-description-file-with-the-required-fields-but-where-is-the-build-pane",
    "href": "create.html#i-have-a-description-file-with-the-required-fields-but-where-is-the-build-pane",
    "title": "Appendix C — Packages FAQ",
    "section": "C.2 I have a DESCRIPTION file with the required fields, but where is the Build pane?",
    "text": "C.2 I have a DESCRIPTION file with the required fields, but where is the Build pane?\nIf the mandatory fields are added to the DESCRIPTION, but the .Rproj file doesn’t have any of the package configuration fields, then the Build pane will not be displayed (see example below):\n\n\n\n\n\n\n\n\n\n(a) Build pane tools\n\n\n\n\n\nFigure C.1: Mandatory DESCRIPTION fields with package configuration in .Rproj file",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Packages FAQ</span>"
    ]
  },
  {
    "objectID": "create.html#what-if-my-.rproj-file-is-configured-to-work-with-a-package-but-my-description-file-is-missing-one-or-more-of-the-required-fields",
    "href": "create.html#what-if-my-.rproj-file-is-configured-to-work-with-a-package-but-my-description-file-is-missing-one-or-more-of-the-required-fields",
    "title": "Appendix C — Packages FAQ",
    "section": "C.3 What if my .Rproj file is configured to work with a package, but my DESCRIPTION file is missing one (or more) of the required fields?",
    "text": "C.3 What if my .Rproj file is configured to work with a package, but my DESCRIPTION file is missing one (or more) of the required fields?\nSetting the Project build tools in your Project Options is insufficient to convert a project into a package. If the .Rproj file has the package development fields (i.e., Project build tools to Package) but the mandatory fields are missing from the DESCRIPTION file, the Build pane will be triggered:\n\n\n\n\n\n\n\n\n\n(a) DESCRIPTION\n\n\n\n\n\nFigure C.2: Unchanged DESCRIPTION file after changing .Rproj\n\n\n\nBut trying to load the code in the R/ folder with Build &gt; Load All (or devtools::load_all()) we return the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n\n\n\n\n(a) Build pane tools\n\n\n\n\n\nFigure C.3: Attempt to load_all() code in R/ folder\n\n\n\nThe directory must include a DESCRIPTION file containing the mandatory fields and an .Rproj file with the package configuration fields listed above to be a functional R package.\nRead more about DESCRIPTION file fields in R Packages, 2ed\n\n\n\n\n\n\nRStudio project files\n\n\n\n\n\n\nYou can read more about the benefits of using RStudio projects to configuring project-level options here.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Packages FAQ</span>"
    ]
  },
  {
    "objectID": "create.html#i-have-the-mandatory-fields-in-my-.rproj-file-and-description-but-still-no-build-pane",
    "href": "create.html#i-have-the-mandatory-fields-in-my-.rproj-file-and-description-but-still-no-build-pane",
    "title": "Appendix C — Packages FAQ",
    "section": "C.4 I have the mandatory fields in my .Rproj file and DESCRIPTION, but still no Build pane?",
    "text": "C.4 I have the mandatory fields in my .Rproj file and DESCRIPTION, but still no Build pane?\nTo get the IDE to re-read the .Rproj file, you might have to terminate the session (Session &gt; Terminate R… &gt; Yes)\n\n\n\n\n\n\n\n\n\n\n\n(a) Session &gt; Terminate\n\n\n\n\n\n\n\n\n\n\n\n(b) Click Yes\n\n\n\n\n\n\n\nFigure C.4: Terminate your R session\n\n\n\nThis prompts the IDE to re-read the .Rproj file and trigger the Build pane.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Packages FAQ</span>"
    ]
  },
  {
    "objectID": "bdd.html",
    "href": "bdd.html",
    "title": "Appendix D — BDD",
    "section": "",
    "text": "This appendix provides more information on behavior-driven development (BDD). If you decide to adopt the BDD functions in your test suite, I highly recommend creating code snippets to reduce the typing/copying and pasting.1\nYou can edit keyboard shortcuts by selecting Tools &gt; Edit Code Snippets…\nSnippets also work well with tab completion in the Posit Workbench IDE:\nBDD uses a specific format for translating application behavior into into features. These ‘user stories’ are typically written in the Gherkin language and include the following sections:\nThe testthat BDD functions can be adapted to use this format, because the description argument a text string and these functions can be nested.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>BDD</span>"
    ]
  },
  {
    "objectID": "bdd.html#footnotes",
    "href": "bdd.html#footnotes",
    "title": "Appendix D — BDD",
    "section": "",
    "text": "Read more about creating code snippets on the Posit website.↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>BDD</span>"
    ]
  },
  {
    "objectID": "test_snapshots_mocks.html",
    "href": "test_snapshots_mocks.html",
    "title": "Appendix E — Mocks and snapshots",
    "section": "",
    "text": "E.1 Snapshots\nIf we want to create a graph snapshot test, the vdiffr package allows us to perform a ‘visual unit test’ by capturing the expected output as an .svg file that we can compare with future versions.\nThe expect_doppelganger() function from vdiffr is designed specifically to work with ‘graphical plots’.\nvdiffr::expect_doppelganger(\n      title = \"name of graph\", \n      fig = # ...code to create graph...\n  )\nAnother option for using snapshots for testing is the expect_snapshot_file() function 1 but expect_doppelganger() is probably the better option for comparing graph outputs.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Mocks and snapshots</span>"
    ]
  },
  {
    "objectID": "test_snapshots_mocks.html#sec-tests-snapshots-vdiffr",
    "href": "test_snapshots_mocks.html#sec-tests-snapshots-vdiffr",
    "title": "Appendix E — Mocks and snapshots",
    "section": "",
    "text": "Launch app with the shinypak package:\n\nlaunch('A.E-mocks-snapshots')\n\n\n\n\n\nE.1.1 Testing graph outputs\nThe Feature for the initial graph output from scatter_plot() might look like:\n\ntestthat::describe(\n  \"Feature: Scatter Plot Configuration in Movie Review Application\n    As a user who accesses the movie review application,\n    I want the initial scatter plot pre-configured with variables and aesthetics,\n    So that I can immediately see a meaningful visualization.\", code = {\n    \n})\n\nCombining scenarios in the same test file is helpful if we’re trying to keep a 1:1 between the test/testthat/ file names and file names in R/.2\n\n1testthat::it(\n  \"Scenario: Create scatter plot\n      Given I have launched the movie review exploration app,\n      When the scatter plot renders,\n      Then the points on the x axis should represent 'Ratings'\n      And the points on the y axis should represent 'Length'\n      And the points should be colored by 'MPAA' rating\n      And the opacity of the points should be set to '0.5'\n      And the size of the points should be set to '2'\n      And the plot title should be set to 'Enter plot title'\",\n  code = {\n    \n2    test_logger(\n      start = \"snap scatter_plot()\", \n      msg = \"initial x,y,z,size,alpha\")\n\n3    scatter_inputs &lt;- list(\n      x = \"imdb_rating\",\n      y = \"audience_score\",\n      z = \"mpaa_rating\",\n      alpha = 0.5,\n      size = 2,\n      plot_title = \"Enter plot title\"\n    )\n\n4    vdiffr::expect_doppelganger(\n      title = \"Initial x y z axes\",\n      fig = scatter_plot(movies,\n        x_var = scatter_inputs$x,\n        y_var = scatter_inputs$y,\n        col_var = scatter_inputs$z,\n        alpha_var = scatter_inputs$alpha,\n        size_var = scatter_inputs$size\n      ) +\n        ggplot2::labs(\n          title = scatter_inputs$plot_title,\n          x = stringr::str_replace_all(\n            tools::toTitleCase(\n              scatter_inputs$x\n            ), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            tools::toTitleCase(\n              scatter_inputs$y\n            ), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    )\n\n5    test_logger(\n      end = \"snap scatter_plot()\", \n      msg = \"initial x,y,z,size,alpha\")\n    \n  }\n)\n\n\n1\n\nTest scope\n\n\n2\n\nLog start\n\n\n3\n\nInitial movies variable inputs for x, y, and z from UI\n\n\n4\n\nSnapshot with initial values\n\n\n5\n\nLog end\n\n\n\n\nTest results also return the output from test_logger() with the context I’ve added on what’s being tested.\n\n\nE.1.2 Snapshots\nWe also see a warning when the snapshot has been saved in the tests/testthat/_snaps/ folder the first time the test is run:\n── Warning (test-scatter_plot.R:124:9): \n      Scenario: Create scatter plot\n          Given I have launched the movie review exploration app,\n          When the scatter plot renders,\n          Then the points on the x axis should represent 'Ratings'\n          And the points on the y axis should represent 'Length'\n          And the points should be colored by 'MPAA' rating\n          And the size of the points should be set to '2'\n          And the opacity of the points should be set to '0.5' ──\nAdding new file snapshot: 'tests/testthat/_snaps/initial-x-y-z-axes.svg'\n\n── Warning (test-scatter_plot.R:186:7): \n      Scenario: Change x, y, color values for plotting\n        When I launch the Scatter Plot Data Visualization\n        And I select the variable 'Audience Score' for the x-axis\n        And I select the variable 'IMDB Rating' for the y-axis\n        And I select the variable 'Critics Rating' for the color\n        Then the scatter plot should show 'Audience Score' on the x-axis\n        And the scatter plot should show 'IMDB Rating' on the y-axis\n        And the points on the scatter plot should be colored by 'Critics Rating' ──\nAdding new file snapshot: 'tests/testthat/_snaps/updated-x-y-color.svg'\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 2 ]\nOn subsequent runs, this warning will disappear (as long as there are no changes to the .svg files).\nINFO [2023-10-27 10:58:25] [ START snap scatter_plot() = initial x,y,z,size,alpha]\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 3 ]\nINFO [2023-10-27 10:58:25] [ END snap scatter_plot() = initial x,y,z,size,alpha]\n\n\nE.1.3 Comparing graph objects\nBelow is the output from diffobj::diffObj() comparing our custom plotting function (scatter_plot()) against a graph built with analogous ggplot2 code:\n\nggp_graph &lt;- ggplot2::ggplot(mtcars, \n              ggplot2::aes(x = mpg, y = disp)) + \n              ggplot2::geom_point(\n                ggplot2::aes(color = cyl), \n                             alpha = 0.5, \n                             size = 3)\n  \napp_graph &lt;- scatter_plot(mtcars, \n                  x_var = \"mpg\", \n                  y_var = \"disp\", \n                  col_var = \"cyl\", \n                  alpha_var = 0.5, \n                  size_var = 3)\n\ndiffobj::diffObj(ggp_graph, app_graph)\n\n\n\n\n\n\n\n\ndiffobj::diffObj() on graph outputs\n\n\n\n\nFigure E.1: Graph objects are difficult to use as test objects\n\n\n\n\nThe output shows us all the potential points of failure when comparing complex objects like graphs (despite the actual outputs appearing identical), so it’s best to limit the number of ‘visual unit tests’ unless they’re absolutely necessary.\nI’ve included additional snapshot tests (test-text_logo.R) in the A.E-mocks-snapshots branch of sap:\ntests/testthat/\n    ├── test-scatter_plot.R\n    └── test-text_logo.R",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Mocks and snapshots</span>"
    ]
  },
  {
    "objectID": "test_snapshots_mocks.html#mocks",
    "href": "test_snapshots_mocks.html#mocks",
    "title": "Appendix E — Mocks and snapshots",
    "section": "E.2 Mocks",
    "text": "E.2 Mocks\nTest code may rely on external systems, behavior, functions, or objects. To ensure that our unit tests remain fast and focused solely on the functional requirement being tested, it’s important to minimize these external dependencies.\nThe mocking functions can be used to substitute functions by emulating their behavior within the test scope (in BDD terms, mocks are creating the Given conditions).3\n\n\nLaunch app with the shinypak package:\n\nlaunch('A.E-mocks-snapshots')\n\n\nE.2.1 Example: mocking add-on functions\nWe’ll use local_mocked_bindings() from testthat to mock the behavior of rlang::is_installed().4 Instead of real-time computations, mocks return predefined responses to given inputs. Consider the check_installed() function below:\n\ncheck_installed &lt;- function(package) {\n  if (is_installed(package)) {\n    return(invisible())\n  } else {\n    stop(\"Please install '{package}' before continuing\")\n  }\n}\n\nBelow is a feature description for check_installed() and two scenarios for each expected behavior:\nFeature: Checking if an R package is installed\n\n  Scenario: Checking an installed package\n    Given the R package 'base' is installed\n    When I call the `check_installed()` function with 'base'\n    Then the function should return without any error\n\n  Scenario: Checking an uninstalled package\n    Given the R package 'foo' is not installed\n    When I call the `check_installed()` function with 'foo'\n    Then the function should raise an error with the message\n      `Please install 'nonexistent_package' before continuing`\nThe check_installed() shouldn’t be confused with rlang::check_installed(), which checks if a package is installed, and if it isn’t, prompts the user install the package using pak::pkg_install().\nLets review how is_installed() behaves with installed and missing packages:\n\nrlang::is_installed('foo')\n## [1] FALSE\nrlang::is_installed('base')\n## [1] TRUE\n\nThe version of check_installed() in sap will check if a package is installed and return invisible() if it is (which, when assigned to an object, evaluates to NULL):\n\ncheck_installed('base')\n\n\nx &lt;- check_installed('base')\nx\n## NULL\n\nIf the package is not installed, check_installed() prints an error message:\n\ncheck_installed('foo')\n## Error in check_installed(\"foo\"): Please install '{package}' before continuing\n\nTo use mocking with is_installed(), we’ll use the following syntax:\nlocal_mocked_bindings(\n  {local function} = function(...) {value}\n)\nIn this case, {local function} is is_installed() from rlang, and we want to test the two possible {value}s (TRUE/FALSE).\nIn the first test, we’ll use expect_error() to confirm that the error message is returned for an uninstalled package by using local_mocked_bindings() and setting the is_installed() value to FALSE:\n\ndescribe(\"Feature: Checking if an R package is installed\", {\n  \n  test_that(\n    \"Scenario: Checking an uninstalled package\n        Given the R package 'foo' is not installed\n        When I call the `check_installed()` function with 'foo'\n        Then the function should raise an error with the message\n        `Please install 'nonexistent_package' before continuing`\", {\n          \n1    test_logger(start = \"mock is_installed\", msg = \"FALSE\")\n2    local_mocked_bindings(is_installed = function(package) FALSE)\n3    expect_error(object = check_installed(\"foo\"))\n    test_logger(end = \"mock is_installed\", msg = \"FALSE\")\n    \n  })\n  \n})\n\n\n1\n\nLog test start and end\n\n2\n\nSet {value} to FALSE\n\n\n3\n\nPass a package we know is not installed\n\n\n\n\nTo test installed packages, we’ll confirm check_installed('foo') with expect_invisible():\n\ndescribe(\"Feature: Checking if an R package is installed\", {\n  \n  test_that(\n    \"Scenario: Checking an installed package\n        Given the R package 'base' is installed\n        When I call the `check_installed()` function with 'base'\n        Then the function should return without any error\", {\n          \n1    test_logger(start = \"mock is_installed\", msg = \"TRUE\")\n2    local_mocked_bindings(is_installed = function(package) TRUE)\n3    expect_invisible(check_installed(\"base\"))\n    test_logger(end = \"mock is_installed\", msg = \"TRUE\")\n    \n  })\n})\n\n\n1\n\nLog test start and end\n\n2\n\nSet {value} to TRUE\n\n\n3\n\nPass a package we know is installed\n\n\n\n\nThe output from the tests above is provided below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-10-08 22:59:43] [ START mock is_installed = FALSE]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nINFO [2023-10-08 22:59:43] [ END mock is_installed = FALSE]\n\nINFO [2023-10-08 22:59:43] [ START mock is_installed = TRUE]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\nINFO [2023-10-08 22:59:43] [ END mock is_installed = TRUE]\n\n\nE.2.2 Notes on mocking\nThe roxygen2 documentation for check_installed() uses the @importFrom tag to import is_installed and add it to the sap namespace (using explicit namespacing alone won’t work):\n\n#' Check if package is installed\n#' \n#' @description\n#' An example function for demonstrating how to use `testthat`'s\n#' mocking functions.\n#' \n#' @param package string, name of package\n#'\n#' @return invisible \n#'\n1#' @importFrom rlang is_installed\n#'\n#' @export\n#'\n#' @examples\n#' check_installed(\"foo\")\n#' check_installed(\"base\")\n\n\n1\n\nFortunately we already included rlang in our DESCRIPTION file for .data in scatter_plot()\n\n\n\n\n\n\n\n\n\n\nRecap: test snapshots & mocks\n\n\n\n\n\n\nSnapshots\nvdiffr: create graph snapshots with the expect_doppelganger() function from vdiffr\nAs stated before, snapshots are brittle and can produce false negatives test failures (i.e., due to inconsequential changes in the graph) when comparing a new graph to the baseline image.\nTest mocks\nUsing testthat’s mocking functions allow us to craft unit tests that evaluate a single, specific behavior. Read more about mocking functions on the testthat webite.\n\n\n\n\n\n\n\n\n\n\nSee a typo, error, or something missing?\n\n\n\n\n\n\nPlease open an issue on GitHub",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Mocks and snapshots</span>"
    ]
  },
  {
    "objectID": "test_snapshots_mocks.html#footnotes",
    "href": "test_snapshots_mocks.html#footnotes",
    "title": "Appendix E — Mocks and snapshots",
    "section": "",
    "text": "Follow the expect_snapshot_file() example from the testthat documentation↩︎\nmatching files names between R/ and tests/testthat/ keeps our code organized and ensures the devtools::test_coverage_active_file() function works.↩︎\nTest mocking functions are a relatively new addition to testthat. Read more in the recent updates to testthat↩︎\nThis example comes from the package development masterclass workshop at posit::conf(2023).↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Mocks and snapshots</span>"
    ]
  },
  {
    "objectID": "comparisons.html",
    "href": "comparisons.html",
    "title": "Appendix F — Comparisons",
    "section": "",
    "text": "F.0.1 waldo::compare()\nComparisons are the backbone of testing. Exploring the mechanics of how tests perform these comparisons (i.e., the underlying package(s)) can save you from surprising results.\nFor example, expect_equal() compares whatever is passed to the observed and expected arguments with the waldo package, with some help from diffobj.\nIf you’d like a preview of a comparison before writing a formal test, you can pass the your observed and expected objects to compare()1\nFor example, suppose we have two objects:\nThe outputs below are example outputs from waldo::compare():\ncompare(\n1  x = old,\n  y = old)\n## ✔ No differences\n\n\n1\n\nComparing identical objects\ncompare(\n1  x = old,\n  y = new)\n## `class(old)`: \"tbl_df\" \"tbl\" \"data.frame\"\n## `class(new)`:                \"data.frame\"\n## \n## `names(old)`: \"chr\" \"num\" \"fct\"\n## `names(new)`: \"CHR\" \"num\" \"fct\"\n## \n## `old$chr` is a character vector ('B', 'C', 'D')\n## `new$chr` is absent\n## \n## `old$num` is a double vector (1, 2, 3)\n## `new$num` is an integer vector (1, 2, 3)\n## \n## `class(old$fct)`: \"ordered\" \"factor\"\n## `class(new$fct)`:           \"factor\"\n## \n## `levels(old$fct)`: \"L\"   \"M\"   \"H\"   \n## `levels(new$fct)`: \"low\" \"med\" \"high\"\n## \n## `old$CHR` is absent\n## `new$CHR` is a character vector ('B', 'C', 'D')\n\n\n1\n\nComparing different objects\ncompare() displays the differences in classes, names, and any individual value differences.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Comparisons</span>"
    ]
  },
  {
    "objectID": "comparisons.html#footnotes",
    "href": "comparisons.html#footnotes",
    "title": "Appendix F — Comparisons",
    "section": "",
    "text": "Be mindful of the difference in arguments between expectation functions (i.e., expect_equal()) and compare()↩︎\nThe results from testthat don’t include the differences between old$num and new$num. This is due to the tolerance argument, which can be adjusted in both functions.↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Comparisons</span>"
    ]
  },
  {
    "objectID": "rhino_cicd.html",
    "href": "rhino_cicd.html",
    "title": "Appendix G — Rhino CI/CD",
    "section": "",
    "text": "G.1 Trigger\nThe rhino framework includes the following GitHub Actions workflow file with new apps:\nThe sections are described below:\nThe .github/workflows/rhino-test.yml file runs on pushes to the repo containing a rhino app.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Rhino CI/CD</span>"
    ]
  },
  {
    "objectID": "rhino_cicd.html#trigger",
    "href": "rhino_cicd.html#trigger",
    "title": "Appendix G — Rhino CI/CD",
    "section": "",
    "text": "name: Rhino Test\non: push",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Rhino CI/CD</span>"
    ]
  },
  {
    "objectID": "rhino_cicd.html#permissions",
    "href": "rhino_cicd.html#permissions",
    "title": "Appendix G — Rhino CI/CD",
    "section": "G.2 Permissions",
    "text": "G.2 Permissions\nThe workflow only has read permission for the repository. Read more about setting permissions here.\npermissions:\n  contents: read",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Rhino CI/CD</span>"
    ]
  },
  {
    "objectID": "rhino_cicd.html#jobs",
    "href": "rhino_cicd.html#jobs",
    "title": "Appendix G — Rhino CI/CD",
    "section": "G.3 Jobs",
    "text": "G.3 Jobs\nrhino-test.yml contains a single job named main with the following steps:\njobs:\n  main:\n    name: Run linters and tests\n    runs-on: ubuntu-20.04\n    env:\n      R_VERSION: '4.1.0'\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n\nG.3.1 Step: Checkout Code, R version, Dependencies\nChecks out the code using actions/checkout@v2, extracts the R version from a lockfile (renv.lock) and sets it as an environment variable (env.R_VERSION), and uses apt-get to install system dependencie (libcurl4-openssl-dev)\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v2\n\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v1\n        with:\n          r-version: ${{ env.R_VERSION }}\n\n      - name: Setup system dependencies\n        run: &gt;\n          sudo apt-get update && sudo apt-get install --yes\n          libcurl4-openssl-dev\n\n\nG.3.2 Step: Restore and sync renv\nThe R dependencies in renv.lock are restored from cache with actions/cache@v2, then the R environment is synchronized with the lockfile (ensuring all necessary R packages are installed).\n\n      - name: Restore renv from cache\n        uses: actions/cache@v2\n        env:\n          CACHE_KEY: renv-${{ runner.arch }}-${{ runner.os }}-${{ env.R_VERSION }}\n        with:\n          path: renv/library\n          key: ${{ env.CACHE_KEY }}-${{ hashFiles('renv.lock') }}\n          restore-keys: ${{ env.CACHE_KEY }}-\n          \n      - name: Sync renv with lockfile\n        shell: Rscript {0}\n        run: |\n          options(renv.config.cache.symlinks = FALSE)\n          renv::restore(clean = TRUE)\n\n\nG.3.3 Step: Node.js\nThe Node.js environment is set up with version 16.\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: 16\n\n\nG.3.4 Step: Linters\nLints R (rhino::lint_r()), JavaScript (rhino::lint_js()), and Sass (rhino::lint_sass()) code for quality and style consistency.\n      - name: Lint R\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_r()\n\n      - name: Lint JavaScript\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_js()\n\n      - name: Lint Sass\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_sass()\n\n\nG.3.5 Step: Unit Tests\nExecutes testthat unit tests written in R (rhino::test_r())\n      - name: Run R unit tests\n        if: always()\n        shell: Rscript {0}\n        run: rhino::test_r()\n\n\nG.3.6 Step: Cypress End-to-End Tests\nSpecifies the working directory .rhino/, starting command for the application (npm run run-app), project directory for tests (../tests), URL to wait for ('http://localhost:3333/'), and a timeout for waiting (60) for Cypress to run end-to-end tests.\n      - name: Run Cypress end-to-end tests\n        if: always()\n        uses: cypress-io/github-action@v5\n        with:\n          working-directory: .rhino # Created by earlier commands which use Node.js\n          start: npm run run-app\n          project: ../tests\n          wait-on: 'http://localhost:3333/'\n          wait-on-timeout: 60",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Rhino CI/CD</span>"
    ]
  }
]