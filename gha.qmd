# GitHub Actions {#sec-gha-cicd}

```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(testthat)
```

```{r}
#| label: co_box_tldr
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b",
  look = "default", hsize = "1.05", size = "0.95",
  header = "TLDR &emsp; ![](images/gha.png){width='45'}",
  fold = TRUE,
  contents = "
  - GitHub Actions automate testing and deployment for R packages.
  
  - Workflows are defined in YAML files under `.github/workflows/`.
  
  - Common tasks include styling/linting, running tests, and deploying apps."
)
```

Continuous Integration (CI) and Continuous Deployment (CD) help automate software development tasks, especially testing and deployment. In the context of a Shiny app-package, CI/CD usually refers to GitHub Actions or Travis CI.

This chapter will only cover CI/CD with GitHub Actions. Travis-CI has been around longer than GitHub Actions, and if you'd like to compare the two, I recommend [this article.](https://talent500.co/blog/github-actions-vs-travis-ci-weighing-pros-cons-and-selecting-the-ideal-platform/)

```{r}
#| label: shinypak_apps
#| echo: false
#| results: asis
#| eval: true
shinypak_apps(regex = "^21", branch = "21.1_gha-style")
```

## GitHub Actions {.unnumbered}

```{r}
#| label: co_box_cicd
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b",
  look = "default", hsize = "1.05", size = "0.95",
  header = "Continuous Integration & Deployment (CI/CD)",
  fold = TRUE,
  contents = "
**Continuous Integration (CI)** can automate testing with `testthat` and `shinytest2`, ensuring any new features or bug fixes don’t introduce errors. It can verify that our app-package installs correctly and prevents any breaking changes. When integrated with version control systems like Git, CI tracks modifications and enforces code reviews before merging updates.  

**Continuous Deployment (CD)** can be used to automate app-package releases by deploying tested code to an internal package management system, ensuring users always have the latest version without manual updates. This accelerates feature delivery, reduces downtime, and streamlines development, allowing us to focus more on writing code than testing and deployments.
  ")

```

:::: {layout="[80, 20]"}

::: {style='color: #000000;'}

[GitHub Actions](https://github.com/features/actions) (or Actions, for short) is a feature provided by GitHub that enables automation of various development workflows. These workflows are defined in YAML files and can automate some of the repetitive tasks in the development lifecycle, right within a GitHub repository. 

:::

![GitHub Actions](images/gha.png){width=50% fig-align='left'}

::::

We can use Actions to create custom workflows for building, testing, and deploying our app-package. 

### Workflows {.unnumbered}

A workflow is a YAML file placed in a repository to automate processes and executes jobs. **Workflows** can be triggered manually or set to run on a schedule based on repository **events**. 

```{=html}
<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}
</style>
```

```{mermaid}
%%| fig-align: center
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', "fontSize":"16px"}}}%%

flowchart TD
  workflow(["Workflow"]) -->|"<em>Triggered by<em>"| event("<strong>Event</strong>: push, pull request, etc.")
    
```

[`on`]{style="font-size: 1.45em; font-weight: bold; font-style: italic;"}

**`on`** defines the [event(s)](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#events) that trigger the **workflow**.

:::: {layout="[50,50]" layout-valign="top"}

``` yaml
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
```

[An event is any activity that triggers a workflow, such as a pull request, a new issue or pushed commits.]{style="font-size: 0.95rem;"}[^triggers]

[^triggers]: Triggers can also be configured to run at scheduled times.

::::

[`name`]{style="font-size: 1.45em; font-weight: bold; font-style: italic;"}

`name` is an optional field to identify a workflow in the Actions tab of the GitHub repository. 

:::: {layout="[50,50]" layout-valign="top"}


```yaml
name: shiny
```

[If `name` is not provided, GitHub will use the file path.]{style="font-size: 0.95rem;"}

::::

[`jobs`]{style="font-size: 1.45em; font-weight: bold; font-style: italic;"}

A [**job**](https://docs.github.com/en/actions/about-github-actions/understanding-github-actions#jobs) consists of a sequence of **steps** defined in the **workflow** file. 

```{=html}
<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}
</style>
```

```{mermaid}
%%| fig-align: center
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', "fontSize":"16px"}}}%%
flowchart 
  workflow(["Workflow"]) -->|"<em>Triggered by<em>"| event("<strong>Event</strong>: push, pull request, etc.")

  event --> |"<em>Executes</em>"| Jobs{"<strong>Jobs</strong>"}
```

:::: {layout="[50,50]" layout-valign="top"}

```yaml
jobs:
  check:
    runs-on: ubuntu-latest
```

[The [identifier](https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow#setting-an-id-for-a-job) (`check` in this case) is used to reference the runner, in this example it's `ubuntu-latest`.]{style="font-size: 0.95rem;"}


::::

A [**runner**](https://docs.github.com/en/actions/about-github-actions/understanding-github-actions#runners) is a server (running Ubuntu Linux, Microsoft Windows, or macOS) that operates within a freshly provisioned virtual machine to execute the triggered **workflow**.

```{=html}
<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}
</style>
```

```{mermaid}
%%| fig-align: center
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', "fontSize":"16px"}}}%%

flowchart 
  workflow(["Workflow"]) -->|"<em>Triggered by<em>"| event("<strong>Event</strong>: push, pull request, etc.")
  
  subgraph VM["Virtual Machine"]
    subgraph runner02["<strong>Runner</strong> 2"]
    end
    subgraph runner01["<strong>Runner</strong> 1"]
    end
  end

  event --> |"<em>Executes</em>"| Jobs{"<strong>Jobs</strong>"}
  Jobs --> |"<em>Launches</em>"|runner01 & runner02
```

Each **runner** can run a single **job** at a time. 

:::: {layout="[50,50]" layout-valign="top"}

``` yaml
jobs:
  check:
    runs-on: ${{ matrix.config.os }}
    
```

[[**`matrix`**](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs#using-a-matrix-strategy) runs jobs across different operating systems, programming language versions, etc.]{style="font-size: 0.95rem;"}

::::

:::: {layout="[50,50]" layout-valign="top"}

``` yaml
    name: ${{ matrix.config.os }} (${{ matrix.config.r }})
    
```

::::

:::: {layout="[50,50]" layout-valign="top"}

``` yaml
    strategy:
      fail-fast: false
      matrix:
        config:
          - {os: macos-latest,   r: 'release'}
          - {os: windows-latest, r: 'release'}
          - {os: ubuntu-latest,   r: 'release'}
```

[**`fail-fast: false`** means the workflow will continue running even if one of the `matrix` jobs fails.]{style="font-size: 0.95rem;"}

::::

[`steps`]{style="font-size: 1.45em; font-weight: bold; font-style: italic;"}

Each **step** can be a shell script or an [**action**](https://docs.github.com/en/actions/about-github-actions/understanding-github-actions#actions), and they are executed in the order they are written. For example, checking out code from a repository, setting up R, installing a package, and launching an app. 

```{=html}
<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}
</style>
```

```{mermaid}
%%| fig-align: center
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', "fontSize":"16px"}}}%%

flowchart 
  workflow(["Workflow"]) -->|"<em>Triggered by<em>"| event("<strong>Event</strong>: push, pull request, etc.")
  
  subgraph VM["Virtual Machine"]
    subgraph runner02["<strong>Runner</strong> 2"]
        action02a("<strong>Action</strong>: checkout code")
        action02b("<strong>Action</strong>: set up R")
        step02a("<strong>Script</strong>: launch app")
    end
    subgraph runner01["<strong>Runner</strong> 1"]
        action01a("<strong>Action</strong>: checkout code")
        action01b("<strong>Action</strong>: set up R")
        step01a("<strong>Script</strong>: install package")
    end
  end

  event --> |"<em>Executes</em>"| Jobs{"<strong>Jobs</strong>"}
  Jobs --> |"<em>Launches</em>"|runner01 & runner02
```

:::: {layout="[50,50]" layout-valign="top"}

``` yaml
steps:
    - uses: actions/checkout@v2

    - name: Set up R
      uses: r-lib/actions/setup-r@v2

    - name: Install package
      run: |
        install.packages('remotes')
        remotes::install_local('.')
      shell: Rscript {0}
      
```

[`steps` define a series of [tasks or actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsteps) that the `job` will execute. These `steps` check out the code, set up the R environment, and install a local R package.]{style="font-size: 0.95rem;"}

::::

```{r}
#| label: co_box_run_e_rscript_comparison
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "g", 
  look = "default", hsize = "1.05", size = "0.95",
  fold = TRUE,
  header = "What is **`shell: Rscript {0}`**?",
  contents = "
  
\`\`\`yaml
  name: Install packages
  run: |
    pkgs <- c('glue', 'cli')
    install.packages(pkgs)
  shell: Rscript {0}
\`\`\`
  
The command `install.packages(pkgs)` is run as an R script:
  
- `shell` specifies which command-line interpreter (`bash`, `pwsh`, `python`, or `Rscript`) to use for the `run` commands
  
- `Rscript` is the command-line tool provided by R to execute R scripts and commands in a non-interactive environment. 

- `{0}` is a placeholder for the R commands written in the `run` section. 

"
)
```

Finally, lines beginning with `#` will not be executed. It's common to provide 1) a reference to the workflow source ([`r-lib/actions`](https://github.com/r-lib/actions/) in this case) and 2) a link for help with debugging build failures.

```yaml
# Workflow derived from https://github.com/r-lib/actions/tree/v2/examples
# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help
```

### Permissions {.unnumbered}

In order for workflows to run, we'll need to make sure Actions have read and write permissions. We can do this by clicking on the repository's **Settings** tab, then expand the **Actions** menu and select **General**:

![Repository Action settings](images/gh_action_settings.png){width='100%'}

In the **General** settings, we want to confirm the workflow has **Read and write permissions** permissions (if this needs to be been changed, be sure to click **Save**). 

![Workflow permissions](images/gh_action_permissions.png){width='100%'}

Now our workflows can commit and push changes to the repository.

## Code styling and linting {#sec-gha-style}

In R packages, we can set up the GitHub Action infrastructure with `usethis::use_github_action()`. The `name` can be any of the workflow files available at [r-lib/actions](https://github.com/r-lib/actions/?tab=readme-ov-file#list-of-actions). The first workflow we'll be demonstrating can be used to automate the [code style in an app-package](https://github.com/r-lib/actions/tree/v2/examples#style-package).

```{r}
#| label: git_box_21.1_gha-style
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "launch",
  fig_pw = '75%', 
  branch = "21.1_gha-style", 
  repo = 'sap')
```

```{r}
#| code-fold: false
#| eval: false
usethis::use_github_action("style")
```

``` sh
✔ Setting active project to '/projects/apps/sap'
✔ Creating '.github/'
✔ Adding '*.html' to '.github/.gitignore'
✔ Creating '.github/workflows/'
✔ Saving 'r-lib/actions/examples/style.yaml@v2' to '.github/workflows/style.yaml'
```

The output tells us a local `.github/workflows/style.yaml` file has been copied from the [`r-lib/actions/examples/style.yaml@v2`](https://github.com/r-lib/actions/blob/v2/examples/style.yml) into the `.github/workflows` folder: 

``` sh
.github/
  └── workflows
    └── style.yaml

2 directories, 1 file
```



The documentation for the `style.yaml@v2` file tells us this workflow,

> "*styles the R code in a package, then commits and pushes the changes to the same branch."* 

The code styling in this workflow is handled by the [`styler` package](https://styler.r-lib.org/), which "*formats your code according to the tidyverse style guide.*"

We'll make one small change to `style.yaml` before pushing it to GitHub. **Instead of having the workflow automatically commit and push the styled code changes to the same branch, we'll limit the code styling to the `21.1_gha-style` branch:**


``` yaml
on:
  push:
    branches: [21.1_gha-style]
    paths: ["**.[rR]", "**.[qrR]md", "**.[rR]markdown", "**.[rR]nw", "**.[rR]profile"]
```

This change ensures our `style` workflow will be triggered only for pushes to the specified `branches` (and when changes are made to files with the specified extensions in `path`). 

After saving these changes to [`.github/workflows/style.yaml`](https://github.com/mjfrigaard/sap/blob/21.1_gha-style/.github/workflows/style.yaml), we'll add, commit, and push the changes to GitHub, 

``` sh 
git add .
git commit -m "updates to style workflow"
```

``` sh
[21.1_gha-style 899bd38] updates to style workflow
 4 files changed, 43 insertions(+), 45 deletions(-)
```

``` sh 
git push
```

``` sh
Enumerating objects: 17, done.
Counting objects: 100% (17/17), done.
Delta compression using up to 12 threads
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 950 bytes | 25.00 KiB/s, done.
Total 9 (delta 6), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (6/6), completed with 6 local objects.
To https://github.com/mjfrigaard/sap.git
   d366e0f..899bd38  21.1_gha-style -> 21.1_gha-style
```

If we view the **Actions** tab, we'll see the workflow listed with the name of our commit message: 

![Currently running workflows](images/gh_action_tab.png){width='100%'}

Clicking on the workflow reveals the following: 

![name of running workflow](images/gh_action_details.png){width='100%'}

The **style** widget contains each step in the workflow file. If we click on it we can see each step executed in real-time. Below we can see the dependencies installed from the `pak` lockfile:

::: {layout="[50,50]" layout-valign="top"}

![Click on the **style** widget](images/gha_style_widget.png){width='100%'}

![View the **Install styler and roxygen2** workflow step running](images/gha_install_dependencies.png){width='100%'}

:::

The actual styling comes is in the **Style** step: 

![**Style** workflow step running](images/gh_action_style_output.png){width='100%'}

When the workflow has finished, we can pull the style changes to our local branch and view the styled files:[^rlib-actions-examples] 

[^rlib-actions-examples]: You can find more examples of common GitHub Actions for R packages in [r-lib/actions/examples](https://github.com/r-lib/actions/tree/v2/examples#readme).

``` sh 
git pull
```

``` sh 
remote: Enumerating objects: 67, done.
remote: Counting objects: 100% (67/67), done.
remote: Compressing objects: 100% (7/7), done.
remote: Total 34 (delta 28), reused 33 (delta 27), pack-reused 0 (from 0)
Unpacking objects: 100% (34/34), 5.60 KiB | 86.00 KiB/s, done.
From https://github.com/mjfrigaard/sap
   5ccdc21..6296140  21.1_gha-style -> origin/21.1_gha-style
Updating 5ccdc21..6296140
Fast-forward
 R/data.R                                         |  10 +++++-----
 R/display_type.R                                 |  16 ++++++++-------
 R/launch_app.R                                   |  88 +++++++++++++++++++++++++++++++++++++++++------------------------------------------
 R/log_message.R                                  |  10 +++++-----
 R/logr_msg.R                                     |  28 +++++++++++++--------------
 R/mod_aes_input.R                                |  54 ++++++++++++++++++++++++++++-----------------------
 R/mod_scatter_display.R                          | 121 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------------------------------------------------------
 R/mod_var_input.R                                |  67 ++++++++++++++++++++++++++++++++++-----------------------------
 R/movies_server.R                                |  69 ++++++++++++++++++++++++++++++++++++-----------------------------
 R/movies_ui.R                                    | 108 ++++++++++++++++++++++++++++++++++++++++++++++++++++-------------------------------------------------
 R/scatter_plot.R                                 |  34 +++++++++++++++++---------------
 R/testthat.R                                     |  16 +++++++--------
 R/text_logo.R                                    |  23 +++++++++++-----------
 R/zzz.R                                          |  58 +++++++++++++++++++++++++++----------------------------
 inst/quarto/index.qmd                            |  32 ++++++++++++++++--------------
 tests/testthat/fixtures/make-tidy_ggp2_movies.R  |   6 ++++--
 tests/testthat/helper.R                          |   7 +++----
 tests/testthat/test-mod_scatter_display_server.R |  88 +++++++++++++++++++++++++++++++++++++++++++++--------------------------------------
 tests/testthat/test-mod_var_input_server.R       |  25 ++++++++++++------------
 tests/testthat/test-scatter_plot.R               |  62 +++++++++++++++++++++++++++++-----------------------------
 tests/testthat/test-shinytest2-export.R          |  31 ++++++++++++++---------------
 tests/testthat/test-shinytest2-prod.R            |  43 ++++++++++++++++++++++-------------------
 tests/testthat/test-shinytest2.R                 |  45 +++++++++++++++++++++++--------------------
 tests/testthat/test-text_logo.R                  |  45 ++++++++++++++++++++++---------------------
 vignettes/specs.Rmd                              |   2 +-
 25 files changed, 570 insertions(+), 518 deletions(-)
```

## Shiny app deployment {#sec-gha-shiny}

In this section we'll be adapting the GitHub Action workflow file provided for [deploying a Shiny applications](https://github.com/r-lib/actions/blob/v2/examples/shiny-deploy.yaml). Before we get to the workflow file, we need to address a few settings and configurations that need to take place *outside* of the workflow file. 

```{r}
#| label: git_box_21.2_gha-shiny-deploy
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "launch",
  fig_pw = '75%', 
  branch = "21.2_gha-shiny-deploy", 
  repo = 'sap')
```

### Creating repository secrets

We need to make sure our `rsconnect` secrets are stored with the GitHub repository (so we can access them from within the workflow file). To do this, we're going to return to the **Settings** tab on the `sap` repository, expand **Secrets and variables** under **Security**, and select **Actions**:[^repo-secrets]

[^repo-secrets]: GitHub secrets should be specified by the user following the instructions in the [Creating secrets for a repository](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions#creating-secrets-for-a-repository) article.

![**Secrets and variables** for `sap` repository](images/gh_action_secrets_repo.png){width='80%' fig-align='center'}

Use **New repository secret** to create three new secrets: **RSCONNECT_USER**, **RSCONNECT_TOKEN**, and **RSCONNECT_SECRET**. You can access these in your shinyapps.io account by clicking on the **Tokens** tab, then **Show** and **Show secret**:

![**Token** from shinyapps.io](images/gh_action_shinyapps_tokens.png){width='100%' fig-align='center'}

![**User** and **Secret** from shinyapps.io](images/gh_action_shinyapps_secrets_token.png){width='100%' fig-align='center'}

When you're finished, should see the following three **Repository secrets**:

![**Repository secrets** in `sap`](images/gh_action_all_repo_secrets.png){width='95%' fig-align='center'}

### Enable private repositories 

We also need to make sure our shinyapps.io account allows us to install from private GitHub repositories during a workflow deployment. We can do this in the **Profile** menu item in our dashboard:

![**Update Authentication** in shinyapps.io profile](images/gh_action_shinyapps_auth.png){width='85%' fig-align='center'}

Clicking **Update Authentication** will open your Posit profile settings, where you can enable private repositories. 

![**Private repo access also enabled**](images/gh_action_shinyapps_private_repos.png){width='95%' fig-align='center'}

### Capture dependencies

The documentation for 'Shiny App Deployment' indicates we need to create a `renv` lockfile in the `21.2_gha-shiny-deploy` branch.[^renv-lockfile] 

[^renv-lockfile]: "*This action assumes you have an `renv` lockfile in your repository that describes the R packages and versions required for your Shiny application.*" - [Shiny App Deployment](https://github.com/r-lib/actions/tree/v2/examples#shiny-app-deployment)

We can create the lockfile with the code below:

```{r}
#| eval: false
#| code-fold: false
install.packages('renv')
renv::init(force = TRUE)
```

```{verbatim}
This project contains a DESCRIPTION file.
Which files should renv use for dependency discovery in this project? 

1: Use only the DESCRIPTION file. (explicit mode)
2: Use all files in this project. (implicit mode)
```

We're going to use the `explicit mode`, because the dependencies in the `DESCRIPTION` should be all that's needed to run and deploy the application.

```{verbatim}
Selection: 1
```

This will update the `renv.lock` file with the packages, their dependencies, and the R version:

```{verbatim}
- Linking packages into the project library ... Done!
```

```{verbatim}
The following package(s) will be updated in the lockfile:
```

```{verbatim}
The version of R recorded in the lockfile will be updated:
```

```{verbatim}
- Lockfile written to "~/projects/apps/R/sap/renv.lock".
- renv activated -- please restart the R session.
```

We will restart the session to finish creating the new project library.

After `renv` has discovered and installed the dependencies, the R session will restart and we'll see the following new folder/files: 

```{verbatim}
#| eval: false
#| code-fold: false
├── .Rprofile # <1>
├── renv/
│   ├── activate.R
│   └── settings.json # <2>
└── renv.lock # <3>
```
1. `.Rprofile` contains a call to `source("renv/activate.R")`, which manages the project-level dependencies   
2. `renv` settings   
3. `renv` lockfile

When using `renv` in package development, we want to be sure to run `renv::install()` and `renv::update()`: 

```{r}
#| eval: false
#| code-fold: false
renv::install()
```

```{bash}
#| eval: false
#| code-fold: false
- There are no packages to install.
```

```{r}
#| eval: false
#| code-fold: false
renv::update()
```

```{bash}
#| eval: false
#| code-fold: false
- Checking for updated packages ... Done!
- All packages appear to be up-to-date.
```

Now that we've handled our secrets and tokens and have all of our dependencies captured, we can write our workflow file.

### [`shiny-deploy.yaml`]{style="font-size: 1.10em; font-weight: bold;"}

We can include the 'Shiny App Deployment' workflow file in `sap` with `usethis::use_github_action("shiny-deploy")`:[^shiny-depoy]

[^shiny-depoy]: Instructions for the GitHub Action Shiny deployment can be found [here](https://github.com/r-lib/actions/tree/v2/examples#shiny-app-deployment)

```{r}
#| eval: false 
#| code-fold: false
usethis::use_github_action("shiny-deploy")
```

```{bash}
#| eval: false 
#| code-fold: false
✔ Creating .github/.
✔ Adding "*.html" to .github/.gitignore.
✔ Creating .github/workflows/.
✔ Saving "r-lib/actions/examples/shiny-deploy.yaml@v2" to .github/workflows/shiny-deploy.yaml.
☐ Learn more at <https://github.com/r-lib/actions/blob/v2/examples/README.md>.
```

This example workflow file is designed to deploy a Shiny application to a server. We're going to make a few changes to `shiny-deploy.yaml` so it will deploy our application to shinyapps.io when we push to the [`21.2_gha-shiny-deploy`](https://github.com/mjfrigaard/sap/tree/21.2_gha-shiny-deploy) branch.

#### Test run

The example shiny workflow includes calls to `rsconnect::setAccountInfo()` and `rsconnect::deployApp()`. We'll perform a test run with these functions to confirm we can deploy the application using the information we've collected:

1. Start by entering your rsconnect info: 

```{r}
#| eval: false 
#| code-fold: false
install.packages('rsconnect')
rsconnect::setAccountInfo(
  name = "mjfrigaard",
  token = "YOUR TOKEN", 
  secret = "YOUR SECRET")
```
    
2. Then try to deploy the application using `rsconnect::deployApp()`:

```{r}
#| eval: false 
#| code-fold: false
library(sap)
rsconnect::deployApp(
  appName = "shinyAppPkgsCICD",
  account = "mjfrigaard",
  server = "shinyapps.io",
  forceUpdate = TRUE)
```

Reading the deployment log will tells us if the secret, token, configuration, and lockfile are all working:

```{bash}
#| eval: false 
#| code-fold: false
── Preparing for deployment ──────────────────────────────────────────────────
✔ Deploying "shinyAppPkgsCICD" using "server: shinyapps.io / username: mjfrigaard"
ℹ Bundling 50 files: .github/workflows/shiny-deploy.yaml, .Rbuildignore, ..., 
tests/testthat.R, and vignettes/test-specs.Rmd
ℹ Capturing R dependencies with renv
✔ Found 99 dependencies
✔ Created 2,431,325b bundle
ℹ Uploading bundle...
✔ Uploaded bundle with id 8130675
── Deploying to server ─────────────────────────────────────────────────────────
Waiting for task: 1372980209
  building: Processing bundle: 8130675
  building: Building image: 9770352
  building: Fetching packages
  building: Installing packages
  building: Installing files
  building: Pushing image: 9770352
  deploying: Starting instances
  unstaging: Stopping old instances
── Deployment complete ─────────────────────────────────────────────────────────
✔ Successfully deployed to <https://mjfrigaard.shinyapps.io/shinyAppPkgsCICD/>
```

Making sure an application will deploy locally with the code we plan on putting into the workflow file builds confidence it run when it's triggered. Now we're ready to adapt the `.github/workflows/shiny-deploy.yaml` file.

#### Event

The event we want to trigger this deployment is a push the `21.2_gha-shiny-deploy` branch. We'll also change of the name of this workflow to `shiny`.

::: {layout="[50,50]" layout-valign="top"}

```YAML
on:
  push:
    branches: [21.2_gha-shiny-deploy]
    
name: shiny
```



  - [Triggered event **`on`** a `push` to the `21.2_gha-shiny-deploy` branch]{style="font-size: 0.90rem;"}    

  - [Change **`name`** to `shiny`]{style="font-size: 0.90rem;"}


:::

```{=html}
<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}
</style>
```

```{mermaid}
%%| fig-align: center
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', "fontSize":"16px"}}}%%
flowchart TD
  Push(["Push to branch"])
  Push -->|"<em>Triggers</em>"| Shiny{"<strong>Job</strong>: <code>shiny</code>"}
```



#### Jobs 

The **job** will set up the runner and pass our stored `GITHUB_TOKEN`. `runs-on` launches a runner with the latest Ubuntu operating system and `env` [maps](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#env) the `GITHUB_TOKEN` environment variable (we can access those secrets with `secrets.<SECRET_NAME>`).

::: {layout="[50,50]" layout-valign="top"}

```yaml
jobs:
  shiny:
    runs-on: ubuntu-latest
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
```


[**`jobs`** remains unchanged, but the identifier should match the **`name`**.]{style="font-size: 0.90rem;"}

:::

```{=html}
<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}
</style>
```

```{mermaid}
%%| fig-align: center
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', "fontSize":"16px"}}}%%
flowchart TD
  Push(["Push to branch"])
  Push -->|"<em>Triggers</em>"| Shiny{"<strong>Job</strong>: <code>shiny</code>"}
    subgraph ubuntu["<strong>Runner</strong>"]
      Env("<strong>Env</strong>: <code>GITHUB</code>")
    end
  Shiny -->|"<em>Runs on: Ubuntu Latest</em>"| ubuntu
```


#### Steps 

The first four **steps** are **actions** that clone our repo and set up the environment for performing the tasks in the **workflow**. The path to the action is passed to `uses:`, so `actions/checkout@v4` uses the YAML file from the [actions/checkout repo](https://github.com/actions/checkout). 

::: {layout="[50,50]" layout-valign="top"}

``` yaml
    steps:
      - uses: actions/checkout@v4

      - uses: r-lib/actions/setup-pandoc@v2

      - uses: r-lib/actions/setup-r@v2
        with:
          use-public-rspm: true
          r-version: renv

      - uses: r-lib/actions/setup-renv@v2
```

  - [Check out the repository code]{style="font-size: 0.90rem;"} 

  - [Set up Pandoc (document conversions)]{style="font-size: 0.90rem;"} 

  - [Set up R environment.]{style="font-size: 0.90rem;"}[^r-env]

  - [Set up `renv` to manage the project-specific dependencies captured in `renv.lock`]{style="font-size: 0.90rem;"} 

:::

[^r-env]: `use-public-rspm` is the public RStudio package manager and `r-version: renv` indicates the R version is captured with `renv`.

```{=html}
<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}
</style>
```

```{mermaid}
%%| fig-align: center
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', "fontSize":"16px"}}}%%
flowchart TD
  Push(["Push to branch"])
  Push -->|"<em>Triggers</em>"| Shiny{"<strong>Job</strong>: <code>shiny</code>"}
    subgraph ubuntu["<strong>Runner</strong>"]
        PAT("<strong>Env</strong>: <code>GITHUB</code>")
        Checkout("<strong>Action</strong>: Checkout")
        SetupPandoc("<strong>Action</strong>: Pandoc")
        SetupR("<strong>Action</strong>: R env")
        SetupRenv("<strong>Action</strong>: <code>renv</code>")
    end
  Shiny -->|"<em>Runs on: Ubuntu Latest</em>"| ubuntu
  PAT --> Checkout --> SetupPandoc --> SetupR
  SetupR --> SetupRenv
```

The following **step** is a script (i.e., `run:`) and it installs the `rsconnect` package:

::: {layout="[50,50]" layout-valign="center"}

``` yaml
      - name: Install rsconnect
        run: install.packages("rsconnect")
        shell: Rscript {0}
```

[`Install rsconnect` uses R to install the `rsconnect`]{style="font-size: 0.90rem;"}       
:::

Next we use `env` again to [map](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#env) our account username (`mjfrigaard`) and app name (`shinyDeployApp`):
        
::: {layout="[50,50]" layout-valign="center"}

     
``` yaml
    - name: Authorize and deploy app
      env: 
        APPNAME: shinyDeployApp
        ACCOUNT: mjfrigaard
        SERVER: shinyapps.io 
```

[Sets up the environment variables `APPNAME`, `ACCOUNT`, and `SERVER` for authorization]{style="font-size: 0.90rem;"}      
        
:::

The final `run` **step** sets the account information using `rsconnect::setAccountInfo()` and deploys the app to the specified server using `rsconnect::deployApp()` (we'll add `forceUpdate = TRUE`):

    
``` yaml
    run: |
      rsconnect::setAccountInfo("${{ secrets.RSCONNECT_USER }}", "${{ secrets.RSCONNECT_TOKEN }}", "${{ secrets.RSCONNECT_SECRET }}")
      rsconnect::deployApp(appName = "${{ env.APPNAME }}", account = "${{ env.ACCOUNT }}", server = "${{ env.SERVER }}", forceUpdate = TRUE)
    shell: Rscript {0}
```

This will deploy an application at `https://<ACCOUNT>.shinyapps.io/<APPNAME>/`.

```{=html}
<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}
</style>
```

```{mermaid}
%%| fig-align: center
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontFamily': 'monospace', "fontSize":"16px"}}}%%
flowchart TD
  Push(["Push to branch"])
  Push -->|"<em>Triggers</em>"| Shiny{"<strong>Job</strong>: <code>shiny</code>"}
    subgraph ubuntu["<strong>Runner</strong>"]
        PAT("<strong>Env</strong>: <code>GITHUB</code>")
        Checkout("<strong>Action</strong>: Checkout")
        SetupPandoc("<strong>Action</strong>: Pandoc")
        SetupR("<strong>Action</strong>: R env")
        SetupRenv("<strong>Action</strong>: <code>renv</code>")
        InstallRsconnect("<strong>Script</strong>: <code>rsconnect</code>")
        Auth("<strong>Env</strong>: <code>RSCONNECT</code>")
        Deploy("<strong>Script</strong>: Deploy")
    end
  Shiny -->|"<em>Runs on: Ubuntu Latest</em>"| ubuntu
  PAT --> Checkout --> SetupPandoc --> SetupR
  SetupR --> SetupRenv --> InstallRsconnect
  InstallRsconnect --> Auth --> Deploy
```

When we add, commit, and push the changes to the repo, we see the following deployment log:

``` sh
git add .
git commit -m "shiny deploy workflow"
git push
```

``` sh
[21.2_gha-shiny 7953a5c] shiny deploy workflow
 10 files changed, 2130 insertions(+)
 create mode 100644 .Rprofile
 create mode 100644 .github/.gitignore
 create mode 100644 .github/workflows/shiny-deploy.yaml
 create mode 100644 renv.lock
 create mode 100644 renv/.gitignore
 create mode 100644 renv/activate.R
 create mode 100644 renv/settings.json
 create mode 100644 rsconnect/shinyapps.io/mjfrigaard/shinyDeployApp.dcf
```

On GitHub, we can see the workflow running on the **Actions** tab of the `sap` repository: 

![shiny deploy workflow running](images/gh_action_shiny_tab.png){width='100%' fig-align='center'}

When it's finished, we can see the deployment log from the workflow looks similar to the log we saw locally:

![deploy log from workflow](images/gh_action_shiny_deploy.png){width='100%' fig-align='center'}

You can view the deployed application here: <https://mjfrigaard.shinyapps.io/shinyDeployApp/>

## Actions, Shiny & Docker {#sec-gha-shiny-docker}

We covered Docker in the previous chapter, which builds and application in an image and containerizes it's deployment. In this section we'll combine Docker and GitHub Actions to automate deployment of our app. Automating app deployments will minimize the risk of environmental discrepancies (avoiding the "*it works on my machine*" problem) and manual deployment processes. Plus, if something goes wrong after a workflow run, rolling back to a previous version in Git is straightforward. 

```{r}
#| label: git_box_21.3_gha-shiny-docker
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "launch",
  fig_pw = '75%', 
  branch = "21.3_gha-shiny-docker", 
  repo = 'sap')
```

### Secrets and tokens

Most of the steps below are covered in the excellent blog post by [Nicola Rennie](https://nrennie.rbind.io/)[^post-automatically-deploying-a-shiny-app] I've updated the contents to work with a Shiny app-package.

[^post-automatically-deploying-a-shiny-app]: [Automatically deploying a Shiny app for browsing #RStats tweets with GitHub Actions.](https://nrennie.rbind.io/blog/2022-10-05-automatically-deploying-a-shiny-app-for-browsing-rstats-tweets-with-github-actions/) Nicola Rennie. October 3, 2022.

To make sure our Connect username, token, and secret travels with our `Dockerfile`, we will need to store them as environmental variables.

Environmental variables can be set/unset with `Sys.setenv()`/`Sys.unsetenv()`:

```{r}
#| eval: false
#| code-fold: false
Sys.setenv(RSCONNECT_USER = '<username>', 
  RSCONNECT_TOKEN = '<token>', 
  RSCONNECT_SECRET = '<secret>')
```

These environmental variables are be passed to `rsconnect::setAccountInfo()` with a `deploy.R` file.

### [`deploy.R`]{style="font-size: 0.95em; font-weight: bold;"}

`deploy.R` contains the calls to `rsconnect::setAccountInfo()` and `rsconnect::deployApp()` we had in our previous workflow file. `Sys.getenv()` will retrieve the username, token, and secret stored with `Sys.setenv()`:

```{r}
#| eval: false
#| code-fold: false
rsconnect::setAccountInfo(name = Sys.getenv("RSCONNECT_USER"),
               token = Sys.getenv("RSCONNECT_TOKEN"),
               secret = Sys.getenv("RSCONNECT_SECRET"))
rsconnect::deployApp(appDir = ".", 
  appName = "shinyAppPkgsDockerCiCd", 
  account = "mjfrigaard", 
	server = "shinyapps.io", 
	forceUpdate = TRUE)
```

The `deploy.R` script should be placed in the root folder of `sap`. By default, this will deploy the application launched with `app.R`. We'll change this to the application launched with `launch_app('ggp2')` by changing the contents of `app.R` to the following: 



```{r}
#| eval: false
#| code-fold: show 
#| code-summary: 'show/hide updated app.R'
withr::with_options(new = list(shiny.autoload.r = FALSE), code = {
  if (!interactive()) {
    sink(stderr(), type = "output")
    tryCatch(
      expr = {
        library(sap)
      },
      error = function(e) {
        pkgload::load_all()
      }
    )
    shinyAppDir(appDir = system.file("prod/app", package = "sap"))
  } else {
    pkgload::load_all()
  }
  launch_app(app = 'ggp2', options = list(test.mode = FALSE))
})
```


### [`Dockerfile`]{style="font-size: 0.95em; font-weight: bold;"}

The `Dockerfile` will look similar to the example in the [Docker](docker.qmd) chapter, but with a few important changes: 

1. When we make the path `/home/shinyAppPkgsDockerCiCd` with `mkdir`, this is not only the image location we'll be launching the application from, but it's also the URL for the deployed app: 
    -   `https://` **`username`** `.shinyapps.io/shinyAppPkgsDockerCiCd/`
    
2. We'll include the packages in the `DESCRIPTION` in our list of dependencies to install, *and* the `remotes` and `rsconnect` packages. 

3. The final `Rscript` command will run the application using our `deploy.R` file.


``` sh
FROM rocker/shiny
RUN mkdir /home/shinyAppPkgsDockerCiCd
ADD . /home/shinyAppPkgsDockerCiCd
WORKDIR /home/shinyAppPkgsDockerCiCd
RUN R -e 'install.packages(c("bslib", "cli", "fst", "ggplot2", "ggplot2movies", "logger", "pkgload", "quarto", "ragg", "remotes", "rlang", "rsconnect", "sass", "shiny", "shinytest2", "shinythemes", "stringr", "thematic", "tidyr", "testthat", "tools", "waldo", "withr"))'
RUN R -e 'remotes::install_local(upgrade="never")'
EXPOSE 8180
CMD Rscript deploy.R
```

### [`shiny-docker.yml`]{style="font-size: 0.95em; font-weight: bold;"}

In the `.github/workflows` folder, we'll create a `shiny-docker.yml` file with the following contents:

::: {layout="[50,50]" layout-valign="top"}

``` yaml
name: docker-shiny, sap

on:
  push:
    branches: [ 21.3_gha-shiny-docker ]

jobs:
  docker:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4

      - name: Build image
        run: docker build -t sap . 
```

  - [Add a `name` for the Docker/Shiny workflow]{style="font-size: 0.90rem;"}   

  - [Specify the triggering event the workflow will run **`on`**]{style="font-size: 0.90rem;"} 

  - [The **`job`** will run on `ubuntu-latest` (with **`docker`** id)]{style="font-size: 0.90rem;"}  

  - [Checkout the code]{style="font-size: 0.90rem;"}

  - [Build the docker image with `docker build`]{style="font-size: 0.90rem;"}

:::

The final `execute` **step** is `docker run` and it passes our environment variables to the secrets we have stored in GitHub (i.e., with `secrets.<SECRET_NAME>`):

``` yaml
      - name: execute
        run: >
          docker run -e RSCONNECT_USER=${{ secrets.RSCONNECT_USER }} -e RSCONNECT_TOKEN=${{ secrets.RSCONNECT_TOKEN }}  -e RSCONNECT_SECRET=${{ secrets.RSCONNECT_SECRET }} sap  
       
```

### App dependencies 

`rsconnect` has a handy `appDependencies()` function that returns a `data.frame` of packages, versions, and repositories for your application: 

```{r}
#| eval: false
#| code-fold: false
head(rsconnect:::appDependencies(appDir = "."))
```

```{r}
#| eval: false
#| code-fold: false
#        Package Version Source               Repository
# 1         MASS  7.3-65   CRAN https://cran.rstudio.com
# 2       Matrix   1.7-2   CRAN https://cran.rstudio.com
# 3           R6   2.6.1   CRAN https://cran.rstudio.com
# 4 RColorBrewer   1.1-3   CRAN https://cran.rstudio.com
# 5         Rcpp  1.0.14   CRAN https://cran.rstudio.com
# 6    base64enc   0.1-3   CRAN https://cran.rstudio.com
```

Passing `appDependencies()` in your app-package's root directory will tell you if any packages have missing `Source` or `Repository` values (this can cause the deployment to fail).

I also recommend running `attachment::att_amend_desc()` to capture all the dependencies in the `DESCRIPTION`. For example, `att_amend_desc()` added the following packages to the `Suggests` field in the `DESCRIPTION`:[^attachment-dev]

[^attachment-dev]: `att_amend_desc()` adds a `dev` folder with a YAML config file, but you can remove this before building/deploying.


``` sh
[+] 2 package(s) added: shinytest2, testthat.
```

### Docker build 

In the `docker` workflow log, we can see the commands from our `Dockerfile` executed to install the necessary packages:

![Installing R packages from `Dockerfile`](images/gha_docker_build_image.png){width='100%'}

After installing the dependencies, the `sap.tar.gz` is installed from `*source*`:

![Building our app-package from `*source*`](images/gha_docker_shiny_build.png){width='100%'}

The output above should look familiar--it's very similar to what we see when we run `devtools::load_all()`.

After installing the dependencies, we can see the Shiny deployment log execute in the workflow: 

![Docker deploy log](images/gh_docker_deploy.png){width='100%' fig-align='center'}

View the deployed application [here](https://mjfrigaard.shinyapps.io/shinyAppPkgsDockerCiCd/).

```{r}
#| label: co_box_app_depends
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "r",
  look = "default", 
  hsize = "1.05", 
  size = "0.95",
  header = "Capturing and recording dependencies with `renv`",
  fold = FALSE,
  contents = "
In the Shiny workflow example above, we captured the application dependencies with `renv`. However, in this Docker *and* Shiny workflow, we didn't create a `renv.lock` file or a `renv/` folder.
  
We get away with this because when the workflow runs, `renv` is used to capture the dependencies (line 9-12 in the output below). We see a message about the packages listed in the `Suggests` field or our `DESCRIPTION`:  
  
![Docker dependencies](images/gh_docker_dependencies.png){width='100%' fig-align='center'}
  
Not having `shinytest2` and `testthat` packages installed won't interfere with our application deploying because these packages are listed in the `Suggests` field in the `DESCRIPTION` file and are used in`tests/`.
  
  ")
```

## Recap {.unnumbered}

GitHub Actions can be used to set up the necessary R environment and dependencies required to deploy the application from your app-package, while allowing secure account credentials stored in GitHub secrets. 

```{r}
#| label: co_box_recap
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "g", 
  fold = FALSE,
  look = "default", hsize = "1.05", size = "0.95", 
  header = "Recap: GitHub Actions",
  contents = "
<br>
  
We've covered the GitHub Action examples for styling the code in our package, deploying our app, and running a docker container. 
  
- GitHub Actions can streamline a secure deployment process, which allows you to focus more on developing your application.
  
- Read about GitHub Actions in the [`rhino` framework section](rhino.qmd).
  ")
```


```{r}
#| label: git_contrib_box
#| echo: false
#| results: asis
#| eval: true
git_contrib_box()
```



<!-- https://github.com/pharmaverse/admiralci/blob/main/.github/workflows/code-coverage.yml --> 

